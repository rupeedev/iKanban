// This file was generated by `crates/core/src/bin/generate_types.rs`.

// Do not edit this file manually.

// If you are an AI, and you absolutely have to edit this file, please confirm with the user first.

export type SharedTaskResponse = { task: SharedTask, user: UserData | null, };

export type AssigneesQuery = { project_id: string, };

export type SharedTask = { id: string, organization_id: string, project_id: string, creator_user_id: string | null, assignee_user_id: string | null, deleted_by_user_id: string | null, title: string, description: string | null, status: TaskStatus, deleted_at: string | null, shared_at: string | null, created_at: string, updated_at: string, };

export type UserData = { user_id: string, first_name: string | null, last_name: string | null, username: string | null, };

export type Project = { id: string, name: string, dev_script: string | null, dev_script_working_dir: string | null, default_agent_working_dir: string | null, remote_project_id: string | null, 
/**
 * Priority: 0=none, 1=urgent, 2=high, 3=medium, 4=low
 */
priority: number | null, lead_id: string | null, start_date: string | null, target_date: string | null, status: string | null, 
/**
 * Health percentage 0-100
 */
health: number | null, description: string | null, summary: string | null, icon: string | null, created_at: Date, updated_at: Date, };

export type ProjectStatus = "backlog" | "planned" | "inprogress" | "paused" | "completed" | "cancelled";

export type CreateProject = { name: string, repositories: Array<CreateProjectRepo>, priority: number | null, lead_id: string | null, start_date: string | null, target_date: string | null, status: string | null, description: string | null, summary: string | null, icon: string | null, tenant_workspace_id?: string | null, };

export type UpdateProject = { name: string | null, dev_script: string | null, dev_script_working_dir: string | null, default_agent_working_dir: string | null, priority: number | null, lead_id: string | null, start_date: string | null, target_date: string | null, status: string | null, health: number | null, description: string | null, summary: string | null, icon: string | null, };

export type SearchResult = { path: string, is_file: boolean, match_type: SearchMatchType, };

export type SearchMatchType = "FileName" | "DirectoryName" | "FullPath";

export type Repo = { id: string, path: string, name: string, display_name: string, created_at: Date, updated_at: Date, };

export type ProjectRepo = { id: string, project_id: string, repo_id: string, setup_script: string | null, cleanup_script: string | null, copy_files: string | null, parallel_setup_script: boolean, };

export type CreateProjectRepo = { display_name: string, git_repo_path: string, };

export type UpdateProjectRepo = { setup_script: string | null, cleanup_script: string | null, copy_files: string | null, parallel_setup_script: boolean | null, };

export type WorkspaceRepo = { id: string, workspace_id: string, repo_id: string, target_branch: string, created_at: Date, updated_at: Date, };

export type CreateWorkspaceRepo = { repo_id: string, target_branch: string, };

export type RepoWithTargetBranch = { target_branch: string, id: string, path: string, name: string, display_name: string, created_at: Date, updated_at: Date, };

export type Tag = { id: string, tag_name: string, content: string, color: string | null, team_id: string | null, created_at: string, updated_at: string, };

export type CreateTag = { tag_name: string, content: string, color?: string | null, team_id?: string | null, };

export type UpdateTag = { tag_name: string | null, content: string | null, color?: string | null, team_id?: string | null, };

export type TaskTag = { id: string, task_id: string, tag_id: string, created_at: string, };

export type TaskTagWithDetails = { id: string, tag_id: string, tag_name: string, content: string, color: string | null, created_at: string, };

export type Team = { id: string, name: string, slug: string | null, identifier: string | null, icon: string | null, color: string | null, document_storage_path: string | null, created_at: Date, updated_at: Date, };

export type TeamProject = { team_id: string, project_id: string, created_at: Date, };

export type CreateTeam = { name: string, slug: string, identifier: string | null, icon: string | null, color: string | null, tenant_workspace_id: string | null, };

export type UpdateTeam = { name: string | null, identifier: string | null, icon: string | null, color: string | null, document_storage_path: string | null, };

export type TeamProjectAssignment = { project_id: string, };

/**
 * Aggregated team dashboard response
 * Returns all data needed for the TeamIssues page in a single request
 */
export type TeamDashboard = {
  team: Team,
  members: TeamMember[],
  project_ids: string[],
  projects: Project[],
  issues: TaskWithAttemptStatus[],
};

export type TeamMemberRole = "viewer" | "contributor" | "maintainer" | "owner";

export type TeamInvitationStatus = "pending" | "accepted" | "declined" | "expired";

export type TeamMember = { id: string, team_id: string, email: string, display_name: string | null, role: TeamMemberRole, invited_by: string | null, 
/**
 * Clerk user ID for integration
 */
clerk_user_id: string | null, 
/**
 * Avatar URL from Clerk
 */
avatar_url: string | null, 
/**
 * Number of tasks assigned to this member
 */
assigned_task_count: number, joined_at: Date, created_at: Date, updated_at: Date, };

export type CreateTeamMember = { email: string, display_name: string | null, role: TeamMemberRole | null, clerk_user_id: string | null, avatar_url: string | null, };

export type UpdateTeamMemberRole = { role: TeamMemberRole, };

export type SyncClerkMember = { clerk_user_id: string, email: string, display_name: string | null, avatar_url: string | null, };

export type TeamInvitation = { id: string, team_id: string, email: string, role: TeamMemberRole, status: TeamInvitationStatus, invited_by: string | null, 
/**
 * Unique token for shareable invite link
 */
token: string | null, expires_at: Date, created_at: Date, };

export type TeamInvitationWithTeam = { team_name: string, id: string, team_id: string, email: string, role: TeamMemberRole, status: TeamInvitationStatus, invited_by: string | null, 
/**
 * Unique token for shareable invite link
 */
token: string | null, expires_at: Date, created_at: Date, };

export type CreateTeamInvitation = { email: string, role: TeamMemberRole | null, };

export type UpdateTeamInvitation = { role: TeamMemberRole, };

export type MemberProjectAccess = { id: string, member_id: string, project_id: string, created_at: string, };

export type SetMemberProjectAccess = { project_ids: Array<string>, };

export type GitHubConnection = { id: string, 
/**
 * Team ID - NULL for workspace-level connection
 */
team_id: string | null, access_token: string, github_username: string | null, connected_at: Date, updated_at: Date, };

export type GitHubRepository = { id: string, connection_id: string, repo_full_name: string, repo_name: string, repo_owner: string, repo_url: string, default_branch: string | null, is_private: boolean, linked_at: Date, 
/**
 * Path in the repo where documents are synced (e.g., "docs/team-notes")
 */
sync_path: string | null, 
/**
 * The folder ID in vibe-kanban that syncs to this repo
 */
sync_folder_id: string | null, 
/**
 * Last sync timestamp
 */
last_synced_at: Date | null, };

export type CreateGitHubConnection = { access_token: string, };

export type UpdateGitHubConnection = { access_token: string | null, github_username: string | null, };

export type LinkGitHubRepository = { repo_full_name: string, repo_name: string, repo_owner: string, repo_url: string, default_branch: string | null, is_private: boolean, };

export type GitHubConnectionWithRepos = { repositories: Array<GitHubRepository>, id: string, 
/**
 * Team ID - NULL for workspace-level connection
 */
team_id: string | null, access_token: string, github_username: string | null, connected_at: Date, updated_at: Date, };

export type GitHubRepoSyncConfig = { id: string, repo_id: string, folder_id: string, 
/**
 * Path in repo where folder syncs. If None, uses folder name.
 */
github_path: string | null, created_at: Date, };

export type CreateRepoSyncConfig = { folder_id: string, github_path: string | null, };

export type ConfigureMultiFolderSync = { folder_configs: Array<CreateRepoSyncConfig>, };

export type MigrateTasksRequest = { 
/**
 * The project ID to migrate tasks from
 */
project_id: string, };

export type MigrateTasksResponse = { 
/**
 * Number of tasks migrated
 */
migrated_count: number, 
/**
 * List of migrated task IDs
 */
task_ids: Array<string>, };

export type ValidateStoragePathRequest = { 
/**
 * The path to validate
 */
path: string, };

export type ValidateStoragePathResponse = { 
/**
 * Whether the path is valid
 */
valid: boolean, 
/**
 * Error message if invalid
 */
error: string | null, };

export type GitHubRepoInfo = { id: bigint, name: string, full_name: string, html_url: string, default_branch: string | null, private: boolean, description: string | null, };

// GitLab connection types (similar to GitHub)
export type GitLabConnection = {
  id: string,
  /** Team ID - NULL for workspace-level connection */
  team_id: string | null,
  gitlab_username: string | null,
  /** GitLab instance URL (for self-hosted instances) */
  gitlab_url: string,
  connected_at: Date,
  updated_at: Date,
};

export type GitLabRepository = {
  id: string,
  connection_id: string,
  repo_full_name: string,
  repo_name: string,
  repo_namespace: string,
  repo_url: string,
  default_branch: string | null,
  is_private: boolean,
  linked_at: Date,
};

export type CreateGitLabConnection = {
  access_token: string,
  /** GitLab instance URL - defaults to https://gitlab.com */
  gitlab_url: string | null,
};

export type UpdateGitLabConnection = {
  access_token: string | null,
  gitlab_username: string | null,
  gitlab_url: string | null,
};

export type LinkGitLabRepository = {
  repo_full_name: string,
  repo_name: string,
  repo_namespace: string,
  repo_url: string,
  default_branch: string | null,
  is_private: boolean,
};

export type GitLabConnectionWithRepos = {
  connection: GitLabConnection,
  repositories: Array<GitLabRepository>,
};

export type GitLabNamespace = {
  id: bigint,
  name: string,
  path: string,
  full_path: string,
};

export type GitLabProjectInfo = {
  id: bigint,
  name: string,
  path_with_namespace: string,
  web_url: string,
  default_branch: string | null,
  visibility: string,
  description: string | null,
  namespace: GitLabNamespace,
};

export type ConfigureSyncRequest = { 
/**
 * Path in the repo where documents will be synced (e.g., "docs/team-notes")
 */
sync_path: string, 
/**
 * The folder ID in vibe-kanban to sync
 */
sync_folder_id: string, };

export type PushDocumentsRequest = { 
/**
 * Commit message for the push
 */
commit_message: string | null, };

export type SyncOperationResponse = { 
/**
 * Number of files synced
 */
files_synced: number, 
/**
 * List of file paths that were synced
 */
synced_files: Array<string>, 
/**
 * Any warnings or notes
 */
message: string | null, };

export type InvitationByTokenResponse = { invitation: TeamInvitation, team_name: string, };

export type ScanFilesystemResponse = { 
/**
 * Number of new documents found and registered
 */
documents_added: number, 
/**
 * List of document titles that were added
 */
added_titles: Array<string>, 
/**
 * Number of files scanned
 */
files_scanned: number, };

export type ScanAllResponse = { 
/**
 * Number of folders created
 */
folders_created: number, 
/**
 * Number of documents created
 */
documents_created: number, 
/**
 * Total items scanned (folders + files)
 */
total_scanned: number, 
/**
 * Names of folders created
 */
folder_names: Array<string>, 
/**
 * Names of documents created
 */
document_names: Array<string>, };

export type DiscoverFoldersResponse = { 
/**
 * Names of folders that were created in the database
 */
folders_created: Array<string>, 
/**
 * Names of folders that already existed in the database
 */
folders_existing: Array<string>, 
/**
 * Total number of folders found on filesystem
 */
total_folders: number, };

export type DocumentContentResponse = { 
/**
 * The document ID
 */
document_id: string, 
/**
 * Content type: "text", "csv", "pdf_text", "image_base64", "binary"
 */
content_type: string, 
/**
 * The actual content (text, extracted text, or base64 for images)
 */
content: string, 
/**
 * Optional structured data for CSV files
 */
csv_data: CsvDataResponse | null, 
/**
 * File path on disk
 */
file_path: string | null, 
/**
 * Original file type/extension
 */
file_type: string, 
/**
 * MIME type
 */
mime_type: string | null, };

export type CsvDataResponse = { 
/**
 * Column headers
 */
headers: Array<string>, 
/**
 * Data rows (limited to 1000)
 */
rows: Array<Array<string>>, };

export type UploadResult = { 
/**
 * Number of files successfully uploaded
 */
uploaded: number, 
/**
 * Number of files skipped (already exist)
 */
skipped: number, 
/**
 * Error messages for failed files
 */
errors: Array<string>, 
/**
 * Titles of uploaded documents
 */
uploaded_titles: Array<string>, };

export type DocumentFileType = "markdown" | "pdf" | "txt" | "csv" | "xlsx";

export type DocumentFolder = { id: string, team_id: string, parent_id: string | null, name: string, icon: string | null, color: string | null, 
/**
 * Optional local filesystem path for syncing documents
 */
local_path: string | null, position: number, created_at: Date, updated_at: Date, };

export type Document = { id: string, team_id: string, folder_id: string | null, title: string, slug: string | null, content: string | null, file_path: string | null, file_type: string, file_size: bigint | null, mime_type: string | null, icon: string | null, is_pinned: boolean, is_archived: boolean, position: number, created_by: string | null, created_at: Date, updated_at: Date, storage_key: string | null, storage_bucket: string | null, storage_metadata: Record<string, unknown> | null, storage_provider: string, };

export type CreateDocumentFolder = { team_id: string, parent_id: string | null, name: string, icon: string | null, color: string | null, 
/**
 * Optional local filesystem path for syncing documents
 */
local_path: string | null, };

export type UpdateDocumentFolder = { parent_id: string | null, name: string | null, icon: string | null, color: string | null, 
/**
 * Optional local filesystem path for syncing documents
 */
local_path: string | null, position: number | null, };

export type CreateDocument = { team_id: string, folder_id: string | null, title: string, content: string | null, file_type: string | null, icon: string | null,
/**
 * Storage URL (Supabase or external) for uploaded files
 */
file_path: string | null,
/**
 * Size in bytes
 */
file_size: number | null,
/**
 * MIME type for uploaded files
 */
mime_type: string | null,
/**
 * Storage provider ("local", "supabase", "s3", etc.)
 */
storage_provider: string | null,
/**
 * Storage key (path in bucket)
 */
storage_key: string | null, };

export type UpdateDocument = { folder_id: string | null, title: string | null, content: string | null, icon: string | null, is_pinned: boolean | null, is_archived: boolean | null, position: number | null, };

export type ListDocumentsQuery = { 
/**
 * Filter by folder ID (null for root level documents)
 */
folder_id: string | null, 
/**
 * Include archived documents
 */
include_archived: boolean | null, 
/**
 * Search query
 */
search: string | null, 
/**
 * If true, return all documents across all folders
 */
all: boolean | null, };

export type InboxNotificationType = "task_assigned" | "task_mentioned" | "task_comment" | "task_status_changed" | "task_completed" | "workspace_created" | "system_notification";

export type InboxItem = { id: string, notification_type: InboxNotificationType, title: string, message: string | null, task_id: string | null, project_id: string | null, workspace_id: string | null, is_read: boolean, created_at: string, updated_at: string, };

export type CreateInboxItem = { notification_type: InboxNotificationType, title: string, message: string | null, task_id: string | null, project_id: string | null, workspace_id: string | null, };

export type InboxSummary = { total_count: bigint, unread_count: bigint, };

// Pulse (Activity) types
export type ProjectHealthStatus = "on_track" | "at_risk" | "off_track" | "completed" | "paused";

export type ProjectUpdate = {
  id: string,
  project_id: string,
  author_id: string,
  content: string,
  health_status: ProjectHealthStatus | null,
  progress_data: Record<string, unknown> | null,
  created_at: string,
  updated_at: string,
};

export type ReactionCount = {
  emoji: string,
  count: number,
};

export type ProjectUpdateWithReactions = ProjectUpdate & {
  reactions: ReactionCount[],
  user_reactions: string[],
};

export type CreateProjectUpdate = {
  content: string,
  health_status?: ProjectHealthStatus | null,
  progress_data?: Record<string, unknown> | null,
};

export type UpdateProjectUpdate = {
  content?: string | null,
  health_status?: ProjectHealthStatus | null,
  progress_data?: Record<string, unknown> | null,
};

export type UpdateReaction = {
  id: string,
  update_id: string,
  user_id: string,
  emoji: string,
  created_at: string,
};

export type PulseFilter = "recent" | "for_me" | "popular";

// Subscription types
export type DigestFrequency = "daily" | "weekly" | "never";

export type ProjectSubscription = {
  project_id: string,
  project_name: string,
  subscribed_at: string,
};

export type SubscriptionSettings = {
  global_frequency: DigestFrequency,
  project_subscriptions: ProjectSubscription[],
};

export type UserSubscription = {
  id: string,
  user_id: string,
  project_id: string | null,
  tenant_workspace_id: string | null,
  digest_frequency: DigestFrequency,
  subscribed_at: string,
  updated_at: string,
};

export type TaskStatus = "todo" | "inprogress" | "inreview" | "done" | "cancelled";

export type TaskPriority = "None" | "Urgent" | "High" | "Medium" | "Low";

export type Task = { id: string, project_id: string, title: string, description: string | null, status: TaskStatus, parent_workspace_id: string | null, shared_task_id: string | null, team_id: string | null, issue_number: number | null, priority: number | null, due_date: string | null, assignee_id: string | null, created_at: string, updated_at: string, };

export type TaskWithAttemptStatus = { has_in_progress_attempt: boolean, last_attempt_failed: boolean, executor: string, id: string, project_id: string, title: string, description: string | null, status: TaskStatus, parent_workspace_id: string | null, shared_task_id: string | null, team_id: string | null, issue_number: number | null, priority: number | null, due_date: string | null, assignee_id: string | null, created_at: string, updated_at: string, };

export type TaskRelationships = { parent_task: Task | null, current_workspace: Workspace, children: Array<Task>, };

export type CreateTask = { project_id: string, title: string, description: string | null, status: TaskStatus | null, parent_workspace_id: string | null, image_ids: Array<string> | null, shared_task_id: string | null, team_id: string | null, priority: number | null, due_date: string | null, assignee_id: string | null, };

export type UpdateTask = { title: string | null, description: string | null, status: TaskStatus | null, parent_workspace_id: string | null, image_ids: Array<string> | null, priority: number | null, due_date: string | null, assignee_id: string | null, };

export type TaskComment = { id: string, task_id: string, author_id: string | null, author_name: string, author_email: string | null, content: string, is_internal: boolean, created_at: Date, updated_at: Date, };

export type CreateTaskComment = { content: string, is_internal: boolean, author_name: string, author_email: string | null, author_id: string | null, };

export type UpdateTaskComment = { content: string | null, is_internal: boolean | null, };

export type TaskDocumentLink = { id: string, task_id: string, document_id: string, created_at: Date, };

export type LinkDocumentsRequest = { document_ids: Array<string>, };

export type LinkedDocument = { id: string, document_id: string, document_title: string, folder_name: string | null, linked_at: Date, };

export type DraftFollowUpData = { message: string, variant: string | null, };

export type ScratchPayload = { "type": "DRAFT_TASK", "data": string } | { "type": "DRAFT_FOLLOW_UP", "data": DraftFollowUpData };

export enum ScratchType { DRAFT_TASK = "DRAFT_TASK", DRAFT_FOLLOW_UP = "DRAFT_FOLLOW_UP" }

export type Scratch = { id: string, payload: ScratchPayload, created_at: string, updated_at: string, };

export type CreateScratch = { payload: ScratchPayload, };

export type UpdateScratch = { payload: ScratchPayload, };

// Copilot Assignment types (IKA-93: GitHub Copilot Integration)
export type CopilotAssignmentStatus =
  | 'pending'
  | 'issue_created'
  | 'pr_created'
  | 'completed'
  | 'failed'
  | 'ci_pending'
  | 'ci_passed'
  | 'ci_failed'
  | 'merging'
  | 'merged'
  | 'merge_failed'
  | 'deploying'
  | 'deployed'
  | 'deploy_failed';

export type CopilotAssignment = {
  id: string;
  task_id: string;
  github_issue_id: number | null;
  github_issue_url: string | null;
  github_pr_id: number | null;
  github_pr_url: string | null;
  github_repo_owner: string | null;
  github_repo_name: string | null;
  ci_status: string | null;
  ci_checks_url: string | null;
  ci_completed_at: Date | null;
  deployment_workflow_run_id: number | null;
  deployment_url: string | null;
  deployed_at: Date | null;
  status: CopilotAssignmentStatus;
  prompt: string;
  error_message: string | null;
  created_at: Date;
  completed_at: Date | null;
};

export type CreateCopilotAssignment = {
  prompt: string;
};

// Copilot Deployment Config types (IKA-94: Auto-merge and Deploy)
export type MergeMethod = 'squash' | 'merge' | 'rebase';

export type CopilotDeploymentConfig = {
  id: string;
  repository_id: string;
  auto_merge_enabled: boolean;
  merge_method: MergeMethod;
  deploy_workflow_enabled: boolean;
  deploy_workflow_name: string | null;
  deploy_workflow_ref: string | null;
  required_ci_checks: string[] | null;
  wait_for_all_checks: boolean;
  auto_mark_task_done: boolean;
  created_at: Date;
  updated_at: Date;
};

export type UpdateDeploymentConfigPayload = {
  auto_merge_enabled?: boolean;
  merge_method?: string;
  deploy_workflow_enabled?: boolean;
  deploy_workflow_name?: string;
  deploy_workflow_ref?: string;
  required_ci_checks?: string[];
  wait_for_all_checks?: boolean;
  auto_mark_task_done?: boolean;
};

export type Image = { id: string, file_path: string, original_name: string, mime_type: string | null, size_bytes: bigint, hash: string, created_at: string, updated_at: string, };

export type CreateImage = { file_path: string, original_name: string, mime_type: string | null, size_bytes: bigint, hash: string, };

export type Workspace = { id: string, task_id: string, container_ref: string | null, branch: string, agent_working_dir: string | null, setup_completed_at: string | null, created_at: string, updated_at: string, };

export type Session = { id: string, workspace_id: string, executor: string | null, created_at: string, updated_at: string, };

export type ExecutionProcess = { id: string, session_id: string, run_reason: ExecutionProcessRunReason, executor_action: ExecutorAction, status: ExecutionProcessStatus, exit_code: bigint | null, 
/**
 * dropped: true if this process is excluded from the current
 * history view (due to restore/trimming). Hidden from logs/timeline;
 * still listed in the Processes tab.
 */
dropped: boolean, started_at: string, completed_at: string | null, created_at: string, updated_at: string, };

export enum ExecutionProcessStatus { running = "running", completed = "completed", failed = "failed", killed = "killed" }

export type ExecutionProcessRunReason = "setupscript" | "cleanupscript" | "codingagent" | "devserver";

export type ExecutionProcessRepoState = { id: string, execution_process_id: string, repo_id: string, before_head_commit: string | null, after_head_commit: string | null, merge_commit: string | null, created_at: Date, updated_at: Date, };

export type Merge = { "type": "direct" } & DirectMerge | { "type": "pr" } & PrMerge;

export type DirectMerge = { id: string, workspace_id: string, repo_id: string, merge_commit: string, target_branch_name: string, created_at: string, };

export type PrMerge = { id: string, workspace_id: string, repo_id: string, created_at: string, target_branch_name: string, pr_info: PullRequestInfo, };

export type MergeStatus = "open" | "merged" | "closed" | "unknown";

export type PullRequestInfo = { number: bigint, url: string, status: MergeStatus, merged_at: string | null, merge_commit_sha: string | null, };

export type ApprovalStatus = { "status": "pending" } | { "status": "approved" } | { "status": "denied", reason?: string, } | { "status": "timed_out" };

export type CreateApprovalRequest = { tool_name: string, tool_input: JsonValue, tool_call_id: string, };

export type ApprovalResponse = { execution_process_id: string, status: ApprovalStatus, };

export type Diff = { change: DiffChangeKind, oldPath: string | null, newPath: string | null, oldContent: string | null, newContent: string | null, 
/**
 * True when file contents are intentionally omitted (e.g., too large)
 */
contentOmitted: boolean, 
/**
 * Optional precomputed stats for omitted content
 */
additions: number | null, deletions: number | null, };

export type DiffChangeKind = "added" | "deleted" | "modified" | "renamed" | "copied" | "permissionChange";

export type ApiResponse<T, E = T> = { success: boolean, data: T | null, error_data: E | null, message: string | null, };

export type LoginStatus = { "status": "loggedout" } | { "status": "loggedin", profile: ProfileResponse, };

export type ProfileResponse = { user_id: string, username: string | null, email: string, providers: Array<ProviderProfile>, };

export type ProviderProfile = { provider: string, username: string | null, display_name: string | null, email: string | null, avatar_url: string | null, };

export type StatusResponse = { logged_in: boolean, profile: ProfileResponse | null, degraded: boolean | null, };

export enum MemberRole { ADMIN = "ADMIN", MEMBER = "MEMBER" }

export enum InvitationStatus { PENDING = "PENDING", ACCEPTED = "ACCEPTED", DECLINED = "DECLINED", EXPIRED = "EXPIRED" }

export type Organization = { id: string, name: string, slug: string, is_personal: boolean, created_at: string, updated_at: string, };

export type OrganizationWithRole = { id: string, name: string, slug: string, is_personal: boolean, created_at: string, updated_at: string, user_role: MemberRole, };

export type ListOrganizationsResponse = { organizations: Array<OrganizationWithRole>, };

export type GetOrganizationResponse = { organization: Organization, user_role: string, };

export type CreateOrganizationRequest = { name: string, slug: string, };

export type CreateOrganizationResponse = { organization: OrganizationWithRole, };

export type UpdateOrganizationRequest = { name: string, };

export type Invitation = { id: string, organization_id: string, invited_by_user_id: string | null, email: string, role: MemberRole, status: InvitationStatus, token: string, created_at: string, expires_at: string, };

export type CreateInvitationRequest = { email: string, role: MemberRole, };

export type CreateInvitationResponse = { invitation: Invitation, };

export type ListInvitationsResponse = { invitations: Array<Invitation>, };

export type GetInvitationResponse = { id: string, organization_slug: string, role: MemberRole, expires_at: string, };

export type AcceptInvitationResponse = { organization_id: string, organization_slug: string, role: MemberRole, };

export type RevokeInvitationRequest = { invitation_id: string, };

export type OrganizationMember = { user_id: string, role: MemberRole, joined_at: string, };

export type OrganizationMemberWithProfile = { user_id: string, role: MemberRole, joined_at: string, first_name: string | null, last_name: string | null, username: string | null, email: string | null, avatar_url: string | null, };

export type ListMembersResponse = { members: Array<OrganizationMemberWithProfile>, };

export type UpdateMemberRoleRequest = { role: MemberRole, };

export type UpdateMemberRoleResponse = { user_id: string, role: MemberRole, };

export type RemoteProject = { id: string, organization_id: string, name: string, metadata: Record<string, unknown>, created_at: string, };

export type ListProjectsResponse = { projects: Array<RemoteProject>, };

export type RemoteProjectMembersResponse = { organization_id: string, members: Array<OrganizationMemberWithProfile>, };

export type CreateRemoteProjectRequest = { organization_id: string, name: string, };

export type LinkToExistingRequest = { remote_project_id: string, };

export type RegisterRepoRequest = { path: string, display_name: string | null, };

export type InitRepoRequest = { parent_path: string, folder_name: string, };

export type TagSearchParams = { search?: string | null, team_id?: string | null, };

export type TokenResponse = { access_token: string, expires_at: string | null, };

export type UserSystemInfo = { config: Config, analytics_user_id: string, login_status: LoginStatus, environment: Environment, 
/**
 * Capabilities supported per executor (e.g., { "CLAUDE_CODE": ["SESSION_FORK"] })
 */
capabilities: { [key in string]?: Array<BaseAgentCapability> }, executors: { [key in BaseCodingAgent]?: ExecutorConfig }, };

export type Environment = { os_type: string, os_version: string, os_architecture: string, bitness: string, };

export type McpServerQuery = { executor: BaseCodingAgent, };

export type UpdateMcpServersBody = { servers: { [key in string]?: JsonValue }, };

export type GetMcpServerResponse = { mcp_config: McpConfig, config_path: string, };

export type CheckEditorAvailabilityQuery = { editor_type: EditorType, };

export type CheckEditorAvailabilityResponse = { available: boolean, };

export type CheckAgentAvailabilityQuery = { executor: BaseCodingAgent, };

export type CurrentUserResponse = { user_id: string, };

export type GitHubAuthorizeResponse = { authorize_url: string, state: string, };

export type CreateFollowUpAttempt = { prompt: string, variant: string | null, retry_process_id: string | null, force_when_dirty: boolean | null, perform_git_reset: boolean | null, };

export type ChangeTargetBranchRequest = { repo_id: string, new_target_branch: string, };

export type ChangeTargetBranchResponse = { repo_id: string, new_target_branch: string, status: [number, number], };

export type MergeTaskAttemptRequest = { repo_id: string, };

export type PushTaskAttemptRequest = { repo_id: string, };

export type RenameBranchRequest = { new_branch_name: string, };

export type RenameBranchResponse = { branch: string, };

export type OpenEditorRequest = { editor_type: string | null, file_path: string | null, };

export type OpenEditorResponse = { url: string | null, };

export type AssignSharedTaskRequest = { new_assignee_user_id: string | null, };

export type ShareTaskResponse = { shared_task_id: string, };

export type CreateAndStartTaskRequest = { task: CreateTask, executor_profile_id: ExecutorProfileId, repos: Array<WorkspaceRepoInput>, };

export type CreateGitHubPrRequest = { title: string, body: string | null, target_branch: string | null, draft: boolean | null, repo_id: string, auto_generate_description: boolean, };

export type ImageResponse = { id: string, file_path: string, original_name: string, mime_type: string | null, size_bytes: bigint, hash: string, created_at: string, updated_at: string, };

export type ImageMetadata = { exists: boolean, file_name: string | null, path: string | null, size_bytes: bigint | null, format: string | null, proxy_url: string | null, };

export type CreateTaskAttemptBody = { task_id: string, executor_profile_id: ExecutorProfileId, repos: Array<WorkspaceRepoInput>, };

export type WorkspaceRepoInput = { repo_id: string, target_branch: string, };

export type RunAgentSetupRequest = { executor_profile_id: ExecutorProfileId, };

export type RunAgentSetupResponse = Record<string, never>;

export type GhCliSetupError = "BREW_MISSING" | "SETUP_HELPER_NOT_SUPPORTED" | { "OTHER": { message: string, } };

export type RebaseTaskAttemptRequest = { repo_id: string, old_base_branch: string | null, new_base_branch: string | null, };

export type AbortConflictsRequest = { repo_id: string, };

export type GitOperationError = { "type": "merge_conflicts", message: string, op: ConflictOp, } | { "type": "rebase_in_progress" };

export type PushError = { "type": "force_push_required" };

export type CreatePrError = { "type": "github_cli_not_installed" } | { "type": "github_cli_not_logged_in" } | { "type": "git_cli_not_logged_in" } | { "type": "git_cli_not_installed" } | { "type": "target_branch_not_found", branch: string, };

export type BranchStatus = { commits_behind: number | null, commits_ahead: number | null, has_uncommitted_changes: boolean | null, head_oid: string | null, uncommitted_count: number | null, untracked_count: number | null, target_branch_name: string, remote_commits_behind: number | null, remote_commits_ahead: number | null, merges: Array<Merge>, 
/**
 * True if a `git rebase` is currently in progress in this worktree
 */
is_rebase_in_progress: boolean, 
/**
 * Current conflict operation if any
 */
conflict_op: ConflictOp | null, 
/**
 * List of files currently in conflicted (unmerged) state
 */
conflicted_files: Array<string>, };

export type RunScriptError = { "type": "no_script_configured" } | { "type": "process_already_running" };

export type AttachPrResponse = { pr_attached: boolean, pr_url: string | null, pr_number: bigint | null, pr_status: MergeStatus | null, };

export type AttachExistingPrRequest = { repo_id: string, };

export type PrCommentsResponse = { comments: Array<UnifiedPrComment>, };

export type GetPrCommentsError = { "type": "no_pr_attached" } | { "type": "github_cli_not_installed" } | { "type": "github_cli_not_logged_in" };

export type GetPrCommentsQuery = { repo_id: string, };

export type UnifiedPrComment = { "comment_type": "general", id: string, author: string, author_association: string, body: string, created_at: string, url: string, } | { "comment_type": "review", id: bigint, author: string, author_association: string, body: string, created_at: string, url: string, path: string, line: bigint | null, diff_hunk: string, };

export type RepoBranchStatus = { repo_id: string, repo_name: string, commits_behind: number | null, commits_ahead: number | null, has_uncommitted_changes: boolean | null, head_oid: string | null, uncommitted_count: number | null, untracked_count: number | null, target_branch_name: string, remote_commits_behind: number | null, remote_commits_ahead: number | null, merges: Array<Merge>, 
/**
 * True if a `git rebase` is currently in progress in this worktree
 */
is_rebase_in_progress: boolean, 
/**
 * Current conflict operation if any
 */
conflict_op: ConflictOp | null, 
/**
 * List of files currently in conflicted (unmerged) state
 */
conflicted_files: Array<string>, };

export type DirectoryEntry = { name: string, path: string, is_directory: boolean, is_git_repo: boolean, last_modified: bigint | null, };

export type DirectoryListResponse = { entries: Array<DirectoryEntry>, current_path: string, };

export type Config = { config_version: string, theme: ThemeMode, executor_profile: ExecutorProfileId, disclaimer_acknowledged: boolean, onboarding_acknowledged: boolean, notifications: NotificationConfig, editor: EditorConfig, github: GitHubConfig, analytics_enabled: boolean, workspace_dir: string | null, last_app_version: string | null, show_release_notes: boolean, language: UiLanguage, git_branch_prefix: string, showcases: ShowcaseState, pr_auto_description_enabled: boolean, pr_auto_description_prompt: string | null, };

export type NotificationConfig = { sound_enabled: boolean, push_enabled: boolean, sound_file: SoundFile, };

export enum ThemeMode { LIGHT = "LIGHT", DARK = "DARK", SYSTEM = "SYSTEM" }

export type EditorConfig = { editor_type: EditorType, custom_command: string | null, remote_ssh_host: string | null, remote_ssh_user: string | null, };

export enum EditorType { VS_CODE = "VS_CODE", CURSOR = "CURSOR", WINDSURF = "WINDSURF", INTELLI_J = "INTELLI_J", ZED = "ZED", XCODE = "XCODE", CUSTOM = "CUSTOM" }

export type EditorOpenError = { "type": "executable_not_found", executable: string, editor_type: EditorType, } | { "type": "invalid_command", details: string, editor_type: EditorType, } | { "type": "launch_failed", executable: string, details: string, editor_type: EditorType, };

export type GitHubConfig = { pat: string | null, oauth_token: string | null, username: string | null, primary_email: string | null, default_pr_base: string | null, };

export enum SoundFile { ABSTRACT_SOUND1 = "ABSTRACT_SOUND1", ABSTRACT_SOUND2 = "ABSTRACT_SOUND2", ABSTRACT_SOUND3 = "ABSTRACT_SOUND3", ABSTRACT_SOUND4 = "ABSTRACT_SOUND4", COW_MOOING = "COW_MOOING", PHONE_VIBRATION = "PHONE_VIBRATION", ROOSTER = "ROOSTER" }

export type UiLanguage = "BROWSER" | "EN" | "JA" | "ES" | "KO" | "ZH_HANS";

export type ShowcaseState = { seen_features: Array<string>, };

export type GitBranch = { name: string, is_current: boolean, is_remote: boolean, last_commit_date: Date, };

export type SharedTaskDetails = { id: string, project_id: string, title: string, description: string | null, status: TaskStatus, };

export type QueuedMessage = { 
/**
 * The session this message is queued for
 */
session_id: string, 
/**
 * The follow-up data (message + variant)
 */
data: DraftFollowUpData, 
/**
 * Timestamp when the message was queued
 */
queued_at: string, };

export type QueueStatus = { "status": "empty" } | { "status": "queued", message: QueuedMessage, };

export type ConflictOp = "rebase" | "merge" | "cherry_pick" | "revert";

export type ExecutorAction = { typ: ExecutorActionType, next_action: ExecutorAction | null, };

export type McpConfig = { servers: { [key in string]?: JsonValue }, servers_path: Array<string>, template: JsonValue, preconfigured: JsonValue, is_toml_config: boolean, };

export type ExecutorActionType = { "type": "CodingAgentInitialRequest" } & CodingAgentInitialRequest | { "type": "CodingAgentFollowUpRequest" } & CodingAgentFollowUpRequest | { "type": "ScriptRequest" } & ScriptRequest;

export type ScriptContext = "SetupScript" | "CleanupScript" | "DevServer" | "ToolInstallScript";

export type ScriptRequest = { script: string, language: ScriptRequestLanguage, context: ScriptContext, 
/**
 * Optional relative path to execute the script in (relative to container_ref).
 * If None, uses the container_ref directory directly.
 */
working_dir: string | null, };

export type ScriptRequestLanguage = "Bash";

export enum BaseCodingAgent { CLAUDE_CODE = "CLAUDE_CODE", AMP = "AMP", GEMINI = "GEMINI", CODEX = "CODEX", OPENCODE = "OPENCODE", CURSOR_AGENT = "CURSOR_AGENT", QWEN_CODE = "QWEN_CODE", COPILOT = "COPILOT", DROID = "DROID" }

export type CodingAgent = { "CLAUDE_CODE": ClaudeCode } | { "AMP": Amp } | { "GEMINI": Gemini } | { "CODEX": Codex } | { "OPENCODE": Opencode } | { "CURSOR_AGENT": CursorAgent } | { "QWEN_CODE": QwenCode } | { "COPILOT": Copilot } | { "DROID": Droid };

export type AvailabilityInfo = { "type": "LOGIN_DETECTED", last_auth_timestamp: bigint, } | { "type": "INSTALLATION_FOUND" } | { "type": "NOT_FOUND" };

export type CommandBuilder = { 
/**
 * Base executable command (e.g., "npx -y @anthropic-ai/claude-code@latest")
 */
base: string, 
/**
 * Optional parameters to append to the base command
 */
params: Array<string> | null, };

export type ExecutorProfileId = { 
/**
 * The executor type (e.g., "CLAUDE_CODE", "AMP")
 */
executor: BaseCodingAgent, 
/**
 * Optional variant name (e.g., "PLAN", "ROUTER")
 */
variant: string | null, };

export type ExecutorConfig = { [key in string]?: { "CLAUDE_CODE": ClaudeCode } | { "AMP": Amp } | { "GEMINI": Gemini } | { "CODEX": Codex } | { "OPENCODE": Opencode } | { "CURSOR_AGENT": CursorAgent } | { "QWEN_CODE": QwenCode } | { "COPILOT": Copilot } | { "DROID": Droid } };

export type ExecutorConfigs = {
  executors: { [key in BaseCodingAgent]?: ExecutorConfig },
  /** Visibility settings per executor (true = visible, false = hidden in UI). Defaults to all visible if not specified. */
  visibility?: { [key in BaseCodingAgent]?: boolean },
};

export enum BaseAgentCapability { SESSION_FORK = "SESSION_FORK", SETUP_HELPER = "SETUP_HELPER" }

export type ClaudeCode = { append_prompt: AppendPrompt, claude_code_router?: boolean | null, plan?: boolean | null, approvals?: boolean | null, model?: string | null, dangerously_skip_permissions?: boolean | null, disable_api_key?: boolean | null, base_command_override?: string | null, additional_params?: Array<string> | null, env?: { [key in string]?: string } | null, };

export type Gemini = { append_prompt: AppendPrompt, model?: string | null, yolo?: boolean | null, base_command_override?: string | null, additional_params?: Array<string> | null, env?: { [key in string]?: string } | null, };

export type Amp = { append_prompt: AppendPrompt, dangerously_allow_all?: boolean | null, base_command_override?: string | null, additional_params?: Array<string> | null, env?: { [key in string]?: string } | null, };

export type Codex = { append_prompt: AppendPrompt, sandbox?: SandboxMode | null, ask_for_approval?: AskForApproval | null, oss?: boolean | null, model?: string | null, model_reasoning_effort?: ReasoningEffort | null, model_reasoning_summary?: ReasoningSummary | null, model_reasoning_summary_format?: ReasoningSummaryFormat | null, profile?: string | null, base_instructions?: string | null, include_apply_patch_tool?: boolean | null, model_provider?: string | null, compact_prompt?: string | null, developer_instructions?: string | null, base_command_override?: string | null, additional_params?: Array<string> | null, env?: { [key in string]?: string } | null, };

export type SandboxMode = "auto" | "read-only" | "workspace-write" | "danger-full-access";

export type AskForApproval = "unless-trusted" | "on-failure" | "on-request" | "never";

export type ReasoningEffort = "low" | "medium" | "high" | "xhigh";

export type ReasoningSummary = "auto" | "concise" | "detailed" | "none";

export type ReasoningSummaryFormat = "none" | "experimental";

export type CursorAgent = { append_prompt: AppendPrompt, force?: boolean | null, model?: string | null, base_command_override?: string | null, additional_params?: Array<string> | null, env?: { [key in string]?: string } | null, };

export type Copilot = { append_prompt: AppendPrompt, model?: string | null, allow_all_tools?: boolean | null, allow_tool?: string | null, deny_tool?: string | null, add_dir?: Array<string> | null, disable_mcp_server?: Array<string> | null, base_command_override?: string | null, additional_params?: Array<string> | null, env?: { [key in string]?: string } | null, };

export type Opencode = { append_prompt: AppendPrompt, model?: string | null, mode?: string | null, 
/**
 * Auto-approve agent actions
 */
auto_approve: boolean, base_command_override?: string | null, additional_params?: Array<string> | null, env?: { [key in string]?: string } | null, };

export type QwenCode = { append_prompt: AppendPrompt, yolo?: boolean | null, base_command_override?: string | null, additional_params?: Array<string> | null, env?: { [key in string]?: string } | null, };

export type Droid = { append_prompt: AppendPrompt, autonomy: Autonomy, model?: string | null, reasoning_effort?: DroidReasoningEffort | null, base_command_override?: string | null, additional_params?: Array<string> | null, env?: { [key in string]?: string } | null, };

export type Autonomy = "normal" | "low" | "medium" | "high" | "skip-permissions-unsafe";

export type DroidReasoningEffort = "none" | "dynamic" | "off" | "low" | "medium" | "high";

export type AppendPrompt = string | null;

export type CodingAgentInitialRequest = { prompt: string, 
/**
 * Executor profile specification
 */
executor_profile_id: ExecutorProfileId, 
/**
 * Optional relative path to execute the agent in (relative to container_ref).
 * If None, uses the container_ref directory directly.
 */
working_dir: string | null, };

export type CodingAgentFollowUpRequest = { prompt: string, session_id: string, 
/**
 * Executor profile specification
 */
executor_profile_id: ExecutorProfileId, 
/**
 * Optional relative path to execute the agent in (relative to container_ref).
 * If None, uses the container_ref directory directly.
 */
working_dir: string | null, };

export type CommandExitStatus = { "type": "exit_code", code: number, } | { "type": "success", success: boolean, };

export type CommandRunResult = { exit_status: CommandExitStatus | null, output: string | null, };

export type NormalizedEntry = { timestamp: string | null, entry_type: NormalizedEntryType, content: string, };

export type NormalizedEntryType = { "type": "user_message" } | { "type": "user_feedback", denied_tool: string, } | { "type": "assistant_message" } | { "type": "tool_use", tool_name: string, action_type: ActionType, status: ToolStatus, } | { "type": "system_message" } | { "type": "error_message", error_type: NormalizedEntryError, } | { "type": "thinking" } | { "type": "loading" } | { "type": "next_action", failed: boolean, execution_processes: number, needs_setup: boolean, };

export type FileChange = { "action": "write", content: string, } | { "action": "delete" } | { "action": "rename", new_path: string, } | { "action": "edit", 
/**
 * Unified diff containing file header and hunks.
 */
unified_diff: string, 
/**
 * Whether line number in the hunks are reliable.
 */
has_line_numbers: boolean, };

export type ActionType = { "action": "file_read", path: string, } | { "action": "file_edit", path: string, changes: Array<FileChange>, } | { "action": "command_run", command: string, result: CommandRunResult | null, } | { "action": "search", query: string, } | { "action": "web_fetch", url: string, } | { "action": "tool", tool_name: string, arguments: JsonValue | null, result: ToolResult | null, } | { "action": "task_create", description: string, } | { "action": "plan_presentation", plan: string, } | { "action": "todo_management", todos: Array<TodoItem>, operation: string, } | { "action": "other", description: string, };

export type TodoItem = { content: string, status: string, priority: string | null, };

export type NormalizedEntryError = { "type": "setup_required" } | { "type": "other" };

export type ToolResult = { type: ToolResultValueType, 
/**
 * For Markdown, this will be a JSON string; for JSON, a structured value
 */
value: JsonValue, };

export type ToolResultValueType = { "type": "markdown" } | { "type": "json" };

export type ToolStatus = { "status": "created" } | { "status": "success" } | { "status": "failed" } | { "status": "denied", reason: string | null, } | { "status": "pending_approval", approval_id: string, requested_at: string, timeout_at: string, } | { "status": "timed_out" };

export type PatchType = { "type": "NORMALIZED_ENTRY", "content": NormalizedEntry } | { "type": "STDOUT", "content": string } | { "type": "STDERR", "content": string } | { "type": "DIFF", "content": Diff };

export type JsonValue = number | string | boolean | Array<JsonValue> | { [key in string]?: JsonValue } | null;

export const DEFAULT_PR_DESCRIPTION_PROMPT = `Update the GitHub PR that was just created with a better title and description.
The PR number is #{pr_number} and the URL is {pr_url}.

Analyze the changes in this branch and write:
1. A concise, descriptive title that summarizes the changes, postfixed with "(Vibe Kanban)"
2. A detailed description that explains:
   - What changes were made
   - Why they were made (based on the task context)
   - Any important implementation details
   - At the end, include a note: "This PR was written using [Vibe Kanban](https://vibekanban.com)"

Use \`gh pr edit\` to update the PR.`;

// User Registration types for onboarding flow
export type RegistrationStatus = "pending" | "approved" | "rejected";

export type UserRegistration = {
  id: string;
  clerk_user_id: string;
  email: string;
  first_name: string | null;
  last_name: string | null;
  workspace_name: string;
  planned_teams: number;
  planned_projects: number;
  status: RegistrationStatus;
  reviewed_by: string | null;
  reviewed_at: Date | null;
  rejection_reason: string | null;
  created_at: Date;
  updated_at: Date;
};

export type CreateUserRegistration = {
  clerk_user_id: string;
  email: string;
  first_name: string | null;
  last_name: string | null;
  workspace_name: string;
  planned_teams: number | null;
  planned_projects: number | null;
};

export type ReviewUserRegistration = {
  status: RegistrationStatus;
  rejection_reason: string | null;
};