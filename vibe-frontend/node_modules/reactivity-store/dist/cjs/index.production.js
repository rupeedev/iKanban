'use strict';

var reactivity = require('@vue/reactivity');
var shared = require('@vue/shared');
var react = require('react');
var index_js = require('use-sync-external-store/shim/index.js');

/**
 * @internal
 */
const isServer = typeof window === "undefined";
/**
 * @internal
 */
var InternalNameSpace;
(function (InternalNameSpace) {
    InternalNameSpace["$$__ignore__$$"] = "$$__ignore__$$";
    InternalNameSpace["$$__persist__$$"] = "$$__persist__$$";
    InternalNameSpace["$$__subscribe__$$"] = "$$__subscribe__$$";
    InternalNameSpace["$$__redux_dev_tool__$$"] = "$$__redux_dev_tool__$$";
})(InternalNameSpace || (InternalNameSpace = {}));

const jobs = new Set();
const MAX_UPDATE = 20;
let process = false;
let updateCount = 0;
const flushQueue = () => {
    const all = [...jobs.values()].slice(0);
    jobs.clear();
    for (const job of all) {
        job.notify();
    }
    process = false;
    // fix miss update
    if (jobs.size) {
        updateCount++;
        if (updateCount > MAX_UPDATE) {
            throw new Error(`[reactivity-store] have a infinity update for current store, pendingJobs: ${new Set(jobs)}`);
        }
        flushQueue();
    }
};
/**
 * @internal
 */
const queueJob = (job) => {
    jobs.add(job);
    if (process)
        return;
    process = true;
    updateCount = 0;
    Promise.resolve().then(flushQueue);
};

let currentController = null;
/**
 * @public
 */
function getCurrentController() {
    return currentController;
}
class ControllerEffect extends reactivity.ReactiveEffect {
    get _isControllerEffect() {
        return true;
    }
    constructor(getter) {
        super(getter);
    }
}
const catchError = (cb, instance) => {
    return () => {
        if (!instance._isActive)
            return;
        try {
            const res = cb();
            if (shared.isPromise(res)) {
                throw new Error(`[reactivity-store] selector should be a pure function, but current is a async function`);
            }
            return res;
        }
        catch (e) {
            return null;
        }
    };
};
/**
 * @public
 */
class Controller {
    constructor(_getState, _compare, _lifeCycle, _namespace, _onUpdate) {
        this._getState = _getState;
        this._compare = _compare;
        this._lifeCycle = _lifeCycle;
        this._namespace = _namespace;
        this._onUpdate = _onUpdate;
        this._listeners = new Set();
        // make the state change and component update
        this._updateCount = 0;
        this._isActive = true;
        this.notify = () => {
            var _a;
            if (!this._isActive)
                return;
            this._updateCount++;
            try {
                (_a = this._onUpdate) === null || _a === void 0 ? void 0 : _a.call(this);
            }
            catch (e) {
                this._lifeCycle.canUpdateComponent = false;
            }
            this._listeners.forEach((f) => f());
        };
        this._scheduler = () => {
            const p = getCurrentController();
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            currentController = this;
            const newState = this._effect.run();
            currentController = p;
            if (!this._isActive)
                return;
            const isSame = this._compare(this._state, newState);
            this._state = newState;
            if (!isSame) {
                if (this._lifeCycle.canUpdateComponent) {
                    if (this._lifeCycle.syncUpdateComponent) {
                        this.notify();
                    }
                    else {
                        queueJob(this);
                    }
                }
            }
        };
        this.subscribe = (listener) => {
            this._listeners.add(listener);
            return () => this._listeners.delete(listener);
        };
        this.getState = () => {
            return this._updateCount;
        };
        this.getEffect = () => {
            return this._effect;
        };
        this.getSelectorState = () => {
            return this._getStateSafe();
        };
        this.getLifeCycle = () => {
            return this._lifeCycle;
        };
        this._getStateSafe = catchError(_getState, this);
        this._effect = new ControllerEffect(this._getStateSafe);
        this._effect.scheduler = this._scheduler;
    }
    // TODO move into constructor function?
    run() {
        const p = getCurrentController();
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        currentController = this;
        this._state = this._effect.run();
        currentController = p;
    }
    stop() {
        this._effect.stop();
        this._listeners.clear();
        this._isActive = false;
        this._state = null;
    }
    setActive(d) {
        this._isActive = d;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * @internal
 */
const createLifeCycle = () => ({
    onBeforeMount: [],
    onBeforeUpdate: [],
    onBeforeUnmount: [],
    onMounted: [],
    onUpdated: [],
    onUnmounted: [],
    hasHookInstall: false,
    canUpdateComponent: true,
    syncUpdateComponent: false,
});

/* eslint-disable @typescript-eslint/no-unused-expressions */
function _traverse(value, seen) {
    if (!shared.isObject(value) || value[reactivity.ReactiveFlags.SKIP] || react.isValidElement(value)) {
        return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
        return value;
    }
    seen.add(value);
    if (reactivity.isRef(value)) {
        traverse(value.value, seen);
    }
    else if (shared.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if (shared.isSet(value) || shared.isMap(value)) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else if (shared.isPlainObject(value)) {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}
function traverseShallow(value) {
    if (!shared.isObject(value) || value[reactivity.ReactiveFlags.SKIP] || react.isValidElement(value)) {
        return value;
    }
    if (reactivity.isRef(value)) {
        value.value;
    }
    else if (shared.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            value[i];
        }
    }
    else if (shared.isSet(value) || shared.isMap(value)) {
        value.forEach((v) => {
        });
    }
    else if (shared.isPlainObject(value)) {
        for (const key in value) {
            value[key];
        }
    }
    return value;
}
/**
 * @internal
 */
function traverse(value, seen) {
    {
        return _traverse(value, seen);
    }
}

/* eslint-disable @typescript-eslint/no-unsafe-function-type */
/**
 * @internal
 */
const useCallbackRef = (callback) => {
    const callbackRef = react.useRef(callback);
    callbackRef.current = callback;
    const memoCallback = react.useCallback((...args) => {
        var _a;
        return (_a = callbackRef.current) === null || _a === void 0 ? void 0 : _a.call(null, ...args);
    }, []);
    return memoCallback;
};
/**
 * @internal
 */
const useSubscribeCallbackRef = (callback, deepSelector) => {
    const callbackRef = react.useRef();
    callbackRef.current = typeof callback === "function" ? callback : null;
    const memoCallback = useCallbackRef((arg) => {
        if (callbackRef.current) {
            const re = callbackRef.current(arg);
            if (deepSelector) {
                traverse(re);
            }
            else {
                // fix useState(s => s) not subscribe reactive state update
                traverseShallow(re);
            }
            return re;
        }
        else {
            // !BREAKING CHANGE, will change the default behavior when the deepSelector is true
            if (deepSelector) {
                traverse(arg);
            }
            else {
                traverseShallow(arg);
            }
            return arg;
        }
    });
    return memoCallback;
};
/**
 * @internal
 */
const usePrevValue = (v) => {
    const vRef = react.useRef(v);
    react.useEffect(() => {
        vRef.current = v;
    }, [v]);
    return vRef.current;
};
const createHook = (reactiveState, readonlyState, initialState, lifeCycle, deepSelector = true, stableSelector = false, stableCompare = true, namespace, actions = undefined) => {
    const controllerList = new Set();
    let active = true;
    namespace = namespace || InternalNameSpace.$$__ignore__$$;
    // tool function to generate `useSelector` hook
    const generateUseHook = (type) => {
        const currentIsDeep = type === "default" ? deepSelector : type === "deep" || type === "deep-stable";
        const currentIsStable = type === "default" ? stableSelector : type === "deep-stable" || type === "shallow-stable";
        function useReactiveHookWithSelector(selector, compare) {
            const ref = react.useRef();
            const selectorRef = useSubscribeCallbackRef(selector, currentIsDeep);
            const getSelected = useCallbackRef(() => {
                // 0.1.9
                // make the returned value as a readonly value, so the only way to change the state is in the `actions` middleware
                if (selector) {
                    ref.current = selector(Object.assign(Object.assign({}, readonlyState), actions));
                }
                else {
                    ref.current = Object.assign(Object.assign({}, readonlyState), actions);
                }
            });
            const memoCompare = useCallbackRef((p, n) => {
                if (compare && typeof compare === "function") {
                    return compare(p, n);
                }
                return false;
            });
            // may not work will with hmr
            const prevSelector = currentIsStable ? selector : usePrevValue(selector);
            const prevCompare = stableCompare ? compare : usePrevValue(compare);
            const ControllerInstance = react.useMemo(() => new Controller(() => selectorRef(reactiveState), memoCompare, lifeCycle, namespace, getSelected), []);
            index_js.useSyncExternalStore(ControllerInstance.subscribe, ControllerInstance.getState, ControllerInstance.getState);
            // initial
            react.useMemo(() => {
                ControllerInstance.run();
                getSelected();
            }, [ControllerInstance, getSelected]);
            // !TODO try to improve the performance
            // rerun when the 'selector' change
            react.useMemo(() => {
                if (prevSelector !== selector) {
                    ControllerInstance.run();
                    getSelected();
                }
            }, [ControllerInstance, prevSelector, selector]);
            react.useMemo(() => {
                if (prevCompare !== compare) {
                    ControllerInstance.run();
                    getSelected();
                }
            }, [ControllerInstance, prevCompare, compare]);
            react.useEffect(() => {
                ControllerInstance.setActive(true);
                controllerList.add(ControllerInstance);
                return () => {
                    // fix React strictMode issue
                    {
                        ControllerInstance.stop();
                    }
                    controllerList.delete(ControllerInstance);
                };
            }, [ControllerInstance]);
            return ref.current;
        }
        return useReactiveHookWithSelector;
    };
    const defaultHook = generateUseHook("default");
    const deepHook = generateUseHook("deep");
    const deepStableHook = generateUseHook("deep-stable");
    const shallowHook = generateUseHook("shallow");
    const shallowStableHook = generateUseHook("shallow-stable");
    function useSelector(selector, compare) {
        return defaultHook(selector, compare);
    }
    const typedUseSelector = useSelector;
    typedUseSelector.getState = () => {
        return reactivity.toRaw(initialState);
    };
    typedUseSelector.getLifeCycle = () => lifeCycle;
    typedUseSelector.getActions = () => actions;
    typedUseSelector.getReactiveState = () => reactiveState;
    typedUseSelector.getReadonlyState = () => readonlyState;
    typedUseSelector.useDeepSelector = deepHook;
    typedUseSelector.useDeepStableSelector = deepStableHook;
    typedUseSelector.useShallowSelector = shallowHook;
    typedUseSelector.useShallowStableSelector = shallowStableHook;
    typedUseSelector.subscribe = (selector, cb, shallow) => {
        const subscribeSelector = () => {
            const re = selector(reactiveState);
            if (shallow) {
                traverseShallow(re);
            }
            else {
                traverse(re);
            }
            return re;
        };
        const controller = new Controller(subscribeSelector, Object.is, lifeCycle, InternalNameSpace.$$__subscribe__$$, () => cb());
        controller.run();
        controllerList.add(controller);
        return () => {
            controllerList.delete(controller);
            controller.stop();
        };
    };
    typedUseSelector.getIsActive = () => active;
    typedUseSelector.clear = () => {
        controllerList.forEach((i) => i.stop());
        active = false;
    };
    return typedUseSelector;
};

/* eslint-disable @typescript-eslint/no-unsafe-function-type */
/**
 * @internal
 */
const persistKey = "reactivity-store/persist-";
/**
 * @internal
 */
const debounce = (cb, time) => {
    let id = null;
    return ((...args) => {
        clearTimeout(id);
        id = setTimeout(() => cb.call(null, ...args), time);
    });
};
/**
 * @internal
 */
const getFinalState = (state) => {
    if (state["$$__state__$$"])
        return state["$$__state__$$"];
    return state;
};
/**
 * @internal
 */
const getFinalMiddleware = (state) => {
    if (state["$$__state__$$"])
        return (state["$$__middleware__$$"] || {});
    return {};
};
/**
 * @internal
 */
const getFinalActions = (state) => {
    if (state["$$__state__$$"])
        return (state["$$__actions__$$"] || {});
    return {};
};
/**
 * @internal
 */
const getFinalNamespace = (state) => {
    if (state["$$__state__$$"])
        return (state["$$__namespace__$$"] || {});
    return {};
};
/**
 * @internal
 */
const getFinalSelectorOptions = (state) => {
    if (state["$$__state__$$"])
        return (state["$$__selectorOptions__$$"] || {});
    return {};
};
// function for help to build external middleware
/**
 * @internal
 */
function createMiddleware(setup, options) {
    return () => {
        const state = setup();
        const initialState = getFinalState(state);
        const middleware = getFinalMiddleware(state);
        const actions = getFinalActions(state);
        const namespace = getFinalNamespace(state);
        const selectorOptions = getFinalSelectorOptions(state);
        middleware[options.name] = true;
        return {
            ["$$__state__$$"]: reactivity.toRaw(initialState),
            ["$$__actions__$$"]: actions,
            // field to check duplicate middleware
            ["$$__middleware__$$"]: middleware,
            ["$$__namespace__$$"]: namespace,
            ["$$__selectorOptions__$$"]: selectorOptions,
        };
    };
}

/**
 * @internal
 */
const _internalCreateStore = (creator, name = "createStore", lifeCycle) => {
    const state = creator();
    const _state = getFinalState(state);
    const rawState = reactivity.toRaw(_state);
    const reactiveState = reactivity.reactive(_state);
    const readonlyState = reactivity.readonly(_state);
    const lifeCycleInstance = lifeCycle || createLifeCycle();
    const useSelector = createHook(reactiveState, readonlyState, rawState, lifeCycleInstance);
    return useSelector;
};
/**
 * @internal
 */
const internalCreateStore = (creator, name = "createStore", lifeCycle) => {
    const scope = reactivity.effectScope();
    const useSelector = scope.run(() => _internalCreateStore(creator, name, lifeCycle));
    useSelector.scope = scope;
    return useSelector;
};
/**
 * @internal
 */
let globalStoreLifeCycle = null;
/**
 * @internal
 */
const setGlobalStoreLifeCycle = (instance) => {
    globalStoreLifeCycle = instance;
};

// vue like lifeCycle for react app;
/**
 * @public
 */
const onMounted = (cb) => {
    if (!globalStoreLifeCycle)
        throw new Error("[reactivity-store] can not use 'onMounted' outside of the 'createStoreWithComponent' function");
    globalStoreLifeCycle.onMounted.push(cb);
    globalStoreLifeCycle.hasHookInstall = true;
};
/**
 * @public
 */
const onUpdated = (cb) => {
    if (!globalStoreLifeCycle)
        throw new Error("[reactivity-store] can not use 'onUpdated' outside of the 'createStoreWithComponent' function");
    globalStoreLifeCycle.onUpdated.push(cb);
    globalStoreLifeCycle.hasHookInstall = true;
};
/**
 * @public
 */
const onUnmounted = (cb) => {
    if (!globalStoreLifeCycle)
        throw new Error("[reactivity-store] can not use 'onUnmounted' outside of the 'createStoreWithComponent' function");
    globalStoreLifeCycle.onUnmounted.push(cb);
    globalStoreLifeCycle.hasHookInstall = true;
};
/**
 * @public
 */
const onBeforeMount = (cb) => {
    if (!globalStoreLifeCycle)
        throw new Error("[reactivity-store] can not use 'onBeforeMount' outside of the 'createStoreWithComponent' function");
    globalStoreLifeCycle.onBeforeMount.push(cb);
    globalStoreLifeCycle.hasHookInstall = true;
};
/**
 * @public
 */
const onBeforeUpdate = (cb) => {
    if (!globalStoreLifeCycle)
        throw new Error("[reactivity-store] can not use 'onBeforeUpdate' outside of the 'createStoreWithComponent' function");
    globalStoreLifeCycle.onBeforeUpdate.push(cb);
    globalStoreLifeCycle.hasHookInstall = true;
};
/**
 * @public
 */
const onBeforeUnmount = (cb) => {
    if (!globalStoreLifeCycle)
        throw new Error("[reactivity-store] can not use 'onBeforeUnmount' outside of the 'createStoreWithComponent' function");
    globalStoreLifeCycle.onBeforeUnmount.push(cb);
    globalStoreLifeCycle.hasHookInstall = true;
};

/* eslint-disable @typescript-eslint/no-unsafe-function-type */
/**
 * @public
 */
function withActions(setup, options) {
    return createMiddleware(() => {
        const _initialState = setup();
        const initialState = getFinalState(_initialState);
        const middleware = getFinalMiddleware(_initialState);
        const actions = getFinalActions(_initialState);
        const namespace = getFinalNamespace(_initialState);
        const selectorOptions = getFinalSelectorOptions(_initialState);
        const reactiveState = reactivity.reactive(initialState);
        const pendingGenerate = options.generateActions;
        const allActions = pendingGenerate === null || pendingGenerate === void 0 ? void 0 : pendingGenerate(reactiveState);
        const batchActions = allActions;
        return {
            ["$$__state__$$"]: reactivity.toRaw(reactiveState),
            ["$$__actions__$$"]: Object.assign(Object.assign({}, actions), batchActions),
            ["$$__middleware__$$"]: middleware,
            ["$$__namespace__$$"]: namespace,
            ["$$__selectorOptions__$$"]: selectorOptions,
        };
    }, { name: "withActions" });
}

/* eslint-disable @typescript-eslint/no-unsafe-function-type */
const defaultCompare$1 = () => false;
/**
 * @public
 */
function withPersist(setup, options) {
    return createMiddleware(() => {
        var _a, _b, _c, _d, _e;
        const _initialState = setup();
        const initialState = getFinalState(_initialState);
        const middleware = getFinalMiddleware(_initialState);
        const auctions = getFinalActions(_initialState);
        const namespace = getFinalNamespace(_initialState);
        const selectorOptions = getFinalSelectorOptions(_initialState);
        let hasSet = false;
        if (middleware["withPersist"])
            hasSet = true;
        const getMigrateState = (storage) => {
            try {
                if (options.migrateVersion) {
                    const migrateKey = persistKey + options.key + `_${options.migrateVersion}`;
                    const migrateStateString = storage.getItem(migrateKey);
                    if (migrateStateString) {
                        const migrateState = JSON.parse(migrateStateString);
                        if ((migrateState === null || migrateState === void 0 ? void 0 : migrateState.version) === options.migrateVersion && migrateState.data) {
                            return options.migrateState(migrateState, () => { var _a; return (_a = storage.removeItem) === null || _a === void 0 ? void 0 : _a.call(storage, migrateKey); });
                        }
                    }
                }
                return null;
            }
            catch (_a) {
            }
        };
        if (!isServer && !hasSet) {
            let re = initialState;
            const storageKey = persistKey + options.key + (options.version ? `_${options.version}` : "");
            let storage = null;
            try {
                storage = ((_a = options === null || options === void 0 ? void 0 : options.getStorage) === null || _a === void 0 ? void 0 : _a.call(options)) || (window === null || window === void 0 ? void 0 : window.localStorage);
                if (!storage) {
                    if (false) ;
                    return {
                        ["$$__state__$$"]: reactivity.toRaw(initialState),
                        ["$$__middleware__$$"]: middleware,
                        ["$$__actions__$$"]: auctions,
                        ["$$__namespace__$$"]: namespace,
                        ["$$__selectorOptions__$$"]: selectorOptions,
                    };
                }
                const storageStateString = storage.getItem(storageKey);
                const storageState = JSON.parse(storageStateString);
                const migrateState = getMigrateState(storage);
                if (false && migrateState && storageState) ;
                if ((storageState === null || storageState === void 0 ? void 0 : storageState.version) === (options.version || options.key) && storageState.data) {
                    const cachedState = ((_b = options === null || options === void 0 ? void 0 : options.parse) === null || _b === void 0 ? void 0 : _b.call(options, storageState.data)) || JSON.parse(storageState.data);
                    re = ((_c = options === null || options === void 0 ? void 0 : options.merge) === null || _c === void 0 ? void 0 : _c.call(options, initialState, cachedState)) || Object.assign(initialState, cachedState);
                }
                else if (migrateState) {
                    re = ((_d = options === null || options === void 0 ? void 0 : options.merge) === null || _d === void 0 ? void 0 : _d.call(options, initialState, migrateState)) || Object.assign(initialState, migrateState);
                }
            }
            catch (e) {
                try {
                    (_e = storage.removeItem) === null || _e === void 0 ? void 0 : _e.call(storage, storageKey);
                }
                catch (_f) {
                }
            }
            re = reactivity.reactive(re);
            const onUpdate = debounce(() => {
                var _a, _b, _c;
                try {
                    const stringifyState = ((_a = options === null || options === void 0 ? void 0 : options.stringify) === null || _a === void 0 ? void 0 : _a.call(options, re)) || JSON.stringify(re);
                    const cache = { data: stringifyState, version: options.version || options.key };
                    if (false && options.devLog) ;
                    (_b = storage.setItem) === null || _b === void 0 ? void 0 : _b.call(storage, storageKey, JSON.stringify(cache));
                }
                catch (e) {
                    try {
                        (_c = storage.removeItem) === null || _c === void 0 ? void 0 : _c.call(storage, storageKey);
                    }
                    catch (_d) {
                    }
                }
            }, options.debounceTime || 40);
            const subscribe = () => {
                let _re = re;
                if (typeof options.listener === "function") {
                    _re = options.listener(re);
                }
                if (options.shallow) {
                    traverseShallow(_re);
                }
                else {
                    traverse(_re);
                }
            };
            const ControllerInstance = new Controller(subscribe, defaultCompare$1, createLifeCycle(), InternalNameSpace.$$__persist__$$, onUpdate);
            ControllerInstance.run();
            return {
                ["$$__state__$$"]: reactivity.toRaw(re),
                ["$$__middleware__$$"]: middleware,
                ["$$__actions__$$"]: auctions,
                ["$$__namespace__$$"]: namespace,
                ["$$__selectorOptions__$$"]: selectorOptions,
            };
        }
        else {
            return {
                ["$$__state__$$"]: reactivity.toRaw(initialState),
                ["$$__middleware__$$"]: middleware,
                ["$$__actions__$$"]: auctions,
                ["$$__namespace__$$"]: namespace,
                ["$$__selectorOptions__$$"]: selectorOptions,
            };
        }
    }, { name: "withPersist" });
}

/* eslint-disable @typescript-eslint/no-unsafe-function-type */
/**
 * @public
 */
function withNamespace(setup, options) {
    return createMiddleware(() => {
        const _initialState = setup();
        const initialState = getFinalState(_initialState);
        const middleware = getFinalMiddleware(_initialState);
        const actions = getFinalActions(_initialState);
        const namespace = getFinalNamespace(_initialState);
        const selectorOptions = getFinalSelectorOptions(_initialState);
        return {
            ["$$__state__$$"]: reactivity.toRaw(initialState),
            ["$$__actions__$$"]: actions,
            ["$$__middleware__$$"]: middleware,
            ["$$__namespace__$$"]: Object.assign(Object.assign({}, namespace), options),
            ["$$__selectorOptions__$$"]: selectorOptions,
        };
    }, { name: "withNamespace" });
}

/* eslint-disable @typescript-eslint/no-unsafe-function-type */
/**
 * @public
 */
function withSelectorOptions(setup, options) {
    return createMiddleware(() => {
        const _initialState = setup();
        const initialState = getFinalState(_initialState);
        const middleware = getFinalMiddleware(_initialState);
        const actions = getFinalActions(_initialState);
        const namespace = getFinalNamespace(_initialState);
        const selectorOptions = getFinalSelectorOptions(_initialState);
        return {
            ["$$__state__$$"]: reactivity.toRaw(initialState),
            ["$$__actions__$$"]: actions,
            ["$$__middleware__$$"]: middleware,
            ["$$__namespace__$$"]: namespace,
            ["$$__selectorOptions__$$"]: Object.assign(Object.assign({}, selectorOptions), options),
        };
    }, { name: "withSelectorOptions" });
}
/**
 * @public
 * @deprecated
 * use `withSelectorOptions` instead
 */
const withDeepSelector = withSelectorOptions;

/**
 * @public
 * @deprecated
 * not recommend to use this function, use `createStore` instead
 */
function createStoreWithComponent(props) {
    const { setup, render } = props;
    const ComponentWithState = (props) => {
        const useSelector = react.useMemo(() => {
            const lifeCycleInstance = createLifeCycle();
            setGlobalStoreLifeCycle(lifeCycleInstance);
            const useSelector = internalCreateStore(setup, "createStoreWithComponent", lifeCycleInstance);
            setGlobalStoreLifeCycle(null);
            return useSelector;
        }, []);
        const [isMount, setIsMount] = react.useState(false);
        const state = useSelector.getReadonlyState();
        const lifeCycleInstance = useSelector.getLifeCycle();
        const { children } = props, last = __rest(props, ["children"]);
        const _targetRender = render || props.children;
        const targetRender = _targetRender !== null && _targetRender !== void 0 ? _targetRender : (() => {
            lifeCycleInstance.canUpdateComponent = false;
        });
        // subscribe reactivity-store update
        useSelector();
        react.useEffect(() => {
            if (lifeCycleInstance.hasHookInstall) {
                if (!isMount) {
                    lifeCycleInstance.onBeforeMount.forEach((f) => f());
                    lifeCycleInstance.onMounted.forEach((f) => f());
                    setIsMount(true);
                }
                else {
                    const lastSync = lifeCycleInstance.syncUpdateComponent;
                    lifeCycleInstance.syncUpdateComponent = true;
                    lifeCycleInstance.canUpdateComponent = false;
                    lifeCycleInstance.onBeforeUpdate.forEach((f) => f());
                    lifeCycleInstance.canUpdateComponent = true;
                    lifeCycleInstance.syncUpdateComponent = lastSync;
                    lifeCycleInstance.onUpdated.forEach((f) => f());
                }
            }
        });
        react.useEffect(() => {
            return () => {
                if (lifeCycleInstance.hasHookInstall) {
                    lifeCycleInstance.onBeforeUnmount.forEach((f) => f());
                    lifeCycleInstance.onUnmounted.forEach((f) => f());
                }
            };
        }, [lifeCycleInstance]);
        react.useEffect(() => () => { var _a; return (_a = useSelector.scope) === null || _a === void 0 ? void 0 : _a.stop(); }, [useSelector]);
        const renderedChildren = targetRender(Object.assign(Object.assign({}, last), state)) || null;
        return renderedChildren;
    };
    return ComponentWithState;
}

/**
 * @public
 *
 * @example
 * ```typescript
 * import { createStore, ref } from "r-store";
 *
 * const count = createStore(() => {
 *  const state = ref(0);
 *
 *  const increment = () => {
 *    state.value++;
 *  };
 *
 *  return { state, increment };
 * });
 * ```
 */
const createStore = (creator) => {
    return internalCreateStore(creator);
};

/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
function internalCreateState(setup, name, option) {
    var _a, _b, _c;
    let creator = setup;
    if (option === null || option === void 0 ? void 0 : option.withPersist) {
        creator = withPersist(creator, typeof option.withPersist === "string" ? { key: option.withPersist } : option.withPersist);
    }
    if (option === null || option === void 0 ? void 0 : option.withActions) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        creator = withActions(creator, { generateActions: option.withActions });
    }
    if (option === null || option === void 0 ? void 0 : option.withNamespace) {
        creator = withNamespace(creator, typeof option.withNamespace === "string" ? { namespace: option.withNamespace, reduxDevTool: true } : option.withNamespace);
    }
    if (typeof (option === null || option === void 0 ? void 0 : option.withDeepSelector) !== "undefined" || typeof (option === null || option === void 0 ? void 0 : option.withStableSelector) !== "undefined") {
        creator = withSelectorOptions(creator, { deepSelector: option.withDeepSelector, stableSelector: option.withStableSelector });
    }
    const lifeCycle = createLifeCycle();
    const state = creator();
    // handle withActions middleware;
    const initialState = getFinalState(state);
    let actions = getFinalActions(state);
    const namespaceOptions = getFinalNamespace(state);
    const selectorOptions = getFinalSelectorOptions(state);
    const rawState = reactivity.toRaw(initialState);
    namespaceOptions.reduxDevTool && !isServer;
    const reactiveState = reactivity.reactive(initialState);
    const readonlyState = reactivity.readonly(initialState);
    const deepSelector = (_a = selectorOptions === null || selectorOptions === void 0 ? void 0 : selectorOptions.deepSelector) !== null && _a !== void 0 ? _a : true;
    const stableSelector = (_b = selectorOptions === null || selectorOptions === void 0 ? void 0 : selectorOptions.stableSelector) !== null && _b !== void 0 ? _b : false;
    const stableCompare = (_c = selectorOptions.stableCompare) !== null && _c !== void 0 ? _c : true;
    const useSelector = createHook(reactiveState, readonlyState, rawState, lifeCycle, deepSelector, stableSelector, stableCompare, namespaceOptions.namespace, actions);
    return useSelector;
}

/* eslint-disable @typescript-eslint/no-empty-object-type */
/* eslint-disable @typescript-eslint/no-unsafe-function-type */
// `createState` provider
/**
 * @public
 *
 * @example
 * ```typescript
 * import { createState } from "r-store";
 *
 * const count = createState(() => ({state: 0}), {
 *  withPersist: "count",
 *  withActions: (state) => ({
 *   increment: () => {
 *    state.state++;
 *   },
 *  }),
 *  withNamespace: "count",
 *  withDeepSelector: true,
 *  withStableSelector: true,
 * });
 * ```
 */
function createState(setup, options) {
    return internalCreateState(setup, "createState", options);
}

const defaultBatch = (cb) => cb();
/**
 * @internal
 */
const batchObject = { current: defaultBatch };
/**
 * @public
 * @deprecated
 * no need to use this function
 */
const setBatch = (batch) => {
    batchObject.current = batch;
};
/**
 * @public
 * @deprecated
 * no need to use this function
 */
const getBatch = () => {
    return batchObject.current;
};
/**
 * @public
 * @deprecated
 * no need to use this function
 */
const resetBatch = () => {
    batchObject.current = defaultBatch;
};
/**
 * @public
 * @deprecated
 * no need to use this function
 */
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const wrapperBatchUpdate = (cb) => {
    return ((...args) => batchObject.current(() => (args.length ? cb.call(null, ...args) : cb.call(null))));
};

const defaultCompare = () => false;
/**
 * @public
 */
const useReactiveEffect = (effectCallback) => {
    const memoCallback = useCallbackRef(effectCallback);
    react.useEffect(() => {
        let cleanCb = () => void 0;
        const subscribe = () => {
            const clean = memoCallback();
            if (typeof clean === "function") {
                cleanCb = clean;
            }
            else {
                cleanCb = () => void 0;
            }
        };
        const controller = new Controller(subscribe, defaultCompare, createLifeCycle(), InternalNameSpace.$$__subscribe__$$, () => {
            // run the effect when the subscribed state change
            cleanCb();
        });
        // run the effect on the component mount
        controller.run();
        return () => {
            cleanCb();
            controller.stop();
        };
    }, []);
};

/**
 * @public
 */
const useReactiveState = (initialState) => {
    const [useSelector] = react.useState(() => {
        const setup = typeof initialState === "function" ? initialState : () => initialState;
        return internalCreateState(setup);
    });
    // subscribe reactive store update
    useSelector();
    const setState = react.useMemo(() => (payload) => {
        if (typeof payload === "function") {
            payload(useSelector.getReactiveState());
        }
        else {
            const reactiveObj = useSelector.getReactiveState();
            Object.keys(payload).forEach((key) => {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-expect-error
                reactiveObj[key] = payload[key];
            });
        }
    }, [useSelector]);
    react.useEffect(() => () => useSelector.clear(), [useSelector]);
    // make the state can be used in the `useReactiveEffect` hook
    // use getReactiveState to make effect can track deps
    return [useSelector.getReactiveState(), setState];
};

/**
 * @public
 */
const version = "0.3.12";

exports.Controller = Controller;
exports.createState = createState;
exports.createStore = createStore;
exports.createStoreWithComponent = createStoreWithComponent;
exports.getBatch = getBatch;
exports.getCurrentController = getCurrentController;
exports.onBeforeMount = onBeforeMount;
exports.onBeforeUnmount = onBeforeUnmount;
exports.onBeforeUpdate = onBeforeUpdate;
exports.onMounted = onMounted;
exports.onUnmounted = onUnmounted;
exports.onUpdated = onUpdated;
exports.resetBatch = resetBatch;
exports.setBatch = setBatch;
exports.useReactiveEffect = useReactiveEffect;
exports.useReactiveState = useReactiveState;
exports.version = version;
exports.withActions = withActions;
exports.withDeepSelector = withDeepSelector;
exports.withNamespace = withNamespace;
exports.withPersist = withPersist;
exports.withSelectorOptions = withSelectorOptions;
exports.wrapperBatchUpdate = wrapperBatchUpdate;
Object.keys(reactivity).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return reactivity[k]; }
    });
});
