import {
  createLowlight,
  grammars2 as grammars
} from "./chunk-4XTBART3.js";
import {
  __commonJS,
  __toESM
} from "./chunk-OL46QLBJ.js";

// ../node_modules/.pnpm/fast-diff@1.3.0/node_modules/fast-diff/diff.js
var require_diff = __commonJS({
  "../node_modules/.pnpm/fast-diff@1.3.0/node_modules/fast-diff/diff.js"(exports, module) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, cleanup, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      if (cleanup) {
        diff_cleanupSemantic(diffs);
      }
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [
          [DIFF_DELETE, text1],
          [DIFF_INSERT, text2]
        ];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [
        [DIFF_DELETE, text1],
        [DIFF_INSERT, text2]
      ];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_commonOverlap_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i),
            shorttext2.substring(j)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 4)
      );
      var hm2 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 2)
      );
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupSemantic(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastequality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastequality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, [
              DIFF_DELETE,
              lastequality
            ]);
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs);
      }
      diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                insertion.substring(0, overlap_length1)
              ]);
              diffs[pointer - 1][1] = deletion.substring(
                0,
                deletion.length - overlap_length1
              );
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                deletion.substring(0, overlap_length2)
              ]);
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(
                0,
                insertion.length - overlap_length2
              );
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    }
    var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    var whitespaceRegex_ = /\s/;
    var linebreakRegex_ = /[\r\n]/;
    var blanklineEndRegex_ = /\n\r?\n$/;
    var blanklineStartRegex_ = /^\r?\n\r?\n/;
    function diff_cleanupSemanticLossless(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    }
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(
                  0,
                  -1
                );
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(
                      0,
                      commonlength
                    );
                  } else {
                    diffs.splice(0, 0, [
                      DIFF_EQUAL,
                      text_insert.substring(0, commonlength)
                    ]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(
                    0,
                    text_insert.length - commonlength
                  );
                  text_delete = text_delete.substring(
                    0,
                    text_delete.length - commonlength
                  );
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(
                  pointer - n,
                  n,
                  [DIFF_DELETE, text_delete],
                  [DIFF_INSERT, text_insert]
                );
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(
            diffs[pointer][1].length - diffs[pointer - 1][1].length
          ) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(
              0,
              diffs[pointer][1].length - diffs[pointer - 1][1].length
            );
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    function diff(text1, text2, cursor_pos, cleanup) {
      return diff_main(text1, text2, cursor_pos, cleanup, true);
    }
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module.exports = diff;
  }
});

// ../node_modules/.pnpm/@git-diff-view+lowlight@0.0.30/node_modules/@git-diff-view/lowlight/dist/esm/index.mjs
var processAST = (ast) => {
  let lineNumber = 1;
  const syntaxObj = {};
  const loopAST = (nodes, wrapper) => {
    nodes.forEach((node) => {
      if (node.type === "text") {
        if (node.value.indexOf("\n") === -1) {
          const valueLength = node.value.length;
          if (!syntaxObj[lineNumber]) {
            node.startIndex = 0;
            node.endIndex = valueLength - 1;
            const item = {
              value: node.value,
              lineNumber,
              valueLength,
              nodeList: [{ node, wrapper }]
            };
            syntaxObj[lineNumber] = item;
          } else {
            node.startIndex = syntaxObj[lineNumber].valueLength;
            node.endIndex = node.startIndex + valueLength - 1;
            syntaxObj[lineNumber].value += node.value;
            syntaxObj[lineNumber].valueLength += valueLength;
            syntaxObj[lineNumber].nodeList.push({ node, wrapper });
          }
          node.lineNumber = lineNumber;
          return;
        }
        const lines = node.value.split("\n");
        node.children = node.children || [];
        for (let i = 0; i < lines.length; i++) {
          const _value = i === lines.length - 1 ? lines[i] : lines[i] + "\n";
          const _lineNumber = i === 0 ? lineNumber : ++lineNumber;
          const _valueLength = _value.length;
          const _node = {
            type: "text",
            value: _value,
            startIndex: Infinity,
            endIndex: Infinity,
            lineNumber: _lineNumber
          };
          if (!syntaxObj[_lineNumber]) {
            _node.startIndex = 0;
            _node.endIndex = _valueLength - 1;
            const item = {
              value: _value,
              lineNumber: _lineNumber,
              valueLength: _valueLength,
              nodeList: [{ node: _node, wrapper }]
            };
            syntaxObj[_lineNumber] = item;
          } else {
            _node.startIndex = syntaxObj[_lineNumber].valueLength;
            _node.endIndex = _node.startIndex + _valueLength - 1;
            syntaxObj[_lineNumber].value += _value;
            syntaxObj[_lineNumber].valueLength += _valueLength;
            syntaxObj[_lineNumber].nodeList.push({ node: _node, wrapper });
          }
          node.children.push(_node);
        }
        node.lineNumber = lineNumber;
        return;
      }
      if (node.children) {
        loopAST(node.children, node);
        node.lineNumber = lineNumber;
      }
    });
  };
  loopAST(ast.children);
  return { syntaxFileObject: syntaxObj, syntaxFileLineNumber: lineNumber };
};
function _getAST(_raw, _fileName, _lang, _theme) {
  return {};
}
var lowlight = createLowlight(grammars);
lowlight.register("vue", function hljsDefineVue(hljs) {
  return {
    subLanguage: "xml",
    contains: [
      hljs.COMMENT("<!--", "-->", {
        relevance: 10
      }),
      {
        begin: /^(\s*)(<script>)/gm,
        end: /^(\s*)(<\/script>)/gm,
        subLanguage: "javascript",
        excludeBegin: true,
        excludeEnd: true
      },
      {
        begin: /^(?:\s*)(?:<script\s+lang=(["'])ts\1>)/gm,
        end: /^(\s*)(<\/script>)/gm,
        subLanguage: "typescript",
        excludeBegin: true,
        excludeEnd: true
      },
      {
        begin: /^(\s*)(<style(\s+scoped)?>)/gm,
        end: /^(\s*)(<\/style>)/gm,
        subLanguage: "css",
        excludeBegin: true,
        excludeEnd: true
      },
      {
        begin: /^(?:\s*)(?:<style(?:\s+scoped)?\s+lang=(["'])(?:s[ca]ss)\1(?:\s+scoped)?>)/gm,
        end: /^(\s*)(<\/style>)/gm,
        subLanguage: "scss",
        excludeBegin: true,
        excludeEnd: true
      },
      {
        begin: /^(?:\s*)(?:<style(?:\s+scoped)?\s+lang=(["'])stylus\1(?:\s+scoped)?>)/gm,
        end: /^(\s*)(<\/style>)/gm,
        subLanguage: "stylus",
        excludeBegin: true,
        excludeEnd: true
      }
    ]
  };
});
var instance = { name: "lowlight" };
var _maxLineToIgnoreSyntax = 2e3;
var _ignoreSyntaxHighlightList = [];
Object.defineProperty(instance, "maxLineToIgnoreSyntax", {
  get: () => _maxLineToIgnoreSyntax
});
Object.defineProperty(instance, "setMaxLineToIgnoreSyntax", {
  value: (v) => {
    _maxLineToIgnoreSyntax = v;
  }
});
Object.defineProperty(instance, "ignoreSyntaxHighlightList", {
  get: () => _ignoreSyntaxHighlightList
});
Object.defineProperty(instance, "setIgnoreSyntaxHighlightList", {
  value: (v) => {
    _ignoreSyntaxHighlightList.length = 0;
    _ignoreSyntaxHighlightList.push(...v);
  }
});
Object.defineProperty(instance, "getAST", {
  value: (raw, fileName, lang) => {
    let hasRegisteredLang = true;
    if (!lowlight.registered(lang)) {
      if (true) {
        console.warn(`not support current lang: ${lang} yet`);
      }
      hasRegisteredLang = false;
    }
    if (fileName && highlighter.ignoreSyntaxHighlightList.some((item) => item instanceof RegExp ? item.test(fileName) : fileName === item)) {
      if (true) {
        console.warn(`ignore syntax for current file, because the fileName is in the ignoreSyntaxHighlightList: ${fileName}`);
      }
      return;
    }
    if (hasRegisteredLang) {
      return lowlight.highlight(lang, raw);
    } else {
      return lowlight.highlightAuto(raw);
    }
  }
});
Object.defineProperty(instance, "processAST", {
  value: (ast) => {
    return processAST(ast);
  }
});
Object.defineProperty(instance, "hasRegisteredCurrentLang", {
  value: (lang) => {
    return lowlight.registered(lang);
  }
});
Object.defineProperty(instance, "getHighlighterEngine", {
  value: () => lowlight
});
Object.defineProperty(instance, "type", { value: "class" });
var highlighter = instance;

// ../node_modules/.pnpm/@git-diff-view+core@0.0.30/node_modules/@git-diff-view/core/dist/esm/index.mjs
var import_fast_diff = __toESM(require_diff(), 1);
var DiffHunkExpansionType;
(function(DiffHunkExpansionType2) {
  DiffHunkExpansionType2["None"] = "None";
  DiffHunkExpansionType2["Up"] = "Up";
  DiffHunkExpansionType2["Down"] = "Down";
  DiffHunkExpansionType2["Both"] = "Both";
  DiffHunkExpansionType2["Short"] = "Short";
})(DiffHunkExpansionType || (DiffHunkExpansionType = {}));
var DiffHunk = class {
  /**
   * @param header The details from the diff hunk header about the line start and patch length.
   * @param lines The contents - context and changes - of the diff section.
   * @param unifiedDiffStart The diff hunk's start position in the overall file diff.
   * @param unifiedDiffEnd The diff hunk's end position in the overall file diff.
   */
  constructor(header, lines, unifiedDiffStart, unifiedDiffEnd, expansionType) {
    this.header = header;
    this.lines = lines;
    this.unifiedDiffStart = unifiedDiffStart;
    this.unifiedDiffEnd = unifiedDiffEnd;
    this.expansionType = expansionType;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    return this.header.equals(other.header) && this.unifiedDiffStart === other.unifiedDiffStart && this.unifiedDiffEnd === other.unifiedDiffEnd && this.expansionType === other.expansionType && this.lines.length === other.lines.length && this.lines.every((xLine, ix) => xLine.equals(other.lines[ix]));
  }
};
var DiffHunkHeader = class {
  /**
   * @param oldStartLine The line in the old (or original) file where this diff hunk starts.
   * @param oldLineCount The number of lines in the old (or original) file that this diff hunk covers
   * @param newStartLine The line in the new file where this diff hunk starts.
   * @param newLineCount The number of lines in the new file that this diff hunk covers.
   */
  constructor(oldStartLine, oldLineCount, newStartLine, newLineCount) {
    this.oldStartLine = oldStartLine;
    this.oldLineCount = oldLineCount;
    this.newStartLine = newStartLine;
    this.newLineCount = newLineCount;
  }
  toDiffLineRepresentation() {
    return `@@ -${this.oldStartLine},${this.oldLineCount} +${this.newStartLine},${this.newLineCount} @@`;
  }
  equals(other) {
    return this.oldStartLine === other.oldStartLine && this.oldLineCount === other.oldLineCount && this.newStartLine === other.newStartLine && this.oldStartLine === other.oldStartLine;
  }
};
var addContentHighlightBGName = "--diff-add-content-highlight--";
var delContentHighlightBGName = "--diff-del-content-highlight--";
var NewLineSymbol;
(function(NewLineSymbol2) {
  NewLineSymbol2[NewLineSymbol2["CRLF"] = 1] = "CRLF";
  NewLineSymbol2[NewLineSymbol2["CR"] = 2] = "CR";
  NewLineSymbol2[NewLineSymbol2["LF"] = 3] = "LF";
  NewLineSymbol2[NewLineSymbol2["NEWLINE"] = 4] = "NEWLINE";
  NewLineSymbol2[NewLineSymbol2["NORMAL"] = 5] = "NORMAL";
  NewLineSymbol2[NewLineSymbol2["NULL"] = 6] = "NULL";
})(NewLineSymbol || (NewLineSymbol = {}));
var getSymbol = (symbol) => {
  switch (symbol) {
    case NewLineSymbol.LF:
      return "␊";
    case NewLineSymbol.CR:
      return "␍";
    case NewLineSymbol.CRLF:
      return "␍␊";
    default:
      return "";
  }
};
var DiffModeEnum;
(function(DiffModeEnum2) {
  DiffModeEnum2[DiffModeEnum2["SplitGitHub"] = 1] = "SplitGitHub";
  DiffModeEnum2[DiffModeEnum2["SplitGitLab"] = 2] = "SplitGitLab";
  DiffModeEnum2[DiffModeEnum2["Split"] = 3] = "Split";
  DiffModeEnum2[DiffModeEnum2["Unified"] = 4] = "Unified";
})(DiffModeEnum || (DiffModeEnum = {}));
var maxLength = 1e3;
function rangeMax(range) {
  return range.location + range.length;
}
function commonLength(stringA, rangeA, stringB, rangeB, reverse) {
  const max = Math.min(rangeA.length, rangeB.length);
  const startA = reverse ? rangeMax(rangeA) - 1 : rangeA.location;
  const startB = reverse ? rangeMax(rangeB) - 1 : rangeB.location;
  const stride = reverse ? -1 : 1;
  let length = 0;
  while (Math.abs(length) < max) {
    if (stringA[startA + length] !== stringB[startB + length]) {
      break;
    }
    length += stride;
  }
  return Math.abs(length);
}
function isInValidString(s) {
  return s.trim().length === 0 || s.length >= maxLength;
}
function checkNewLineSymbolChange(addition, deletion) {
  const stringA = addition.text;
  const stringB = deletion.text;
  const aEndStr = stringA.slice(-2);
  const bEndStr = stringB.slice(-2);
  const aSymbol = aEndStr === "\r\n" ? NewLineSymbol.CRLF : aEndStr.endsWith("\r") ? NewLineSymbol.CR : aEndStr.endsWith("\n") ? NewLineSymbol.LF : NewLineSymbol.NULL;
  const bSymbol = bEndStr === "\r\n" ? NewLineSymbol.CRLF : bEndStr.endsWith("\r") ? NewLineSymbol.CR : bEndStr.endsWith("\n") ? NewLineSymbol.LF : NewLineSymbol.NULL;
  const hasNewLineChanged = addition.noTrailingNewLine !== deletion.noTrailingNewLine;
  if (aSymbol === bSymbol && !hasNewLineChanged) {
    return { addSymbol: void 0, addString: stringA, delSymbol: void 0, delString: stringB };
  }
  return {
    addSymbol: hasNewLineChanged ? addition.noTrailingNewLine ? NewLineSymbol.NEWLINE : NewLineSymbol.NORMAL : aSymbol,
    addString: aSymbol === NewLineSymbol.CRLF ? stringA.slice(0, -2) : aSymbol === NewLineSymbol.CR || aSymbol === NewLineSymbol.LF ? stringA.slice(0, -1) : stringA,
    delSymbol: hasNewLineChanged ? deletion.noTrailingNewLine ? NewLineSymbol.NEWLINE : NewLineSymbol.NORMAL : bSymbol,
    delString: bSymbol === NewLineSymbol.CRLF ? stringB.slice(0, -2) : bSymbol === NewLineSymbol.CR || bSymbol === NewLineSymbol.LF ? stringB.slice(0, -1) : stringB
  };
}
function relativeChanges(addition, deletion) {
  const stringA = addition.text;
  const stringB = deletion.text;
  const { addString, delString, addSymbol, delSymbol } = checkNewLineSymbolChange(addition, deletion);
  if (addString === delString && addSymbol && delSymbol) {
    return {
      addRange: {
        range: {
          location: addString.length,
          length: stringA.length - addString.length
        },
        hasLineChange: true,
        newLineSymbol: addSymbol
      },
      delRange: {
        range: {
          location: delString.length,
          length: stringB.length - delString.length
        },
        hasLineChange: true,
        newLineSymbol: delSymbol
      }
    };
  }
  let delRange = { location: 0, length: delString.length };
  let addRange = { location: 0, length: addString.length };
  if (isInValidString(stringA) || isInValidString(stringB)) {
    addRange.length = 0;
    delRange.length = 0;
    return {
      addRange: { range: addRange },
      delRange: { range: delRange }
    };
  }
  const prefixLength = commonLength(delString, delRange, addString, addRange, false);
  delRange = {
    location: delRange.location + prefixLength,
    length: delRange.length - prefixLength
  };
  addRange = {
    location: addRange.location + prefixLength,
    length: addRange.length - prefixLength
  };
  const suffixLength = commonLength(delString, delRange, addString, addRange, true);
  delRange.length -= suffixLength;
  addRange.length -= suffixLength;
  return {
    addRange: {
      range: addRange,
      hasLineChange: (addString.slice(0, addRange.location) + addString.slice(addRange.location + addRange.length)).trim().length > 0
    },
    delRange: {
      range: delRange,
      hasLineChange: (delString.slice(0, delRange.location) + delString.slice(delRange.location + delRange.length)).trim().length > 0
    }
  };
}
function diffChanges(addition, deletion) {
  const { addString, addSymbol, delString, delSymbol } = checkNewLineSymbolChange(addition, deletion);
  if (isInValidString(addString) || isInValidString(delString)) {
    return {
      addRange: { range: [], hasLineChange: !!addSymbol, newLineSymbol: addSymbol },
      delRange: { range: [], hasLineChange: !!delSymbol, newLineSymbol: delSymbol }
    };
  }
  const diffRange = (0, import_fast_diff.default)(delString, addString, 0, true);
  let aStart = 0;
  let bStart = 0;
  const aRange = diffRange.filter((i) => i[0] !== -1).map((i) => ({ type: i[0], str: i[1], location: aStart, length: (aStart += i[1].length, i[1].length) }));
  const bRange = diffRange.filter((i) => i[0] !== 1).map((i) => ({ type: i[0], str: i[1], location: bStart, length: (bStart += i[1].length, i[1].length) }));
  return {
    addRange: {
      range: aRange,
      hasLineChange: aRange.some((i) => i.type === 0 && i.str.trim().length > 0),
      newLineSymbol: addSymbol
    },
    delRange: {
      range: bRange,
      hasLineChange: aRange.some((i) => i.type === 0 && i.str.trim().length > 0),
      newLineSymbol: delSymbol
    }
  };
}
var DiffLineType;
(function(DiffLineType2) {
  DiffLineType2[DiffLineType2["Context"] = 0] = "Context";
  DiffLineType2[DiffLineType2["Add"] = 1] = "Add";
  DiffLineType2[DiffLineType2["Delete"] = 2] = "Delete";
  DiffLineType2[DiffLineType2["Hunk"] = 3] = "Hunk";
})(DiffLineType || (DiffLineType = {}));
var DiffLine = class _DiffLine {
  constructor(text, type, originalLineNumber, oldLineNumber, newLineNumber, noTrailingNewLine = false, changes, diffChanges2, plainTemplate, syntaxTemplate) {
    this.text = text;
    this.type = type;
    this.originalLineNumber = originalLineNumber;
    this.oldLineNumber = oldLineNumber;
    this.newLineNumber = newLineNumber;
    this.noTrailingNewLine = noTrailingNewLine;
    this.changes = changes;
    this.diffChanges = diffChanges2;
    this.plainTemplate = plainTemplate;
    this.syntaxTemplate = syntaxTemplate;
  }
  withNoTrailingNewLine(noTrailingNewLine) {
    return new _DiffLine(this.text, this.type, this.originalLineNumber, this.oldLineNumber, this.newLineNumber, noTrailingNewLine);
  }
  isIncludeableLine() {
    return this.type === DiffLineType.Add || this.type === DiffLineType.Delete;
  }
  equals(other) {
    return this.text === other.text && this.type === other.type && this.originalLineNumber === other.originalLineNumber && this.oldLineNumber === other.oldLineNumber && this.newLineNumber === other.newLineNumber && this.noTrailingNewLine === other.noTrailingNewLine;
  }
  clone(text) {
    return new _DiffLine(text, this.type, this.originalLineNumber, this.oldLineNumber, this.newLineNumber, this.noTrailingNewLine);
  }
};
var checkDiffLineIncludeChange = (diffLine) => {
  if (!diffLine)
    return false;
  return diffLine.type === DiffLineType.Add || diffLine.type === DiffLineType.Delete;
};
var escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
var enableTransform = false;
var temp = (f) => f;
var transformContent = temp;
var transformFile = temp;
var setTransformForTemplateContent = (fn) => {
  if (typeof fn !== "function") {
    throw new Error("Transform must be a function");
  }
  transformContent = fn;
  enableTransform = true;
};
var setTransformForFile = (fn) => {
  if (typeof fn !== "function") {
    throw new Error("Transform must be a function");
  }
  transformFile = fn;
  enableTransform = true;
};
var resetTransform = () => {
  enableTransform = false;
  transformContent = temp;
  transformFile = temp;
};
var isTransformEnabled = () => enableTransform;
var processTransformTemplateContent = (content) => {
  if (enableTransform && temp !== transformContent) {
    return transformContent(content);
  }
  return content;
};
var processTransformForFile = (content) => {
  if (enableTransform && temp !== transformFile) {
    return transformFile(content);
  }
  return content;
};
var defaultTransform = (content) => escapeHtml(content).replace(/\n/g, "").replace(/\r/g, "");
var getPlainDiffTemplate = ({ diffLine, rawLine, operator }) => {
  if (diffLine.plainTemplate)
    return;
  const changes = diffLine.changes;
  if (!changes || !changes.hasLineChange || !rawLine)
    return;
  const transform = isTransformEnabled() ? processTransformTemplateContent : defaultTransform;
  const range = changes.range;
  const str1 = rawLine.slice(0, range.location);
  const str2 = rawLine.slice(range.location, range.location + range.length);
  const str3 = rawLine.slice(range.location + range.length);
  const isLast = str2.includes("\n");
  const _str2 = isLast ? str2.replace("\n", "").replace("\r", "") : str2;
  const isNewLineSymbolChanged = changes.newLineSymbol;
  const template = `<span data-range-start="${range.location}" data-range-end="${range.location + range.length}">${transform(str1)}<span data-diff-highlight style="background-color: var(${operator === "add" ? addContentHighlightBGName : delContentHighlightBGName});border-radius: 0.2em;">${isLast ? `${transform(_str2)}<span data-newline-symbol>${getSymbol(isNewLineSymbolChanged)}</span>` : transform(str2)}</span>${transform(str3)}</span>`;
  diffLine.plainTemplate = template;
};
var getSyntaxDiffTemplate = ({ diffLine, syntaxLine, operator }) => {
  var _a;
  if (diffLine.syntaxTemplate || !syntaxLine)
    return;
  const changes = diffLine.changes;
  if (!changes || !changes.hasLineChange)
    return;
  const transform = isTransformEnabled() ? processTransformTemplateContent : defaultTransform;
  const range = changes.range;
  let template = `<span data-range-start="${range.location}" data-range-end="${range.location + range.length}">`;
  (_a = syntaxLine === null || syntaxLine === void 0 ? void 0 : syntaxLine.nodeList) === null || _a === void 0 ? void 0 : _a.forEach(({ node, wrapper }) => {
    var _a2, _b, _c, _d, _e, _f;
    if (node.endIndex < range.location || range.location + range.length < node.startIndex) {
      template += `<span data-start="${node.startIndex}" data-end="${node.endIndex}" class="${(_b = ((_a2 = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _a2 === void 0 ? void 0 : _a2.className) || []) === null || _b === void 0 ? void 0 : _b.join(" ")}" style="${((_c = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _c === void 0 ? void 0 : _c.style) || ""}">${transform(node.value)}</span>`;
    } else {
      const index1 = range.location - node.startIndex;
      const index2 = index1 < 0 ? 0 : index1;
      const str1 = node.value.slice(0, index2);
      const str2 = node.value.slice(index2, index1 + range.length);
      const str3 = node.value.slice(index1 + range.length);
      const isStart = str1.length || range.location === node.startIndex;
      const isEnd = str3.length || node.endIndex === range.location + range.length - 1;
      const isLast = str2.includes("\n");
      const _str2 = isLast ? str2.replace("\n", "").replace("\r", "") : str2;
      template += `<span data-start="${node.startIndex}" data-end="${node.endIndex}" class="${(_e = ((_d = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _d === void 0 ? void 0 : _d.className) || []) === null || _e === void 0 ? void 0 : _e.join(" ")}" style="${((_f = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _f === void 0 ? void 0 : _f.style) || ""}">${transform(str1)}<span data-diff-highlight style="background-color: var(${operator === "add" ? addContentHighlightBGName : delContentHighlightBGName});border-top-left-radius: ${isStart ? "0.2em" : "0"};border-bottom-left-radius: ${isStart ? "0.2em" : "0"};border-top-right-radius: ${isEnd || isLast ? "0.2em" : "0"};border-bottom-right-radius: ${isEnd || isLast ? "0.2em" : "0"}">${isLast ? `${transform(_str2)}<span data-newline-symbol>${getSymbol(changes.newLineSymbol)}</span>` : transform(str2)}</span>${transform(str3)}</span>`;
    }
  });
  template += "</span>";
  diffLine.syntaxTemplate = template;
};
var getSyntaxLineTemplate = (line) => {
  var _a;
  let template = "";
  const transform = isTransformEnabled() ? processTransformTemplateContent : defaultTransform;
  (_a = line === null || line === void 0 ? void 0 : line.nodeList) === null || _a === void 0 ? void 0 : _a.forEach(({ node, wrapper }) => {
    var _a2, _b, _c;
    template += `<span data-start="${node.startIndex}" data-end="${node.endIndex}" class="${(_b = ((_a2 = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _a2 === void 0 ? void 0 : _a2.className) || []) === null || _b === void 0 ? void 0 : _b.join(" ")}" style="${((_c = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _c === void 0 ? void 0 : _c.style) || ""}">${transform(node.value)}</span>`;
  });
  return template;
};
var getPlainLineTemplate = (line) => {
  if (!line)
    return "";
  const transform = isTransformEnabled() ? processTransformTemplateContent : defaultTransform;
  const template = transform(line);
  return template;
};
var DefaultDiffExpansionStep = 40;
function assertNever(_, message) {
  throw new Error(message);
}
function getLargestLineNumber(hunks) {
  var _a, _b;
  if (hunks.length === 0) {
    return 0;
  }
  for (let i = hunks.length - 1; i >= 0; i--) {
    const hunk = hunks[i];
    for (let j = hunk.lines.length - 1; j >= 0; j--) {
      const line = hunk.lines[j];
      if (line.type === DiffLineType.Hunk) {
        continue;
      }
      const newLineNumber = (_a = line.newLineNumber) !== null && _a !== void 0 ? _a : 0;
      const oldLineNumber = (_b = line.oldLineNumber) !== null && _b !== void 0 ? _b : 0;
      return newLineNumber > oldLineNumber ? newLineNumber : oldLineNumber;
    }
  }
  return 0;
}
function getHunkHeaderExpansionType(hunkIndex, hunkHeader, previousHunk) {
  const distanceToPrevious = previousHunk === null ? Infinity : hunkHeader.oldStartLine - previousHunk.header.oldStartLine - previousHunk.header.oldLineCount;
  if (hunkIndex === 0) {
    if (hunkHeader.oldStartLine > 1 && hunkHeader.newStartLine > 1) {
      return DiffHunkExpansionType.Up;
    } else {
      return DiffHunkExpansionType.None;
    }
  } else if (distanceToPrevious <= DefaultDiffExpansionStep) {
    return DiffHunkExpansionType.Short;
  } else {
    return DiffHunkExpansionType.Both;
  }
}
var numIterator = (num, cb) => {
  const re = [];
  for (let i = 0; i < num; i++) {
    re.push(cb(i));
  }
  return re;
};
var getLang = (fileName) => {
  const dotIndex = fileName.lastIndexOf(".");
  const extension = fileName.slice(dotIndex + 1);
  return extension;
};
var getDiffRange = (additions, deletions, { getAdditionRaw, getDeletionRaw, getAdditionSyntax, getDeletionSyntax }) => {
  if (additions.length === deletions.length) {
    const len = additions.length;
    for (let i = 0; i < len; i++) {
      const addition = additions[i];
      const deletion = deletions[i];
      if (!addition.changes || !deletion.changes) {
        const _addition = addition.clone(getAdditionRaw(addition.newLineNumber) || addition.text || "");
        const _deletion = deletion.clone(getDeletionRaw(deletion.oldLineNumber) || deletion.text || "");
        const { addRange, delRange } = relativeChanges(_addition, _deletion);
        addition.changes = addRange;
        deletion.changes = delRange;
      }
      if (!addition.plainTemplate || !deletion.plainTemplate) {
        getPlainDiffTemplate({ diffLine: addition, rawLine: getAdditionRaw(addition.newLineNumber), operator: "add" });
        getPlainDiffTemplate({ diffLine: deletion, rawLine: getDeletionRaw(deletion.oldLineNumber), operator: "del" });
      }
      if (!addition.syntaxTemplate || !deletion.syntaxTemplate) {
        getSyntaxDiffTemplate({
          diffLine: addition,
          syntaxLine: getAdditionSyntax(addition.newLineNumber),
          operator: "add"
        });
        getSyntaxDiffTemplate({
          diffLine: deletion,
          syntaxLine: getDeletionSyntax(deletion.oldLineNumber),
          operator: "del"
        });
      }
    }
  }
};
var diffHeaderRe = /^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/;
var HiddenBidiCharsRegex = /[\u202A-\u202E]|[\u2066-\u2069]/;
var DiffPrefixAdd = "+";
var DiffPrefixDelete = "-";
var DiffPrefixContext = " ";
var DiffPrefixNoNewline = "\\";
var DiffLinePrefixChars = /* @__PURE__ */ new Set([
  DiffPrefixAdd,
  DiffPrefixDelete,
  DiffPrefixContext,
  DiffPrefixNoNewline
]);
var DiffParser = class {
  constructor() {
    Object.defineProperty(this, "__v_skip", { value: true });
    this.reset();
  }
  /**
   * Resets the internal parser state so that it can be reused.
   *
   * This is done automatically at the end of each parse run.
   */
  reset() {
    this.ls = 0;
    this.le = -1;
    this.text = "";
  }
  /**
   * Aligns the internal character pointers at the boundaries of
   * the next line.
   *
   * Returns true if successful or false if the end of the diff
   * has been reached.
   */
  nextLine() {
    this.ls = this.le + 1;
    if (this.ls >= this.text.length) {
      return false;
    }
    this.le = this.text.indexOf("\n", this.ls);
    if (this.le === -1) {
      this.le = this.text.length;
    }
    return this.ls !== this.le;
  }
  /**
   * Advances to the next line and returns it as a substring
   * of the raw diff text. Returns null if end of diff was
   * reached.
   */
  readLine(header) {
    if (header) {
      return this.nextLine() ? this.text.substring(this.ls, this.le) : null;
    } else {
      return this.nextLine() ? this.text.substring(this.ls + 1, this.le + 1) : null;
    }
  }
  /** Tests if the current line starts with the given search text */
  lineStartsWith(searchString) {
    return this.text.startsWith(searchString, this.ls);
  }
  /** Tests if the current line ends with the given search text */
  lineEndsWith(searchString) {
    return this.text.endsWith(searchString, this.le);
  }
  /**
   * Returns the starting character of the next line without
   * advancing the internal state. Returns null if advancing
   * would mean reaching the end of the diff.
   */
  peek() {
    const p = this.le + 1;
    return p < this.text.length ? this.text[p] : null;
  }
  /**
   * Parse the diff header, meaning everything from the
   * start of the diff output to the end of the line beginning
   * with +++
   *
   * Example diff header:
   *
   *   diff --git a/app/src/lib/diff-parser.ts b/app/src/lib/diff-parser.ts
   *   index e1d4871..3bd3ee0 100644
   *   --- a/app/src/lib/diff-parser.ts
   *   +++ b/app/src/lib/diff-parser.ts
   *
   * Returns an object with information extracted from the diff
   * header (currently whether it's a binary patch) or null if
   * the end of the diff was reached before the +++ line could be
   * found (which is a valid state).
   */
  parseDiffHeader() {
    while (this.nextLine()) {
      if (this.lineStartsWith("Binary files ") && this.lineEndsWith("differ")) {
        return { isBinary: true };
      }
      if (this.lineStartsWith("+++")) {
        return { isBinary: false };
      }
    }
    return null;
  }
  /**
   * Attempts to convert a RegExp capture group into a number.
   * If the group doesn't exist or wasn't captured the function
   * will return the value of the defaultValue parameter or throw
   * an error if no default value was provided. If the captured
   * string can't be converted to a number an error will be thrown.
   */
  numberFromGroup(m, group, defaultValue = null) {
    const str = m[group];
    if (!str) {
      if (!defaultValue) {
        throw new Error(`Group ${group} missing from regexp match and no defaultValue was provided`);
      }
      return defaultValue;
    }
    const num = parseInt(str, 10);
    if (isNaN(num)) {
      throw new Error(`Could not parse capture group ${group} into number: ${str}`);
    }
    return num;
  }
  /**
   * Parses a hunk header or throws an error if the given line isn't
   * a well-formed hunk header.
   *
   * We currently only extract the line number information and
   * ignore any hunk headings.
   *
   * Example hunk header (text within ``):
   *
   * `@@ -84,10 +82,8 @@ export function parseRawDiff(lines: ReadonlyArray<string>): Diff {`
   *
   * Where everything after the last @@ is what's known as the hunk, or section, heading
   */
  parseHunkHeader(line) {
    const m = diffHeaderRe.exec(line);
    if (!m) {
      throw new Error(`Invalid hunk header format`);
    }
    const oldStartLine = this.numberFromGroup(m, 1);
    const oldLineCount = this.numberFromGroup(m, 2, 1);
    const newStartLine = this.numberFromGroup(m, 3);
    const newLineCount = this.numberFromGroup(m, 4, 1);
    return new DiffHunkHeader(oldStartLine, oldLineCount, newStartLine, newLineCount);
  }
  /**
   * Convenience function which lets us leverage the type system to
   * prove exhaustive checks in parseHunk.
   *
   * Takes an arbitrary string and checks to see if the first character
   * of that string is one of the allowed prefix characters for diff
   * lines (ie lines in between hunk headers).
   */
  parseLinePrefix(c) {
    if (c && c.length && DiffLinePrefixChars.has(c[0])) {
      return c[0];
    }
    return null;
  }
  /**
   * Parses a hunk, including its header or throws an error if the diff doesn't
   * contain a well-formed diff hunk at the current position.
   *
   * Expects that the position has been advanced to the beginning of a presumed
   * diff hunk header.
   *
   * @param linesConsumed The number of unified diff lines consumed up until
   *                      this point by the diff parser. Used to give the
   *                      position and length (in lines) of the parsed hunk
   *                      relative to the overall parsed diff. These numbers
   *                      have no real meaning in the context of a diff and
   *                      are only used to aid the app in line-selections.
   */
  parseHunk(linesConsumed, hunkIndex, previousHunk) {
    const headerLine = this.readLine(true);
    if (!headerLine) {
      throw new Error("Expected hunk header but reached end of diff");
    }
    const header = this.parseHunkHeader(headerLine);
    const lines = new Array();
    lines.push(new DiffLine(headerLine, DiffLineType.Hunk, 1, null, null));
    let c;
    let rollingDiffBeforeCounter = header.oldStartLine;
    let rollingDiffAfterCounter = header.newStartLine;
    let diffLineNumber = linesConsumed;
    while (c = this.parseLinePrefix(this.peek())) {
      const line = this.readLine(false);
      if (!line) {
        throw new Error("Expected unified diff line but reached end of diff");
      }
      if (c === DiffPrefixNoNewline) {
        if (line.length < 12) {
          throw new Error(`Expected "no newline at end of file" marker to be at least 12 bytes long`);
        }
        const previousLineIndex = lines.length - 1;
        const previousLine = lines[previousLineIndex];
        lines[previousLineIndex] = previousLine.withNoTrailingNewLine(true);
        continue;
      }
      diffLineNumber++;
      let diffLine;
      if (c === DiffPrefixAdd) {
        diffLine = new DiffLine(line, DiffLineType.Add, diffLineNumber, null, rollingDiffAfterCounter++);
      } else if (c === DiffPrefixDelete) {
        diffLine = new DiffLine(line, DiffLineType.Delete, diffLineNumber, rollingDiffBeforeCounter++, null);
      } else if (c === DiffPrefixContext) {
        diffLine = new DiffLine(line, DiffLineType.Context, diffLineNumber, rollingDiffBeforeCounter++, rollingDiffAfterCounter++);
      } else {
        return assertNever(c, `Unknown DiffLinePrefix: ${c}`);
      }
      lines.push(diffLine);
    }
    if (lines.length === 1) {
      throw new Error("Malformed diff, empty hunk");
    }
    return new DiffHunk(header, lines, linesConsumed, linesConsumed + lines.length - 1, getHunkHeaderExpansionType(hunkIndex, header, previousHunk));
  }
  /**
   * Parse a well-formed unified diff into hunks and lines.
   *
   * @param text A unified diff produced by git diff, git log --patch
   *             or any other git plumbing command that produces unified
   *             diffs.
   */
  parse(text) {
    this.text = text;
    try {
      const headerInfo = this.parseDiffHeader();
      const headerEnd = this.le;
      const header = this.text.substring(0, headerEnd);
      if (!headerInfo) {
        return {
          header,
          contents: "",
          hunks: [],
          isBinary: false,
          maxLineNumber: 0,
          hasHiddenBidiChars: false
        };
      }
      if (headerInfo.isBinary) {
        return {
          header,
          contents: "",
          hunks: [],
          isBinary: true,
          maxLineNumber: 0,
          hasHiddenBidiChars: false
        };
      }
      const hunks = new Array();
      let linesConsumed = 0;
      let previousHunk = null;
      do {
        const hunk = this.parseHunk(linesConsumed, hunks.length, previousHunk);
        hunks.push(hunk);
        previousHunk = hunk;
        linesConsumed += hunk.lines.length;
      } while (this.peek());
      const contents = this.text.substring(headerEnd + 1, this.le).replace(/\n\\ No newline at end of file/g, "");
      return {
        header,
        contents,
        hunks,
        isBinary: headerInfo.isBinary,
        maxLineNumber: getLargestLineNumber(hunks),
        hasHiddenBidiChars: HiddenBidiCharsRegex.test(text)
      };
    } finally {
      this.reset();
    }
  }
};
var parseInstance = new DiffParser();
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var _Cache_instances;
var _Cache_keyArray;
var _Cache_maxLength;
var _Cache_checkLength;
var Cache = class extends Map {
  constructor() {
    super(...arguments);
    _Cache_instances.add(this);
    _Cache_keyArray.set(this, []);
    _Cache_maxLength.set(this, 30);
  }
  get maxLength() {
    return __classPrivateFieldGet(this, _Cache_maxLength, "f");
  }
  setMaxLength(length) {
    __classPrivateFieldSet(this, _Cache_maxLength, length, "f");
    __classPrivateFieldGet(this, _Cache_instances, "m", _Cache_checkLength).call(this);
  }
  set(key, value) {
    if (__classPrivateFieldGet(this, _Cache_maxLength, "f") <= 0)
      return this;
    if (this.has(key))
      return this;
    __classPrivateFieldGet(this, _Cache_keyArray, "f").push(key);
    __classPrivateFieldGet(this, _Cache_instances, "m", _Cache_checkLength).call(this);
    return super.set(key, value);
  }
};
_Cache_keyArray = /* @__PURE__ */ new WeakMap(), _Cache_maxLength = /* @__PURE__ */ new WeakMap(), _Cache_instances = /* @__PURE__ */ new WeakSet(), _Cache_checkLength = function _Cache_checkLength2() {
  while (__classPrivateFieldGet(this, _Cache_keyArray, "f").length > __classPrivateFieldGet(this, _Cache_maxLength, "f")) {
    const key = __classPrivateFieldGet(this, _Cache_keyArray, "f").shift();
    this.delete(key);
  }
};
var _File_instances;
var _File_doCheck;
var map = new Cache();
var devKey = "@git-diff-cache";
map.setMaxLength(50);
map.name = "@git-diff-view/core";
if (typeof globalThis !== "undefined") {
  if (Array.isArray(globalThis[devKey])) {
    globalThis[devKey] = globalThis[devKey].filter((i) => i !== map);
    if (globalThis[devKey].length > 0) {
      console.warn("there are multiple instance of @git-diff-view/core in current environment!");
    }
    globalThis[devKey].push(map);
  } else {
    globalThis[devKey] = [map];
  }
}
var File = class _File {
  static createInstance(data) {
    var _a;
    const file = new _File(data === null || data === void 0 ? void 0 : data.raw, data === null || data === void 0 ? void 0 : data.lang, data === null || data === void 0 ? void 0 : data.fileName);
    file.ast = data === null || data === void 0 ? void 0 : data.ast;
    file.rawFile = (data === null || data === void 0 ? void 0 : data.rawFile) || {};
    file.plainFile = (data === null || data === void 0 ? void 0 : data.plainFile) || {};
    file.hasDoRaw = data === null || data === void 0 ? void 0 : data.hasDoRaw;
    file.rawLength = data === null || data === void 0 ? void 0 : data.rawLength;
    file.syntaxFile = (data === null || data === void 0 ? void 0 : data.syntaxFile) || {};
    file.hasDoSyntax = data === null || data === void 0 ? void 0 : data.hasDoSyntax;
    file.syntaxLength = data === null || data === void 0 ? void 0 : data.syntaxLength;
    file.highlighterName = data === null || data === void 0 ? void 0 : data.highlighterName;
    file.highlighterType = data === null || data === void 0 ? void 0 : data.highlighterType;
    file.maxLineNumber = data === null || data === void 0 ? void 0 : data.maxLineNumber;
    file.enableTemplate = (_a = data === null || data === void 0 ? void 0 : data.enableTemplate) !== null && _a !== void 0 ? _a : true;
    return file;
  }
  constructor(raw, lang, fileName) {
    _File_instances.add(this);
    this.raw = raw;
    this.lang = lang;
    this.fileName = fileName;
    this.rawFile = {};
    this.hasDoRaw = false;
    this.syntaxFile = {};
    this.plainFile = {};
    this.hasDoSyntax = false;
    this.maxLineNumber = 0;
    this.enableTemplate = true;
    this.raw = processTransformForFile(raw);
    Object.defineProperty(this, "__v_skip", { value: true });
  }
  doSyntax({ registerHighlighter, theme }) {
    if (!this.raw || this.hasDoSyntax)
      return;
    const finalHighlighter = registerHighlighter || highlighter;
    if (this.syntaxLength) {
      if (true) {
        console.error("current file already doSyntax before!");
      }
      return;
    }
    if (this.rawLength > finalHighlighter.maxLineToIgnoreSyntax) {
      if (true) {
        console.warn(`ignore syntax for current file, because the rawLength is too long: ${this.rawLength}`);
      }
      return;
    }
    let supportEngin = finalHighlighter;
    try {
      if (!finalHighlighter.hasRegisteredCurrentLang(this.lang)) {
        supportEngin = highlighter;
      }
    } catch (_a) {
      supportEngin = highlighter;
    }
    this.ast = supportEngin.getAST(this.raw, this.fileName, this.lang, theme);
    if (!this.ast)
      return;
    const { syntaxFileObject, syntaxFileLineNumber } = supportEngin.processAST(this.ast);
    if (this.enableTemplate) {
      Object.values(syntaxFileObject).forEach((line) => {
        line.template = getSyntaxLineTemplate(line);
      });
    }
    this.syntaxFile = syntaxFileObject;
    this.syntaxLength = syntaxFileLineNumber;
    this.highlighterName = supportEngin.name;
    this.highlighterType = supportEngin.type;
    if (true) {
      __classPrivateFieldGet(this, _File_instances, "m", _File_doCheck).call(this);
    }
    this.hasDoSyntax = true;
  }
  doRaw() {
    if (!this.raw || this.hasDoRaw)
      return;
    const rawString = this.raw;
    const rawArray = rawString.split("\n");
    this.rawLength = rawArray.length;
    this.maxLineNumber = rawArray.length;
    this.rawFile = {};
    this.plainFile = {};
    for (let i = 0; i < rawArray.length; i++) {
      this.rawFile[i + 1] = i < rawArray.length - 1 ? rawArray[i] + "\n" : rawArray[i];
      if (this.enableTemplate) {
        this.plainFile[i + 1] = {
          value: this.rawFile[i + 1],
          template: getPlainLineTemplate(this.rawFile[i + 1])
        };
      }
    }
    this.hasDoRaw = true;
  }
};
_File_instances = /* @__PURE__ */ new WeakSet(), _File_doCheck = function _File_doCheck2() {
  if (this.rawLength && this.syntaxLength) {
    if (this.rawLength !== this.syntaxLength) {
      console.warn("the rawLength not match for the syntaxLength");
    }
    Object.values(this.syntaxFile).forEach(({ value, lineNumber }) => {
      if (value !== this.rawFile[lineNumber]) {
        console.log("some line not match:" + value + " __ " + this.rawFile[lineNumber] + " __ at: " + lineNumber + " lineNumber");
      }
    });
  }
};
function getFile(raw, lang, theme, fileName, uuid) {
  let key = raw + "--0.0.30--" + theme + "--" + lang;
  if (uuid) {
    key = uuid + "--0.0.30--" + theme + "--" + lang;
  }
  let otherThemeKey = raw + "--0.0.30--" + (theme === "light" ? "dark" : "light") + "--" + lang;
  if (uuid) {
    otherThemeKey = uuid + "--0.0.30--" + (theme === "light" ? "dark" : "light") + "--" + lang;
  }
  if (map.has(key))
    return map.get(key);
  if (map.has(otherThemeKey)) {
    const cacheFile = map.get(otherThemeKey);
    if (cacheFile.highlighterType === "class") {
      return cacheFile;
    }
  }
  const file = new File(raw, lang, fileName);
  map.set(key, file);
  return file;
}
var _cacheMap = map;
var disableCache = () => map.setMaxLength(0);
var _DiffFile_instances;
var _DiffFile_oldFileResult;
var _DiffFile_newFileResult;
var _DiffFile_diffListResults;
var _DiffFile_diffLines;
var _DiffFile_oldFileDiffLines;
var _DiffFile_newFileDiffLines;
var _DiffFile_oldFileLines;
var _DiffFile_newFileLines;
var _DiffFile_oldFilePlainLines;
var _DiffFile_newFilePlainLines;
var _DiffFile_oldFileSyntaxLines;
var _DiffFile_newFileSyntaxLines;
var _DiffFile_oldFilePlaceholderLines;
var _DiffFile_newFilePlaceholderLines;
var _DiffFile_splitLeftLines;
var _DiffFile_splitRightLines;
var _DiffFile_splitHunksLines;
var _DiffFile_unifiedLines;
var _DiffFile_unifiedHunksLines;
var _DiffFile_listeners;
var _DiffFile_hasInitRaw;
var _DiffFile_hasInitSyntax;
var _DiffFile_hasBuildSplit;
var _DiffFile_hasBuildUnified;
var _DiffFile_updateCount;
var _DiffFile_composeByDiff;
var _DiffFile_composeByMerge;
var _DiffFile_enableTemplate;
var _DiffFile_composeByFullMerge;
var _DiffFile_highlighterName;
var _DiffFile_highlighterType;
var _DiffFile_theme;
var _DiffFile__theme;
var _DiffFile_hasExpandSplitAll;
var _DiffFile_hasExpandUnifiedAll;
var _DiffFile_id;
var _DiffFile_clonedInstance;
var _DiffFile_doDiff;
var _DiffFile_doFile;
var _DiffFile_composeRaw;
var _DiffFile_composeFile;
var _DiffFile_composeDiff;
var _DiffFile_composeSyntax;
var _DiffFile_doSyntax;
var _DiffFile_getOldDiffLine;
var _DiffFile_getNewDiffLine;
var _DiffFile_getOldRawLine;
var _DiffFile_getNewRawLine;
var _DiffFile_getOldSyntaxLine;
var _DiffFile_getNewSyntaxLine;
var composeLen = 40;
var getCurrentComposeLength = () => composeLen;
var changeDefaultComposeLength = (compose) => {
  composeLen = compose;
};
var resetDefaultComposeLength = () => {
  composeLen = 40;
};
var idSet = /* @__PURE__ */ new Set();
var DiffFile = class _DiffFile {
  static createInstance(data, bundle) {
    var _a, _b, _c, _d, _e, _f;
    const instance2 = new _DiffFile(((_a = data === null || data === void 0 ? void 0 : data.oldFile) === null || _a === void 0 ? void 0 : _a.fileName) || "", ((_b = data === null || data === void 0 ? void 0 : data.oldFile) === null || _b === void 0 ? void 0 : _b.content) || "", ((_c = data === null || data === void 0 ? void 0 : data.newFile) === null || _c === void 0 ? void 0 : _c.fileName) || "", ((_d = data === null || data === void 0 ? void 0 : data.newFile) === null || _d === void 0 ? void 0 : _d.content) || "", (data === null || data === void 0 ? void 0 : data.hunks) || [], ((_e = data === null || data === void 0 ? void 0 : data.oldFile) === null || _e === void 0 ? void 0 : _e.fileLang) || "", ((_f = data === null || data === void 0 ? void 0 : data.newFile) === null || _f === void 0 ? void 0 : _f.fileLang) || "");
    if (bundle) {
      if (bundle.isFullMerge) {
        instance2._mergeFullBundle(bundle);
      } else {
        instance2.mergeBundle(bundle);
      }
    }
    return instance2;
  }
  constructor(_oldFileName, _oldFileContent, _newFileName, _newFileContent, _diffList, _oldFileLang, _newFileLang, uuid) {
    _DiffFile_instances.add(this);
    this.uuid = uuid;
    _DiffFile_oldFileResult.set(this, void 0);
    _DiffFile_newFileResult.set(this, void 0);
    _DiffFile_diffListResults.set(this, void 0);
    _DiffFile_diffLines.set(this, void 0);
    _DiffFile_oldFileDiffLines.set(this, void 0);
    _DiffFile_newFileDiffLines.set(this, void 0);
    _DiffFile_oldFileLines.set(this, void 0);
    _DiffFile_newFileLines.set(this, void 0);
    _DiffFile_oldFilePlainLines.set(this, void 0);
    _DiffFile_newFilePlainLines.set(this, void 0);
    _DiffFile_oldFileSyntaxLines.set(this, void 0);
    _DiffFile_newFileSyntaxLines.set(this, void 0);
    _DiffFile_oldFilePlaceholderLines.set(this, void 0);
    _DiffFile_newFilePlaceholderLines.set(this, void 0);
    _DiffFile_splitLeftLines.set(this, []);
    _DiffFile_splitRightLines.set(this, []);
    _DiffFile_splitHunksLines.set(this, void 0);
    _DiffFile_unifiedLines.set(this, []);
    _DiffFile_unifiedHunksLines.set(this, void 0);
    _DiffFile_listeners.set(this, []);
    _DiffFile_hasInitRaw.set(this, false);
    _DiffFile_hasInitSyntax.set(this, false);
    _DiffFile_hasBuildSplit.set(this, false);
    _DiffFile_hasBuildUnified.set(this, false);
    _DiffFile_updateCount.set(this, 0);
    _DiffFile_composeByDiff.set(this, false);
    _DiffFile_composeByMerge.set(this, false);
    _DiffFile_enableTemplate.set(this, true);
    _DiffFile_composeByFullMerge.set(this, false);
    _DiffFile_highlighterName.set(this, void 0);
    _DiffFile_highlighterType.set(this, void 0);
    _DiffFile_theme.set(this, "light");
    _DiffFile__theme.set(this, void 0);
    _DiffFile_hasExpandSplitAll.set(this, { state: false });
    _DiffFile_hasExpandUnifiedAll.set(this, { state: false });
    this._version_ = "0.0.30";
    this._oldFileName = "";
    this._oldFileContent = "";
    this._oldFileLang = "";
    this._newFileName = "";
    this._newFileContent = "";
    this._newFileLang = "";
    this._diffList = [];
    this.diffLineLength = 0;
    this.splitLineLength = 0;
    this.unifiedLineLength = 0;
    this.fileLineLength = 0;
    this.additionLength = 0;
    this.deletionLength = 0;
    this.hasSomeLineCollapsed = false;
    _DiffFile_id.set(this, "");
    _DiffFile_clonedInstance.set(this, /* @__PURE__ */ new Map());
    this.getSplitLeftLine = (index) => {
      return __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")[index];
    };
    this.getSplitLineByLineNumber = (lineNumber, side) => {
      var _a, _b;
      if (side === SplitSide.old) {
        return (_a = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")) === null || _a === void 0 ? void 0 : _a.find((item) => item.lineNumber === lineNumber);
      } else {
        return (_b = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")) === null || _b === void 0 ? void 0 : _b.find((item) => item.lineNumber === lineNumber);
      }
    };
    this.getSplitLineIndexByLineNumber = (lineNumber, side) => {
      var _a, _b;
      if (side === SplitSide.old) {
        return (_a = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")) === null || _a === void 0 ? void 0 : _a.findIndex((item) => item.lineNumber === lineNumber);
      } else {
        return (_b = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")) === null || _b === void 0 ? void 0 : _b.findIndex((item) => item.lineNumber === lineNumber);
      }
    };
    this.getSplitRightLine = (index) => {
      return __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")[index];
    };
    this.getSplitHunkLine = (index) => {
      var _a;
      return (_a = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")) === null || _a === void 0 ? void 0 : _a[index];
    };
    this.onSplitHunkExpand = (dir, index, needTrigger = true) => {
      var _a, _b;
      const current = (_a = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")) === null || _a === void 0 ? void 0 : _a[index];
      if (!current || !current.splitInfo)
        return;
      if (__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f"))
        return;
      if (dir === "all") {
        for (let i = current.splitInfo.startHiddenIndex; i < current.splitInfo.endHiddenIndex; i++) {
          const leftLine = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")[i];
          const rightLine = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")[i];
          if (leftLine === null || leftLine === void 0 ? void 0 : leftLine.isHidden)
            leftLine.isHidden = false;
          if (rightLine === null || rightLine === void 0 ? void 0 : rightLine.isHidden)
            rightLine.isHidden = false;
        }
        current.splitInfo = Object.assign(Object.assign(Object.assign({}, current.splitInfo), current.hunkInfo), { plainText: current.text, startHiddenIndex: current.splitInfo.endHiddenIndex });
      } else if (dir === "down") {
        for (let i = current.splitInfo.startHiddenIndex; i < current.splitInfo.startHiddenIndex + composeLen; i++) {
          const leftLine = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")[i];
          const rightLine = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")[i];
          if (leftLine === null || leftLine === void 0 ? void 0 : leftLine.isHidden)
            leftLine.isHidden = false;
          if (rightLine === null || rightLine === void 0 ? void 0 : rightLine.isHidden)
            rightLine.isHidden = false;
        }
        if (current.isLast) {
          current.splitInfo = Object.assign(Object.assign({}, current.splitInfo), { startHiddenIndex: current.splitInfo.startHiddenIndex + composeLen });
        } else {
          current.splitInfo = Object.assign(Object.assign({}, current.splitInfo), { startHiddenIndex: current.splitInfo.startHiddenIndex + composeLen, plainText: `@@ -${current.splitInfo.oldStartIndex},${current.splitInfo.oldLength} +${current.splitInfo.newStartIndex},${current.splitInfo.newLength}` });
        }
      } else {
        if (current.isLast) {
          if (true) {
            console.error("the last hunk can not expand up!");
          }
          return;
        }
        for (let i = current.splitInfo.endHiddenIndex - composeLen; i < current.splitInfo.endHiddenIndex; i++) {
          const leftLine = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")[i];
          const rightLine = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")[i];
          if (leftLine === null || leftLine === void 0 ? void 0 : leftLine.isHidden)
            leftLine.isHidden = false;
          if (rightLine === null || rightLine === void 0 ? void 0 : rightLine.isHidden)
            rightLine.isHidden = false;
        }
        const oldStartIndex = current.splitInfo.oldStartIndex - composeLen;
        const oldLength = current.splitInfo.oldLength + composeLen;
        const newStartIndex = current.splitInfo.newStartIndex - composeLen;
        const newLength = current.splitInfo.newLength + composeLen;
        current.splitInfo = Object.assign(Object.assign({}, current.splitInfo), {
          endHiddenIndex: current.splitInfo.endHiddenIndex - composeLen,
          oldStartIndex,
          oldLength,
          newStartIndex,
          newLength,
          plainText: `@@ -${oldStartIndex},${oldLength} +${newStartIndex},${newLength}`
        });
        (_b = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")) === null || _b === void 0 ? true : delete _b[index];
        __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")[current.splitInfo.endHiddenIndex] = current;
      }
      if (needTrigger) {
        this.notifyAll();
      }
    };
    this.getUnifiedLine = (index) => {
      return __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")[index];
    };
    this.getUnifiedLineByLineNumber = (lienNumber, side) => {
      var _a, _b;
      if (side === SplitSide.old) {
        return (_a = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _a === void 0 ? void 0 : _a.find((item) => item.oldLineNumber === lienNumber);
      } else {
        return (_b = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _b === void 0 ? void 0 : _b.find((item) => item.newLineNumber === lienNumber);
      }
    };
    this.getUnifiedLineIndexByLineNumber = (lineNumber, side) => {
      var _a, _b;
      if (side === SplitSide.old) {
        return (_a = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _a === void 0 ? void 0 : _a.findIndex((item) => item.oldLineNumber === lineNumber);
      } else {
        return (_b = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _b === void 0 ? void 0 : _b.findIndex((item) => item.newLineNumber === lineNumber);
      }
    };
    this.getUnifiedHunkLine = (index) => {
      var _a;
      return (_a = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")) === null || _a === void 0 ? void 0 : _a[index];
    };
    this.onUnifiedHunkExpand = (dir, index, needTrigger = true) => {
      var _a, _b, _c;
      if (__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f"))
        return;
      const current = (_a = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")) === null || _a === void 0 ? void 0 : _a[index];
      if (!current || !current.unifiedInfo)
        return;
      if (dir === "all") {
        for (let i = current.unifiedInfo.startHiddenIndex; i < current.unifiedInfo.endHiddenIndex; i++) {
          const unifiedLine = (_b = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _b === void 0 ? void 0 : _b[i];
          if (unifiedLine === null || unifiedLine === void 0 ? void 0 : unifiedLine.isHidden) {
            unifiedLine.isHidden = false;
          }
        }
        current.unifiedInfo = Object.assign(Object.assign(Object.assign({}, current.unifiedInfo), current.hunkInfo), { plainText: current.text, startHiddenIndex: current.unifiedInfo.endHiddenIndex });
      } else if (dir === "down") {
        for (let i = current.unifiedInfo.startHiddenIndex; i < current.unifiedInfo.startHiddenIndex + composeLen; i++) {
          const unifiedLine = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")[i];
          if (unifiedLine === null || unifiedLine === void 0 ? void 0 : unifiedLine.isHidden)
            unifiedLine.isHidden = false;
        }
        if (current.isLast) {
          current.unifiedInfo = Object.assign(Object.assign({}, current.unifiedInfo), { startHiddenIndex: current.unifiedInfo.startHiddenIndex + composeLen });
        } else {
          current.unifiedInfo = Object.assign(Object.assign({}, current.unifiedInfo), { startHiddenIndex: current.unifiedInfo.startHiddenIndex + composeLen, plainText: `@@ -${current.unifiedInfo.oldStartIndex},${current.unifiedInfo.oldLength} +${current.unifiedInfo.newStartIndex},${current.unifiedInfo.newLength}` });
        }
      } else {
        if (current.isLast) {
          if (true) {
            console.error("the last hunk can not expand up!");
          }
          return;
        }
        for (let i = current.unifiedInfo.endHiddenIndex - composeLen; i < current.unifiedInfo.endHiddenIndex; i++) {
          const unifiedLine = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")[i];
          if (unifiedLine === null || unifiedLine === void 0 ? void 0 : unifiedLine.isHidden)
            unifiedLine.isHidden = false;
        }
        const oldStartIndex = current.unifiedInfo.oldStartIndex - composeLen;
        const oldLength = current.unifiedInfo.oldLength + composeLen;
        const newStartIndex = current.unifiedInfo.newStartIndex - composeLen;
        const newLength = current.unifiedInfo.newLength + composeLen;
        current.unifiedInfo = Object.assign(Object.assign({}, current.unifiedInfo), {
          endHiddenIndex: current.unifiedInfo.endHiddenIndex - composeLen,
          oldStartIndex,
          oldLength,
          newStartIndex,
          newLength,
          plainText: `@@ -${oldStartIndex},${oldLength} +${newStartIndex},${newLength}`
        });
        (_c = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")) === null || _c === void 0 ? true : delete _c[index];
        __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")[current.unifiedInfo.endHiddenIndex] = current;
      }
      if (needTrigger) {
        this.notifyAll();
      }
    };
    this.onAllExpand = (mode) => {
      if (__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f"))
        return;
      if (mode === "split") {
        Object.keys(__classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f") || {}).forEach((key) => {
          this.onSplitHunkExpand("all", +key, false);
        });
        __classPrivateFieldGet(this, _DiffFile_hasExpandSplitAll, "f").state = true;
      } else {
        Object.keys(__classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f") || {}).forEach((key) => {
          this.onUnifiedHunkExpand("all", +key, false);
        });
        __classPrivateFieldGet(this, _DiffFile_hasExpandUnifiedAll, "f").state = true;
      }
      this.notifyAll();
    };
    this.onAllCollapse = (mode) => {
      if (__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f"))
        return;
      if (mode === "split") {
        Object.values(__classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f") || {}).forEach((item) => {
          if (!item.isHidden && item._isHidden) {
            item.isHidden = item._isHidden;
          }
        });
        Object.values(__classPrivateFieldGet(this, _DiffFile_splitRightLines, "f") || {}).forEach((item) => {
          if (!item.isHidden && item._isHidden) {
            item.isHidden = item._isHidden;
          }
        });
        Object.values(__classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f") || {}).forEach((item) => {
          if (!item.splitInfo)
            return;
          item.splitInfo = Object.assign(Object.assign({}, item.splitInfo), { oldStartIndex: item.splitInfo._oldStartIndex, oldLength: item.splitInfo._oldLength, newStartIndex: item.splitInfo._newStartIndex, newLength: item.splitInfo._newLength, startHiddenIndex: item.splitInfo._startHiddenIndex, endHiddenIndex: item.splitInfo._endHiddenIndex, plainText: item.splitInfo._plainText });
        });
        Object.keys(__classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f") || {}).forEach((key) => {
          const item = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")[key];
          if (!item.splitInfo)
            return;
          if (item.splitInfo.endHiddenIndex !== +key) {
            delete __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")[key];
            __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")[item.splitInfo.endHiddenIndex] = item;
          }
        });
        __classPrivateFieldGet(this, _DiffFile_hasExpandSplitAll, "f").state = false;
      } else {
        Object.values(__classPrivateFieldGet(this, _DiffFile_unifiedLines, "f") || {}).forEach((item) => {
          if (!item.isHidden && item._isHidden) {
            item.isHidden = item._isHidden;
          }
        });
        Object.values(__classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f") || {}).forEach((item) => {
          if (!item.unifiedInfo)
            return;
          item.unifiedInfo = Object.assign(Object.assign({}, item.unifiedInfo), { oldStartIndex: item.unifiedInfo._oldStartIndex, oldLength: item.unifiedInfo._oldLength, newStartIndex: item.unifiedInfo._newStartIndex, newLength: item.unifiedInfo._newLength, startHiddenIndex: item.unifiedInfo._startHiddenIndex, endHiddenIndex: item.unifiedInfo._endHiddenIndex, plainText: item.unifiedInfo._plainText });
        });
        Object.keys(__classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f") || {}).forEach((key) => {
          const item = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")[key];
          if (!item.unifiedInfo)
            return;
          if (item.unifiedInfo.endHiddenIndex !== +key) {
            delete __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")[key];
            __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")[item.unifiedInfo.endHiddenIndex] = item;
          }
        });
        __classPrivateFieldGet(this, _DiffFile_hasExpandUnifiedAll, "f").state = false;
      }
      this.notifyAll();
    };
    this.getOldFileContent = () => {
      var _a;
      return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.raw;
    };
    this.getNewFileContent = () => {
      var _a;
      return (_a = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _a === void 0 ? void 0 : _a.raw;
    };
    this.getOldPlainLine = (lineNumber) => {
      var _a;
      return (_a = __classPrivateFieldGet(this, _DiffFile_oldFilePlainLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
    };
    this.getOldSyntaxLine = (lineNumber) => {
      var _a;
      return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileSyntaxLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
    };
    this.getNewPlainLine = (lineNumber) => {
      var _a;
      return (_a = __classPrivateFieldGet(this, _DiffFile_newFilePlainLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
    };
    this.getNewSyntaxLine = (lineNumber) => {
      var _a;
      return (_a = __classPrivateFieldGet(this, _DiffFile_newFileSyntaxLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
    };
    this.subscribe = (listener) => {
      __classPrivateFieldGet(this, _DiffFile_listeners, "f").push(listener);
      return () => {
        __classPrivateFieldSet(this, _DiffFile_listeners, __classPrivateFieldGet(this, _DiffFile_listeners, "f").filter((i) => i !== listener), "f");
      };
    };
    this.notifyAll = (skipSyncExternal) => {
      var _a;
      __classPrivateFieldSet(this, _DiffFile_updateCount, (_a = __classPrivateFieldGet(this, _DiffFile_updateCount, "f"), _a++, _a), "f");
      __classPrivateFieldGet(this, _DiffFile_listeners, "f").forEach((f) => {
        if (skipSyncExternal && f.isSyncExternal) {
          return;
        }
        f();
      });
      __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").forEach((_, instance2) => {
        instance2.notifyAll(true);
      });
    };
    this.getUpdateCount = () => __classPrivateFieldGet(this, _DiffFile_updateCount, "f");
    this.getExpandEnabled = () => !__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f");
    this.getBundle = () => {
      const hasInitRaw = __classPrivateFieldGet(this, _DiffFile_hasInitRaw, "f");
      const hasInitSyntax = __classPrivateFieldGet(this, _DiffFile_hasInitSyntax, "f");
      const hasBuildSplit = __classPrivateFieldGet(this, _DiffFile_hasBuildSplit, "f");
      const hasBuildUnified = __classPrivateFieldGet(this, _DiffFile_hasBuildUnified, "f");
      const oldFileLines = __classPrivateFieldGet(this, _DiffFile_oldFileLines, "f");
      const oldFileDiffLines = __classPrivateFieldGet(this, _DiffFile_oldFileDiffLines, "f");
      const oldFilePlainLines = __classPrivateFieldGet(this, _DiffFile_oldFilePlainLines, "f");
      const oldFileSyntaxLines = __classPrivateFieldGet(this, _DiffFile_oldFileSyntaxLines, "f");
      const oldFilePlaceholderLines = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f");
      const newFileLines = __classPrivateFieldGet(this, _DiffFile_newFileLines, "f");
      const newFileDiffLines = __classPrivateFieldGet(this, _DiffFile_newFileDiffLines, "f");
      const newFilePlainLines = __classPrivateFieldGet(this, _DiffFile_newFilePlainLines, "f");
      const newFileSyntaxLines = __classPrivateFieldGet(this, _DiffFile_newFileSyntaxLines, "f");
      const newFilePlaceholderLines = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f");
      const splitLineLength = this.splitLineLength;
      const unifiedLineLength = this.unifiedLineLength;
      const fileLineLength = this.fileLineLength;
      const additionLength = this.additionLength;
      const deletionLength = this.deletionLength;
      const composeByDiff = __classPrivateFieldGet(this, _DiffFile_composeByDiff, "f");
      const highlighterName = __classPrivateFieldGet(this, _DiffFile_highlighterName, "f");
      const highlighterType = __classPrivateFieldGet(this, _DiffFile_highlighterType, "f");
      const hasSomeLineCollapsed = this.hasSomeLineCollapsed;
      const hasExpandSplitAll = __classPrivateFieldGet(this, _DiffFile_hasExpandSplitAll, "f");
      const hasExpandUnifiedAll = __classPrivateFieldGet(this, _DiffFile_hasExpandUnifiedAll, "f");
      const splitLeftLines = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f");
      const splitRightLines = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f");
      const splitHunkLines = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f");
      const unifiedLines = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f");
      const unifiedHunkLines = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f");
      const version = this._version_;
      const theme = __classPrivateFieldGet(this, _DiffFile_theme, "f");
      const enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
      return {
        hasInitRaw,
        hasInitSyntax,
        hasBuildSplit,
        hasBuildUnified,
        oldFileLines,
        oldFileDiffLines,
        oldFilePlainLines,
        oldFileSyntaxLines,
        oldFilePlaceholderLines,
        newFileLines,
        newFileDiffLines,
        newFilePlainLines,
        newFileSyntaxLines,
        newFilePlaceholderLines,
        splitLineLength,
        unifiedLineLength,
        fileLineLength,
        additionLength,
        deletionLength,
        splitLeftLines,
        splitRightLines,
        splitHunkLines,
        unifiedLines,
        unifiedHunkLines,
        highlighterName,
        highlighterType,
        composeByDiff,
        hasSomeLineCollapsed,
        hasExpandSplitAll,
        hasExpandUnifiedAll,
        version,
        theme,
        enableTemplate,
        isFullMerge: false
      };
    };
    this.mergeBundle = (data, notifyUpdate = true) => {
      __classPrivateFieldSet(this, _DiffFile_hasInitRaw, data.hasInitRaw, "f");
      __classPrivateFieldSet(this, _DiffFile_hasInitSyntax, data.hasInitSyntax, "f");
      __classPrivateFieldSet(this, _DiffFile_hasBuildSplit, data.hasBuildSplit, "f");
      __classPrivateFieldSet(this, _DiffFile_hasBuildUnified, data.hasBuildUnified, "f");
      __classPrivateFieldSet(this, _DiffFile_composeByDiff, data.composeByDiff, "f");
      __classPrivateFieldSet(this, _DiffFile_highlighterName, data.highlighterName, "f");
      __classPrivateFieldSet(this, _DiffFile_highlighterType, data.highlighterType, "f");
      __classPrivateFieldSet(this, _DiffFile_oldFileLines, data.oldFileLines, "f");
      __classPrivateFieldSet(this, _DiffFile_oldFileDiffLines, data.oldFileDiffLines, "f");
      __classPrivateFieldSet(this, _DiffFile_oldFilePlainLines, data.oldFilePlainLines, "f");
      __classPrivateFieldSet(this, _DiffFile_oldFileSyntaxLines, data.oldFileSyntaxLines, "f");
      __classPrivateFieldSet(this, _DiffFile_oldFilePlaceholderLines, data.oldFilePlaceholderLines, "f");
      __classPrivateFieldSet(this, _DiffFile_newFileLines, data.newFileLines, "f");
      __classPrivateFieldSet(this, _DiffFile_newFileDiffLines, data.newFileDiffLines, "f");
      __classPrivateFieldSet(this, _DiffFile_newFilePlainLines, data.newFilePlainLines, "f");
      __classPrivateFieldSet(this, _DiffFile_newFileSyntaxLines, data.newFileSyntaxLines, "f");
      __classPrivateFieldSet(this, _DiffFile_newFilePlaceholderLines, data.newFilePlaceholderLines, "f");
      this.splitLineLength = data.splitLineLength;
      this.unifiedLineLength = data.unifiedLineLength;
      this.fileLineLength = data.fileLineLength;
      this.additionLength = data.additionLength;
      this.deletionLength = data.deletionLength;
      this.hasSomeLineCollapsed = data.hasSomeLineCollapsed;
      __classPrivateFieldSet(this, _DiffFile_hasExpandSplitAll, data.hasExpandSplitAll, "f");
      __classPrivateFieldSet(this, _DiffFile_hasExpandUnifiedAll, data.hasExpandUnifiedAll, "f");
      __classPrivateFieldSet(this, _DiffFile_splitLeftLines, data.splitLeftLines, "f");
      __classPrivateFieldSet(this, _DiffFile_splitRightLines, data.splitRightLines, "f");
      __classPrivateFieldSet(this, _DiffFile_splitHunksLines, data.splitHunkLines, "f");
      __classPrivateFieldSet(this, _DiffFile_unifiedLines, data.unifiedLines, "f");
      __classPrivateFieldSet(this, _DiffFile_unifiedHunksLines, data.unifiedHunkLines, "f");
      __classPrivateFieldSet(this, _DiffFile_theme, data.theme, "f");
      __classPrivateFieldSet(this, _DiffFile_enableTemplate, data.enableTemplate, "f");
      __classPrivateFieldSet(this, _DiffFile_composeByMerge, true, "f");
      if (this._version_ !== data.version) {
        console.error("the version of the `diffInstance` is not match, some error may happen");
      }
      if (!data.hasInitRaw) {
        console.error(`there are not a valid bundle data, try to call 'initRaw' function before merge / getBundle`);
      }
      if (notifyUpdate) {
        this.notifyAll();
      }
    };
    this._getHighlighterName = () => __classPrivateFieldGet(this, _DiffFile_highlighterName, "f") || "";
    this._getIsPureDiffRender = () => __classPrivateFieldGet(this, _DiffFile_composeByDiff, "f");
    this._getTheme = () => __classPrivateFieldGet(this, _DiffFile_theme, "f");
    this._addClonedInstance = (instance2) => {
      const updateFunc = () => {
        this._notifyOthers(instance2);
        this._mergeFullBundle(instance2._getFullBundle(), false);
      };
      updateFunc.isSyncExternal = true;
      const unsubscribe = instance2.subscribe(updateFunc);
      __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").set(instance2, unsubscribe);
    };
    this._notifyOthers = (instance2) => {
      __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").forEach((_, i) => {
        if (i !== instance2) {
          i.notifyAll(true);
        }
      });
    };
    this._delClonedInstance = (instance2) => {
      const unsubscribe = __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").get(instance2);
      unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
      __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").delete(instance2);
    };
    this._getFullBundle = () => {
      const bundle = this.getBundle();
      const oldFileResult = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f");
      const newFileResult = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f");
      const diffLines = __classPrivateFieldGet(this, _DiffFile_diffLines, "f");
      const diffListResults = __classPrivateFieldGet(this, _DiffFile_diffListResults, "f");
      return Object.assign(Object.assign({}, bundle), {
        oldFileResult,
        newFileResult,
        diffLines,
        diffListResults,
        // get current instance is a fullMerge instance or not
        isFullMerge: __classPrivateFieldGet(this, _DiffFile_composeByMerge, "f") ? __classPrivateFieldGet(this, _DiffFile_composeByFullMerge, "f") : true
      });
    };
    this._mergeFullBundle = (data, notifyUpdate = true) => {
      this.mergeBundle(data, notifyUpdate);
      try {
        __classPrivateFieldSet(this, _DiffFile_oldFileResult, data.oldFileResult ? File.createInstance(data.oldFileResult) : null, "f");
        __classPrivateFieldSet(this, _DiffFile_newFileResult, data.newFileResult ? File.createInstance(data.newFileResult) : null, "f");
        __classPrivateFieldSet(this, _DiffFile_diffLines, data.diffLines, "f");
        __classPrivateFieldSet(this, _DiffFile_diffListResults, data.diffListResults, "f");
        __classPrivateFieldSet(this, _DiffFile_composeByFullMerge, data.isFullMerge, "f");
      } catch (_a) {
      }
    };
    this._destroy = () => {
      this.clearId();
      __classPrivateFieldGet(this, _DiffFile_listeners, "f").splice(0, __classPrivateFieldGet(this, _DiffFile_listeners, "f").length);
      __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").forEach((v) => v());
      __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").clear();
    };
    this.clear = () => {
      this._destroy();
      __classPrivateFieldSet(this, _DiffFile_oldFileResult, null, "f");
      __classPrivateFieldSet(this, _DiffFile_newFileResult, null, "f");
      __classPrivateFieldSet(this, _DiffFile_diffLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_diffListResults, null, "f");
      __classPrivateFieldSet(this, _DiffFile_newFileDiffLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_oldFileDiffLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_newFileLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_oldFileLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_newFileSyntaxLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_oldFileSyntaxLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_splitHunksLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_splitLeftLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_splitRightLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_unifiedHunksLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_unifiedLines, null, "f");
      __classPrivateFieldSet(this, _DiffFile_theme, void 0, "f");
    };
    Object.defineProperty(this, "__v_skip", { value: true });
    const diffList = Array.from(new Set(_diffList));
    this._oldFileName = _oldFileName;
    this._newFileName = _newFileName;
    this._diffList = diffList;
    this._oldFileLang = getLang(_oldFileLang || _oldFileName || _newFileLang || _newFileName) || "txt";
    this._newFileLang = getLang(_newFileLang || _newFileName || _oldFileLang || _oldFileName) || "txt";
    this._oldFileContent = _oldFileContent;
    this._newFileContent = _newFileContent;
    this.initId();
  }
  initId() {
    let id = "--" + Math.random().toString().slice(2);
    while (idSet.has(id)) {
      id = "--" + Math.random().toString().slice(2);
    }
    idSet.add(id);
    __classPrivateFieldSet(this, _DiffFile_id, id, "f");
  }
  getId() {
    return __classPrivateFieldGet(this, _DiffFile_id, "f");
  }
  clearId() {
    idSet.delete(__classPrivateFieldGet(this, _DiffFile_id, "f"));
  }
  initTheme(theme) {
    __classPrivateFieldSet(this, _DiffFile__theme, __classPrivateFieldGet(this, _DiffFile_theme, "f"), "f");
    __classPrivateFieldSet(this, _DiffFile_theme, theme || __classPrivateFieldGet(this, _DiffFile_theme, "f") || "light", "f");
  }
  initRaw() {
    if (__classPrivateFieldGet(this, _DiffFile_hasInitRaw, "f"))
      return;
    __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_doFile).call(this);
    __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeRaw).call(this);
    __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_doDiff).call(this);
    __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeDiff).call(this);
    __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeFile).call(this);
    __classPrivateFieldSet(this, _DiffFile_hasInitRaw, true, "f");
  }
  initSyntax({ registerHighlighter } = {}) {
    if (__classPrivateFieldGet(this, _DiffFile_hasInitSyntax, "f") && (!__classPrivateFieldGet(this, _DiffFile__theme, "f") || __classPrivateFieldGet(this, _DiffFile_theme, "f") === __classPrivateFieldGet(this, _DiffFile__theme, "f")))
      return;
    __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_doSyntax).call(this, { registerHighlighter });
    __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeDiff).call(this);
    __classPrivateFieldSet(this, _DiffFile_hasInitSyntax, true, "f");
  }
  init() {
    this.initRaw();
    this.initSyntax();
  }
  enableTemplate() {
    __classPrivateFieldSet(this, _DiffFile_enableTemplate, true, "f");
  }
  disableTemplate() {
    __classPrivateFieldSet(this, _DiffFile_enableTemplate, false, "f");
  }
  getIsEnableTemplate() {
    return __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
  }
  buildSplitDiffLines() {
    var _a, _b, _c, _d, _e, _f;
    if (__classPrivateFieldGet(this, _DiffFile_hasBuildSplit, "f"))
      return;
    let oldFileLineNumber = 1;
    let newFileLineNumber = 1;
    let prevIsHidden = true;
    let hideStart = Infinity;
    const maxOldFileLineNumber = ((_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.maxLineNumber) || 0;
    const maxNewFileLineNumber = ((_b = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _b === void 0 ? void 0 : _b.maxLineNumber) || 0;
    if (!__classPrivateFieldGet(this, _DiffFile_oldFileResult, "f") && !__classPrivateFieldGet(this, _DiffFile_newFileResult, "f") && __classPrivateFieldGet(this, _DiffFile_composeByMerge, "f")) {
      console.error("this instance can not `buildSplitDiffLines` because of the data missing, try to use '_getFullBundle' & '_mergeFullBundle' instead of 'getBundle' & 'mergeBundle'");
    }
    while (oldFileLineNumber <= maxOldFileLineNumber || newFileLineNumber <= maxNewFileLineNumber) {
      const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldFileLineNumber);
      const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newFileLineNumber);
      const oldRawLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldRawLine).call(this, oldFileLineNumber);
      const newRawLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewRawLine).call(this, newFileLineNumber);
      const oldLineHasChange = DiffLine.prototype.isIncludeableLine.call(oldDiffLine || {});
      const newLineHasChange = DiffLine.prototype.isIncludeableLine.call(newDiffLine || {});
      const len = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length;
      const isHidden = !oldDiffLine && !newDiffLine;
      if (oldDiffLine && !newDiffLine) {
        if (oldDiffLine.newLineNumber && oldDiffLine.newLineNumber > newFileLineNumber) {
          newFileLineNumber++;
          continue;
        }
        if (oldDiffLine.newLineNumber === null || oldDiffLine.newLineNumber === void 0) {
          newFileLineNumber++;
        }
      }
      if (newDiffLine && !oldDiffLine) {
        if (newDiffLine.oldLineNumber && newDiffLine.oldLineNumber > oldFileLineNumber) {
          oldFileLineNumber++;
          continue;
        }
        if (newDiffLine.oldLineNumber === null || newDiffLine.oldLineNumber === void 0) {
          oldFileLineNumber++;
        }
      }
      if (!oldDiffLine && !oldRawLine && !newDiffLine && !newRawLine)
        break;
      if (!oldDiffLine && !newDiffLine) {
        if (((_c = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f")) === null || _c === void 0 ? void 0 : _c[oldFileLineNumber]) && ((_d = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f")) === null || _d === void 0 ? void 0 : _d[newFileLineNumber])) {
          oldFileLineNumber++;
          newFileLineNumber++;
          continue;
        }
        if (!oldRawLine && ((_e = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f")) === null || _e === void 0 ? void 0 : _e[newFileLineNumber])) {
          newFileLineNumber++;
          continue;
        }
        if (!newRawLine && ((_f = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f")) === null || _f === void 0 ? void 0 : _f[oldFileLineNumber])) {
          oldFileLineNumber++;
          continue;
        }
      }
      if (oldLineHasChange && newLineHasChange || !oldLineHasChange && !newLineHasChange) {
        __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f").push({
          lineNumber: oldFileLineNumber++,
          value: oldRawLine,
          diff: oldDiffLine,
          isHidden,
          _isHidden: isHidden
        });
        __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").push({
          lineNumber: newFileLineNumber++,
          value: newRawLine,
          diff: newDiffLine,
          isHidden,
          _isHidden: isHidden
        });
      } else if (oldLineHasChange) {
        __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f").push({
          lineNumber: oldFileLineNumber++,
          value: oldRawLine,
          diff: oldDiffLine,
          isHidden,
          _isHidden: isHidden
        });
        __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").push({});
      } else if (newLineHasChange) {
        __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f").push({});
        __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").push({
          lineNumber: newFileLineNumber++,
          value: newRawLine,
          diff: newDiffLine,
          isHidden,
          _isHidden: isHidden
        });
      }
      if (!prevIsHidden && isHidden) {
        hideStart = len;
      }
      if (isHidden) {
        this.hasSomeLineCollapsed = true;
      }
      prevIsHidden = isHidden;
      if ((oldDiffLine === null || oldDiffLine === void 0 ? void 0 : oldDiffLine.prevHunkLine) || (newDiffLine === null || newDiffLine === void 0 ? void 0 : newDiffLine.prevHunkLine)) {
        const prevHunkLine = (oldDiffLine === null || oldDiffLine === void 0 ? void 0 : oldDiffLine.prevHunkLine) || newDiffLine.prevHunkLine;
        if (prevHunkLine.isFirst) {
          if (Number.isFinite(hideStart)) {
            console.warn("the first hunk can not have a previous diff line");
          }
          prevHunkLine.splitInfo = Object.assign(Object.assign({}, prevHunkLine.hunkInfo), { startHiddenIndex: 0, endHiddenIndex: prevHunkLine.hunkInfo.newStartIndex - 1, plainText: prevHunkLine.text, _startHiddenIndex: 0, _endHiddenIndex: prevHunkLine.hunkInfo.newStartIndex - 1, _plainText: prevHunkLine.text });
          hideStart = Infinity;
        } else if (Number.isFinite(hideStart)) {
          prevHunkLine.splitInfo = Object.assign(Object.assign({}, prevHunkLine.hunkInfo), { startHiddenIndex: hideStart, endHiddenIndex: len, plainText: prevHunkLine.text, _startHiddenIndex: hideStart, _endHiddenIndex: len, _plainText: prevHunkLine.text });
          hideStart = Infinity;
        }
        __classPrivateFieldSet(this, _DiffFile_splitHunksLines, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")), { [len]: prevHunkLine }), "f");
      }
    }
    if (Number.isFinite(hideStart)) {
      const lastDiff = new DiffLine("", DiffLineType.Hunk, null, null, null);
      const lastHunk = lastDiff;
      lastHunk.isLast = true;
      lastHunk.splitInfo = {
        startHiddenIndex: hideStart,
        endHiddenIndex: __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length,
        _startHiddenIndex: hideStart,
        _endHiddenIndex: __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length,
        // just for placeholder
        plainText: "",
        oldStartIndex: 0,
        newStartIndex: 0,
        oldLength: 0,
        newLength: 0,
        _plainText: "",
        _oldStartIndex: 0,
        _newStartIndex: 0,
        _oldLength: 0,
        _newLength: 0
      };
      __classPrivateFieldSet(this, _DiffFile_splitHunksLines, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")), { [__classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length]: lastHunk }), "f");
      hideStart = Infinity;
    }
    this.splitLineLength = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length;
    __classPrivateFieldSet(this, _DiffFile_hasBuildSplit, true, "f");
    this.notifyAll();
  }
  buildUnifiedDiffLines() {
    var _a, _b, _c, _d, _e, _f;
    if (__classPrivateFieldGet(this, _DiffFile_hasBuildUnified, "f"))
      return;
    let oldFileLineNumber = 1;
    let newFileLineNumber = 1;
    let prevIsHidden = true;
    let hideStart = Infinity;
    const maxOldFileLineNumber = ((_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.maxLineNumber) || 0;
    const maxNewFileLineNumber = ((_b = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _b === void 0 ? void 0 : _b.maxLineNumber) || 0;
    if (!__classPrivateFieldGet(this, _DiffFile_oldFileResult, "f") && !__classPrivateFieldGet(this, _DiffFile_newFileResult, "f") && __classPrivateFieldGet(this, _DiffFile_composeByMerge, "f")) {
      console.error("this instance can not `buildUnifiedDiffLines` because of the data missing, try to use '_getFullBundle' & '_mergeFullBundle' instead of 'getBundle' & 'mergeBundle'");
    }
    while (oldFileLineNumber <= maxOldFileLineNumber || newFileLineNumber <= maxNewFileLineNumber) {
      const oldRawLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldRawLine).call(this, oldFileLineNumber);
      const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldFileLineNumber);
      const newRawLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewRawLine).call(this, newFileLineNumber);
      const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newFileLineNumber);
      const oldLineHasChange = DiffLine.prototype.isIncludeableLine.call(oldDiffLine || {});
      const newLineHasChange = DiffLine.prototype.isIncludeableLine.call(newDiffLine || {});
      const len = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length;
      const isHidden = !oldDiffLine && !newDiffLine;
      if (oldDiffLine && !newDiffLine) {
        if (oldDiffLine.newLineNumber && oldDiffLine.newLineNumber > newFileLineNumber) {
          newFileLineNumber++;
          continue;
        }
        if (oldDiffLine.newLineNumber === null || oldDiffLine.newLineNumber === void 0) {
          newFileLineNumber++;
        }
      }
      if (newDiffLine && !oldDiffLine) {
        if (newDiffLine.oldLineNumber && newDiffLine.oldLineNumber > oldFileLineNumber) {
          oldFileLineNumber++;
          continue;
        }
        if (newDiffLine.oldLineNumber === null || newDiffLine.oldLineNumber === void 0) {
          oldFileLineNumber++;
        }
      }
      if (!oldRawLine && !newRawLine && !newDiffLine && !oldDiffLine)
        break;
      if (!oldDiffLine && !newDiffLine) {
        if (((_c = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f")) === null || _c === void 0 ? void 0 : _c[oldFileLineNumber]) && ((_d = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f")) === null || _d === void 0 ? void 0 : _d[newFileLineNumber])) {
          oldFileLineNumber++;
          newFileLineNumber++;
          continue;
        }
        if (!oldRawLine && ((_e = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f")) === null || _e === void 0 ? void 0 : _e[newFileLineNumber])) {
          newFileLineNumber++;
          continue;
        }
        if (!newRawLine && ((_f = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f")) === null || _f === void 0 ? void 0 : _f[oldFileLineNumber])) {
          oldFileLineNumber++;
          continue;
        }
      }
      if (!oldLineHasChange && !newLineHasChange) {
        __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").push({
          oldLineNumber: oldFileLineNumber++,
          newLineNumber: newFileLineNumber++,
          value: newRawLine,
          diff: newDiffLine,
          isHidden,
          _isHidden: isHidden
        });
      } else if (oldLineHasChange) {
        __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").push({
          oldLineNumber: oldFileLineNumber++,
          value: oldRawLine,
          diff: oldDiffLine,
          isHidden,
          _isHidden: isHidden
        });
      } else if (newLineHasChange) {
        __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").push({
          newLineNumber: newFileLineNumber++,
          value: newRawLine,
          diff: newDiffLine,
          isHidden,
          _isHidden: isHidden
        });
      }
      if (!prevIsHidden && isHidden) {
        hideStart = len;
      }
      if (isHidden) {
        this.hasSomeLineCollapsed = true;
      }
      prevIsHidden = isHidden;
      if ((oldDiffLine === null || oldDiffLine === void 0 ? void 0 : oldDiffLine.prevHunkLine) || (newDiffLine === null || newDiffLine === void 0 ? void 0 : newDiffLine.prevHunkLine)) {
        const prevHunkLine = (oldDiffLine === null || oldDiffLine === void 0 ? void 0 : oldDiffLine.prevHunkLine) || newDiffLine.prevHunkLine;
        if (prevHunkLine.isFirst) {
          if (Number.isFinite(hideStart)) {
            console.warn("the first hunk can not have a previous diff line");
          }
          prevHunkLine.unifiedInfo = Object.assign(Object.assign({}, prevHunkLine.hunkInfo), { startHiddenIndex: 0, endHiddenIndex: prevHunkLine.hunkInfo.newStartIndex - 1, plainText: prevHunkLine.text, _startHiddenIndex: 0, _endHiddenIndex: prevHunkLine.hunkInfo.newStartIndex - 1, _plainText: prevHunkLine.text });
          hideStart = Infinity;
        } else if (Number.isFinite(hideStart)) {
          prevHunkLine.unifiedInfo = Object.assign(Object.assign({}, prevHunkLine.hunkInfo), { startHiddenIndex: hideStart, endHiddenIndex: len, plainText: prevHunkLine.text, _startHiddenIndex: hideStart, _endHiddenIndex: len, _plainText: prevHunkLine.text });
          hideStart = Infinity;
        }
        __classPrivateFieldSet(this, _DiffFile_unifiedHunksLines, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")), { [len]: prevHunkLine }), "f");
      }
    }
    if (Number.isFinite(hideStart)) {
      const lastDiff = new DiffLine("", DiffLineType.Hunk, null, null, null);
      const lastHunk = lastDiff;
      lastHunk.isLast = true;
      lastHunk.unifiedInfo = {
        startHiddenIndex: hideStart,
        endHiddenIndex: __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length,
        _startHiddenIndex: hideStart,
        _endHiddenIndex: __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length,
        // just for placeholder
        plainText: "",
        oldStartIndex: 0,
        newStartIndex: 0,
        oldLength: 0,
        newLength: 0,
        _plainText: "",
        _oldStartIndex: 0,
        _newStartIndex: 0,
        _oldLength: 0,
        _newLength: 0
      };
      __classPrivateFieldSet(this, _DiffFile_unifiedHunksLines, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")), { [__classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length]: lastHunk }), "f");
      hideStart = Infinity;
    }
    this.unifiedLineLength = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length;
    __classPrivateFieldSet(this, _DiffFile_hasBuildUnified, true, "f");
    this.notifyAll();
  }
  get hasExpandSplitAll() {
    return __classPrivateFieldGet(this, _DiffFile_hasExpandSplitAll, "f").state;
  }
  get hasExpandUnifiedAll() {
    return __classPrivateFieldGet(this, _DiffFile_hasExpandUnifiedAll, "f").state;
  }
};
_DiffFile_oldFileResult = /* @__PURE__ */ new WeakMap(), _DiffFile_newFileResult = /* @__PURE__ */ new WeakMap(), _DiffFile_diffListResults = /* @__PURE__ */ new WeakMap(), _DiffFile_diffLines = /* @__PURE__ */ new WeakMap(), _DiffFile_oldFileDiffLines = /* @__PURE__ */ new WeakMap(), _DiffFile_newFileDiffLines = /* @__PURE__ */ new WeakMap(), _DiffFile_oldFileLines = /* @__PURE__ */ new WeakMap(), _DiffFile_newFileLines = /* @__PURE__ */ new WeakMap(), _DiffFile_oldFilePlainLines = /* @__PURE__ */ new WeakMap(), _DiffFile_newFilePlainLines = /* @__PURE__ */ new WeakMap(), _DiffFile_oldFileSyntaxLines = /* @__PURE__ */ new WeakMap(), _DiffFile_newFileSyntaxLines = /* @__PURE__ */ new WeakMap(), _DiffFile_oldFilePlaceholderLines = /* @__PURE__ */ new WeakMap(), _DiffFile_newFilePlaceholderLines = /* @__PURE__ */ new WeakMap(), _DiffFile_splitLeftLines = /* @__PURE__ */ new WeakMap(), _DiffFile_splitRightLines = /* @__PURE__ */ new WeakMap(), _DiffFile_splitHunksLines = /* @__PURE__ */ new WeakMap(), _DiffFile_unifiedLines = /* @__PURE__ */ new WeakMap(), _DiffFile_unifiedHunksLines = /* @__PURE__ */ new WeakMap(), _DiffFile_listeners = /* @__PURE__ */ new WeakMap(), _DiffFile_hasInitRaw = /* @__PURE__ */ new WeakMap(), _DiffFile_hasInitSyntax = /* @__PURE__ */ new WeakMap(), _DiffFile_hasBuildSplit = /* @__PURE__ */ new WeakMap(), _DiffFile_hasBuildUnified = /* @__PURE__ */ new WeakMap(), _DiffFile_updateCount = /* @__PURE__ */ new WeakMap(), _DiffFile_composeByDiff = /* @__PURE__ */ new WeakMap(), _DiffFile_composeByMerge = /* @__PURE__ */ new WeakMap(), _DiffFile_enableTemplate = /* @__PURE__ */ new WeakMap(), _DiffFile_composeByFullMerge = /* @__PURE__ */ new WeakMap(), _DiffFile_highlighterName = /* @__PURE__ */ new WeakMap(), _DiffFile_highlighterType = /* @__PURE__ */ new WeakMap(), _DiffFile_theme = /* @__PURE__ */ new WeakMap(), _DiffFile__theme = /* @__PURE__ */ new WeakMap(), _DiffFile_hasExpandSplitAll = /* @__PURE__ */ new WeakMap(), _DiffFile_hasExpandUnifiedAll = /* @__PURE__ */ new WeakMap(), _DiffFile_id = /* @__PURE__ */ new WeakMap(), _DiffFile_clonedInstance = /* @__PURE__ */ new WeakMap(), _DiffFile_instances = /* @__PURE__ */ new WeakSet(), _DiffFile_doDiff = function _DiffFile_doDiff2() {
  if (!this._diffList)
    return;
  __classPrivateFieldSet(this, _DiffFile_diffListResults, this._diffList.map((s) => parseInstance.parse(s)), "f");
}, _DiffFile_doFile = function _DiffFile_doFile2() {
  if (!this._oldFileContent && !this._newFileContent)
    return;
  if (this._oldFileContent) {
    __classPrivateFieldSet(this, _DiffFile_oldFileResult, getFile(this._oldFileContent, this._oldFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._oldFileName, this.uuid ? this.uuid + "-old" : void 0), "f");
    __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
  }
  if (this._newFileContent) {
    __classPrivateFieldSet(this, _DiffFile_newFileResult, getFile(this._newFileContent, this._newFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._newFileName, this.uuid ? this.uuid + "-new" : void 0), "f");
    __classPrivateFieldGet(this, _DiffFile_newFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
  }
}, _DiffFile_composeRaw = function _DiffFile_composeRaw2() {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  (_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.doRaw();
  __classPrivateFieldSet(this, _DiffFile_oldFileLines, (_b = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _b === void 0 ? void 0 : _b.rawFile, "f");
  __classPrivateFieldSet(this, _DiffFile_oldFilePlainLines, (_c = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _c === void 0 ? void 0 : _c.plainFile, "f");
  (_d = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _d === void 0 ? void 0 : _d.doRaw();
  __classPrivateFieldSet(this, _DiffFile_newFileLines, (_e = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _e === void 0 ? void 0 : _e.rawFile, "f");
  __classPrivateFieldSet(this, _DiffFile_newFilePlainLines, (_f = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _f === void 0 ? void 0 : _f.plainFile, "f");
  this.fileLineLength = Math.max(this.fileLineLength, ((_g = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _g === void 0 ? void 0 : _g.maxLineNumber) || 0, ((_h = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _h === void 0 ? void 0 : _h.maxLineNumber) || 0);
}, _DiffFile_composeFile = function _DiffFile_composeFile2() {
  if (this._oldFileContent && this._newFileContent)
    return;
  const oldFilePlaceholderLines = {};
  const newFilePlaceholderLines = {};
  if (!this._oldFileContent && !this._newFileContent) {
    let newLineNumber = 1;
    let oldLineNumber = 1;
    let oldFileContent = "";
    let newFileContent = "";
    let hasSymbolChanged = false;
    while (oldLineNumber <= this.diffLineLength || newLineNumber <= this.diffLineLength) {
      const oldIndex = oldLineNumber++;
      const newIndex = newLineNumber++;
      const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldIndex);
      const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newIndex);
      if (oldDiffLine) {
        oldFileContent += oldDiffLine.text;
      } else {
        oldFileContent += "\n";
        oldFilePlaceholderLines[oldIndex] = true;
      }
      if (newDiffLine) {
        newFileContent += newDiffLine.text;
      } else {
        newFileContent += "\n";
        newFilePlaceholderLines[newIndex] = true;
      }
      if (!hasSymbolChanged && oldDiffLine && newDiffLine) {
        hasSymbolChanged = hasSymbolChanged || oldDiffLine.noTrailingNewLine !== newDiffLine.noTrailingNewLine;
      }
    }
    if (!hasSymbolChanged && oldFileContent === newFileContent)
      return;
    this._oldFileContent = oldFileContent;
    this._newFileContent = newFileContent;
    __classPrivateFieldSet(this, _DiffFile_oldFileResult, getFile(this._oldFileContent, this._oldFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._oldFileName, this.uuid ? this.uuid + "-old" : void 0), "f");
    __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
    __classPrivateFieldSet(this, _DiffFile_newFileResult, getFile(this._newFileContent, this._newFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._newFileName, this.uuid ? this.uuid + "-new" : void 0), "f");
    __classPrivateFieldGet(this, _DiffFile_newFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
    __classPrivateFieldSet(this, _DiffFile_oldFilePlaceholderLines, oldFilePlaceholderLines, "f");
    __classPrivateFieldSet(this, _DiffFile_newFilePlaceholderLines, newFilePlaceholderLines, "f");
    __classPrivateFieldSet(this, _DiffFile_composeByDiff, true, "f");
  } else if (__classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) {
    let newLineNumber = 1;
    let oldLineNumber = 1;
    let newFileContent = "";
    let hasSymbolChanged = false;
    while (oldLineNumber <= __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f").maxLineNumber) {
      const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newLineNumber++);
      const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldLineNumber);
      if (newDiffLine) {
        newFileContent += newDiffLine.text;
        oldLineNumber = newDiffLine.oldLineNumber ? newDiffLine.oldLineNumber + 1 : oldLineNumber;
      } else {
        if (!oldDiffLine) {
          newFileContent += __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldRawLine).call(this, oldLineNumber);
        }
        oldLineNumber++;
      }
      if (!hasSymbolChanged && newDiffLine && oldDiffLine) {
        hasSymbolChanged = hasSymbolChanged || newDiffLine.noTrailingNewLine !== oldDiffLine.noTrailingNewLine;
      }
    }
    if (!hasSymbolChanged && newFileContent === this._oldFileContent)
      return;
    this._newFileContent = newFileContent;
    __classPrivateFieldSet(this, _DiffFile_newFileResult, getFile(this._newFileContent, this._newFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._newFileName, this.uuid ? this.uuid + "-new" : void 0), "f");
    __classPrivateFieldGet(this, _DiffFile_newFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
  } else if (__classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) {
    let oldLineNumber = 1;
    let newLineNumber = 1;
    let oldFileContent = "";
    let hasSymbolChanged = false;
    while (newLineNumber <= __classPrivateFieldGet(this, _DiffFile_newFileResult, "f").maxLineNumber) {
      const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldLineNumber++);
      const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newLineNumber);
      if (oldDiffLine) {
        oldFileContent += oldDiffLine.text;
        newLineNumber = oldDiffLine.newLineNumber ? oldDiffLine.newLineNumber + 1 : newLineNumber;
      } else {
        if (!newDiffLine) {
          oldFileContent += __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewRawLine).call(this, newLineNumber);
        }
        newLineNumber++;
      }
      if (!hasSymbolChanged && newDiffLine && oldDiffLine) {
        hasSymbolChanged = hasSymbolChanged || newDiffLine.noTrailingNewLine !== oldDiffLine.noTrailingNewLine;
      }
    }
    if (!hasSymbolChanged && oldFileContent === this._newFileContent)
      return;
    this._oldFileContent = oldFileContent;
    __classPrivateFieldSet(this, _DiffFile_oldFileResult, getFile(this._oldFileContent, this._oldFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._oldFileName, this.uuid ? this.uuid + "-old" : void 0), "f");
    __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
  }
  __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeRaw).call(this);
}, _DiffFile_composeDiff = function _DiffFile_composeDiff2() {
  var _a;
  if (!((_a = __classPrivateFieldGet(this, _DiffFile_diffListResults, "f")) === null || _a === void 0 ? void 0 : _a.length))
    return;
  const getAdditionRaw = (lineNumber) => {
    return __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewRawLine).call(this, lineNumber);
  };
  const getDeletionRaw = (lineNumber) => {
    return __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldRawLine).call(this, lineNumber);
  };
  const getAdditionSyntax = (lineNumber) => {
    return __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewSyntaxLine).call(this, lineNumber);
  };
  const getDeletionSyntax = (lineNumber) => {
    return __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldSyntaxLine).call(this, lineNumber);
  };
  __classPrivateFieldSet(this, _DiffFile_diffLines, [], "f");
  this.additionLength = 0;
  this.deletionLength = 0;
  const tmp = [];
  __classPrivateFieldGet(this, _DiffFile_diffListResults, "f").forEach((item) => {
    const hunks = item.hunks;
    hunks.forEach((hunk) => {
      let additions = [];
      let deletions = [];
      hunk.lines.forEach((line) => {
        if (line.type === DiffLineType.Add) {
          additions.push(line);
          this.additionLength++;
        } else if (line.type === DiffLineType.Delete) {
          deletions.push(line);
          this.deletionLength++;
        } else {
          getDiffRange(additions, deletions, {
            getAdditionRaw,
            getDeletionRaw,
            getAdditionSyntax,
            getDeletionSyntax
          });
          additions = [];
          deletions = [];
        }
        tmp.push(line);
      });
      getDiffRange(additions, deletions, { getAdditionRaw, getDeletionRaw, getAdditionSyntax, getDeletionSyntax });
    });
  });
  let prevHunkLine = null;
  __classPrivateFieldSet(this, _DiffFile_diffLines, tmp.map((i, index) => {
    var _a2;
    const typedI = i;
    typedI.index = index;
    typedI.isFirst = index === 0;
    if (typedI.type === DiffLineType.Hunk) {
      const numInfo = (_a2 = typedI.text.split("@@")) === null || _a2 === void 0 ? void 0 : _a2[1].split(" ").filter(Boolean);
      const oldNumInfo = (numInfo === null || numInfo === void 0 ? void 0 : numInfo[0]) || "";
      const newNumInfo = (numInfo === null || numInfo === void 0 ? void 0 : numInfo[1]) || "";
      const [oldNumStartIndex, oldNumLength] = oldNumInfo.split(",");
      const [newNumStartIndex, newNumLength] = newNumInfo.split(",");
      typedI.hunkInfo = {
        oldStartIndex: -Number(oldNumStartIndex),
        oldLength: Number(oldNumLength),
        newStartIndex: +Number(newNumStartIndex),
        newLength: Number(newNumLength),
        _oldStartIndex: -Number(oldNumStartIndex),
        _oldLength: Number(oldNumLength),
        _newStartIndex: +Number(newNumStartIndex),
        _newLength: Number(newNumLength)
      };
      if (typedI.isFirst && typedI.hunkInfo.oldStartIndex && typedI.hunkInfo.newStartIndex && typedI.hunkInfo.oldStartIndex !== typedI.hunkInfo.newStartIndex) {
        console.warn("the first hunk should start with the same line number");
      }
      prevHunkLine = typedI;
    } else if (typedI.type === DiffLineType.Context) {
      const typedItem = i;
      if (prevHunkLine) {
        typedItem.prevHunkLine = prevHunkLine;
        prevHunkLine = null;
      }
    } else {
      prevHunkLine = null;
    }
    return typedI;
  }), "f");
  __classPrivateFieldSet(this, _DiffFile_oldFileDiffLines, {}, "f");
  __classPrivateFieldSet(this, _DiffFile_newFileDiffLines, {}, "f");
  let maxOldLineNumber = -1;
  let maxNewLineNumber = -1;
  __classPrivateFieldGet(this, _DiffFile_diffLines, "f").forEach((item) => {
    if (item.oldLineNumber) {
      this.diffLineLength = Math.max(this.diffLineLength, item.oldLineNumber);
      __classPrivateFieldGet(this, _DiffFile_oldFileDiffLines, "f")[item.oldLineNumber] = item;
      if (true) {
        if (item.oldLineNumber <= maxOldLineNumber) {
          console.warn('the "lineNumber" from "diff" should be in ascending order, maybe current "diff" string is not a valid "diff" string');
        }
        maxOldLineNumber = Math.max(maxOldLineNumber, item.oldLineNumber);
      }
    }
    if (item.newLineNumber) {
      this.diffLineLength = Math.max(this.diffLineLength, item.newLineNumber);
      __classPrivateFieldGet(this, _DiffFile_newFileDiffLines, "f")[item.newLineNumber] = item;
      if (true) {
        if (item.newLineNumber <= maxNewLineNumber) {
          console.warn('the "lineNumber" from "diff" should be in ascending order, maybe current "diff" string is not a valid "diff" string');
        }
        maxNewLineNumber = Math.max(maxNewLineNumber, item.newLineNumber);
      }
    }
  });
}, _DiffFile_composeSyntax = function _DiffFile_composeSyntax2({ registerHighlighter }) {
  var _a, _b, _c, _d;
  (_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.doSyntax({ registerHighlighter, theme: __classPrivateFieldGet(this, _DiffFile_theme, "f") });
  __classPrivateFieldSet(this, _DiffFile_oldFileSyntaxLines, (_b = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _b === void 0 ? void 0 : _b.syntaxFile, "f");
  (_c = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _c === void 0 ? void 0 : _c.doSyntax({ registerHighlighter, theme: __classPrivateFieldGet(this, _DiffFile_theme, "f") });
  __classPrivateFieldSet(this, _DiffFile_newFileSyntaxLines, (_d = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _d === void 0 ? void 0 : _d.syntaxFile, "f");
}, _DiffFile_doSyntax = function _DiffFile_doSyntax2({ registerHighlighter } = {}) {
  var _a, _b, _c, _d;
  if (__classPrivateFieldGet(this, _DiffFile_highlighterType, "f") === "class")
    return;
  if (__classPrivateFieldGet(this, _DiffFile_composeByMerge, "f") && !__classPrivateFieldGet(this, _DiffFile_composeByFullMerge, "f")) {
    if (true) {
      console.error(`this instance can not do syntax because of the data missing, try to use '_getFullBundle' & '_mergeFullBundle' instead of 'getBundle' & 'mergeBundle'`);
    }
    return;
  }
  __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeSyntax).call(this, { registerHighlighter });
  __classPrivateFieldSet(this, _DiffFile_highlighterName, ((_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.highlighterName) || ((_b = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _b === void 0 ? void 0 : _b.highlighterName) || __classPrivateFieldGet(this, _DiffFile_highlighterName, "f"), "f");
  __classPrivateFieldSet(this, _DiffFile_highlighterType, ((_c = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _c === void 0 ? void 0 : _c.highlighterType) || ((_d = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _d === void 0 ? void 0 : _d.highlighterType) || __classPrivateFieldGet(this, _DiffFile_highlighterType, "f"), "f");
}, _DiffFile_getOldDiffLine = function _DiffFile_getOldDiffLine2(lineNumber) {
  var _a;
  if (!lineNumber)
    return;
  return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileDiffLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getNewDiffLine = function _DiffFile_getNewDiffLine2(lineNumber) {
  var _a;
  if (!lineNumber)
    return;
  return (_a = __classPrivateFieldGet(this, _DiffFile_newFileDiffLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getOldRawLine = function _DiffFile_getOldRawLine2(lineNumber) {
  var _a;
  return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getNewRawLine = function _DiffFile_getNewRawLine2(lineNumber) {
  var _a;
  return (_a = __classPrivateFieldGet(this, _DiffFile_newFileLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getOldSyntaxLine = function _DiffFile_getOldSyntaxLine2(lineNumber) {
  var _a;
  return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileSyntaxLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getNewSyntaxLine = function _DiffFile_getNewSyntaxLine2(lineNumber) {
  var _a;
  return (_a = __classPrivateFieldGet(this, _DiffFile_newFileSyntaxLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
};
if (true) {
  Object.defineProperty(DiffFile.prototype, "__full_bundle__", {
    get: function() {
      return this._getFullBundle();
    }
  });
}
var DiffFileLineType;
(function(DiffFileLineType2) {
  DiffFileLineType2[DiffFileLineType2["hunk"] = 1] = "hunk";
  DiffFileLineType2[DiffFileLineType2["content"] = 2] = "content";
  DiffFileLineType2[DiffFileLineType2["widget"] = 3] = "widget";
  DiffFileLineType2[DiffFileLineType2["extend"] = 4] = "extend";
})(DiffFileLineType || (DiffFileLineType = {}));
var SplitSide;
(function(SplitSide2) {
  SplitSide2[SplitSide2["old"] = 1] = "old";
  SplitSide2[SplitSide2["new"] = 2] = "new";
})(SplitSide || (SplitSide = {}));
var getSplitLines = (diffFile) => {
  const splitLineLength = diffFile.splitLineLength;
  const splitLines = [];
  numIterator(splitLineLength, (index) => {
    splitLines.push({ type: DiffFileLineType.hunk, index, lineNumber: index + 1 });
    splitLines.push({
      type: DiffFileLineType.content,
      index,
      lineNumber: index + 1
    });
    splitLines.push({ type: DiffFileLineType.widget, index, lineNumber: index + 1 });
    splitLines.push({ type: DiffFileLineType.extend, index, lineNumber: index + 1 });
  });
  return splitLines;
};
var getSplitContentLines = (diffFile) => {
  const splitLineLength = diffFile.splitLineLength;
  const splitLines = [];
  numIterator(splitLineLength, (index) => {
    const splitLeftLine = diffFile.getSplitLeftLine(index);
    const splitRightLine = diffFile.getSplitRightLine(index);
    if (!(splitLeftLine === null || splitLeftLine === void 0 ? void 0 : splitLeftLine.isHidden) && !(splitRightLine === null || splitRightLine === void 0 ? void 0 : splitRightLine.isHidden)) {
      {
        splitLines.push({
          type: DiffFileLineType.content,
          index,
          lineNumber: index + 1,
          splitLine: { left: splitLeftLine, right: splitRightLine }
        });
      }
    }
  });
  return splitLines;
};
var getUnifiedLines = (diffFile) => {
  const unifiedLineLength = diffFile.unifiedLineLength;
  const unifiedLines = [];
  numIterator(unifiedLineLength, (index) => {
    unifiedLines.push({ type: DiffFileLineType.hunk, index, lineNumber: index + 1 });
    unifiedLines.push({ type: DiffFileLineType.content, index, lineNumber: index + 1 });
    unifiedLines.push({ type: DiffFileLineType.widget, index, lineNumber: index + 1 });
    unifiedLines.push({ type: DiffFileLineType.extend, index, lineNumber: index + 1 });
  });
  return unifiedLines;
};
var getUnifiedContentLine = (diffFile) => {
  const unifiedLineLength = diffFile.unifiedLineLength;
  const unifiedLines = [];
  numIterator(unifiedLineLength, (index) => {
    const unifiedLine = diffFile.getUnifiedLine(index);
    if (!unifiedLine.isHidden) {
      unifiedLines.push({ type: DiffFileLineType.content, index, lineNumber: index + 1, unifiedLine });
    }
  });
  return unifiedLines;
};
var checkCurrentLineIsHidden = (diffFile, lineNumber, side) => {
  const splitLine = diffFile.getSplitLineByLineNumber(lineNumber, side);
  const unifiedLine = diffFile.getUnifiedLineByLineNumber(lineNumber, side);
  return {
    split: !splitLine || splitLine.isHidden,
    unified: !unifiedLine || unifiedLine.isHidden
  };
};
var versions = "0.0.30";

export {
  processAST,
  _getAST,
  highlighter,
  DiffHunkExpansionType,
  DiffHunk,
  DiffHunkHeader,
  relativeChanges,
  diffChanges,
  DiffLineType,
  DiffLine,
  checkDiffLineIncludeChange,
  escapeHtml,
  setTransformForTemplateContent,
  setTransformForFile,
  resetTransform,
  isTransformEnabled,
  processTransformTemplateContent,
  processTransformForFile,
  getPlainDiffTemplate,
  getSyntaxDiffTemplate,
  getSyntaxLineTemplate,
  getPlainLineTemplate,
  DefaultDiffExpansionStep,
  assertNever,
  getLargestLineNumber,
  getHunkHeaderExpansionType,
  numIterator,
  getLang,
  getDiffRange,
  HiddenBidiCharsRegex,
  DiffParser,
  parseInstance,
  File,
  getFile,
  _cacheMap,
  disableCache,
  composeLen,
  getCurrentComposeLength,
  changeDefaultComposeLength,
  resetDefaultComposeLength,
  DiffFile,
  DiffFileLineType,
  SplitSide,
  getSplitLines,
  getSplitContentLines,
  getUnifiedLines,
  getUnifiedContentLine,
  checkCurrentLineIsHidden,
  versions
};
//# sourceMappingURL=chunk-ISULB72G.js.map
