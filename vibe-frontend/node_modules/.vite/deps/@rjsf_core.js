import {
  ADDITIONAL_PROPERTY_FLAG,
  ANY_OF_KEY,
  CONST_KEY,
  DEFAULT_ID_PREFIX,
  DEFAULT_ID_SEPARATOR,
  DEFAULT_KEY,
  DateElement,
  ERRORS_KEY,
  ErrorSchemaBuilder,
  ID_KEY,
  ITEMS_KEY,
  NAME_KEY,
  ONE_OF_KEY,
  PROPERTIES_KEY,
  READONLY_KEY,
  REF_KEY,
  RJSF_ADDITIONAL_PROPERTIES_FLAG,
  SUBMIT_BTN_OPTIONS_KEY,
  SetCache_default,
  TranslatableString,
  UI_GLOBAL_OPTIONS_KEY,
  UI_OPTIONS_KEY,
  allowAdditionalItems,
  ariaDescribedByIds,
  arrayIncludesWith_default,
  arrayIncludes_default,
  arrayMap_default,
  asNumber,
  baseIndexOf_default,
  basePickBy_default,
  baseRest_default,
  baseUnary_default,
  baseUnset_default,
  buttonId,
  cacheHas_default,
  canExpand,
  cloneDeep_default,
  createSchemaUtils,
  deepEquals,
  descriptionId,
  englishStringTranslator,
  enumOptionsDeselectValue,
  enumOptionsIndexForValue,
  enumOptionsIsSelected,
  enumOptionsSelectValue,
  enumOptionsValueForIndex,
  errorId,
  examplesId,
  flatRest_default,
  flatten_default,
  forEach_default,
  getChangedFields,
  getDiscriminatorFieldFromSchema,
  getInputProps,
  getSchemaType,
  getSubmitButtonOptions,
  getTemplate,
  getTestIds,
  getUiOptions,
  getWidget,
  get_default,
  hasIn_default,
  hasWidget,
  has_default,
  hashObject,
  helpId,
  isArrayLikeObject_default,
  isArrayLike_default,
  isCustomWidget,
  isEmpty_default,
  isEqual_default,
  isFixedItems,
  isFormDataAvailable,
  isFunction_default,
  isObject,
  isObject_default,
  isPlainObject_default,
  isString_default,
  keys_default,
  labelValue,
  last_default,
  lib_default,
  localToUTC,
  lookupFromFormContext,
  mergeObjects,
  mergeSchemas,
  noop_default,
  omit_default,
  optionId,
  optionalControlsId,
  optionsList,
  orderProperties,
  schemaRequiresTrueValue,
  set_default,
  shouldRender,
  shouldRenderOptionalField,
  titleId,
  toErrorList,
  toFieldPathId,
  toInteger_default,
  toPath_default,
  uniqueId_default,
  useAltDateWidgetProps,
  useDeepCompareMemo,
  useFileWidgetProps,
  utcToLocal,
  validationDataMerge
} from "./chunk-RBCYY6PA.js";
import {
  require_jsx_runtime
} from "./chunk-7BUGFXDR.js";
import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __publicField,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@rjsf/core/lib/components/Form.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);

// node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value, path) {
    return hasIn_default(object, path);
  });
}
var basePick_default = basePick;

// node_modules/lodash-es/pick.js
var pick = flatRest_default(function(object, paths) {
  return object == null ? {} : basePick_default(object, paths);
});
var pick_default = pick;

// node_modules/lodash-es/unset.js
function unset(object, path) {
  return object == null ? true : baseUnset_default(object, path);
}
var unset_default = unset;

// node_modules/@rjsf/core/lib/components/fields/ArrayField.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
function generateRowId() {
  return uniqueId_default("rjsf-array-item-");
}
function generateKeyedFormData(formData) {
  return !Array.isArray(formData) ? [] : formData.map((item) => {
    return {
      key: generateRowId(),
      item
    };
  });
}
function keyedToPlainFormData(keyedFormData) {
  if (Array.isArray(keyedFormData)) {
    return keyedFormData.map((keyedItem) => keyedItem.item);
  }
  return [];
}
function isItemRequired(itemSchema) {
  if (Array.isArray(itemSchema.type)) {
    return !itemSchema.type.includes("null");
  }
  return itemSchema.type !== "null";
}
function canAddItem(registry, schema, formItems, uiSchema) {
  let { addable } = getUiOptions(uiSchema, registry.globalUiOptions);
  if (addable !== false) {
    if (schema.maxItems !== void 0) {
      addable = formItems.length < schema.maxItems;
    } else {
      addable = true;
    }
  }
  return addable;
}
function computeItemUiSchema(uiSchema, item, index, formContext) {
  if (typeof uiSchema.items === "function") {
    try {
      const result = uiSchema.items(item, index, formContext);
      return result;
    } catch (e2) {
      console.error(`Error executing dynamic uiSchema.items function for item at index ${index}:`, e2);
      return void 0;
    }
  } else {
    return uiSchema.items;
  }
}
function getNewFormDataRow(registry, schema) {
  const { schemaUtils, globalFormOptions } = registry;
  let itemSchema = schema.items;
  if (globalFormOptions.useFallbackUiForUnsupportedType && !itemSchema) {
    itemSchema = {};
  } else if (isFixedItems(schema) && allowAdditionalItems(schema)) {
    itemSchema = schema.additionalItems;
  }
  return schemaUtils.getDefaultFormState(itemSchema);
}
function ArrayAsMultiSelect(props) {
  const { schema, fieldPathId, uiSchema, formData: items = [], disabled = false, readonly = false, autofocus = false, required = false, placeholder, onBlur, onFocus, registry, rawErrors, name, onSelectChange } = props;
  const { widgets: widgets2, schemaUtils, globalFormOptions, globalUiOptions } = registry;
  const itemsSchema = schemaUtils.retrieveSchema(schema.items, items);
  const enumOptions = optionsList(itemsSchema, uiSchema);
  const { widget = "select", title: uiTitle, ...options } = getUiOptions(uiSchema, globalUiOptions);
  const Widget = getWidget(schema, widget, widgets2);
  const label = uiTitle ?? schema.title ?? name;
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const multiValueFieldPathId = useDeepCompareMemo(toFieldPathId("", globalFormOptions, fieldPathId, true));
  return (0, import_jsx_runtime.jsx)(Widget, { id: multiValueFieldPathId[ID_KEY], name, multiple: true, onChange: onSelectChange, onBlur, onFocus, options: { ...options, enumOptions }, schema, uiSchema, registry, value: items, disabled, readonly, required, label, hideLabel: !displayLabel, placeholder, autofocus, rawErrors, htmlName: multiValueFieldPathId.name });
}
function ArrayAsCustomWidget(props) {
  const { schema, fieldPathId, uiSchema, disabled = false, readonly = false, autofocus = false, required = false, hideError, placeholder, onBlur, onFocus, formData: items = [], registry, rawErrors, name, onSelectChange } = props;
  const { widgets: widgets2, schemaUtils, globalFormOptions, globalUiOptions } = registry;
  const { widget, title: uiTitle, ...options } = getUiOptions(uiSchema, globalUiOptions);
  const Widget = getWidget(schema, widget, widgets2);
  const label = uiTitle ?? schema.title ?? name;
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const multiValueFieldPathId = useDeepCompareMemo(toFieldPathId("", globalFormOptions, fieldPathId, true));
  return (0, import_jsx_runtime.jsx)(Widget, { id: multiValueFieldPathId[ID_KEY], name, multiple: true, onChange: onSelectChange, onBlur, onFocus, options, schema, uiSchema, registry, value: items, disabled, readonly, hideError, required, label, hideLabel: !displayLabel, placeholder, autofocus, rawErrors, htmlName: multiValueFieldPathId.name });
}
function ArrayAsFiles(props) {
  const { schema, uiSchema, fieldPathId, name, disabled = false, readonly = false, autofocus = false, required = false, onBlur, onFocus, registry, formData: items = [], rawErrors, onSelectChange } = props;
  const { widgets: widgets2, schemaUtils, globalFormOptions, globalUiOptions } = registry;
  const { widget = "files", title: uiTitle, ...options } = getUiOptions(uiSchema, globalUiOptions);
  const Widget = getWidget(schema, widget, widgets2);
  const label = uiTitle ?? schema.title ?? name;
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const multiValueFieldPathId = useDeepCompareMemo(toFieldPathId("", globalFormOptions, fieldPathId, true));
  return (0, import_jsx_runtime.jsx)(Widget, { options, id: multiValueFieldPathId[ID_KEY], name, multiple: true, onChange: onSelectChange, onBlur, onFocus, schema, uiSchema, value: items, disabled, readonly, required, registry, autofocus, rawErrors, label, hideLabel: !displayLabel, htmlName: multiValueFieldPathId.name });
}
function ArrayFieldItem(props) {
  const { itemKey, index, name, disabled, hideError, readonly, registry, uiOptions, parentUiSchema, canAdd, canRemove = true, canMoveUp, canMoveDown, itemSchema, itemData, itemUiSchema, itemFieldPathId, itemErrorSchema, autofocus, onBlur, onFocus, onChange, rawErrors, totalItems, title, handleAddItem, handleCopyItem, handleRemoveItem, handleReorderItems } = props;
  const { schemaUtils, fields: { ArraySchemaField, SchemaField: SchemaField2 }, globalUiOptions } = registry;
  const fieldPathId = useDeepCompareMemo(itemFieldPathId);
  const ItemSchemaField = ArraySchemaField || SchemaField2;
  const ArrayFieldItemTemplate2 = getTemplate("ArrayFieldItemTemplate", registry, uiOptions);
  const displayLabel = schemaUtils.getDisplayLabel(itemSchema, itemUiSchema, globalUiOptions);
  const { description } = getUiOptions(itemUiSchema);
  const hasDescription = !!description || !!itemSchema.description;
  const { orderable = true, removable = true, copyable = false } = uiOptions;
  const has = {
    moveUp: orderable && canMoveUp,
    moveDown: orderable && canMoveDown,
    copy: copyable && canAdd,
    remove: removable && canRemove,
    toolbar: false
  };
  has.toolbar = Object.keys(has).some((key) => has[key]);
  const onAddItem = (0, import_react.useCallback)((event) => {
    handleAddItem(event, index + 1);
  }, [handleAddItem, index]);
  const onCopyItem = (0, import_react.useCallback)((event) => {
    handleCopyItem(event, index);
  }, [handleCopyItem, index]);
  const onRemoveItem = (0, import_react.useCallback)((event) => {
    handleRemoveItem(event, index);
  }, [handleRemoveItem, index]);
  const onMoveUpItem = (0, import_react.useCallback)((event) => {
    handleReorderItems(event, index, index - 1);
  }, [handleReorderItems, index]);
  const onMoveDownItem = (0, import_react.useCallback)((event) => {
    handleReorderItems(event, index, index + 1);
  }, [handleReorderItems, index]);
  const templateProps = {
    children: (0, import_jsx_runtime.jsx)(ItemSchemaField, { name, title, index, schema: itemSchema, uiSchema: itemUiSchema, formData: itemData, errorSchema: itemErrorSchema, fieldPathId, required: isItemRequired(itemSchema), onChange, onBlur, onFocus, registry, disabled, readonly, hideError, autofocus, rawErrors }),
    buttonsProps: {
      fieldPathId,
      disabled,
      readonly,
      canAdd,
      hasCopy: has.copy,
      hasMoveUp: has.moveUp,
      hasMoveDown: has.moveDown,
      hasRemove: has.remove,
      index,
      totalItems,
      onAddItem,
      onCopyItem,
      onRemoveItem,
      onMoveUpItem,
      onMoveDownItem,
      registry,
      schema: itemSchema,
      uiSchema: itemUiSchema
    },
    itemKey,
    className: "rjsf-array-item",
    disabled,
    hasToolbar: has.toolbar,
    index,
    totalItems,
    readonly,
    registry,
    schema: itemSchema,
    uiSchema: itemUiSchema,
    parentUiSchema,
    displayLabel,
    hasDescription
  };
  return (0, import_jsx_runtime.jsx)(ArrayFieldItemTemplate2, { ...templateProps });
}
function NormalArray(props) {
  const { schema, uiSchema = {}, errorSchema, fieldPathId, formData: formDataFromProps, name, title, disabled = false, readonly = false, autofocus = false, required = false, hideError = false, registry, onBlur, onFocus, rawErrors, onChange, keyedFormData, handleAddItem, handleCopyItem, handleRemoveItem, handleReorderItems } = props;
  const fieldTitle = schema.title || title || name;
  const { schemaUtils, fields: fields2, formContext, globalFormOptions, globalUiOptions } = registry;
  const { OptionalDataControlsField: OptionalDataControlsField2 } = fields2;
  const uiOptions = getUiOptions(uiSchema, globalUiOptions);
  const _schemaItems = isObject_default(schema.items) ? schema.items : {};
  const itemsSchema = schemaUtils.retrieveSchema(_schemaItems);
  const formData = keyedToPlainFormData(keyedFormData);
  const renderOptionalField = shouldRenderOptionalField(registry, schema, required, uiSchema);
  const hasFormData = isFormDataAvailable(formDataFromProps);
  const canAdd = canAddItem(registry, schema, formData, uiSchema) && (!renderOptionalField || hasFormData);
  const actualFormData = hasFormData ? keyedFormData : [];
  const extraClass = renderOptionalField ? " rjsf-optional-array-field" : "";
  const childFieldPathId = props.childFieldPathId ?? fieldPathId;
  const optionalDataControl = renderOptionalField ? (0, import_jsx_runtime.jsx)(OptionalDataControlsField2, { ...props, fieldPathId: childFieldPathId }) : void 0;
  const arrayProps = {
    canAdd,
    items: actualFormData.map((keyedItem, index) => {
      const { key, item } = keyedItem;
      const itemCast = item;
      const itemSchema = schemaUtils.retrieveSchema(_schemaItems, itemCast);
      const itemErrorSchema = errorSchema ? errorSchema[index] : void 0;
      const itemFieldPathId = toFieldPathId(index, globalFormOptions, childFieldPathId);
      const itemUiSchema = computeItemUiSchema(uiSchema, item, index, formContext);
      const itemProps = {
        itemKey: key,
        index,
        name: name && `${name}-${index}`,
        registry,
        uiOptions,
        hideError,
        readonly,
        disabled,
        required,
        title: fieldTitle ? `${fieldTitle}-${index + 1}` : void 0,
        canAdd,
        canMoveUp: index > 0,
        canMoveDown: index < formData.length - 1,
        itemSchema,
        itemFieldPathId,
        itemErrorSchema,
        itemData: itemCast,
        itemUiSchema,
        autofocus: autofocus && index === 0,
        onBlur,
        onFocus,
        rawErrors,
        totalItems: keyedFormData.length,
        handleAddItem,
        handleCopyItem,
        handleRemoveItem,
        handleReorderItems,
        onChange
      };
      return (0, import_jsx_runtime.jsx)(ArrayFieldItem, { ...itemProps }, key);
    }),
    className: `rjsf-field rjsf-field-array rjsf-field-array-of-${itemsSchema.type}${extraClass}`,
    disabled,
    fieldPathId,
    uiSchema,
    onAddClick: handleAddItem,
    readonly,
    required,
    schema,
    title: fieldTitle,
    formData,
    rawErrors,
    registry,
    optionalDataControl
  };
  const Template = getTemplate("ArrayFieldTemplate", registry, uiOptions);
  return (0, import_jsx_runtime.jsx)(Template, { ...arrayProps });
}
function FixedArray(props) {
  const { schema, uiSchema = {}, formData, errorSchema, fieldPathId, name, title, disabled = false, readonly = false, autofocus = false, required = false, hideError = false, registry, onBlur, onFocus, rawErrors, keyedFormData, onChange, handleAddItem, handleCopyItem, handleRemoveItem, handleReorderItems } = props;
  let { formData: items = [] } = props;
  const fieldTitle = schema.title || title || name;
  const { schemaUtils, fields: fields2, formContext, globalFormOptions, globalUiOptions } = registry;
  const uiOptions = getUiOptions(uiSchema, globalUiOptions);
  const { OptionalDataControlsField: OptionalDataControlsField2 } = fields2;
  const renderOptionalField = shouldRenderOptionalField(registry, schema, required, uiSchema);
  const hasFormData = isFormDataAvailable(formData);
  const _schemaItems = isObject_default(schema.items) ? schema.items : [];
  const itemSchemas = _schemaItems.map((item, index) => schemaUtils.retrieveSchema(item, items[index]));
  const additionalSchema = isObject_default(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, formData) : null;
  const childFieldPathId = props.childFieldPathId ?? fieldPathId;
  if (items.length < itemSchemas.length) {
    items = items.concat(new Array(itemSchemas.length - items.length));
  }
  const actualFormData = hasFormData ? keyedFormData : [];
  const extraClass = renderOptionalField ? " rjsf-optional-array-field" : "";
  const optionalDataControl = renderOptionalField ? (0, import_jsx_runtime.jsx)(OptionalDataControlsField2, { ...props, fieldPathId: childFieldPathId }) : void 0;
  const canAdd = canAddItem(registry, schema, items, uiSchema) && !!additionalSchema && (!renderOptionalField || hasFormData);
  const arrayProps = {
    canAdd,
    className: `rjsf-field rjsf-field-array rjsf-field-array-fixed-items${extraClass}`,
    disabled,
    fieldPathId,
    formData,
    items: actualFormData.map((keyedItem, index) => {
      const { key, item } = keyedItem;
      const itemCast = item;
      const additional = index >= itemSchemas.length;
      const itemSchema = (additional && isObject_default(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, itemCast) : itemSchemas[index]) || {};
      const itemFieldPathId = toFieldPathId(index, globalFormOptions, childFieldPathId);
      let itemUiSchema;
      if (additional) {
        itemUiSchema = uiSchema.additionalItems;
      } else {
        if (Array.isArray(uiSchema.items)) {
          itemUiSchema = uiSchema.items[index];
        } else {
          itemUiSchema = computeItemUiSchema(uiSchema, item, index, formContext);
        }
      }
      const itemErrorSchema = errorSchema ? errorSchema[index] : void 0;
      const itemProps = {
        index,
        itemKey: key,
        name: name && `${name}-${index}`,
        registry,
        uiOptions,
        hideError,
        readonly,
        disabled,
        required,
        title: fieldTitle ? `${fieldTitle}-${index + 1}` : void 0,
        canAdd,
        canRemove: additional,
        canMoveUp: index >= itemSchemas.length + 1,
        canMoveDown: additional && index < items.length - 1,
        itemSchema,
        itemData: itemCast,
        itemUiSchema,
        itemFieldPathId,
        itemErrorSchema,
        autofocus: autofocus && index === 0,
        onBlur,
        onFocus,
        rawErrors,
        totalItems: keyedFormData.length,
        onChange,
        handleAddItem,
        handleCopyItem,
        handleRemoveItem,
        handleReorderItems
      };
      return (0, import_jsx_runtime.jsx)(ArrayFieldItem, { ...itemProps }, key);
    }),
    onAddClick: handleAddItem,
    readonly,
    required,
    registry,
    schema,
    uiSchema,
    title: fieldTitle,
    errorSchema,
    rawErrors,
    optionalDataControl
  };
  const Template = getTemplate("ArrayFieldTemplate", registry, uiOptions);
  return (0, import_jsx_runtime.jsx)(Template, { ...arrayProps });
}
function useKeyedFormData(formData = []) {
  const newHash = (0, import_react.useMemo)(() => hashObject(formData), [formData]);
  const [state, setState] = (0, import_react.useState)(() => ({
    formDataHash: newHash,
    keyedFormData: generateKeyedFormData(formData)
  }));
  let { keyedFormData, formDataHash } = state;
  if (newHash !== formDataHash) {
    const nextFormData = Array.isArray(formData) ? formData : [];
    const previousKeyedFormData = keyedFormData || [];
    keyedFormData = nextFormData.length === previousKeyedFormData.length ? previousKeyedFormData.map((previousKeyedFormDatum, index) => ({
      key: previousKeyedFormDatum.key,
      item: nextFormData[index]
    })) : generateKeyedFormData(nextFormData);
    formDataHash = newHash;
    setState({ formDataHash, keyedFormData });
  }
  const updateKeyedFormData = (0, import_react.useCallback)((newData) => {
    const plainFormData = keyedToPlainFormData(newData);
    const newHash2 = hashObject(plainFormData);
    setState({ formDataHash: newHash2, keyedFormData: newData });
    return plainFormData;
  }, []);
  return { keyedFormData, updateKeyedFormData };
}
function ArrayField(props) {
  const { schema, uiSchema, errorSchema, fieldPathId, registry, formData, onChange } = props;
  const { globalFormOptions, schemaUtils, translateString } = registry;
  const { keyedFormData, updateKeyedFormData } = useKeyedFormData(formData);
  const childFieldPathId = props.childFieldPathId ?? fieldPathId;
  const handleAddItem = (0, import_react.useCallback)((event, index) => {
    if (event) {
      event.preventDefault();
    }
    let newErrorSchema;
    if (errorSchema) {
      newErrorSchema = {};
      for (const idx in errorSchema) {
        const i2 = parseInt(idx);
        if (index === void 0 || i2 < index) {
          set_default(newErrorSchema, [i2], errorSchema[idx]);
        } else if (i2 >= index) {
          set_default(newErrorSchema, [i2 + 1], errorSchema[idx]);
        }
      }
    }
    const newKeyedFormDataRow = {
      key: generateRowId(),
      item: getNewFormDataRow(registry, schema)
    };
    const newKeyedFormData = [...keyedFormData];
    if (index !== void 0) {
      newKeyedFormData.splice(index, 0, newKeyedFormDataRow);
    } else {
      newKeyedFormData.push(newKeyedFormDataRow);
    }
    onChange(updateKeyedFormData(newKeyedFormData), childFieldPathId.path, newErrorSchema);
  }, [keyedFormData, registry, schema, onChange, updateKeyedFormData, errorSchema, childFieldPathId]);
  const handleCopyItem = (0, import_react.useCallback)((event, index) => {
    if (event) {
      event.preventDefault();
    }
    let newErrorSchema;
    if (errorSchema) {
      newErrorSchema = {};
      for (const idx in errorSchema) {
        const i2 = parseInt(idx);
        if (i2 <= index) {
          set_default(newErrorSchema, [i2], errorSchema[idx]);
        } else if (i2 > index) {
          set_default(newErrorSchema, [i2 + 1], errorSchema[idx]);
        }
      }
    }
    const newKeyedFormDataRow = {
      key: generateRowId(),
      item: cloneDeep_default(keyedFormData[index].item)
    };
    const newKeyedFormData = [...keyedFormData];
    if (index !== void 0) {
      newKeyedFormData.splice(index + 1, 0, newKeyedFormDataRow);
    } else {
      newKeyedFormData.push(newKeyedFormDataRow);
    }
    onChange(updateKeyedFormData(newKeyedFormData), childFieldPathId.path, newErrorSchema);
  }, [keyedFormData, onChange, updateKeyedFormData, errorSchema, childFieldPathId]);
  const handleRemoveItem = (0, import_react.useCallback)((event, index) => {
    if (event) {
      event.preventDefault();
    }
    let newErrorSchema;
    if (errorSchema) {
      newErrorSchema = {};
      for (const idx in errorSchema) {
        const i2 = parseInt(idx);
        if (i2 < index) {
          set_default(newErrorSchema, [i2], errorSchema[idx]);
        } else if (i2 > index) {
          set_default(newErrorSchema, [i2 - 1], errorSchema[idx]);
        }
      }
    }
    const newKeyedFormData = keyedFormData.filter((_2, i2) => i2 !== index);
    onChange(updateKeyedFormData(newKeyedFormData), childFieldPathId.path, newErrorSchema);
  }, [keyedFormData, onChange, updateKeyedFormData, errorSchema, childFieldPathId]);
  const handleReorderItems = (0, import_react.useCallback)((event, index, newIndex) => {
    if (event) {
      event.preventDefault();
      event.currentTarget.blur();
    }
    let newErrorSchema;
    if (errorSchema) {
      newErrorSchema = {};
      for (const idx in errorSchema) {
        const i2 = parseInt(idx);
        if (i2 == index) {
          set_default(newErrorSchema, [newIndex], errorSchema[index]);
        } else if (i2 == newIndex) {
          set_default(newErrorSchema, [index], errorSchema[newIndex]);
        } else {
          set_default(newErrorSchema, [idx], errorSchema[i2]);
        }
      }
    }
    function reOrderArray() {
      const _newKeyedFormData = keyedFormData.slice();
      _newKeyedFormData.splice(index, 1);
      _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);
      return _newKeyedFormData;
    }
    const newKeyedFormData = reOrderArray();
    onChange(updateKeyedFormData(newKeyedFormData), childFieldPathId.path, newErrorSchema);
  }, [keyedFormData, onChange, updateKeyedFormData, errorSchema, childFieldPathId]);
  const handleChange = (0, import_react.useCallback)((value, path, newErrorSchema, id) => {
    onChange(
      // We need to treat undefined items as nulls to have validation.
      // See https://github.com/tdegrunt/jsonschema/issues/206
      value === void 0 ? null : value,
      path,
      newErrorSchema,
      id
    );
  }, [onChange]);
  const onSelectChange = (0, import_react.useCallback)((value) => {
    onChange(value, childFieldPathId.path, void 0, childFieldPathId == null ? void 0 : childFieldPathId[ID_KEY]);
  }, [onChange, childFieldPathId]);
  const arrayAsMultiProps = {
    ...props,
    formData,
    fieldPathId: childFieldPathId,
    onSelectChange
  };
  const arrayProps = {
    ...props,
    handleAddItem,
    handleCopyItem,
    handleRemoveItem,
    handleReorderItems,
    keyedFormData,
    onChange: handleChange
  };
  if (!(ITEMS_KEY in schema)) {
    if (!globalFormOptions.useFallbackUiForUnsupportedType) {
      const uiOptions = getUiOptions(uiSchema);
      const UnsupportedFieldTemplate = getTemplate("UnsupportedFieldTemplate", registry, uiOptions);
      return (0, import_jsx_runtime.jsx)(UnsupportedFieldTemplate, { schema, fieldPathId, reason: translateString(TranslatableString.MissingItems), registry });
    }
    const fallbackSchema = { ...schema, [ITEMS_KEY]: { type: void 0 } };
    arrayAsMultiProps.schema = fallbackSchema;
    arrayProps.schema = fallbackSchema;
  }
  if (schemaUtils.isMultiSelect(arrayAsMultiProps.schema)) {
    return (0, import_jsx_runtime.jsx)(ArrayAsMultiSelect, { ...arrayAsMultiProps });
  }
  if (isCustomWidget(uiSchema)) {
    return (0, import_jsx_runtime.jsx)(ArrayAsCustomWidget, { ...arrayAsMultiProps });
  }
  if (isFixedItems(arrayAsMultiProps.schema)) {
    return (0, import_jsx_runtime.jsx)(FixedArray, { ...arrayProps });
  }
  if (schemaUtils.isFilesArray(arrayAsMultiProps.schema, uiSchema)) {
    return (0, import_jsx_runtime.jsx)(ArrayAsFiles, { ...arrayAsMultiProps });
  }
  return (0, import_jsx_runtime.jsx)(NormalArray, { ...arrayProps });
}

// node_modules/@rjsf/core/lib/components/fields/BooleanField.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
function BooleanField(props) {
  const { schema, name, uiSchema, fieldPathId, formData, registry, required, disabled, readonly, hideError, autofocus, title, onChange, onFocus, onBlur, rawErrors } = props;
  const { title: schemaTitle } = schema;
  const { widgets: widgets2, translateString, globalUiOptions } = registry;
  const {
    widget = "checkbox",
    title: uiTitle,
    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
    label: displayLabel = true,
    enumNames,
    ...options
  } = getUiOptions(uiSchema, globalUiOptions);
  const Widget = getWidget(schema, widget, widgets2);
  const yes = translateString(TranslatableString.YesLabel);
  const no = translateString(TranslatableString.NoLabel);
  let enumOptions;
  const label = uiTitle ?? schemaTitle ?? title ?? name;
  if (Array.isArray(schema.oneOf)) {
    enumOptions = optionsList({
      oneOf: schema.oneOf.map((option) => {
        if (isObject_default(option)) {
          return {
            ...option,
            title: option.title || (option.const === true ? yes : no)
          };
        }
        return void 0;
      }).filter((o2) => o2)
      // cast away the error that typescript can't grok is fixed
    }, uiSchema);
  } else {
    const enums = schema.enum ?? [true, false];
    if (!enumNames && enums.length === 2 && enums.every((v2) => typeof v2 === "boolean")) {
      enumOptions = [
        {
          value: enums[0],
          label: enums[0] ? yes : no
        },
        {
          value: enums[1],
          label: enums[1] ? yes : no
        }
      ];
    } else {
      enumOptions = optionsList({ enum: enums }, uiSchema);
    }
  }
  const onWidgetChange = (0, import_react2.useCallback)((value, errorSchema, id) => {
    return onChange(value, fieldPathId.path, errorSchema, id);
  }, [onChange, fieldPathId]);
  return (0, import_jsx_runtime2.jsx)(Widget, { options: { ...options, enumOptions }, schema, uiSchema, id: fieldPathId.$id, name, onChange: onWidgetChange, onFocus, onBlur, label, hideLabel: !displayLabel, value: formData, required, disabled, readonly, hideError, registry, autofocus, rawErrors, htmlName: fieldPathId.name });
}
var BooleanField_default = BooleanField;

// node_modules/@rjsf/core/lib/components/fields/FallbackField.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
function getFallbackTypeSelectionSchema(title) {
  return {
    type: "string",
    enum: ["string", "number", "boolean", "object", "array"],
    default: "string",
    title
  };
}
function getTypeOfFormData(formData) {
  const dataType = typeof formData;
  if (dataType === "string" || dataType === "number" || dataType === "boolean") {
    return dataType;
  }
  if (dataType === "object") {
    return Array.isArray(formData) ? "array" : "object";
  }
  return "string";
}
function castToNewType(formData, newType) {
  switch (newType) {
    case "string":
      return String(formData);
    case "number": {
      const castedNumber = Number(formData);
      return isNaN(castedNumber) ? 0 : castedNumber;
    }
    case "boolean":
      return Boolean(formData);
    default:
      return formData;
  }
}
function FallbackField(props) {
  const { id, formData, displayLabel = true, schema, name, uiSchema, required, disabled = false, readonly = false, onBlur, onFocus, registry, fieldPathId, onChange, errorSchema } = props;
  const { translateString, fields: fields2, globalFormOptions } = registry;
  const [type, setType] = (0, import_react3.useState)(getTypeOfFormData(formData));
  const uiOptions = getUiOptions(uiSchema);
  const typeSelectorInnerFieldPathId = useDeepCompareMemo(toFieldPathId("__internal_type_selector", globalFormOptions, fieldPathId));
  const schemaTitle = translateString(TranslatableString.Type);
  const typesOptionSchema = (0, import_react3.useMemo)(() => getFallbackTypeSelectionSchema(schemaTitle), [schemaTitle]);
  const onTypeChange = (newType) => {
    if (newType != null) {
      setType(newType);
      onChange(castToNewType(formData, newType), fieldPathId.path, errorSchema, id);
    }
  };
  if (!globalFormOptions.useFallbackUiForUnsupportedType) {
    const { reason = translateString(TranslatableString.UnknownFieldType, [String(schema.type)]) } = props;
    const UnsupportedFieldTemplate = getTemplate("UnsupportedFieldTemplate", registry, uiOptions);
    return (0, import_jsx_runtime3.jsx)(UnsupportedFieldTemplate, { schema, fieldPathId, reason, registry });
  }
  const FallbackFieldTemplate2 = getTemplate("FallbackFieldTemplate", registry, uiOptions);
  const { SchemaField: SchemaField2 } = fields2;
  return (0, import_jsx_runtime3.jsx)(FallbackFieldTemplate2, { schema, registry, typeSelector: (0, import_jsx_runtime3.jsx)(SchemaField2, { fieldPathId: typeSelectorInnerFieldPathId, name: `${name}__fallback_type`, schema: typesOptionSchema, formData: type, onChange: onTypeChange, onBlur, onFocus, registry, hideLabel: !displayLabel, disabled, readonly, required }, formData ? hashObject(formData) : "__empty__"), schemaField: (0, import_jsx_runtime3.jsx)(SchemaField2, { ...props, schema: {
    type,
    title: translateString(TranslatableString.Value),
    ...type === "object" && { additionalProperties: true }
  } }) });
}

// node_modules/@rjsf/core/lib/components/fields/LayoutGridField.js
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default = values;

// node_modules/lodash-es/includes.js
var nativeMax = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin = Math.min;
function baseIntersection(arrays, iteratee, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap_default(array, baseUnary_default(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache_default(othIndex && array) : void 0;
  }
  array = arrays[0];
  var index = -1, seen = caches[0];
  outer:
    while (++index < length && result.length < maxLength) {
      var value = array[index], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas_default(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value) {
  return isArrayLikeObject_default(value) ? value : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersection.js
var intersection = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection;

// node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined;

// node_modules/@rjsf/core/lib/components/fields/LayoutGridField.js
var GridType;
(function(GridType2) {
  GridType2["ROW"] = "ui:row";
  GridType2["COLUMN"] = "ui:col";
  GridType2["COLUMNS"] = "ui:columns";
  GridType2["CONDITION"] = "ui:condition";
})(GridType || (GridType = {}));
var Operators;
(function(Operators2) {
  Operators2["ALL"] = "all";
  Operators2["SOME"] = "some";
  Operators2["NONE"] = "none";
})(Operators || (Operators = {}));
var LOOKUP_REGEX = /^\$lookup=(.+)/;
var LAYOUT_GRID_UI_OPTION = "layoutGrid";
var LAYOUT_GRID_OPTION = `ui:${LAYOUT_GRID_UI_OPTION}`;
function getNonNullishValue(value, fallback) {
  return value ?? fallback;
}
function isNumericIndex(str) {
  return /^\d+?$/.test(str);
}
var LAYOUT_GRID_FIELD_TEST_IDS = getTestIds();
function computeFieldUiSchema(field, uiProps, uiSchema, schemaReadonly, forceReadonly) {
  const globalUiOptions = get_default(uiSchema, [UI_GLOBAL_OPTIONS_KEY], {});
  const localUiSchema = get_default(uiSchema, field);
  const localUiOptions = { ...get_default(localUiSchema, [UI_OPTIONS_KEY], {}), ...uiProps, ...globalUiOptions };
  const fieldUiSchema = { ...localUiSchema };
  if (!isEmpty_default(localUiOptions)) {
    set_default(fieldUiSchema, [UI_OPTIONS_KEY], localUiOptions);
  }
  if (!isEmpty_default(globalUiOptions)) {
    set_default(fieldUiSchema, [UI_GLOBAL_OPTIONS_KEY], globalUiOptions);
  }
  let { readonly: uiReadonly } = getUiOptions(fieldUiSchema);
  if (forceReadonly === true || isUndefined_default(uiReadonly) && schemaReadonly === true) {
    uiReadonly = true;
    if (has_default(localUiOptions, READONLY_KEY)) {
      set_default(fieldUiSchema, [UI_OPTIONS_KEY, READONLY_KEY], true);
    } else {
      set_default(fieldUiSchema, `ui:${READONLY_KEY}`, true);
    }
  }
  return { fieldUiSchema, uiReadonly };
}
function conditionMatches(operator, datum, value = "$0m3tH1nG Un3xP3cT3d") {
  const data = flatten_default([datum]).sort();
  const values2 = flatten_default([value]).sort();
  switch (operator) {
    case Operators.ALL:
      return isEqual_default(data, values2);
    case Operators.SOME:
      return intersection_default(data, values2).length > 0;
    case Operators.NONE:
      return intersection_default(data, values2).length === 0;
    default:
      return false;
  }
}
function findChildrenAndProps(layoutGridSchema, schemaKey, registry) {
  let gridProps = {};
  let children = layoutGridSchema[schemaKey];
  if (isPlainObject_default(children)) {
    const { children: elements, className: toMapClassNames, ...otherProps } = children;
    children = elements;
    if (toMapClassNames) {
      const classes = toMapClassNames.split(" ");
      const className = classes.map((ele) => lookupFromFormContext(registry, ele, ele)).join(" ");
      gridProps = { ...otherProps, className };
    } else {
      gridProps = otherProps;
    }
  }
  if (!Array.isArray(children)) {
    throw new TypeError(`Expected array for "${schemaKey}" in ${JSON.stringify(layoutGridSchema)}`);
  }
  return { children, gridProps };
}
function computeArraySchemasIfPresent(schema, fieldPathId, potentialIndex) {
  let rawSchema;
  if (isNumericIndex(potentialIndex) && schema && (schema == null ? void 0 : schema.type) === "array" && has_default(schema, ITEMS_KEY)) {
    const index = Number(potentialIndex);
    const items = schema[ITEMS_KEY];
    if (Array.isArray(items)) {
      if (index > items.length) {
        rawSchema = last_default(items);
      } else {
        rawSchema = items[index];
      }
    } else {
      rawSchema = items;
    }
    fieldPathId = {
      [ID_KEY]: fieldPathId[ID_KEY],
      path: [...fieldPathId.path.slice(0, fieldPathId.path.length - 1), index]
    };
  }
  return { rawSchema, fieldPathId };
}
function getSchemaDetailsForField(registry, dottedPath, initialSchema, formData, initialFieldIdPath) {
  const { schemaUtils, globalFormOptions } = registry;
  let rawSchema = initialSchema;
  let fieldPathId = initialFieldIdPath;
  const parts = dottedPath.split(".");
  const leafPath = parts.pop();
  let schema = schemaUtils.retrieveSchema(rawSchema, formData);
  let innerData = formData;
  let isReadonly = schema.readOnly;
  parts.forEach((part) => {
    fieldPathId = toFieldPathId(part, globalFormOptions, fieldPathId);
    if (has_default(schema, PROPERTIES_KEY)) {
      rawSchema = get_default(schema, [PROPERTIES_KEY, part], {});
    } else if (schema && (has_default(schema, ONE_OF_KEY) || has_default(schema, ANY_OF_KEY))) {
      const xxx = has_default(schema, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;
      const selectedSchema = schemaUtils.findSelectedOptionInXxxOf(schema, part, xxx, innerData);
      rawSchema = get_default(selectedSchema, [PROPERTIES_KEY, part], {});
    } else {
      const result = computeArraySchemasIfPresent(schema, fieldPathId, part);
      rawSchema = result.rawSchema ?? {};
      fieldPathId = result.fieldPathId;
    }
    innerData = get_default(innerData, part, {});
    schema = schemaUtils.retrieveSchema(rawSchema, innerData);
    isReadonly = getNonNullishValue(schema.readOnly, isReadonly);
  });
  let optionsInfo;
  let isRequired2 = false;
  if (isEmpty_default(schema)) {
    schema = void 0;
  }
  if (schema && leafPath) {
    if (schema && (has_default(schema, ONE_OF_KEY) || has_default(schema, ANY_OF_KEY))) {
      const xxx = has_default(schema, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;
      schema = schemaUtils.findSelectedOptionInXxxOf(schema, leafPath, xxx, innerData);
    }
    fieldPathId = toFieldPathId(leafPath, globalFormOptions, fieldPathId);
    isRequired2 = schema !== void 0 && Array.isArray(schema.required) && includes_default(schema.required, leafPath);
    const result = computeArraySchemasIfPresent(schema, fieldPathId, leafPath);
    if (result.rawSchema) {
      schema = result.rawSchema;
      fieldPathId = result.fieldPathId;
    } else {
      schema = get_default(schema, [PROPERTIES_KEY, leafPath]);
      schema = schema ? schemaUtils.retrieveSchema(schema) : schema;
    }
    isReadonly = getNonNullishValue(schema == null ? void 0 : schema.readOnly, isReadonly);
    if (schema && (has_default(schema, ONE_OF_KEY) || has_default(schema, ANY_OF_KEY))) {
      const xxx = has_default(schema, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;
      const discriminator = getDiscriminatorFieldFromSchema(schema);
      optionsInfo = { options: schema[xxx], hasDiscriminator: !!discriminator };
    }
  }
  return { schema, isRequired: isRequired2, isReadonly, optionsInfo, fieldPathId };
}
function getCustomRenderComponent(render, registry) {
  let customRenderer = render;
  if (isString_default(customRenderer)) {
    customRenderer = lookupFromFormContext(registry, customRenderer);
  }
  if (isFunction_default(customRenderer)) {
    return customRenderer;
  }
  return null;
}
function computeUIComponentPropsFromGridSchema(registry, gridSchema) {
  let name;
  let UIComponent = null;
  let uiProps = {};
  let rendered;
  if (isString_default(gridSchema) || isUndefined_default(gridSchema)) {
    name = gridSchema ?? "";
  } else {
    const { name: innerName = "", render, ...innerProps } = gridSchema;
    name = innerName;
    uiProps = innerProps;
    if (!isEmpty_default(uiProps)) {
      forEach_default(uiProps, (prop, key) => {
        if (isString_default(prop)) {
          const match = LOOKUP_REGEX.exec(prop);
          if (Array.isArray(match) && match.length > 1) {
            const name2 = match[1];
            uiProps[key] = lookupFromFormContext(registry, name2, name2);
          }
        }
      });
    }
    UIComponent = getCustomRenderComponent(render, registry);
    if (!innerName && UIComponent) {
      rendered = (0, import_jsx_runtime4.jsx)(UIComponent, { ...innerProps, "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.uiComponent });
    }
  }
  return { name, UIComponent, uiProps, rendered };
}
function LayoutGridFieldChildren(props) {
  const { childrenLayoutGridSchemaId, ...layoutGridFieldProps } = props;
  const { registry, schema: rawSchema, formData } = layoutGridFieldProps;
  const { schemaUtils } = registry;
  const schema = schemaUtils.retrieveSchema(rawSchema, formData);
  return childrenLayoutGridSchemaId.map((layoutGridSchema) => (0, import_react4.createElement)(LayoutGridField, { ...layoutGridFieldProps, key: `layoutGrid-${hashObject(layoutGridSchema)}`, schema, layoutGridSchema }));
}
function LayoutGridCondition(props) {
  const { layoutGridSchema, ...layoutGridFieldProps } = props;
  const { formData, registry } = layoutGridFieldProps;
  const { children, gridProps } = findChildrenAndProps(layoutGridSchema, GridType.CONDITION, registry);
  const { operator, field = "", value } = gridProps;
  const fieldData = get_default(formData, field, null);
  if (conditionMatches(operator, fieldData, value)) {
    return (0, import_jsx_runtime4.jsx)(LayoutGridFieldChildren, { ...layoutGridFieldProps, childrenLayoutGridSchemaId: children });
  }
  return null;
}
function LayoutGridCol(props) {
  const { layoutGridSchema, ...layoutGridFieldProps } = props;
  const { registry, uiSchema } = layoutGridFieldProps;
  const { children, gridProps } = findChildrenAndProps(layoutGridSchema, GridType.COLUMN, registry);
  const uiOptions = getUiOptions(uiSchema);
  const GridTemplate2 = getTemplate("GridTemplate", registry, uiOptions);
  return (0, import_jsx_runtime4.jsx)(GridTemplate2, { column: true, "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.col, ...gridProps, children: (0, import_jsx_runtime4.jsx)(LayoutGridFieldChildren, { ...layoutGridFieldProps, childrenLayoutGridSchemaId: children }) });
}
function LayoutGridColumns(props) {
  const { layoutGridSchema, ...layoutGridFieldProps } = props;
  const { registry, uiSchema } = layoutGridFieldProps;
  const { children, gridProps } = findChildrenAndProps(layoutGridSchema, GridType.COLUMNS, registry);
  const uiOptions = getUiOptions(uiSchema);
  const GridTemplate2 = getTemplate("GridTemplate", registry, uiOptions);
  return children.map((child) => (0, import_jsx_runtime4.jsx)(GridTemplate2, { column: true, "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.col, ...gridProps, children: (0, import_jsx_runtime4.jsx)(LayoutGridFieldChildren, { ...layoutGridFieldProps, childrenLayoutGridSchemaId: [child] }) }, `column-${hashObject(child)}`));
}
function LayoutGridRow(props) {
  const { layoutGridSchema, ...layoutGridFieldProps } = props;
  const { registry, uiSchema } = layoutGridFieldProps;
  const { children, gridProps } = findChildrenAndProps(layoutGridSchema, GridType.ROW, registry);
  const uiOptions = getUiOptions(uiSchema);
  const GridTemplate2 = getTemplate("GridTemplate", registry, uiOptions);
  return (0, import_jsx_runtime4.jsx)(GridTemplate2, { ...gridProps, "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.row, children: (0, import_jsx_runtime4.jsx)(LayoutGridFieldChildren, { ...layoutGridFieldProps, childrenLayoutGridSchemaId: children }) });
}
function LayoutGridFieldComponent(props) {
  const {
    gridSchema,
    schema: initialSchema,
    uiSchema,
    errorSchema,
    fieldPathId,
    onBlur,
    onFocus,
    formData,
    readonly,
    registry,
    layoutGridSchema,
    // Used to pull this out of otherProps since we don't want to pass it through
    ...otherProps
  } = props;
  const { onChange } = otherProps;
  const { fields: fields2 } = registry;
  const { SchemaField: SchemaField2, LayoutMultiSchemaField: LayoutMultiSchemaField2 } = fields2;
  const uiComponentProps = computeUIComponentPropsFromGridSchema(registry, gridSchema);
  const { name, UIComponent, uiProps } = uiComponentProps;
  const { schema, isRequired: isRequired2, isReadonly, optionsInfo, fieldPathId: fieldIdSchema } = getSchemaDetailsForField(registry, name, initialSchema, formData, fieldPathId);
  const memoFieldPathId = useDeepCompareMemo(fieldIdSchema);
  if (uiComponentProps.rendered) {
    return uiComponentProps.rendered;
  }
  if (schema) {
    const Field = (optionsInfo == null ? void 0 : optionsInfo.hasDiscriminator) ? LayoutMultiSchemaField2 : SchemaField2;
    const { fieldUiSchema, uiReadonly } = computeFieldUiSchema(name, uiProps, uiSchema, isReadonly, readonly);
    return (0, import_jsx_runtime4.jsx)(Field, { "data-testid": (optionsInfo == null ? void 0 : optionsInfo.hasDiscriminator) ? LAYOUT_GRID_FIELD_TEST_IDS.layoutMultiSchemaField : LAYOUT_GRID_FIELD_TEST_IDS.field, ...otherProps, name, required: isRequired2, readonly: uiReadonly, schema, uiSchema: fieldUiSchema, errorSchema: get_default(errorSchema, name), fieldPathId: memoFieldPathId, formData: get_default(formData, name), onChange, onBlur, onFocus, options: optionsInfo == null ? void 0 : optionsInfo.options, registry });
  }
  if (UIComponent) {
    return (0, import_jsx_runtime4.jsx)(UIComponent, { "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.uiComponent, ...otherProps, name, required: isRequired2, formData, readOnly: !!isReadonly || readonly, errorSchema, uiSchema, schema: initialSchema, fieldPathId, onBlur, onFocus, registry, ...uiProps });
  }
  return null;
}
function LayoutGridField(props) {
  const { uiSchema } = props;
  let { layoutGridSchema } = props;
  const uiOptions = getUiOptions(uiSchema);
  if (!layoutGridSchema && LAYOUT_GRID_UI_OPTION in uiOptions && isObject_default(uiOptions[LAYOUT_GRID_UI_OPTION])) {
    layoutGridSchema = uiOptions[LAYOUT_GRID_UI_OPTION];
  }
  if (isObject_default(layoutGridSchema)) {
    if (GridType.ROW in layoutGridSchema) {
      return (0, import_jsx_runtime4.jsx)(LayoutGridRow, { ...props, layoutGridSchema });
    }
    if (GridType.COLUMN in layoutGridSchema) {
      return (0, import_jsx_runtime4.jsx)(LayoutGridCol, { ...props, layoutGridSchema });
    }
    if (GridType.COLUMNS in layoutGridSchema) {
      return (0, import_jsx_runtime4.jsx)(LayoutGridColumns, { ...props, layoutGridSchema });
    }
    if (GridType.CONDITION in layoutGridSchema) {
      return (0, import_jsx_runtime4.jsx)(LayoutGridCondition, { ...props, layoutGridSchema });
    }
  }
  return (0, import_jsx_runtime4.jsx)(LayoutGridFieldComponent, { ...props, gridSchema: layoutGridSchema });
}
LayoutGridField.TEST_IDS = LAYOUT_GRID_FIELD_TEST_IDS;

// node_modules/@rjsf/core/lib/components/fields/LayoutHeaderField.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function LayoutHeaderField(props) {
  const { fieldPathId, title, schema, uiSchema, required, registry, name } = props;
  const options = getUiOptions(uiSchema, registry.globalUiOptions);
  const { title: uiTitle } = options;
  const { title: schemaTitle } = schema;
  const fieldTitle = uiTitle || title || schemaTitle || name;
  if (!fieldTitle) {
    return null;
  }
  const TitleFieldTemplate = getTemplate("TitleFieldTemplate", registry, options);
  return (0, import_jsx_runtime5.jsx)(TitleFieldTemplate, { id: titleId(fieldPathId), title: fieldTitle, required, schema, uiSchema, registry });
}

// node_modules/@rjsf/core/lib/components/fields/LayoutMultiSchemaField.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
function getSelectedOption(options, selectorField, value) {
  const defaultValue = "!@#!@$@#$!@$#";
  const schemaOptions = options.map(({ schema }) => schema);
  return schemaOptions.find((option) => {
    const selector = get_default(option, [PROPERTIES_KEY, selectorField]);
    const result = get_default(selector, DEFAULT_KEY, get_default(selector, CONST_KEY, defaultValue));
    return result === value;
  });
}
function computeEnumOptions(schema, options, schemaUtils, uiSchema, formData) {
  const realOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
  let tempSchema = schema;
  if (has_default(schema, ONE_OF_KEY)) {
    tempSchema = { ...schema, [ONE_OF_KEY]: realOptions };
  } else if (has_default(schema, ANY_OF_KEY)) {
    tempSchema = { ...schema, [ANY_OF_KEY]: realOptions };
  }
  const enumOptions = optionsList(tempSchema, uiSchema);
  if (!enumOptions) {
    throw new Error(`No enumOptions were computed from the schema ${JSON.stringify(tempSchema)}`);
  }
  return enumOptions;
}
function LayoutMultiSchemaField(props) {
  var _a;
  const { name, baseType, disabled = false, formData, fieldPathId, onBlur, onChange, options, onFocus, registry, uiSchema, schema, autofocus, readonly, required, errorSchema, hideError = false } = props;
  const { widgets: widgets2, schemaUtils, globalUiOptions } = registry;
  const [enumOptions, setEnumOptions] = (0, import_react5.useState)(computeEnumOptions(schema, options, schemaUtils, uiSchema, formData));
  const id = get_default(fieldPathId, ID_KEY);
  const discriminator = getDiscriminatorFieldFromSchema(schema);
  const FieldErrorTemplate2 = getTemplate("FieldErrorTemplate", registry, options);
  const FieldTemplate2 = getTemplate("FieldTemplate", registry, options);
  const schemaHash = hashObject(schema);
  const optionsHash = hashObject(options);
  const uiSchemaHash = uiSchema ? hashObject(uiSchema) : "";
  const formDataHash = formData ? hashObject(formData) : "";
  (0, import_react5.useEffect)(() => {
    setEnumOptions(computeEnumOptions(schema, options, schemaUtils, uiSchema, formData));
  }, [schemaHash, optionsHash, schemaUtils, uiSchemaHash, formDataHash]);
  const { widget = discriminator ? "radio" : "select", title = "", placeholder = "", optionsSchemaSelector: selectorField = discriminator, hideError: uiSchemaHideError, ...uiOptions } = getUiOptions(uiSchema);
  if (!selectorField) {
    throw new Error("No selector field provided for the LayoutMultiSchemaField");
  }
  const selectedOption = get_default(formData, selectorField);
  let optionSchema = get_default((_a = enumOptions[0]) == null ? void 0 : _a.schema, [PROPERTIES_KEY, selectorField], {});
  const option = getSelectedOption(enumOptions, selectorField, selectedOption);
  optionSchema = (optionSchema == null ? void 0 : optionSchema.type) ? optionSchema : { ...optionSchema, type: (option == null ? void 0 : option.type) || baseType };
  const Widget = getWidget(optionSchema, widget, widgets2);
  const hideFieldError = uiSchemaHideError === void 0 ? hideError : Boolean(uiSchemaHideError);
  const rawErrors = get_default(errorSchema, [ERRORS_KEY], []);
  const fieldErrorSchema = omit_default(errorSchema, [ERRORS_KEY]);
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const onOptionChange = (opt) => {
    const newOption = getSelectedOption(enumOptions, selectorField, opt);
    const oldOption = getSelectedOption(enumOptions, selectorField, selectedOption);
    let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);
    if (newFormData && newOption) {
      newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, "excludeObjectChildren");
    }
    if (newFormData) {
      set_default(newFormData, selectorField, opt);
    }
    onChange(newFormData, fieldPathId.path, void 0, id);
  };
  const widgetOptions = { enumOptions, ...uiOptions };
  const errors = !hideFieldError && rawErrors.length > 0 ? (0, import_jsx_runtime6.jsx)(FieldErrorTemplate2, { fieldPathId, schema, errors: rawErrors, registry }) : void 0;
  return (0, import_jsx_runtime6.jsx)(FieldTemplate2, { id, schema, label: (title || schema.title) ?? "", disabled: disabled || Array.isArray(enumOptions) && isEmpty_default(enumOptions), uiSchema, required, readonly: !!readonly, registry, displayLabel, errors, onChange, onKeyRename: noop_default, onKeyRenameBlur: noop_default, onRemoveProperty: noop_default, children: (0, import_jsx_runtime6.jsx)(Widget, { id, name, schema, label: (title || schema.title) ?? "", disabled: disabled || Array.isArray(enumOptions) && isEmpty_default(enumOptions), uiSchema, autofocus, readonly, required, registry, multiple: false, rawErrors, hideError: hideFieldError, hideLabel: !displayLabel, errorSchema: fieldErrorSchema, placeholder, onChange: onOptionChange, onBlur, onFocus, value: selectedOption, options: widgetOptions, htmlName: fieldPathId.name }) });
}

// node_modules/@rjsf/core/lib/components/fields/MultiSchemaField.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var AnyOfField = class extends import_react6.Component {
  /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(props) {
    super(props);
    /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
     * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
     * the `onChange` handler.
     *
     * @param option - The new option value being selected
     */
    __publicField(this, "onOptionChange", (option) => {
      const { selectedOption, retrievedOptions } = this.state;
      const { formData, onChange, registry, fieldPathId } = this.props;
      const { schemaUtils } = registry;
      const intOption = option !== void 0 ? parseInt(option, 10) : -1;
      if (intOption === selectedOption) {
        return;
      }
      const newOption = intOption >= 0 ? retrievedOptions[intOption] : void 0;
      const oldOption = selectedOption >= 0 ? retrievedOptions[selectedOption] : void 0;
      let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);
      if (newOption) {
        newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, "excludeObjectChildren");
      }
      this.setState({ selectedOption: intOption }, () => {
        onChange(newFormData, fieldPathId.path, void 0, this.getFieldId());
      });
    });
    const { formData, options, registry: { schemaUtils } } = this.props;
    const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
    this.state = {
      retrievedOptions,
      selectedOption: this.getMatchingOption(0, formData, retrievedOptions)
    };
  }
  /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
   * currently selected option based on the overall `formData`
   *
   * @param prevProps - The previous `FieldProps` for this template
   * @param prevState - The previous `AnyOfFieldState` for this template
   */
  componentDidUpdate(prevProps, prevState) {
    const { formData, options, fieldPathId } = this.props;
    const { selectedOption } = this.state;
    let newState = this.state;
    if (!deepEquals(prevProps.options, options)) {
      const { registry: { schemaUtils } } = this.props;
      const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
      newState = { selectedOption, retrievedOptions };
    }
    if (!deepEquals(formData, prevProps.formData) && fieldPathId.$id === prevProps.fieldPathId.$id) {
      const { retrievedOptions } = newState;
      const matchingOption = this.getMatchingOption(selectedOption, formData, retrievedOptions);
      if (prevState && matchingOption !== selectedOption) {
        newState = { selectedOption: matchingOption, retrievedOptions };
      }
    }
    if (newState !== this.state) {
      this.setState(newState);
    }
  }
  /** Determines the best matching option for the given `formData` and `options`.
   *
   * @param formData - The new formData
   * @param options - The list of options to choose from
   * @return - The index of the `option` that best matches the `formData`
   */
  getMatchingOption(selectedOption, formData, options) {
    const { schema, registry: { schemaUtils } } = this.props;
    const discriminator = getDiscriminatorFieldFromSchema(schema);
    const option = schemaUtils.getClosestMatchingOption(formData, options, selectedOption, discriminator);
    return option;
  }
  getFieldId() {
    const { fieldPathId, schema } = this.props;
    return `${fieldPathId.$id}${schema.oneOf ? "__oneof_select" : "__anyof_select"}`;
  }
  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
   */
  render() {
    const { name, disabled = false, errorSchema = {}, formData, onBlur, onFocus, readonly, required = false, registry, schema, uiSchema } = this.props;
    const { widgets: widgets2, fields: fields2, translateString, globalUiOptions, schemaUtils } = registry;
    const { SchemaField: _SchemaField } = fields2;
    const MultiSchemaFieldTemplate2 = getTemplate("MultiSchemaFieldTemplate", registry, globalUiOptions);
    const isOptionalRender = shouldRenderOptionalField(registry, schema, required, uiSchema);
    const hasFormData = isFormDataAvailable(formData);
    const { selectedOption, retrievedOptions } = this.state;
    const { widget = "select", placeholder, autofocus, autocomplete, title = schema.title, ...uiOptions } = getUiOptions(uiSchema, globalUiOptions);
    const Widget = getWidget({ type: "number" }, widget, widgets2);
    const rawErrors = get_default(errorSchema, ERRORS_KEY, []);
    const fieldErrorSchema = omit_default(errorSchema, [ERRORS_KEY]);
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    const option = selectedOption >= 0 ? retrievedOptions[selectedOption] || null : null;
    let optionSchema;
    if (option) {
      const { required: required2 } = schema;
      optionSchema = required2 ? mergeSchemas({ required: required2 }, option) : option;
    }
    let optionsUiSchema = [];
    if (ONE_OF_KEY in schema && uiSchema && ONE_OF_KEY in uiSchema) {
      if (Array.isArray(uiSchema[ONE_OF_KEY])) {
        optionsUiSchema = uiSchema[ONE_OF_KEY];
      } else {
        console.warn(`uiSchema.oneOf is not an array for "${title || name}"`);
      }
    } else if (ANY_OF_KEY in schema && uiSchema && ANY_OF_KEY in uiSchema) {
      if (Array.isArray(uiSchema[ANY_OF_KEY])) {
        optionsUiSchema = uiSchema[ANY_OF_KEY];
      } else {
        console.warn(`uiSchema.anyOf is not an array for "${title || name}"`);
      }
    }
    let optionUiSchema = uiSchema;
    if (selectedOption >= 0 && optionsUiSchema.length > selectedOption) {
      optionUiSchema = optionsUiSchema[selectedOption];
    }
    const translateEnum = title ? TranslatableString.TitleOptionPrefix : TranslatableString.OptionPrefix;
    const translateParams = title ? [title] : [];
    const enumOptions = retrievedOptions.map((opt, index) => {
      const { title: uiTitle = opt.title } = getUiOptions(optionsUiSchema[index]);
      return {
        label: uiTitle || translateString(translateEnum, translateParams.concat(String(index + 1))),
        value: index
      };
    });
    const selector = !isOptionalRender || hasFormData ? (0, import_jsx_runtime7.jsx)(Widget, { id: this.getFieldId(), name: `${name}${schema.oneOf ? "__oneof_select" : "__anyof_select"}`, schema: { type: "number", default: 0 }, onChange: this.onOptionChange, onBlur, onFocus, disabled: disabled || isEmpty_default(enumOptions), multiple: false, rawErrors, errorSchema: fieldErrorSchema, value: selectedOption >= 0 ? selectedOption : void 0, options: { enumOptions, ...uiOptions }, registry, placeholder, autocomplete, autofocus, label: title ?? name, hideLabel: !displayLabel, readonly }) : void 0;
    const optionsSchemaField = optionSchema && optionSchema.type !== "null" && (0, import_jsx_runtime7.jsx)(_SchemaField, { ...this.props, schema: optionSchema, uiSchema: optionUiSchema }) || null;
    return (0, import_jsx_runtime7.jsx)(MultiSchemaFieldTemplate2, { schema, registry, uiSchema, selector, optionSchemaField: optionsSchemaField });
  }
};
var MultiSchemaField_default = AnyOfField;

// node_modules/@rjsf/core/lib/components/fields/NumberField.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var trailingCharMatcherWithPrefix = /\.([0-9]*0)*$/;
var trailingCharMatcher = /[0.]0*$/;
function NumberField(props) {
  const { registry, onChange, formData, value: initialValue } = props;
  const [lastValue, setLastValue] = (0, import_react7.useState)(initialValue);
  const { StringField: StringField2 } = registry.fields;
  let value = formData;
  const handleChange = (0, import_react7.useCallback)((value2, path, errorSchema, id) => {
    setLastValue(value2);
    if (`${value2}`.charAt(0) === ".") {
      value2 = `0${value2}`;
    }
    const processed = typeof value2 === "string" && value2.match(trailingCharMatcherWithPrefix) ? asNumber(value2.replace(trailingCharMatcher, "")) : asNumber(value2);
    onChange(processed, path, errorSchema, id);
  }, [onChange]);
  if (typeof lastValue === "string" && typeof value === "number") {
    const re = new RegExp(`^(${String(value).replace(".", "\\.")})?\\.?0*$`);
    if (lastValue.match(re)) {
      value = lastValue;
    }
  }
  return (0, import_jsx_runtime8.jsx)(StringField2, { ...props, formData: value, onChange: handleChange });
}
var NumberField_default = NumberField;

// node_modules/@rjsf/core/lib/components/fields/ObjectField.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/markdown-to-jsx/dist/index.modern.js
var n = __toESM(require_react());
function t() {
  return t = Object.assign ? Object.assign.bind() : function(n2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var e2 in r2) ({}).hasOwnProperty.call(r2, e2) && (n2[e2] = r2[e2]);
    }
    return n2;
  }, t.apply(null, arguments);
}
var r = ["strong", "em", "del", "mark"];
var e = [["**", r[0]], ["__", r[0]], ["~~", r[2]], ["==", r[3]], ["*", "em"], ["_", "em"]];
function o(n2, t2) {
  for (var r2 = 1, e2 = t2 + 1; e2 < n2.length && r2 > 0; ) "\\" !== n2[e2] ? ("[" === n2[e2] && r2++, "]" === n2[e2] && r2--, e2++) : e2 += 2;
  if (0 === r2 && e2 < n2.length && ("(" === n2[e2] || "[" === n2[e2])) {
    var o2 = "(" === n2[e2] ? ")" : "]", u2 = 1;
    for (e2++; e2 < n2.length && u2 > 0; ) "\\" !== n2[e2] ? ("(" === n2[e2] && ")" === o2 && u2++, n2[e2] === o2 && u2--, e2++) : e2 += 2;
    if (0 === u2) return e2;
  }
  return -1;
}
function u(n2, t2) {
  if (!t2 || !t2.inline && !t2.simple) return null;
  var r2 = n2[0];
  if ("*" !== r2 && "_" !== r2 && "~" !== r2 && "=" !== r2) return null;
  for (var u2 = "", a2 = 0, c = "", i2 = 0; i2 < 6; i2++) {
    var l2 = e[i2][0];
    if (n2.startsWith(l2) && n2.length >= 2 * l2.length) {
      u2 = l2, a2 = l2.length, c = e[i2][1];
      break;
    }
  }
  if (!u2) return null;
  for (var f2 = a2, s2 = false, _2 = false, d2 = "", p2 = 0, y2 = "", h2 = false, m2 = ""; f2 < n2.length; ) {
    var g2 = n2[f2];
    if (h2) y2 += g2, h2 = false, m2 = g2, f2++;
    else if ("\\" !== g2) if ("`" !== g2 || 0 !== p2) {
      if ("[" === g2 && !s2 && 0 === p2) {
        var k2 = o(n2, f2);
        if (-1 !== k2) {
          y2 += n2.slice(f2, k2), f2 = k2, m2 = n2[k2 - 1];
          continue;
        }
      }
      if (_2) y2 += g2, d2 ? g2 === d2 && (d2 = "") : '"' === g2 || "'" === g2 ? d2 = g2 : ">" === g2 && (_2 = false), m2 = g2, f2++;
      else if ("<" !== g2 || s2) {
        if ("\n" === g2 && "\n" === m2 && !s2 && 0 === p2) return null;
        if (!s2 && 0 === p2) {
          for (var v2 = 0; f2 + v2 < n2.length && n2[f2 + v2] === u2[0]; ) v2++;
          if (v2 >= a2 && (1 !== a2 || "*" !== u2 && "_" !== u2 || n2[f2 - 1] !== u2 && n2[f2 + 1] !== u2)) {
            var x2 = [n2.slice(0, f2 + v2), c, y2 + n2.slice(f2 + a2, f2 + v2)];
            return x2.index = 0, x2.input = n2, x2;
          }
        }
        y2 += g2, m2 = g2, f2++;
      } else {
        var q2 = n2[f2 + 1], b2 = n2.indexOf(">", f2);
        if (-1 !== b2) {
          var S2 = n2.slice(f2, b2 + 1).endsWith("/>");
          "/" === q2 ? p2 = Math.max(0, p2 - 1) : S2 || p2++;
        }
        _2 = true, y2 += g2, m2 = g2, f2++;
      }
    } else s2 = !s2, y2 += g2, m2 = g2, f2++;
    else y2 += g2, h2 = true, m2 = g2, f2++;
  }
  return null;
}
var a = ["children", "options"];
var i = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((n2, t2) => (n2[t2.toLowerCase()] = t2, n2), { class: "className", for: "htmlFor" });
var l = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "", quot: "" };
var f = ["style", "script", "pre"];
var s = ["src", "href", "data", "formAction", "srcDoc", "action"];
var _ = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi;
var d = /\n{2,}$/;
var p = /^(\s*>[\s\S]*?)(?=\n\n|$)/;
var y = /^ *> ?/gm;
var h = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/;
var m = /^ {2,}\n/;
var g = /^(?:([-*_])( *\1){2,}) *(?:\n *)+\n/;
var k = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/;
var v = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/;
var x = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/;
var q = /^(?:\n *)*\n/;
var b = /\r\n?/g;
var S = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/;
var $ = /^\[\^([^\]]+)]/;
var z = /\f/g;
var A = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/;
var E = /^\[(x|\s)\]/;
var R = /^(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/;
var w = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/;
var L = /^([^\n]+)\n *(=|-)\2{2,} *\n/;
var B = /^<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>/i;
function C(n2) {
  const t2 = B.exec(n2);
  if (!t2) return null;
  const r2 = t2[1], e2 = r2.toLowerCase(), o2 = e2.length + 1;
  let u2 = t2[0].length;
  "\n" === n2[u2] && u2++;
  const a2 = u2;
  let c = u2, i2 = 1;
  const l2 = n2.length;
  for (; i2 > 0; ) {
    const t3 = n2.indexOf("<", u2);
    if (-1 === t3) return null;
    let a3 = -1, f3 = -1;
    if ("/" === n2[t3 + 1]) f3 = t3;
    else if (n2[t3 + 1] === e2[0] || n2[t3 + 1] === r2[0]) {
      let u3 = true;
      for (let o3 = 0; o3 < e2.length; o3++) {
        const a4 = n2[t3 + 1 + o3];
        if (a4 !== e2[o3] && a4 !== r2[o3]) {
          u3 = false;
          break;
        }
      }
      !u3 || " " !== n2[t3 + o2] && ">" !== n2[t3 + o2] || (a3 = t3);
    }
    if (-1 !== a3 || -1 !== f3) if (-1 !== a3 && (-1 === f3 || a3 < f3)) u2 = a3 + o2 + 1, i2++;
    else {
      let t4 = f3 + 2;
      for (; t4 < l2; ) {
        const r3 = n2[t4];
        if (" " !== r3 && "	" !== r3 && "\n" !== r3 && "\r" !== r3) break;
        t4++;
      }
      if (t4 + e2.length > l2) return null;
      let o3 = true;
      for (let u3 = 0; u3 < e2.length; u3++) {
        const a4 = n2[t4 + u3];
        if (a4 !== e2[u3] && a4 !== r2[u3]) {
          o3 = false;
          break;
        }
      }
      if (!o3) {
        u2 = t4;
        continue;
      }
      for (t4 += e2.length; t4 < l2; ) {
        const r3 = n2[t4];
        if (" " !== r3 && "	" !== r3 && "\n" !== r3 && "\r" !== r3) break;
        t4++;
      }
      if (t4 >= l2 || ">" !== n2[t4]) {
        u2 = t4;
        continue;
      }
      c = f3, u2 = t4 + 1, i2--;
    }
    else u2 = t3 + 1;
  }
  let f2 = 0;
  for (; u2 + f2 < l2 && "\n" === n2[u2 + f2]; ) f2++;
  return [n2.slice(0, u2 + f2), r2, t2[2], n2.slice(a2, c)];
}
var I = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi;
var M = /^<!--[\s\S]*?(?:-->)/;
var T = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/;
var F = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i;
var O = /^\{.*\}$/;
var P = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/;
var j = /^<([^ >]+[:@\/][^ >]+)>/;
var D = /-([a-z])?/gi;
var Z = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/;
var N = /^[^\n]+(?:  \n|\n{2,})/;
var G = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/;
var U = /^!\[([^\]]*)\] ?\[([^\]]*)\]/;
var V = /^\[([^\]]*)\] ?\[([^\]]*)\]/;
var H = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/;
var Q = /\t/g;
var W = /(^ *\||\| *$)/g;
var J = /^ *:-+: *$/;
var K = /^ *:-+ *$/;
var X = /^ *-+: *$/;
var Y = /^(:[a-zA-Z0-9-_]+:)/;
var nn = /^\\([^0-9A-Za-z\s])/;
var tn = /\\([^0-9A-Za-z\s])/g;
var rn = /^[\s\S](?:(?!  \n|[0-9]\.|http)[^=*_~\-\n:<`\\\[!])*/;
var en = /^\n+/;
var on = /^([ \t]*)/;
var un = /(?:^|\n)( *)$/;
var an = "(?:\\d+\\.)";
var cn = "(?:[*+-])";
function ln(n2) {
  return "( *)(" + (1 === n2 ? an : cn) + ") +";
}
var fn = ln(1);
var sn = ln(2);
function _n(n2) {
  return RegExp("^" + (1 === n2 ? fn : sn));
}
var dn = _n(1);
var pn = _n(2);
function yn(n2) {
  return RegExp("^" + (1 === n2 ? fn : sn) + "[^\\n]*(?:\\n(?!\\1" + (1 === n2 ? an : cn) + " )[^\\n]*)*(\\n|$)", "gm");
}
var hn = yn(1);
var mn = yn(2);
function gn(n2) {
  const t2 = 1 === n2 ? an : cn;
  return RegExp("^( *)(" + t2 + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t2 + " (?!" + t2 + " ))\\n*|\\s*\\n*$)");
}
var kn = gn(1);
var vn = gn(2);
function xn(n2, t2) {
  const r2 = 1 === t2, e2 = r2 ? kn : vn, o2 = r2 ? hn : mn, u2 = r2 ? dn : pn;
  return { t: (n3) => u2.test(n3), o: In(function(n3, t3) {
    const r3 = un.exec(t3.prevCapture);
    return r3 && (t3.list || !t3.inline && !t3.simple) ? e2.exec(n3 = r3[1] + n3) : null;
  }), u: 1, i(n3, t3, e3) {
    const a2 = r2 ? +n3[2] : void 0, c = n3[0].replace(d, "\n").match(o2), i2 = u2.exec(c[0]), l2 = RegExp("^ {1," + (i2 ? i2[0].length : 0) + "}", "gm");
    let f2 = false;
    return { items: c.map(function(n4, r3) {
      const o3 = n4.replace(l2, "").replace(u2, ""), a3 = r3 === c.length - 1, i3 = An(o3, "\n\n") || a3 && f2;
      f2 = i3;
      const s2 = e3.inline, _2 = e3.list;
      let d2;
      e3.list = true, i3 ? (e3.inline = false, d2 = $n(o3) + "\n\n") : (e3.inline = true, d2 = $n(o3));
      const p2 = t3(d2, e3);
      return e3.inline = s2, e3.list = _2, p2;
    }), ordered: r2, start: a2 };
  } };
}
var qn = RegExp(`^\\[((?:\\[[^\\[\\]]*(?:\\[[^\\[\\]]*\\][^\\[\\]]*)*\\]|[^\\[\\]])*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`);
var bn = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
function Sn(n2) {
  return "string" == typeof n2;
}
function $n(n2) {
  let t2 = n2.length;
  for (; t2 > 0 && n2[t2 - 1] <= " "; ) t2--;
  return n2.slice(0, t2);
}
function zn(n2, t2) {
  return n2.startsWith(t2);
}
function An(n2, t2) {
  return -1 !== n2.indexOf(t2);
}
function En(n2, t2, r2) {
  if (Array.isArray(r2)) {
    for (let t3 = 0; t3 < r2.length; t3++) if (zn(n2, r2[t3])) return true;
    return false;
  }
  return r2(n2, t2);
}
function Rn(n2) {
  return n2.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
}
function wn(n2) {
  return X.test(n2) ? "right" : J.test(n2) ? "center" : K.test(n2) ? "left" : null;
}
function Ln(n2, t2, r2, e2) {
  const o2 = r2.inTable;
  r2.inTable = true;
  let u2 = [[]], a2 = "";
  function c() {
    if (!a2) return;
    const n3 = u2[u2.length - 1];
    n3.push.apply(n3, t2(a2, r2)), a2 = "";
  }
  return n2.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((n3, t3, r3) => {
    "|" === n3.trim() && (c(), e2) ? 0 !== t3 && t3 !== r3.length - 1 && u2.push([]) : a2 += n3;
  }), c(), r2.inTable = o2, u2;
}
function Bn(n2, t2, r2) {
  r2.inline = true;
  const e2 = n2[2] ? n2[2].replace(W, "").split("|").map(wn) : [], o2 = n2[3] ? function(n3, t3, r3) {
    return n3.trim().split("\n").map(function(n4) {
      return Ln(n4, t3, r3, true);
    });
  }(n2[3], t2, r2) : [], u2 = Ln(n2[1], t2, r2, !!o2.length);
  return r2.inline = false, o2.length ? { align: e2, cells: o2, header: u2, type: "25" } : { children: u2, type: "21" };
}
function Cn(n2, t2) {
  return null == n2.align[t2] ? {} : { textAlign: n2.align[t2] };
}
function In(n2) {
  return n2.inline = 1, n2;
}
function Mn(n2) {
  return In(function(t2, r2) {
    return r2.inline ? n2.exec(t2) : null;
  });
}
function Tn(n2) {
  return In(function(t2, r2) {
    return r2.inline || r2.simple ? n2.exec(t2) : null;
  });
}
function Fn(n2) {
  return function(t2, r2) {
    return r2.inline || r2.simple ? null : n2.exec(t2);
  };
}
function On(n2) {
  return In(function(t2) {
    return n2.exec(t2);
  });
}
var Pn = /(javascript|vbscript|data(?!:image)):/i;
function jn(n2) {
  try {
    const t2 = decodeURIComponent(n2).replace(/[^A-Za-z0-9/:]/g, "");
    if (Pn.test(t2)) return null;
  } catch (n3) {
    return null;
  }
  return n2;
}
function Dn(n2) {
  return n2 ? n2.replace(tn, "$1") : n2;
}
function Zn(n2, t2, r2) {
  const e2 = r2.inline || false, o2 = r2.simple || false;
  r2.inline = true, r2.simple = true;
  const u2 = n2(t2, r2);
  return r2.inline = e2, r2.simple = o2, u2;
}
function Nn(n2, t2, r2) {
  const e2 = r2.inline || false, o2 = r2.simple || false;
  r2.inline = false, r2.simple = true;
  const u2 = n2(t2, r2);
  return r2.inline = e2, r2.simple = o2, u2;
}
function Gn(n2, t2, r2) {
  const e2 = r2.inline || false;
  r2.inline = false;
  const o2 = n2(t2, r2);
  return r2.inline = e2, o2;
}
var Un = (n2, t2, r2) => ({ children: Zn(t2, n2[2], r2) });
function Vn() {
  return {};
}
function Hn(...n2) {
  return n2.filter(Boolean).join(" ");
}
function Qn(n2, t2, r2) {
  let e2 = n2;
  const o2 = t2.split(".");
  for (; o2.length && (e2 = e2[o2[0]], void 0 !== e2); ) o2.shift();
  return e2 || r2;
}
function Wn(n2, t2, r2, e2) {
  if (!t2 || !t2.trim()) return null;
  const o2 = t2.match(_);
  return o2 ? o2.reduce(function(t3, o3) {
    const u2 = o3.indexOf("=");
    if (-1 !== u2) {
      const a2 = function(n3) {
        return -1 !== n3.indexOf("-") && null === n3.match(T) && (n3 = n3.replace(D, function(n4, t4) {
          return t4.toUpperCase();
        })), n3;
      }(o3.slice(0, u2)).trim(), c = i[a2] || a2;
      if ("ref" === c) return t3;
      const l2 = t3[c] = function(n3, t4, r3, e3) {
        return "style" === t4 ? function(n4) {
          const t5 = [];
          if (!n4) return t5;
          let r4 = "", e4 = 0, o4 = "";
          for (let u4 = 0; u4 < n4.length; u4++) {
            const a3 = n4[u4];
            if ('"' === a3 || "'" === a3) o4 ? a3 === o4 && (o4 = "", e4--) : (o4 = a3, e4++);
            else if ("(" === a3 && r4.endsWith("url")) e4++;
            else if (")" === a3 && e4 > 0) e4--;
            else if (";" === a3 && 0 === e4) {
              const n5 = r4.indexOf(":");
              n5 > 0 && t5.push([r4.slice(0, n5).trim(), r4.slice(n5 + 1).trim()]), r4 = "";
              continue;
            }
            r4 += a3;
          }
          const u3 = r4.indexOf(":");
          return u3 > 0 && t5.push([r4.slice(0, u3).trim(), r4.slice(u3 + 1).trim()]), t5;
        }(r3).reduce(function(t5, [r4, o4]) {
          return t5[r4.replace(/(-[a-z])/g, (n4) => n4[1].toUpperCase())] = e3(o4, n3, r4), t5;
        }, {}) : -1 !== s.indexOf(t4) ? e3(Dn(r3), n3, t4) : (r3.match(O) && (r3 = Dn(r3.slice(1, r3.length - 1))), "true" === r3 || "false" !== r3 && r3);
      }(n2, a2, function(n3) {
        const t4 = n3[0];
        return ('"' === t4 || "'" === t4) && n3.length >= 2 && n3[n3.length - 1] === t4 ? n3.slice(1, -1) : n3;
      }(o3.slice(u2 + 1).trim()), r2);
      "string" == typeof l2 && (B.test(l2) || F.test(l2)) && (t3[c] = e2(l2.trim()));
    } else "style" !== o3 && (t3[i[o3] || o3] = true);
    return t3;
  }, {}) : null;
}
function Jn(n2, t2) {
  for (let r2 = 0; r2 < n2.length; r2++) if (n2[r2].test(t2)) return true;
  return false;
}
function Kn(r2 = "", e2 = {}) {
  e2.overrides = e2.overrides || {}, e2.namedCodesToUnicode = e2.namedCodesToUnicode ? t({}, l, e2.namedCodesToUnicode) : l;
  const o2 = e2.slugify || Rn, a2 = e2.sanitizer || jn, c = e2.createElement || n.createElement, i2 = [p, k, v, e2.enforceAtxHeadings ? w : R, L, Z, kn, vn], s2 = [...i2, N, B, M, F];
  function _2(n2, r3, ...o3) {
    const u2 = Qn(e2.overrides, n2 + ".props", {});
    return c(function(n3, t2) {
      const r4 = Qn(t2, n3);
      return r4 ? "function" == typeof r4 || "object" == typeof r4 && "render" in r4 ? r4 : Qn(t2, n3 + ".component", n3) : n3;
    }(n2, e2.overrides), t({}, r3, u2, { className: Hn(null == r3 ? void 0 : r3.className, u2.className) || void 0 }), ...o3);
  }
  function d2(n2) {
    n2 = n2.replace(A, "");
    let r3 = false;
    e2.forceInline ? r3 = true : e2.forceBlock || (r3 = false === H.test(n2));
    const u2 = W2(r3 ? n2 : $n(n2).replace(en, "") + "\n\n", { inline: r3 });
    if (e2.ast) return u2;
    const a3 = J2(u2);
    for (; Sn(a3[a3.length - 1]) && !a3[a3.length - 1].trim(); ) a3.pop();
    if (T2.length && a3.push(_2("footer", { key: "footer" }, T2.map(function(n3) {
      return _2("div", { id: o2(n3.identifier, Rn), key: n3.identifier }, n3.identifier, J2(W2(n3.footnote, { inline: true })));
    }))), null === e2.wrapper) return a3;
    const i3 = e2.wrapper || (r3 ? "span" : "div");
    let l2;
    if (a3.length > 1 || e2.forceWrapper) l2 = a3;
    else {
      if (1 === a3.length) return l2 = a3[0], "string" == typeof l2 ? _2("span", { key: "outer" }, l2) : l2;
      l2 = null;
    }
    return c(i3, t({ key: "outer" }, e2.wrapperProps), l2);
  }
  const T2 = [], O2 = {}, D2 = { 0: { t: [">"], o: Fn(p), u: 1, i(n2, t2, r3) {
    const [, e3, o3] = n2[0].replace(y, "").match(h);
    return { alert: e3, children: t2(o3, r3) };
  } }, 1: { t: ["  "], o: Mn(m), u: 1, i: Vn }, 2: { t: function(n2, t2) {
    if (t2.inline || t2.simple) return false;
    var r3 = n2[0];
    return "-" === r3 || "*" === r3 || "_" === r3;
  }, o: Fn(g), u: 1, i: Vn }, 3: { t: ["    "], o: Fn(v), u: 0, i: (n2) => ({ lang: void 0, text: Dn($n(n2[0].replace(/^ {4}/gm, ""))) }) }, 4: { t: ["```", "~~~"], o: Fn(k), u: 0, i: (n2) => ({ attrs: Wn("code", n2[3] || "", a2, d2), lang: n2[2] || void 0, text: n2[4], type: "3" }) }, 5: { t: ["`"], o: Tn(x), u: 3, i: (n2) => ({ text: Dn(n2[2]) }) }, 6: { t: ["[^"], o: Fn(S), u: 0, i: (n2) => (T2.push({ footnote: n2[2], identifier: n2[1] }), {}) }, 7: { t: ["[^"], o: Mn($), u: 1, i: (n2) => ({ target: "#" + o2(n2[1], Rn), text: n2[1] }) }, 8: { t: ["[ ]", "[x]"], o: Mn(E), u: 1, i: (n2) => ({ completed: "x" === n2[1].toLowerCase() }) }, 9: { t: ["#"], o: Fn(e2.enforceAtxHeadings ? w : R), u: 1, i: (n2, t2, r3) => ({ children: Zn(t2, n2[2], r3), id: o2(n2[2], Rn), level: n2[1].length }) }, 10: { t: (n2) => {
    const t2 = n2.indexOf("\n");
    return t2 > 0 && t2 < n2.length - 1 && ("=" === n2[t2 + 1] || "-" === n2[t2 + 1]);
  }, o: Fn(L), u: 1, i: (n2, t2, r3) => ({ children: Zn(t2, n2[1], r3), level: "=" === n2[2] ? 1 : 2, type: "9" }) }, 11: { t: ["<"], o: In(C), u: 1, i(n2, t2, r3) {
    const [, e3] = n2[3].match(on), o3 = RegExp("^" + e3, "gm"), u2 = n2[3].replace(o3, ""), c2 = Jn(s2, u2) ? Gn : Zn, i3 = n2[1].toLowerCase(), l2 = -1 !== f.indexOf(i3), _3 = (l2 ? i3 : n2[1]).trim(), p2 = { attrs: Wn(_3, n2[2], a2, d2), noInnerParse: l2, tag: _3 };
    if (r3.inAnchor = r3.inAnchor || "a" === i3, l2) p2.text = n2[3];
    else {
      const n3 = r3.inHTML;
      r3.inHTML = true, p2.children = c2(t2, u2, r3), r3.inHTML = n3;
    }
    return r3.inAnchor = false, p2;
  } }, 13: { t: ["<"], o: On(F), u: 1, i(n2) {
    const t2 = n2[1].trim();
    return { attrs: Wn(t2, n2[2] || "", a2, d2), tag: t2 };
  } }, 12: { t: ["<!--"], o: On(M), u: 1, i: () => ({}) }, 14: { t: ["!["], o: Tn(bn), u: 1, i: (n2) => ({ alt: Dn(n2[1]), target: Dn(n2[2]), title: Dn(n2[3]) }) }, 15: { t: ["["], o: Mn(qn), u: 3, i: (n2, t2, r3) => ({ children: Nn(t2, n2[1], r3), target: Dn(n2[2]), title: Dn(n2[3]) }) }, 16: { t: function(n2, t2) {
    return !(!t2.inline || t2.inAnchor) && "<" === n2[0] && (An(n2, ":") || An(n2, "@") || An(n2, "/"));
  }, o: Mn(j), u: 0, i(n2) {
    let t2 = n2[1], r3 = false;
    return An(t2, "@") && !An(t2, "//") && (r3 = true, t2 = t2.replace("mailto:", "")), { children: [{ text: t2, type: "27" }], target: r3 ? "mailto:" + t2 : t2, type: "15" };
  } }, 17: { t: (n2, t2) => !t2.inAnchor && !e2.disableAutoLink && zn(n2, "http"), o: Mn(P), u: 0, i: (n2) => ({ children: [{ text: n2[1], type: "27" }], target: n2[1], title: void 0, type: "15" }) }, 20: xn(0, 1), 30: xn(0, 2), 19: { t: ["\n"], o: Fn(q), u: 3, i: Vn }, 21: { t: function(n2, t2) {
    return !t2.inline && !t2.simple;
  }, o: In(function(n2, t2) {
    if (t2.inline || t2.simple || t2.inHTML && !An(n2, "\n\n") && !An(t2.prevCapture, "\n\n")) return null;
    let r3 = "", e3 = 0;
    for (; ; ) {
      const t3 = n2.indexOf("\n", e3), o4 = n2.slice(e3, -1 === t3 ? void 0 : t3 + 1), u2 = n2[e3];
      if ((">" === u2 || "#" === u2 || "|" === u2 || "`" === u2 || "~" === u2 || "*" === u2 || "-" === u2 || "_" === u2 || " " === u2) && Jn(i2, o4)) break;
      if (r3 += o4, -1 === t3 || !o4.trim()) break;
      e3 = t3 + 1;
    }
    const o3 = $n(r3);
    return "" === o3 ? null : [r3, , o3];
  }), u: 3, i: Un }, 22: { t: ["["], o: Mn(G), u: 0, i: (n2) => (O2[n2[1]] = { target: n2[2], title: n2[4] }, {}) }, 23: { t: ["!["], o: Tn(U), u: 0, i: (n2) => ({ alt: n2[1] ? Dn(n2[1]) : void 0, ref: n2[2] }) }, 24: { t: (n2) => "[" === n2[0] && !An(n2, "]("), o: Mn(V), u: 0, i: (n2, t2, r3) => ({ children: t2(n2[1], r3), fallbackChildren: n2[0], ref: n2[2] }) }, 25: { t: ["|"], o: Fn(Z), u: 1, i: Bn }, 27: { o: In(function(n2, t2) {
    let r3;
    return zn(n2, ":") && (r3 = Y.exec(n2)), r3 || rn.exec(n2);
  }), u: 4, i(n2) {
    const t2 = n2[0];
    return { text: An(t2, "&") ? t2.replace(I, (n3, t3) => e2.namedCodesToUnicode[t3] || n3) : t2 };
  } }, 34: { t: ["*", "_", "~", "="], o: In(u), u: 2, i: (n2, t2, r3) => ({ children: t2(n2[2], r3), tag: n2[1] }) }, 28: { t: ["\\"], o: Tn(nn), u: 1, i: (n2) => ({ text: n2[1], type: "27" }) } };
  true === e2.disableParsingRawHTML && (delete D2[11], delete D2[13]);
  const W2 = function(n2) {
    var t2 = Object.keys(n2);
    function r3(e3, o3) {
      var u2 = [];
      if (o3.prevCapture = o3.prevCapture || "", e3.trim()) for (; e3; ) for (var a3 = 0; a3 < t2.length; ) {
        var c2 = t2[a3], i3 = n2[c2];
        if (!i3.t || En(e3, o3, i3.t)) {
          var l2 = i3.o(e3, o3);
          if (l2 && l2[0]) {
            e3 = e3.substring(l2[0].length);
            var f2 = i3.i(l2, r3, o3);
            o3.prevCapture += l2[0], f2.type || (f2.type = c2), u2.push(f2);
            break;
          }
          a3++;
        } else a3++;
      }
      return o3.prevCapture = "", u2;
    }
    return t2.sort(function(t3, r4) {
      return n2[t3].u - n2[r4].u || (t3 < r4 ? -1 : 1);
    }), function(n3, t3) {
      return r3(function(n4) {
        return n4.replace(b, "\n").replace(z, "").replace(Q, "    ");
      }(n3), t3);
    };
  }(D2), J2 = /* @__PURE__ */ function(n2, r3, e3, o3, u2) {
    function a3(n3) {
      return Array.isArray(n3) ? n3.map((n4) => "text" in n4 ? n4.text : "") : "text" in n3 ? n3.text : "";
    }
    return function c2(i3, l2 = {}) {
      const f2 = (l2.renderDepth || 0) + 1;
      if (f2 > 2500) return a3(i3);
      l2.renderDepth = f2;
      try {
        if (Array.isArray(i3)) {
          const n3 = l2.key, t2 = [];
          let r4 = false;
          for (let n4 = 0; n4 < i3.length; n4++) {
            l2.key = n4;
            const e4 = c2(i3[n4], l2), o4 = Sn(e4);
            o4 && r4 ? t2[t2.length - 1] += e4 : null !== e4 && t2.push(e4), r4 = o4;
          }
          return l2.key = n3, l2.renderDepth = f2 - 1, t2;
        }
        const a4 = function(a5, c3, i4) {
          const l3 = () => function(n3, r4, e4, o4, u3, a6, c4) {
            switch (n3.type) {
              case "0": {
                const t2 = { key: e4.key };
                return n3.alert && (t2.className = "markdown-alert-" + a6(n3.alert.toLowerCase(), Rn), n3.children.unshift({ attrs: {}, children: [{ type: "27", text: n3.alert }], noInnerParse: true, type: "11", tag: "header" })), o4("blockquote", t2, r4(n3.children, e4));
              }
              case "1":
                return o4("br", { key: e4.key });
              case "2":
                return o4("hr", { key: e4.key });
              case "3":
                return o4("pre", { key: e4.key }, o4("code", t({}, n3.attrs, { className: n3.lang ? "lang-" + n3.lang : "" }), n3.text));
              case "5":
                return o4("code", { key: e4.key }, n3.text);
              case "7":
                return o4("a", { key: e4.key, href: u3(n3.target, "a", "href") }, o4("sup", { key: e4.key }, n3.text));
              case "8":
                return o4("input", { checked: n3.completed, key: e4.key, readOnly: true, type: "checkbox" });
              case "9":
                return o4("h" + n3.level, { id: n3.id, key: e4.key }, r4(n3.children, e4));
              case "11":
                return o4(n3.tag, t({ key: e4.key }, n3.attrs), n3.text || (n3.children ? r4(n3.children, e4) : ""));
              case "13":
                return o4(n3.tag, t({}, n3.attrs, { key: e4.key }));
              case "14":
                return o4("img", { key: e4.key, alt: n3.alt || void 0, title: n3.title || void 0, src: u3(n3.target, "img", "src") });
              case "15":
                return o4("a", { key: e4.key, href: u3(n3.target, "a", "href"), title: n3.title }, r4(n3.children, e4));
              case "23":
                return c4[n3.ref] ? o4("img", { key: e4.key, alt: n3.alt, src: u3(c4[n3.ref].target, "img", "src"), title: c4[n3.ref].title }) : null;
              case "24":
                return c4[n3.ref] ? o4("a", { key: e4.key, href: u3(c4[n3.ref].target, "a", "href"), title: c4[n3.ref].title }, r4(n3.children, e4)) : o4("span", { key: e4.key }, n3.fallbackChildren);
              case "25": {
                const t2 = n3;
                return o4("table", { key: e4.key }, o4("thead", null, o4("tr", null, t2.header.map(function(n4, u4) {
                  return o4("th", { key: u4, style: Cn(t2, u4) }, r4(n4, e4));
                }))), o4("tbody", null, t2.cells.map(function(n4, u4) {
                  return o4("tr", { key: u4 }, n4.map(function(n5, u5) {
                    return o4("td", { key: u5, style: Cn(t2, u5) }, r4(n5, e4));
                  }));
                })));
              }
              case "27":
                return n3.text;
              case "34":
                return o4(n3.tag, { key: e4.key }, r4(n3.children, e4));
              case "20":
              case "30":
                return o4(n3.ordered ? "ol" : "ul", { key: e4.key, start: "20" === n3.type ? n3.start : void 0 }, n3.items.map(function(n4, t2) {
                  return o4("li", { key: t2 }, r4(n4, e4));
                }));
              case "19":
                return "\n";
              case "21":
                return o4("p", { key: e4.key }, r4(n3.children, e4));
              default:
                return null;
            }
          }(a5, c3, i4, r3, e3, o3, u2);
          return n2 ? n2(l3, a5, c3, i4) : l3();
        }(i3, c2, l2);
        return l2.renderDepth = f2 - 1, a4;
      } catch (n3) {
        if (n3 instanceof RangeError && n3.message.includes("Maximum call stack")) return a3(i3);
        throw n3;
      }
    };
  }(e2.renderRule, _2, a2, o2, O2);
  return d2(r2);
}
var Xn = (n2) => {
  let { children: r2, options: e2 } = n2, o2 = function(n3, t2) {
    if (null == n3) return {};
    var r3 = {};
    for (var e3 in n3) if ({}.hasOwnProperty.call(n3, e3)) {
      if (-1 !== t2.indexOf(e3)) continue;
      r3[e3] = n3[e3];
    }
    return r3;
  }(n2, a);
  return Kn(null == r2 ? "" : r2, t({}, e2, { wrapperProps: t({}, null == e2 ? void 0 : e2.wrapperProps, o2) }));
};

// node_modules/@rjsf/core/lib/components/constants.js
var ADDITIONAL_PROPERTY_KEY_REMOVE = Symbol("remove-this-key");
var IS_RESET = Symbol("reset");

// node_modules/@rjsf/core/lib/components/fields/ObjectField.js
function isRequired(schema, name) {
  return Array.isArray(schema.required) && schema.required.indexOf(name) !== -1;
}
function getDefaultValue(translateString, type) {
  switch (type) {
    case "array":
      return [];
    case "boolean":
      return false;
    case "null":
      return null;
    case "number":
      return 0;
    case "object":
      return {};
    case "string":
    default:
      return translateString(TranslatableString.NewStringDefault);
  }
}
function ObjectFieldProperty(props) {
  const { fieldPathId, schema, registry, uiSchema, errorSchema, formData, onChange, onBlur, onFocus, disabled, readonly, required, hideError, propertyName, handleKeyRename, handleRemoveProperty, addedByAdditionalProperties } = props;
  const [wasPropertyKeyModified, setWasPropertyKeyModified] = (0, import_react8.useState)(false);
  const { globalFormOptions, fields: fields2 } = registry;
  const { SchemaField: SchemaField2 } = fields2;
  const innerFieldIdPathId = useDeepCompareMemo(toFieldPathId(propertyName, globalFormOptions, fieldPathId.path));
  const onPropertyChange = (0, import_react8.useCallback)((value, path, newErrorSchema, id) => {
    if (value === void 0 && addedByAdditionalProperties) {
      value = "";
    }
    onChange(value, path, newErrorSchema, id);
  }, [onChange, addedByAdditionalProperties]);
  const onKeyRename = (0, import_react8.useCallback)((value) => {
    if (propertyName !== value) {
      setWasPropertyKeyModified(true);
    }
    handleKeyRename(propertyName, value);
  }, [propertyName, handleKeyRename]);
  const onKeyRenameBlur = (0, import_react8.useCallback)((event) => {
    const { target: { value } } = event;
    onKeyRename(value);
  }, [onKeyRename]);
  const onRemoveProperty = (0, import_react8.useCallback)(() => {
    handleRemoveProperty(propertyName);
  }, [propertyName, handleRemoveProperty]);
  return (0, import_jsx_runtime9.jsx)(SchemaField2, { name: propertyName, required, schema, uiSchema, errorSchema, fieldPathId: innerFieldIdPathId, formData, wasPropertyKeyModified, onKeyRename, onKeyRenameBlur, onRemoveProperty, onChange: onPropertyChange, onBlur, onFocus, registry, disabled, readonly, hideError });
}
function ObjectField(props) {
  const { schema: rawSchema, uiSchema = {}, formData, errorSchema, fieldPathId, name, required = false, disabled, readonly, hideError, onBlur, onFocus, onChange, registry, title } = props;
  const { fields: fields2, schemaUtils, translateString, globalUiOptions } = registry;
  const { OptionalDataControlsField: OptionalDataControlsField2 } = fields2;
  const schema = schemaUtils.retrieveSchema(rawSchema, formData, true);
  const uiOptions = getUiOptions(uiSchema, globalUiOptions);
  const { properties: schemaProperties = {} } = schema;
  const childFieldPathId = props.childFieldPathId ?? fieldPathId;
  const templateTitle = uiOptions.title ?? schema.title ?? title ?? name;
  const description = uiOptions.description ?? schema.description;
  const renderOptionalField = shouldRenderOptionalField(registry, schema, required, uiSchema);
  const hasFormData = isFormDataAvailable(formData);
  let orderedProperties = [];
  const getAvailableKey = (0, import_react8.useCallback)((preferredKey, formData2) => {
    const { duplicateKeySuffixSeparator = "-" } = getUiOptions(uiSchema, globalUiOptions);
    let index = 0;
    let newKey = preferredKey;
    while (has_default(formData2, newKey)) {
      newKey = `${preferredKey}${duplicateKeySuffixSeparator}${++index}`;
    }
    return newKey;
  }, [uiSchema, globalUiOptions]);
  const onAddProperty = (0, import_react8.useCallback)(() => {
    if (!(schema.additionalProperties || schema.patternProperties)) {
      return;
    }
    const { translateString: translateString2 } = registry;
    const newFormData = { ...formData };
    const newKey = getAvailableKey("newKey", newFormData);
    if (schema.patternProperties) {
      set_default(newFormData, newKey, null);
    } else {
      let type = void 0;
      let constValue = void 0;
      let defaultValue = void 0;
      if (isObject_default(schema.additionalProperties)) {
        type = schema.additionalProperties.type;
        constValue = schema.additionalProperties.const;
        defaultValue = schema.additionalProperties.default;
        let apSchema = schema.additionalProperties;
        if (REF_KEY in apSchema) {
          const { schemaUtils: schemaUtils2 } = registry;
          apSchema = schemaUtils2.retrieveSchema({ [REF_KEY]: apSchema[REF_KEY] }, formData);
          type = apSchema.type;
          constValue = apSchema.const;
          defaultValue = apSchema.default;
        }
        if (!type && (ANY_OF_KEY in apSchema || ONE_OF_KEY in apSchema)) {
          type = "object";
        }
      }
      const newValue = constValue ?? defaultValue ?? getDefaultValue(translateString2, type);
      set_default(newFormData, newKey, newValue);
    }
    onChange(newFormData, childFieldPathId.path);
  }, [formData, onChange, registry, childFieldPathId, getAvailableKey, schema]);
  const handleKeyRename = (0, import_react8.useCallback)((oldKey, newKey) => {
    if (oldKey !== newKey) {
      const actualNewKey = getAvailableKey(newKey, formData);
      const newFormData = {
        ...formData
      };
      const newKeys = { [oldKey]: actualNewKey };
      const keyValues = Object.keys(newFormData).map((key) => {
        const newKey2 = newKeys[key] || key;
        return { [newKey2]: newFormData[key] };
      });
      const renamedObj = Object.assign({}, ...keyValues);
      onChange(renamedObj, childFieldPathId.path);
    }
  }, [formData, onChange, childFieldPathId, getAvailableKey]);
  const handleRemoveProperty = (0, import_react8.useCallback)((key) => {
    onChange(ADDITIONAL_PROPERTY_KEY_REMOVE, [...childFieldPathId.path, key]);
  }, [onChange, childFieldPathId]);
  if (!renderOptionalField || hasFormData) {
    try {
      const properties = Object.keys(schemaProperties);
      orderedProperties = orderProperties(properties, uiOptions.order);
    } catch (err) {
      return (0, import_jsx_runtime9.jsxs)("div", { children: [(0, import_jsx_runtime9.jsx)("p", { className: "rjsf-config-error", style: { color: "red" }, children: (0, import_jsx_runtime9.jsx)(Xn, { options: { disableParsingRawHTML: true }, children: translateString(TranslatableString.InvalidObjectField, [name || "root", err.message]) }) }), (0, import_jsx_runtime9.jsx)("pre", { children: JSON.stringify(schema) })] });
    }
  }
  const Template = getTemplate("ObjectFieldTemplate", registry, uiOptions);
  const optionalDataControl = renderOptionalField ? (0, import_jsx_runtime9.jsx)(OptionalDataControlsField2, { ...props, fieldPathId: childFieldPathId, schema }) : void 0;
  const templateProps = {
    // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
    title: uiOptions.label === false ? "" : templateTitle,
    description: uiOptions.label === false ? void 0 : description,
    properties: orderedProperties.map((name2) => {
      const addedByAdditionalProperties = has_default(schema, [PROPERTIES_KEY, name2, ADDITIONAL_PROPERTY_FLAG]);
      const fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name2];
      const hidden = getUiOptions(fieldUiSchema).widget === "hidden";
      const content = (0, import_jsx_runtime9.jsx)(ObjectFieldProperty, { propertyName: name2, required: isRequired(schema, name2), schema: get_default(schema, [PROPERTIES_KEY, name2], {}), uiSchema: fieldUiSchema, errorSchema: get_default(errorSchema, [name2]), fieldPathId: childFieldPathId, formData: get_default(formData, [name2]), handleKeyRename, handleRemoveProperty, addedByAdditionalProperties, onChange, onBlur, onFocus, registry, disabled, readonly, hideError }, name2);
      return {
        content,
        name: name2,
        readonly,
        disabled,
        required,
        hidden
      };
    }),
    readonly,
    disabled,
    required,
    fieldPathId,
    uiSchema,
    errorSchema,
    schema,
    formData,
    registry,
    optionalDataControl,
    className: renderOptionalField ? "rjsf-optional-object-field" : void 0
  };
  return (0, import_jsx_runtime9.jsx)(Template, { ...templateProps, onAddProperty });
}

// node_modules/@rjsf/core/lib/components/fields/OptionalDataControlsField.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
function OptionalDataControlsField(props) {
  const { schema, uiSchema = {}, formData, disabled = false, readonly = false, onChange, errorSchema, fieldPathId, registry } = props;
  const { globalUiOptions = {}, schemaUtils, translateString } = registry;
  const uiOptions = getUiOptions(uiSchema, globalUiOptions);
  const OptionalDataControlsTemplate2 = getTemplate("OptionalDataControlsTemplate", registry, uiOptions);
  const hasFormData = isFormDataAvailable(formData);
  let id;
  let label;
  let onAddClick;
  let onRemoveClick;
  if (disabled || readonly) {
    id = optionalControlsId(fieldPathId, "Msg");
    label = hasFormData ? void 0 : translateString(TranslatableString.OptionalObjectEmptyMsg);
  } else {
    const labelEnum = hasFormData ? TranslatableString.OptionalObjectRemove : TranslatableString.OptionalObjectAdd;
    label = translateString(labelEnum);
    if (hasFormData) {
      id = optionalControlsId(fieldPathId, "Remove");
      onRemoveClick = () => onChange(void 0, fieldPathId.path, errorSchema);
    } else {
      id = optionalControlsId(fieldPathId, "Add");
      onAddClick = () => {
        let newFormData = schemaUtils.getDefaultFormState(schema, formData, "excludeObjectChildren");
        if (newFormData === void 0) {
          newFormData = getSchemaType(schema) === "array" ? [] : {};
        }
        onChange(newFormData, fieldPathId.path, errorSchema);
      };
    }
  }
  return label && (0, import_jsx_runtime10.jsx)(OptionalDataControlsTemplate2, { id, registry, schema, uiSchema, label, onAddClick, onRemoveClick });
}

// node_modules/@rjsf/core/lib/components/fields/SchemaField.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var COMPONENT_TYPES = {
  array: "ArrayField",
  boolean: "BooleanField",
  integer: "NumberField",
  number: "NumberField",
  object: "ObjectField",
  string: "StringField",
  null: "NullField"
};
function getFieldComponent(schema, uiOptions, registry) {
  const field = uiOptions.field;
  const { fields: fields2 } = registry;
  if (typeof field === "function") {
    return field;
  }
  if (typeof field === "string" && field in fields2) {
    return fields2[field];
  }
  const schemaType = getSchemaType(schema);
  const type = Array.isArray(schemaType) ? schemaType[0] : schemaType || "";
  const schemaId = schema.$id;
  let componentName = COMPONENT_TYPES[type];
  if (schemaId && schemaId in fields2) {
    componentName = schemaId;
  }
  if (!componentName && (schema.anyOf || schema.oneOf)) {
    return () => null;
  }
  return componentName in fields2 ? fields2[componentName] : fields2["FallbackField"];
}
function SchemaFieldRender(props) {
  const { schema: _schema, fieldPathId, uiSchema, formData, errorSchema, name, onChange, onKeyRename, onKeyRenameBlur, onRemoveProperty, required = false, registry, wasPropertyKeyModified = false } = props;
  const { schemaUtils, globalFormOptions, globalUiOptions, fields: fields2 } = registry;
  const { AnyOfField: _AnyOfField, OneOfField: _OneOfField } = fields2;
  const uiOptions = getUiOptions(uiSchema, globalUiOptions);
  const FieldTemplate2 = getTemplate("FieldTemplate", registry, uiOptions);
  const DescriptionFieldTemplate = getTemplate("DescriptionFieldTemplate", registry, uiOptions);
  const FieldHelpTemplate2 = getTemplate("FieldHelpTemplate", registry, uiOptions);
  const FieldErrorTemplate2 = getTemplate("FieldErrorTemplate", registry, uiOptions);
  const schema = schemaUtils.retrieveSchema(_schema, formData);
  const fieldId = fieldPathId[ID_KEY];
  const handleFieldComponentChange = (0, import_react9.useCallback)((formData2, path, newErrorSchema, id2) => {
    const theId = id2 || fieldId;
    return onChange(formData2, path, newErrorSchema, theId);
  }, [fieldId, onChange]);
  const FieldComponent = getFieldComponent(schema, uiOptions, registry);
  const disabled = Boolean(uiOptions.disabled ?? props.disabled);
  const readonly = Boolean(uiOptions.readonly ?? (props.readonly || props.schema.readOnly || schema.readOnly));
  const uiSchemaHideError = uiOptions.hideError;
  const hideError = uiSchemaHideError === void 0 ? props.hideError : Boolean(uiSchemaHideError);
  const autofocus = Boolean(uiOptions.autofocus ?? props.autofocus);
  if (Object.keys(schema).length === 0) {
    return null;
  }
  let displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const isReplacingAnyOrOneOf = uiOptions.field && uiOptions.fieldReplacesAnyOrOneOf === true;
  let XxxOfField;
  let XxxOfOptions;
  let fieldPathIdProps = { fieldPathId };
  if ((ANY_OF_KEY in schema || ONE_OF_KEY in schema) && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema)) {
    if (schema[ANY_OF_KEY]) {
      XxxOfField = _AnyOfField;
      XxxOfOptions = schema[ANY_OF_KEY].map((_schema2) => schemaUtils.retrieveSchema(isObject_default(_schema2) ? _schema2 : {}, formData));
    } else if (schema[ONE_OF_KEY]) {
      XxxOfField = _OneOfField;
      XxxOfOptions = schema[ONE_OF_KEY].map((_schema2) => schemaUtils.retrieveSchema(isObject_default(_schema2) ? _schema2 : {}, formData));
    }
    const isOptionalRender = shouldRenderOptionalField(registry, schema, required, uiSchema);
    const hasFormData = isFormDataAvailable(formData);
    displayLabel = displayLabel && (!isOptionalRender || hasFormData);
    fieldPathIdProps = {
      childFieldPathId: fieldPathId,
      // The main FieldComponent will add `XxxOf` onto the fieldPathId to avoid duplication with the rendering of the
      // same FieldComponent by the `XxxOfField`
      fieldPathId: toFieldPathId("XxxOf", globalFormOptions, fieldPathId)
    };
  }
  const { __errors, ...fieldErrorSchema } = errorSchema || {};
  const fieldUiSchema = omit_default(uiSchema, ["ui:classNames", "classNames", "ui:style"]);
  if (UI_OPTIONS_KEY in fieldUiSchema) {
    fieldUiSchema[UI_OPTIONS_KEY] = omit_default(fieldUiSchema[UI_OPTIONS_KEY], ["classNames", "style"]);
  }
  const field = (0, import_jsx_runtime11.jsx)(FieldComponent, { ...props, onChange: handleFieldComponentChange, ...fieldPathIdProps, schema, uiSchema: fieldUiSchema, disabled, readonly, hideError, autofocus, errorSchema: fieldErrorSchema, rawErrors: __errors });
  const id = fieldPathId[ID_KEY];
  let label;
  if (wasPropertyKeyModified) {
    label = name;
  } else {
    label = ADDITIONAL_PROPERTY_FLAG in schema ? name : uiOptions.title || props.schema.title || schema.title || props.title || name;
  }
  const description = uiOptions.description || props.schema.description || schema.description || "";
  const help = uiOptions.help;
  const hidden = uiOptions.widget === "hidden";
  const classNames = ["rjsf-field", `rjsf-field-${getSchemaType(schema)}`];
  if (!hideError && __errors && __errors.length > 0) {
    classNames.push("rjsf-field-error");
  }
  if (uiOptions.classNames) {
    classNames.push(uiOptions.classNames);
  }
  const helpComponent = (0, import_jsx_runtime11.jsx)(FieldHelpTemplate2, { help, fieldPathId, schema, uiSchema, hasErrors: !hideError && __errors && __errors.length > 0, registry });
  const errorsComponent = hideError || XxxOfField && !schemaUtils.isSelect(schema) ? void 0 : (0, import_jsx_runtime11.jsx)(FieldErrorTemplate2, { errors: __errors, errorSchema, fieldPathId, schema, uiSchema, registry });
  const fieldProps = {
    description: (0, import_jsx_runtime11.jsx)(DescriptionFieldTemplate, { id: descriptionId(id), description, schema, uiSchema, registry }),
    rawDescription: description,
    help: helpComponent,
    rawHelp: typeof help === "string" ? help : void 0,
    errors: errorsComponent,
    rawErrors: hideError ? void 0 : __errors,
    id,
    label,
    hidden,
    onChange,
    onKeyRename,
    onKeyRenameBlur,
    onRemoveProperty,
    required,
    disabled,
    readonly,
    hideError,
    displayLabel,
    classNames: classNames.join(" ").trim(),
    style: uiOptions.style,
    formData,
    schema,
    uiSchema,
    registry
  };
  return (0, import_jsx_runtime11.jsx)(FieldTemplate2, { ...fieldProps, children: (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [field, XxxOfField && (0, import_jsx_runtime11.jsx)(XxxOfField, { name, disabled, readonly, hideError, errorSchema, formData, fieldPathId, onBlur: props.onBlur, onChange: props.onChange, onFocus: props.onFocus, options: XxxOfOptions, registry, required, schema, uiSchema })] }) });
}
var SchemaField = class extends import_react9.Component {
  shouldComponentUpdate(nextProps) {
    const { registry: { globalFormOptions } } = this.props;
    const { experimental_componentUpdateStrategy = "customDeep" } = globalFormOptions;
    return shouldRender(this, nextProps, this.state, experimental_componentUpdateStrategy);
  }
  render() {
    return (0, import_jsx_runtime11.jsx)(SchemaFieldRender, { ...this.props });
  }
};
var SchemaField_default = SchemaField;

// node_modules/@rjsf/core/lib/components/fields/StringField.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
function StringField(props) {
  const { schema, name, uiSchema, fieldPathId, formData, required, disabled = false, readonly = false, autofocus = false, onChange, onBlur, onFocus, registry, rawErrors, hideError, title } = props;
  const { title: schemaTitle, format } = schema;
  const { widgets: widgets2, schemaUtils, globalUiOptions } = registry;
  const enumOptions = schemaUtils.isSelect(schema) ? optionsList(schema, uiSchema) : void 0;
  let defaultWidget = enumOptions ? "select" : "text";
  if (format && hasWidget(schema, format, widgets2)) {
    defaultWidget = format;
  }
  const { widget = defaultWidget, placeholder = "", title: uiTitle, ...options } = getUiOptions(uiSchema);
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const label = uiTitle ?? title ?? schemaTitle ?? name;
  const Widget = getWidget(schema, widget, widgets2);
  const onWidgetChange = (0, import_react10.useCallback)((value, errorSchema, id) => {
    return onChange(value, fieldPathId.path, errorSchema, id);
  }, [onChange, fieldPathId]);
  return (0, import_jsx_runtime12.jsx)(Widget, { options: { ...options, enumOptions }, schema, uiSchema, id: fieldPathId.$id, name, label, hideLabel: !displayLabel, hideError, value: formData, onChange: onWidgetChange, onBlur, onFocus, required, disabled, readonly, autofocus, registry, placeholder, rawErrors, htmlName: fieldPathId.name });
}
var StringField_default = StringField;

// node_modules/@rjsf/core/lib/components/fields/NullField.js
var import_react11 = __toESM(require_react(), 1);
function NullField(props) {
  const { formData, onChange, fieldPathId } = props;
  (0, import_react11.useEffect)(() => {
    if (formData === void 0) {
      onChange(null, fieldPathId.path);
    }
  }, [fieldPathId, formData, onChange]);
  return null;
}
var NullField_default = NullField;

// node_modules/@rjsf/core/lib/components/fields/index.js
function fields() {
  return {
    AnyOfField: MultiSchemaField_default,
    ArrayField,
    // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
    BooleanField: BooleanField_default,
    FallbackField,
    LayoutGridField,
    LayoutHeaderField,
    LayoutMultiSchemaField,
    NumberField: NumberField_default,
    ObjectField,
    OneOfField: MultiSchemaField_default,
    OptionalDataControlsField,
    SchemaField: SchemaField_default,
    StringField: StringField_default,
    NullField: NullField_default
  };
}
var fields_default = fields;

// node_modules/@rjsf/core/lib/components/templates/ArrayFieldDescriptionTemplate.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
function ArrayFieldDescriptionTemplate(props) {
  const { fieldPathId, description, registry, schema, uiSchema } = props;
  const options = getUiOptions(uiSchema, registry.globalUiOptions);
  const { label: displayLabel = true } = options;
  if (!description || !displayLabel) {
    return null;
  }
  const DescriptionFieldTemplate = getTemplate("DescriptionFieldTemplate", registry, options);
  return (0, import_jsx_runtime13.jsx)(DescriptionFieldTemplate, { id: descriptionId(fieldPathId), description, schema, uiSchema, registry });
}

// node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemTemplate.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function ArrayFieldItemTemplate(props) {
  const { children, className, buttonsProps, displayLabel, hasDescription, hasToolbar, registry, uiSchema } = props;
  const uiOptions = getUiOptions(uiSchema);
  const ArrayFieldItemButtonsTemplate2 = getTemplate("ArrayFieldItemButtonsTemplate", registry, uiOptions);
  const btnStyle = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  };
  const margin = hasDescription ? 31 : 9;
  const containerStyle = { display: "flex", alignItems: displayLabel ? "center" : "baseline" };
  const toolbarStyle = { display: "flex", justifyContent: "flex-end", marginTop: displayLabel ? `${margin}px` : 0 };
  return (0, import_jsx_runtime14.jsxs)("div", { className, style: containerStyle, children: [(0, import_jsx_runtime14.jsx)("div", { className: hasToolbar ? "col-xs-9 col-md-10 col-xl-11" : "col-xs-12", children }), hasToolbar && (0, import_jsx_runtime14.jsx)("div", { className: "col-xs-3 col-md-2 col-xl-1 array-item-toolbox", children: (0, import_jsx_runtime14.jsx)("div", { className: "btn-group", style: toolbarStyle, children: (0, import_jsx_runtime14.jsx)(ArrayFieldItemButtonsTemplate2, { ...buttonsProps, style: btnStyle }) }) })] });
}

// node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemButtonsTemplate.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
function ArrayFieldItemButtonsTemplate(props) {
  const { disabled, hasCopy, hasMoveDown, hasMoveUp, hasRemove, fieldPathId, onCopyItem, onRemoveItem, onMoveDownItem, onMoveUpItem, readonly, registry, uiSchema } = props;
  const { CopyButton: CopyButton2, MoveDownButton: MoveDownButton2, MoveUpButton: MoveUpButton2, RemoveButton: RemoveButton2 } = registry.templates.ButtonTemplates;
  return (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [(hasMoveUp || hasMoveDown) && (0, import_jsx_runtime15.jsx)(MoveUpButton2, { id: buttonId(fieldPathId, "moveUp"), className: "rjsf-array-item-move-up", disabled: disabled || readonly || !hasMoveUp, onClick: onMoveUpItem, uiSchema, registry }), (hasMoveUp || hasMoveDown) && (0, import_jsx_runtime15.jsx)(MoveDownButton2, { id: buttonId(fieldPathId, "moveDown"), className: "rjsf-array-item-move-down", disabled: disabled || readonly || !hasMoveDown, onClick: onMoveDownItem, uiSchema, registry }), hasCopy && (0, import_jsx_runtime15.jsx)(CopyButton2, { id: buttonId(fieldPathId, "copy"), className: "rjsf-array-item-copy", disabled: disabled || readonly, onClick: onCopyItem, uiSchema, registry }), hasRemove && (0, import_jsx_runtime15.jsx)(RemoveButton2, { id: buttonId(fieldPathId, "remove"), className: "rjsf-array-item-remove", disabled: disabled || readonly, onClick: onRemoveItem, uiSchema, registry })] });
}

// node_modules/@rjsf/core/lib/components/templates/ArrayFieldTemplate.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
function ArrayFieldTemplate(props) {
  const { canAdd, className, disabled, fieldPathId, uiSchema, items, optionalDataControl, onAddClick, readonly, registry, required, schema, title } = props;
  const uiOptions = getUiOptions(uiSchema);
  const ArrayFieldDescriptionTemplate2 = getTemplate("ArrayFieldDescriptionTemplate", registry, uiOptions);
  const ArrayFieldTitleTemplate2 = getTemplate("ArrayFieldTitleTemplate", registry, uiOptions);
  const showOptionalDataControlInTitle = !readonly && !disabled;
  const { ButtonTemplates: { AddButton: AddButton2 } } = registry.templates;
  return (0, import_jsx_runtime16.jsxs)("fieldset", { className, id: fieldPathId.$id, children: [(0, import_jsx_runtime16.jsx)(ArrayFieldTitleTemplate2, { fieldPathId, title: uiOptions.title || title, required, schema, uiSchema, registry, optionalDataControl: showOptionalDataControlInTitle ? optionalDataControl : void 0 }), (0, import_jsx_runtime16.jsx)(ArrayFieldDescriptionTemplate2, { fieldPathId, description: uiOptions.description || schema.description, schema, uiSchema, registry }), !showOptionalDataControlInTitle ? optionalDataControl : void 0, (0, import_jsx_runtime16.jsx)("div", { className: "row array-item-list", children: items }), canAdd && (0, import_jsx_runtime16.jsx)(AddButton2, { id: buttonId(fieldPathId, "add"), className: "rjsf-array-item-add", onClick: onAddClick, disabled: disabled || readonly, uiSchema, registry })] });
}

// node_modules/@rjsf/core/lib/components/templates/ArrayFieldTitleTemplate.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
function ArrayFieldTitleTemplate(props) {
  const { fieldPathId, title, schema, uiSchema, required, registry, optionalDataControl } = props;
  const options = getUiOptions(uiSchema, registry.globalUiOptions);
  const { label: displayLabel = true } = options;
  if (!title || !displayLabel) {
    return null;
  }
  const TitleFieldTemplate = getTemplate("TitleFieldTemplate", registry, options);
  return (0, import_jsx_runtime17.jsx)(TitleFieldTemplate, { id: titleId(fieldPathId), title, required, schema, uiSchema, registry, optionalDataControl });
}

// node_modules/@rjsf/core/lib/components/templates/BaseInputTemplate.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
function BaseInputTemplate(props) {
  const {
    id,
    name,
    // remove this from ...rest
    htmlName,
    value,
    readonly,
    disabled,
    autofocus,
    onBlur,
    onFocus,
    onChange,
    onChangeOverride,
    options,
    schema,
    uiSchema,
    registry,
    rawErrors,
    type,
    hideLabel,
    // remove this from ...rest
    hideError,
    // remove this from ...rest
    ...rest
  } = props;
  if (!id) {
    console.log("No id for", props);
    throw new Error(`no id for props ${JSON.stringify(props)}`);
  }
  const inputProps = {
    ...rest,
    ...getInputProps(schema, type, options)
  };
  let inputValue;
  if (inputProps.type === "number" || inputProps.type === "integer") {
    inputValue = value || value === 0 ? value : "";
  } else {
    inputValue = value == null ? "" : value;
  }
  const _onChange = (0, import_react12.useCallback)(({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2), [onChange, options]);
  const _onBlur = (0, import_react12.useCallback)(({ target }) => onBlur(id, target && target.value), [onBlur, id]);
  const _onFocus = (0, import_react12.useCallback)(({ target }) => onFocus(id, target && target.value), [onFocus, id]);
  return (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [(0, import_jsx_runtime18.jsx)("input", { id, name: htmlName || id, className: "form-control", readOnly: readonly, disabled, autoFocus: autofocus, value: inputValue, ...inputProps, list: schema.examples ? examplesId(id) : void 0, onChange: onChangeOverride || _onChange, onBlur: _onBlur, onFocus: _onFocus, "aria-describedby": ariaDescribedByIds(id, !!schema.examples) }), Array.isArray(schema.examples) && (0, import_jsx_runtime18.jsx)("datalist", { id: examplesId(id), children: schema.examples.concat(schema.default && !schema.examples.includes(schema.default) ? [schema.default] : []).map((example) => {
    return (0, import_jsx_runtime18.jsx)("option", { value: example }, example);
  }) }, `datalist_${id}`)] });
}

// node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/SubmitButton.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
function SubmitButton({ uiSchema }) {
  const { submitText, norender, props: submitButtonProps = {} } = getSubmitButtonOptions(uiSchema);
  if (norender) {
    return null;
  }
  return (0, import_jsx_runtime19.jsx)("div", { children: (0, import_jsx_runtime19.jsx)("button", { type: "submit", ...submitButtonProps, className: `btn btn-info ${submitButtonProps.className || ""}`, children: submitText }) });
}

// node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);

// node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
function IconButton(props) {
  const { iconType = "default", icon, className, uiSchema, registry, ...otherProps } = props;
  return (0, import_jsx_runtime20.jsx)("button", { type: "button", className: `btn btn-${iconType} ${className}`, ...otherProps, children: (0, import_jsx_runtime20.jsx)("i", { className: `glyphicon glyphicon-${icon}` }) });
}
function CopyButton(props) {
  const { registry: { translateString } } = props;
  return (0, import_jsx_runtime20.jsx)(IconButton, { title: translateString(TranslatableString.CopyButton), ...props, icon: "copy" });
}
function MoveDownButton(props) {
  const { registry: { translateString } } = props;
  return (0, import_jsx_runtime20.jsx)(IconButton, { title: translateString(TranslatableString.MoveDownButton), ...props, icon: "arrow-down" });
}
function MoveUpButton(props) {
  const { registry: { translateString } } = props;
  return (0, import_jsx_runtime20.jsx)(IconButton, { title: translateString(TranslatableString.MoveUpButton), ...props, icon: "arrow-up" });
}
function RemoveButton(props) {
  const { registry: { translateString } } = props;
  return (0, import_jsx_runtime20.jsx)(IconButton, { title: translateString(TranslatableString.RemoveButton), ...props, iconType: "danger", icon: "remove" });
}

// node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js
function AddButton({ id, className, onClick, disabled, registry }) {
  const { translateString } = registry;
  return (0, import_jsx_runtime21.jsx)("div", { className: "row", children: (0, import_jsx_runtime21.jsx)("p", { className: `col-xs-4 col-sm-2 col-lg-1 col-xs-offset-8 col-sm-offset-10 col-lg-offset-11 text-right ${className}`, children: (0, import_jsx_runtime21.jsx)(IconButton, { id, iconType: "info", icon: "plus", className: "btn-add col-xs-12", title: translateString(TranslatableString.AddButton), onClick, disabled, registry }) }) });
}

// node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/index.js
function buttonTemplates() {
  return {
    SubmitButton,
    AddButton,
    CopyButton,
    MoveDownButton,
    MoveUpButton,
    RemoveButton
  };
}
var ButtonTemplates_default = buttonTemplates;

// node_modules/@rjsf/core/lib/components/templates/DescriptionField.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);

// node_modules/@rjsf/core/lib/components/RichDescription.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var TEST_IDS = getTestIds();
function RichDescription({ description, registry, uiSchema = {} }) {
  const { globalUiOptions } = registry;
  const uiOptions = getUiOptions(uiSchema, globalUiOptions);
  if (uiOptions.enableMarkdownInDescription && typeof description === "string") {
    return (0, import_jsx_runtime22.jsx)(Xn, { options: { disableParsingRawHTML: true }, "data-testid": TEST_IDS.markdown, children: description });
  }
  return description;
}
RichDescription.TEST_IDS = TEST_IDS;

// node_modules/@rjsf/core/lib/components/templates/DescriptionField.js
function DescriptionField(props) {
  const { id, description, registry, uiSchema } = props;
  if (!description) {
    return null;
  }
  return (0, import_jsx_runtime23.jsx)("div", { id, className: "field-description", children: (0, import_jsx_runtime23.jsx)(RichDescription, { description, registry, uiSchema }) });
}

// node_modules/@rjsf/core/lib/components/templates/ErrorList.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
function ErrorList({ errors, registry }) {
  const { translateString } = registry;
  return (0, import_jsx_runtime24.jsxs)("div", { className: "panel panel-danger errors", children: [(0, import_jsx_runtime24.jsx)("div", { className: "panel-heading", children: (0, import_jsx_runtime24.jsx)("h3", { className: "panel-title", children: translateString(TranslatableString.ErrorsLabel) }) }), (0, import_jsx_runtime24.jsx)("ul", { className: "list-group", children: errors.map((error, i2) => {
    return (0, import_jsx_runtime24.jsx)("li", { className: "list-group-item text-danger", children: error.stack }, i2);
  }) })] });
}

// node_modules/@rjsf/core/lib/components/templates/FallbackFieldTemplate.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function FallbackFieldTemplate(props) {
  const { schema, registry, typeSelector, schemaField } = props;
  const MultiSchemaFieldTemplate2 = getTemplate("MultiSchemaFieldTemplate", registry);
  return (0, import_jsx_runtime25.jsx)(MultiSchemaFieldTemplate2, { selector: typeSelector, optionSchemaField: schemaField, schema, registry });
}

// node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);

// node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var REQUIRED_FIELD_SYMBOL = "*";
function Label(props) {
  const { label, required, id } = props;
  if (!label) {
    return null;
  }
  return (0, import_jsx_runtime26.jsxs)("label", { className: "control-label", htmlFor: id, children: [label, required && (0, import_jsx_runtime26.jsx)("span", { className: "required", children: REQUIRED_FIELD_SYMBOL })] });
}

// node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js
function FieldTemplate(props) {
  const { id, label, children, errors, help, description, hidden, required, displayLabel, registry, uiSchema } = props;
  const uiOptions = getUiOptions(uiSchema);
  const WrapIfAdditionalTemplate2 = getTemplate("WrapIfAdditionalTemplate", registry, uiOptions);
  if (hidden) {
    return (0, import_jsx_runtime27.jsx)("div", { className: "hidden", children });
  }
  const isCheckbox = uiOptions.widget === "checkbox";
  return (0, import_jsx_runtime27.jsxs)(WrapIfAdditionalTemplate2, { ...props, children: [displayLabel && !isCheckbox && (0, import_jsx_runtime27.jsx)(Label, { label, required, id }), displayLabel && description ? description : null, children, errors, help] });
}

// node_modules/@rjsf/core/lib/components/templates/FieldTemplate/index.js
var FieldTemplate_default = FieldTemplate;

// node_modules/@rjsf/core/lib/components/templates/FieldErrorTemplate.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
function FieldErrorTemplate(props) {
  const { errors = [], fieldPathId } = props;
  if (errors.length === 0) {
    return null;
  }
  const id = errorId(fieldPathId);
  return (0, import_jsx_runtime28.jsx)("div", { children: (0, import_jsx_runtime28.jsx)("ul", { id, className: "error-detail bs-callout bs-callout-info", children: errors.filter((elem) => !!elem).map((error, index) => {
    return (0, import_jsx_runtime28.jsx)("li", { className: "text-danger", children: error }, index);
  }) }) });
}

// node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);

// node_modules/@rjsf/core/lib/components/RichHelp.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var TEST_IDS2 = getTestIds();
function RichHelp({ help, registry, uiSchema = {} }) {
  const { globalUiOptions } = registry;
  const uiOptions = getUiOptions(uiSchema, globalUiOptions);
  if (uiOptions.enableMarkdownInHelp && typeof help === "string") {
    return (0, import_jsx_runtime29.jsx)(Xn, { options: { disableParsingRawHTML: true }, "data-testid": TEST_IDS2.markdown, children: help });
  }
  return help;
}
RichHelp.TEST_IDS = TEST_IDS2;

// node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js
function FieldHelpTemplate(props) {
  const { fieldPathId, help, uiSchema, registry } = props;
  if (!help) {
    return null;
  }
  return (0, import_jsx_runtime30.jsx)("div", { id: helpId(fieldPathId), className: "help-block", children: (0, import_jsx_runtime30.jsx)(RichHelp, { help, registry, uiSchema }) });
}

// node_modules/@rjsf/core/lib/components/templates/GridTemplate.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
function GridTemplate(props) {
  const { children, column, className, ...rest } = props;
  return (0, import_jsx_runtime31.jsx)("div", { className, ...rest, children });
}

// node_modules/@rjsf/core/lib/components/templates/MultiSchemaFieldTemplate.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
function MultiSchemaFieldTemplate(props) {
  const { selector, optionSchemaField } = props;
  return (0, import_jsx_runtime32.jsxs)("div", { className: "panel panel-default panel-body", children: [(0, import_jsx_runtime32.jsx)("div", { className: "form-group", children: selector }), optionSchemaField] });
}

// node_modules/@rjsf/core/lib/components/templates/ObjectFieldTemplate.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
function ObjectFieldTemplate(props) {
  const { className, description, disabled, formData, fieldPathId, onAddProperty, optionalDataControl, properties, readonly, registry, required, schema, title, uiSchema } = props;
  const options = getUiOptions(uiSchema);
  const TitleFieldTemplate = getTemplate("TitleFieldTemplate", registry, options);
  const DescriptionFieldTemplate = getTemplate("DescriptionFieldTemplate", registry, options);
  const showOptionalDataControlInTitle = !readonly && !disabled;
  const { ButtonTemplates: { AddButton: AddButton2 } } = registry.templates;
  return (0, import_jsx_runtime33.jsxs)("fieldset", { className, id: fieldPathId.$id, children: [title && (0, import_jsx_runtime33.jsx)(TitleFieldTemplate, { id: titleId(fieldPathId), title, required, schema, uiSchema, registry, optionalDataControl: showOptionalDataControlInTitle ? optionalDataControl : void 0 }), description && (0, import_jsx_runtime33.jsx)(DescriptionFieldTemplate, { id: descriptionId(fieldPathId), description, schema, uiSchema, registry }), !showOptionalDataControlInTitle ? optionalDataControl : void 0, properties.map((prop) => prop.content), canExpand(schema, uiSchema, formData) && (0, import_jsx_runtime33.jsx)(AddButton2, { id: buttonId(fieldPathId, "add"), className: "rjsf-object-property-expand", onClick: onAddProperty, disabled: disabled || readonly, uiSchema, registry })] });
}

// node_modules/@rjsf/core/lib/components/templates/OptionalDataControlsTemplate.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
function OptionalDataControlsTemplate(props) {
  const { id, registry, label, onAddClick, onRemoveClick } = props;
  if (onAddClick) {
    return (0, import_jsx_runtime34.jsx)(IconButton, { id, registry, icon: "plus", className: "rjsf-add-optional-data btn-sm", onClick: onAddClick, title: label });
  } else if (onRemoveClick) {
    return (0, import_jsx_runtime34.jsx)(IconButton, { id, registry, icon: "remove", className: "rjsf-remove-optional-data btn-sm", onClick: onRemoveClick, title: label });
  }
  return (0, import_jsx_runtime34.jsx)("em", { id, children: label });
}

// node_modules/@rjsf/core/lib/components/templates/TitleField.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var REQUIRED_FIELD_SYMBOL2 = "*";
function TitleField(props) {
  const { id, title, required, optionalDataControl } = props;
  return (0, import_jsx_runtime35.jsxs)("legend", { id, children: [title, required && (0, import_jsx_runtime35.jsx)("span", { className: "required", children: REQUIRED_FIELD_SYMBOL2 }), optionalDataControl && (0, import_jsx_runtime35.jsx)("span", { className: "pull-right", style: { marginBottom: "2px" }, children: optionalDataControl })] });
}

// node_modules/@rjsf/core/lib/components/templates/UnsupportedField.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
function UnsupportedField(props) {
  const { schema, fieldPathId, reason, registry } = props;
  const { translateString } = registry;
  let translateEnum = TranslatableString.UnsupportedField;
  const translateParams = [];
  if (fieldPathId && fieldPathId.$id) {
    translateEnum = TranslatableString.UnsupportedFieldWithId;
    translateParams.push(fieldPathId.$id);
  }
  if (reason) {
    translateEnum = translateEnum === TranslatableString.UnsupportedField ? TranslatableString.UnsupportedFieldWithReason : TranslatableString.UnsupportedFieldWithIdAndReason;
    translateParams.push(reason);
  }
  return (0, import_jsx_runtime36.jsxs)("div", { className: "unsupported-field", children: [(0, import_jsx_runtime36.jsx)("p", { children: (0, import_jsx_runtime36.jsx)(Xn, { options: { disableParsingRawHTML: true }, children: translateString(translateEnum, translateParams) }) }), schema && (0, import_jsx_runtime36.jsx)("pre", { children: JSON.stringify(schema, null, 2) })] });
}
var UnsupportedField_default = UnsupportedField;

// node_modules/@rjsf/core/lib/components/templates/WrapIfAdditionalTemplate.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
function WrapIfAdditionalTemplate(props) {
  const { id, classNames, style, disabled, displayLabel, label, onKeyRenameBlur, onRemoveProperty, rawDescription, readonly, required, schema, hideError, rawErrors, children, uiSchema, registry } = props;
  const { templates: templates2, translateString } = registry;
  const { RemoveButton: RemoveButton2 } = templates2.ButtonTemplates;
  const keyLabel = translateString(TranslatableString.KeyLabel, [label]);
  const additional = ADDITIONAL_PROPERTY_FLAG in schema;
  const hasDescription = !!rawDescription;
  const classNamesList = ["form-group", classNames];
  if (!hideError && rawErrors && rawErrors.length > 0) {
    classNamesList.push("has-error has-danger");
  }
  const uiClassNames = classNamesList.join(" ").trim();
  if (!additional) {
    return (0, import_jsx_runtime37.jsx)("div", { className: uiClassNames, style, children });
  }
  const margin = hasDescription ? 46 : 26;
  return (0, import_jsx_runtime37.jsx)("div", { className: uiClassNames, style, children: (0, import_jsx_runtime37.jsxs)("div", { className: "row", children: [(0, import_jsx_runtime37.jsx)("div", { className: "col-xs-5 form-additional", children: (0, import_jsx_runtime37.jsxs)("div", { className: "form-group", children: [displayLabel && (0, import_jsx_runtime37.jsx)(Label, { label: keyLabel, required, id: `${id}-key` }), displayLabel && rawDescription && (0, import_jsx_runtime37.jsx)("div", { children: "" }), (0, import_jsx_runtime37.jsx)("input", { className: "form-control", type: "text", id: `${id}-key`, onBlur: onKeyRenameBlur, defaultValue: label })] }) }), (0, import_jsx_runtime37.jsx)("div", { className: "form-additional form-group col-xs-5", children }), (0, import_jsx_runtime37.jsx)("div", { className: "col-xs-2", style: { marginTop: displayLabel ? `${margin}px` : void 0 }, children: (0, import_jsx_runtime37.jsx)(RemoveButton2, { id: buttonId(id, "remove"), className: "rjsf-object-property-remove btn-block", style: { border: "0" }, disabled: disabled || readonly, onClick: onRemoveProperty, uiSchema, registry }) })] }) });
}

// node_modules/@rjsf/core/lib/components/templates/index.js
function templates() {
  return {
    ArrayFieldDescriptionTemplate,
    ArrayFieldItemTemplate,
    ArrayFieldItemButtonsTemplate,
    ArrayFieldTemplate,
    ArrayFieldTitleTemplate,
    ButtonTemplates: ButtonTemplates_default(),
    BaseInputTemplate,
    DescriptionFieldTemplate: DescriptionField,
    ErrorListTemplate: ErrorList,
    FallbackFieldTemplate,
    FieldTemplate: FieldTemplate_default,
    FieldErrorTemplate,
    FieldHelpTemplate,
    GridTemplate,
    MultiSchemaFieldTemplate,
    ObjectFieldTemplate,
    OptionalDataControlsTemplate,
    TitleFieldTemplate: TitleField,
    UnsupportedFieldTemplate: UnsupportedField_default,
    WrapIfAdditionalTemplate
  };
}
var templates_default = templates;

// node_modules/@rjsf/core/lib/components/widgets/AltDateWidget.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
function AltDateWidget(props) {
  const { disabled = false, readonly = false, autofocus = false, options, id, name, registry, onBlur, onFocus } = props;
  const { translateString } = registry;
  const { elements, handleChange, handleClear, handleSetNow } = useAltDateWidgetProps(props);
  return (0, import_jsx_runtime38.jsxs)("ul", { className: "list-inline", children: [elements.map((elemProps, i2) => (0, import_jsx_runtime38.jsx)("li", { className: "list-inline-item", children: (0, import_jsx_runtime38.jsx)(DateElement, { rootId: id, name, select: handleChange, ...elemProps, disabled, readonly, registry, onBlur, onFocus, autofocus: autofocus && i2 === 0 }) }, i2)), (options.hideNowButton !== "undefined" ? !options.hideNowButton : true) && (0, import_jsx_runtime38.jsx)("li", { className: "list-inline-item", children: (0, import_jsx_runtime38.jsx)("a", { href: "#", className: "btn btn-info btn-now", onClick: handleSetNow, children: translateString(TranslatableString.NowLabel) }) }), (options.hideClearButton !== "undefined" ? !options.hideClearButton : true) && (0, import_jsx_runtime38.jsx)("li", { className: "list-inline-item", children: (0, import_jsx_runtime38.jsx)("a", { href: "#", className: "btn btn-warning btn-clear", onClick: handleClear, children: translateString(TranslatableString.ClearLabel) }) })] });
}
var AltDateWidget_default = AltDateWidget;

// node_modules/@rjsf/core/lib/components/widgets/AltDateTimeWidget.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
function AltDateTimeWidget({ time = true, ...props }) {
  const { AltDateWidget: AltDateWidget2 } = props.registry.widgets;
  return (0, import_jsx_runtime39.jsx)(AltDateWidget2, { time, ...props });
}
var AltDateTimeWidget_default = AltDateTimeWidget;

// node_modules/@rjsf/core/lib/components/widgets/CheckboxWidget.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
function CheckboxWidget({ schema, uiSchema, options, id, value, disabled, readonly, label, hideLabel, autofocus = false, onBlur, onFocus, onChange, registry, htmlName }) {
  const DescriptionFieldTemplate = getTemplate("DescriptionFieldTemplate", registry, options);
  const required = schemaRequiresTrueValue(schema);
  const handleChange = (0, import_react13.useCallback)((event) => onChange(event.target.checked), [onChange]);
  const handleBlur = (0, import_react13.useCallback)((event) => onBlur(id, event.target.checked), [onBlur, id]);
  const handleFocus = (0, import_react13.useCallback)((event) => onFocus(id, event.target.checked), [onFocus, id]);
  const uiOptions = getUiOptions(uiSchema);
  const isCheckboxWidget = uiOptions.widget === "checkbox";
  const description = isCheckboxWidget ? void 0 : options.description ?? schema.description;
  return (0, import_jsx_runtime40.jsxs)("div", { className: `checkbox ${disabled || readonly ? "disabled" : ""}`, children: [!hideLabel && description && (0, import_jsx_runtime40.jsx)(DescriptionFieldTemplate, { id: descriptionId(id), description, schema, uiSchema, registry }), (0, import_jsx_runtime40.jsxs)("label", { children: [(0, import_jsx_runtime40.jsx)("input", { type: "checkbox", id, name: htmlName || id, checked: typeof value === "undefined" ? false : value, required, disabled: disabled || readonly, autoFocus: autofocus, onChange: handleChange, onBlur: handleBlur, onFocus: handleFocus, "aria-describedby": ariaDescribedByIds(id) }), labelValue((0, import_jsx_runtime40.jsx)("span", { children: label }), hideLabel)] })] });
}
var CheckboxWidget_default = CheckboxWidget;

// node_modules/@rjsf/core/lib/components/widgets/CheckboxesWidget.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
function CheckboxesWidget({ id, disabled, options: { inline = false, enumOptions, enumDisabled, emptyValue }, value, autofocus = false, readonly, onChange, onBlur, onFocus, htmlName }) {
  const checkboxesValues = Array.isArray(value) ? value : [value];
  const handleBlur = (0, import_react14.useCallback)(({ target }) => onBlur(id, enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)), [onBlur, id, enumOptions, emptyValue]);
  const handleFocus = (0, import_react14.useCallback)(({ target }) => onFocus(id, enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)), [onFocus, id, enumOptions, emptyValue]);
  return (0, import_jsx_runtime41.jsx)("div", { className: "checkboxes", id, children: Array.isArray(enumOptions) && enumOptions.map((option, index) => {
    const checked = enumOptionsIsSelected(option.value, checkboxesValues);
    const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
    const disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
    const handleChange = (event) => {
      if (event.target.checked) {
        onChange(enumOptionsSelectValue(index, checkboxesValues, enumOptions));
      } else {
        onChange(enumOptionsDeselectValue(index, checkboxesValues, enumOptions));
      }
    };
    const checkbox = (0, import_jsx_runtime41.jsxs)("span", { children: [(0, import_jsx_runtime41.jsx)("input", { type: "checkbox", id: optionId(id, index), name: htmlName || id, checked, value: String(index), disabled: disabled || itemDisabled || readonly, autoFocus: autofocus && index === 0, onChange: handleChange, onBlur: handleBlur, onFocus: handleFocus, "aria-describedby": ariaDescribedByIds(id) }), (0, import_jsx_runtime41.jsx)("span", { children: option.label })] });
    return inline ? (0, import_jsx_runtime41.jsx)("label", { className: `checkbox-inline ${disabledCls}`, children: checkbox }, index) : (0, import_jsx_runtime41.jsx)("div", { className: `checkbox ${disabledCls}`, children: (0, import_jsx_runtime41.jsx)("label", { children: checkbox }) }, index);
  }) });
}
var CheckboxesWidget_default = CheckboxesWidget;

// node_modules/@rjsf/core/lib/components/widgets/ColorWidget.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
function ColorWidget(props) {
  const { disabled, readonly, options, registry } = props;
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  return (0, import_jsx_runtime42.jsx)(BaseInputTemplate2, { type: "color", ...props, disabled: disabled || readonly });
}

// node_modules/@rjsf/core/lib/components/widgets/DateWidget.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
function DateWidget(props) {
  const { onChange, options, registry } = props;
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  const handleChange = (0, import_react15.useCallback)((value) => onChange(value || void 0), [onChange]);
  return (0, import_jsx_runtime43.jsx)(BaseInputTemplate2, { type: "date", ...props, onChange: handleChange });
}

// node_modules/@rjsf/core/lib/components/widgets/DateTimeWidget.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
function DateTimeWidget(props) {
  const { onChange, value, options, registry } = props;
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  return (0, import_jsx_runtime44.jsx)(BaseInputTemplate2, { type: "datetime-local", ...props, value: utcToLocal(value), onChange: (value2) => onChange(localToUTC(value2)) });
}

// node_modules/@rjsf/core/lib/components/widgets/EmailWidget.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
function EmailWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  return (0, import_jsx_runtime45.jsx)(BaseInputTemplate2, { type: "email", ...props });
}

// node_modules/@rjsf/core/lib/components/widgets/FileWidget.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
function FileInfoPreview({ fileInfo, registry }) {
  const { translateString } = registry;
  const { dataURL, type, name } = fileInfo;
  if (!dataURL) {
    return null;
  }
  if (["image/jpeg", "image/png"].includes(type)) {
    return (0, import_jsx_runtime46.jsx)("img", { src: dataURL, style: { maxWidth: "100%" }, className: "file-preview" });
  }
  return (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [" ", (0, import_jsx_runtime46.jsx)("a", { download: `preview-${name}`, href: dataURL, className: "file-download", children: translateString(TranslatableString.PreviewLabel) })] });
}
function FilesInfo({ filesInfo, registry, preview, onRemove, options }) {
  if (filesInfo.length === 0) {
    return null;
  }
  const { translateString } = registry;
  const { RemoveButton: RemoveButton2 } = getTemplate("ButtonTemplates", registry, options);
  return (0, import_jsx_runtime46.jsx)("ul", { className: "file-info", children: filesInfo.map((fileInfo, key) => {
    const { name, size, type } = fileInfo;
    const handleRemove = () => onRemove(key);
    return (0, import_jsx_runtime46.jsxs)("li", { children: [(0, import_jsx_runtime46.jsx)(Xn, { children: translateString(TranslatableString.FilesInfo, [name, type, String(size)]) }), preview && (0, import_jsx_runtime46.jsx)(FileInfoPreview, { fileInfo, registry }), (0, import_jsx_runtime46.jsx)(RemoveButton2, { onClick: handleRemove, registry })] }, key);
  }) });
}
function FileWidget(props) {
  const { disabled, readonly, required, multiple, onChange, value, options, registry } = props;
  const { filesInfo, handleChange, handleRemove } = useFileWidgetProps(value, onChange, multiple);
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  const handleOnChangeEvent = (event) => {
    if (event.target.files) {
      handleChange(event.target.files);
    }
  };
  return (0, import_jsx_runtime46.jsxs)("div", { children: [(0, import_jsx_runtime46.jsx)(BaseInputTemplate2, { ...props, disabled: disabled || readonly, type: "file", required: value ? false : required, onChangeOverride: handleOnChangeEvent, value: "", accept: options.accept ? String(options.accept) : void 0 }), (0, import_jsx_runtime46.jsx)(FilesInfo, { filesInfo, onRemove: handleRemove, registry, preview: options.filePreview, options })] });
}
var FileWidget_default = FileWidget;

// node_modules/@rjsf/core/lib/components/widgets/HiddenWidget.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
function HiddenWidget({ id, value, htmlName }) {
  return (0, import_jsx_runtime47.jsx)("input", { type: "hidden", id, name: htmlName || id, value: typeof value === "undefined" ? "" : value });
}
var HiddenWidget_default = HiddenWidget;

// node_modules/@rjsf/core/lib/components/widgets/PasswordWidget.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
function PasswordWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  return (0, import_jsx_runtime48.jsx)(BaseInputTemplate2, { type: "password", ...props });
}

// node_modules/@rjsf/core/lib/components/widgets/RadioWidget.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
function RadioWidget({ options, value, required, disabled, readonly, autofocus = false, onBlur, onFocus, onChange, id, htmlName }) {
  const { enumOptions, enumDisabled, inline, emptyValue } = options;
  const handleBlur = (0, import_react16.useCallback)(({ target }) => onBlur(id, enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)), [onBlur, enumOptions, emptyValue, id]);
  const handleFocus = (0, import_react16.useCallback)(({ target }) => onFocus(id, enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue)), [onFocus, enumOptions, emptyValue, id]);
  return (0, import_jsx_runtime49.jsx)("div", { className: "field-radio-group", id, role: "radiogroup", children: Array.isArray(enumOptions) && enumOptions.map((option, i2) => {
    const checked = enumOptionsIsSelected(option.value, value);
    const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
    const disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
    const handleChange = () => onChange(option.value);
    const radio = (0, import_jsx_runtime49.jsxs)("span", { children: [(0, import_jsx_runtime49.jsx)("input", { type: "radio", id: optionId(id, i2), checked, name: htmlName || id, required, value: String(i2), disabled: disabled || itemDisabled || readonly, autoFocus: autofocus && i2 === 0, onChange: handleChange, onBlur: handleBlur, onFocus: handleFocus, "aria-describedby": ariaDescribedByIds(id) }), (0, import_jsx_runtime49.jsx)("span", { children: option.label })] });
    return inline ? (0, import_jsx_runtime49.jsx)("label", { className: `radio-inline ${disabledCls}`, children: radio }, i2) : (0, import_jsx_runtime49.jsx)("div", { className: `radio ${disabledCls}`, children: (0, import_jsx_runtime49.jsx)("label", { children: radio }) }, i2);
  }) });
}
var RadioWidget_default = RadioWidget;

// node_modules/@rjsf/core/lib/components/widgets/RangeWidget.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
function RangeWidget(props) {
  const { value, registry: { templates: { BaseInputTemplate: BaseInputTemplate2 } } } = props;
  return (0, import_jsx_runtime50.jsxs)("div", { className: "field-range-wrapper", children: [(0, import_jsx_runtime50.jsx)(BaseInputTemplate2, { type: "range", ...props }), (0, import_jsx_runtime50.jsx)("span", { className: "range-view", children: value })] });
}

// node_modules/@rjsf/core/lib/components/widgets/RatingWidget.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);
function RatingWidget({ id, value, required, disabled, readonly, autofocus, onChange, onFocus, onBlur, schema, options, htmlName }) {
  const { stars = 5, shape = "star" } = options;
  const numStars = schema.maximum ? Math.min(schema.maximum, 5) : Math.min(Math.max(stars, 1), 5);
  const min = schema.minimum || 0;
  const handleStarClick = (0, import_react17.useCallback)((starValue) => {
    if (!disabled && !readonly) {
      onChange(starValue);
    }
  }, [onChange, disabled, readonly]);
  const handleFocus = (0, import_react17.useCallback)((event) => {
    if (onFocus) {
      const starValue = Number(event.target.dataset.value);
      onFocus(id, starValue);
    }
  }, [onFocus, id]);
  const handleBlur = (0, import_react17.useCallback)((event) => {
    if (onBlur) {
      const starValue = Number(event.target.dataset.value);
      onBlur(id, starValue);
    }
  }, [onBlur, id]);
  const getSymbol = (isFilled) => {
    if (shape === "heart") {
      return isFilled ? "" : "";
    }
    return isFilled ? "" : "";
  };
  return (0, import_jsx_runtime51.jsx)(import_jsx_runtime51.Fragment, { children: (0, import_jsx_runtime51.jsxs)("div", { className: "rating-widget", style: {
    display: "inline-flex",
    fontSize: "1.5rem",
    cursor: disabled || readonly ? "default" : "pointer"
  }, children: [[...Array(numStars)].map((_2, index) => {
    const starValue = min + index;
    const isFilled = starValue <= value;
    return (0, import_jsx_runtime51.jsx)("span", { onClick: () => handleStarClick(starValue), onFocus: handleFocus, onBlur: handleBlur, "data-value": starValue, tabIndex: disabled || readonly ? -1 : 0, role: "radio", "aria-checked": starValue === value, "aria-label": `${starValue} ${shape === "heart" ? "heart" : "star"}${starValue === 1 ? "" : "s"}`, style: {
      color: isFilled ? "#FFD700" : "#ccc",
      padding: "0 0.2rem",
      transition: "color 0.2s",
      userSelect: "none"
    }, children: getSymbol(isFilled) }, index);
  }), (0, import_jsx_runtime51.jsx)("input", { type: "hidden", id, name: htmlName || id, value: value || "", required, disabled: disabled || readonly, "aria-hidden": "true" })] }) });
}

// node_modules/@rjsf/core/lib/components/widgets/SelectWidget.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
function getValue(event, multiple) {
  if (multiple) {
    return Array.from(event.target.options).slice().filter((o2) => o2.selected).map((o2) => o2.value);
  }
  return event.target.value;
}
function SelectWidget({ schema, id, options, value, required, disabled, readonly, multiple = false, autofocus = false, onChange, onBlur, onFocus, placeholder, htmlName }) {
  const { enumOptions, enumDisabled, emptyValue: optEmptyVal } = options;
  const emptyValue = multiple ? [] : "";
  const handleFocus = (0, import_react18.useCallback)((event) => {
    const newValue = getValue(event, multiple);
    return onFocus(id, enumOptionsValueForIndex(newValue, enumOptions, optEmptyVal));
  }, [onFocus, id, multiple, enumOptions, optEmptyVal]);
  const handleBlur = (0, import_react18.useCallback)((event) => {
    const newValue = getValue(event, multiple);
    return onBlur(id, enumOptionsValueForIndex(newValue, enumOptions, optEmptyVal));
  }, [onBlur, id, multiple, enumOptions, optEmptyVal]);
  const handleChange = (0, import_react18.useCallback)((event) => {
    const newValue = getValue(event, multiple);
    return onChange(enumOptionsValueForIndex(newValue, enumOptions, optEmptyVal));
  }, [onChange, multiple, enumOptions, optEmptyVal]);
  const selectedIndexes = enumOptionsIndexForValue(value, enumOptions, multiple);
  const showPlaceholderOption = !multiple && schema.default === void 0;
  return (0, import_jsx_runtime52.jsxs)("select", { id, name: htmlName || id, multiple, role: "combobox", className: "form-control", value: typeof selectedIndexes === "undefined" ? emptyValue : selectedIndexes, required, disabled: disabled || readonly, autoFocus: autofocus, onBlur: handleBlur, onFocus: handleFocus, onChange: handleChange, "aria-describedby": ariaDescribedByIds(id), children: [showPlaceholderOption && (0, import_jsx_runtime52.jsx)("option", { value: "", children: placeholder }), Array.isArray(enumOptions) && enumOptions.map(({ value: value2, label }, i2) => {
    const disabled2 = enumDisabled && enumDisabled.indexOf(value2) !== -1;
    return (0, import_jsx_runtime52.jsx)("option", { value: String(i2), disabled: disabled2, children: label }, i2);
  })] });
}
var SelectWidget_default = SelectWidget;

// node_modules/@rjsf/core/lib/components/widgets/TextareaWidget.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
function TextareaWidget({ id, options = {}, placeholder, value, required, disabled, readonly, autofocus = false, onChange, onBlur, onFocus, htmlName }) {
  const handleChange = (0, import_react19.useCallback)(({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2), [onChange, options.emptyValue]);
  const handleBlur = (0, import_react19.useCallback)(({ target }) => onBlur(id, target && target.value), [onBlur, id]);
  const handleFocus = (0, import_react19.useCallback)(({ target }) => onFocus(id, target && target.value), [id, onFocus]);
  return (0, import_jsx_runtime53.jsx)("textarea", { id, name: htmlName || id, className: "form-control", value: value ? value : "", placeholder, required, disabled, readOnly: readonly, autoFocus: autofocus, rows: options.rows, onBlur: handleBlur, onFocus: handleFocus, onChange: handleChange, "aria-describedby": ariaDescribedByIds(id) });
}
TextareaWidget.defaultProps = {
  autofocus: false,
  options: {}
};
var TextareaWidget_default = TextareaWidget;

// node_modules/@rjsf/core/lib/components/widgets/TextWidget.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
function TextWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  return (0, import_jsx_runtime54.jsx)(BaseInputTemplate2, { ...props });
}

// node_modules/@rjsf/core/lib/components/widgets/TimeWidget.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
function TimeWidget(props) {
  const { onChange, options, registry } = props;
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  const handleChange = (0, import_react20.useCallback)((value) => onChange(value ? `${value}:00` : void 0), [onChange]);
  return (0, import_jsx_runtime55.jsx)(BaseInputTemplate2, { type: "time", ...props, onChange: handleChange });
}

// node_modules/@rjsf/core/lib/components/widgets/URLWidget.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
function URLWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  return (0, import_jsx_runtime56.jsx)(BaseInputTemplate2, { type: "url", ...props });
}

// node_modules/@rjsf/core/lib/components/widgets/UpDownWidget.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
function UpDownWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = getTemplate("BaseInputTemplate", registry, options);
  return (0, import_jsx_runtime57.jsx)(BaseInputTemplate2, { type: "number", ...props });
}

// node_modules/@rjsf/core/lib/components/widgets/index.js
function widgets() {
  return {
    AltDateWidget: AltDateWidget_default,
    AltDateTimeWidget: AltDateTimeWidget_default,
    CheckboxWidget: CheckboxWidget_default,
    CheckboxesWidget: CheckboxesWidget_default,
    ColorWidget,
    DateWidget,
    DateTimeWidget,
    EmailWidget,
    FileWidget: FileWidget_default,
    HiddenWidget: HiddenWidget_default,
    PasswordWidget,
    RadioWidget: RadioWidget_default,
    RangeWidget,
    RatingWidget,
    SelectWidget: SelectWidget_default,
    TextWidget,
    TextareaWidget: TextareaWidget_default,
    TimeWidget,
    UpDownWidget,
    URLWidget
  };
}
var widgets_default = widgets;

// node_modules/@rjsf/core/lib/getDefaultRegistry.js
function getDefaultRegistry() {
  return {
    fields: fields_default(),
    templates: templates_default(),
    widgets: widgets_default(),
    rootSchema: {},
    formContext: {},
    translateString: englishStringTranslator,
    globalFormOptions: {
      idPrefix: DEFAULT_ID_PREFIX,
      idSeparator: DEFAULT_ID_SEPARATOR,
      useFallbackUiForUnsupportedType: false
    }
  };
}

// node_modules/@rjsf/core/lib/components/Form.js
function toIChangeEvent(state, status) {
  return {
    ...pick_default(state, ["schema", "uiSchema", "fieldPathId", "schemaUtils", "formData", "edit", "errors", "errorSchema"]),
    ...status !== void 0 && { status }
  };
}
var Form = class extends import_react21.Component {
  /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
   * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
   * state construction.
   *
   * @param props - The initial props for the `Form`
   */
  constructor(props) {
    super(props);
    /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can
     * provide any possible type here
     */
    __publicField(this, "formElement");
    /** The list of pending changes
     */
    __publicField(this, "pendingChanges", []);
    /** Returns the `formData` with only the elements specified in the `fields` list
     *
     * @param formData - The data for the `Form`
     * @param fields - The fields to keep while filtering
     */
    __publicField(this, "getUsedFormData", (formData, fields2) => {
      if (fields2.length === 0 && typeof formData !== "object") {
        return formData;
      }
      const data = pick_default(formData, fields2);
      if (Array.isArray(formData)) {
        return Object.keys(data).map((key) => data[key]);
      }
      return data;
    });
    /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
     *
     * @param pathSchema - The `PathSchema` object for the form
     * @param [formData] - The form data to use while checking for empty objects/arrays
     */
    __publicField(this, "getFieldNames", (pathSchema, formData) => {
      const formValueHasData = (value, isLeaf) => typeof value !== "object" || isEmpty_default(value) || isLeaf && !isEmpty_default(value);
      const getAllPaths = (_obj, acc = [], paths = [[]]) => {
        const objKeys = Object.keys(_obj);
        objKeys.forEach((key) => {
          const data = _obj[key];
          if (typeof data === "object") {
            const newPaths = paths.map((path) => [...path, key]);
            if (data[RJSF_ADDITIONAL_PROPERTIES_FLAG] && data[NAME_KEY] !== "") {
              acc.push(data[NAME_KEY]);
            } else {
              getAllPaths(data, acc, newPaths);
            }
          } else if (key === NAME_KEY && data !== "") {
            paths.forEach((path) => {
              const formValue = get_default(formData, path);
              const isLeaf = objKeys.length === 1;
              if (formValueHasData(formValue, isLeaf) || Array.isArray(formValue) && formValue.every((val) => formValueHasData(val, isLeaf))) {
                acc.push(path);
              }
            });
          }
        });
        return acc;
      };
      return getAllPaths(pathSchema);
    });
    /** Returns the `formData` after filtering to remove any extra data not in a form field
     *
     * @param formData - The data for the `Form`
     * @returns The `formData` after omitting extra data
     */
    __publicField(this, "omitExtraData", (formData) => {
      const { schema, schemaUtils } = this.state;
      const retrievedSchema = schemaUtils.retrieveSchema(schema, formData);
      const pathSchema = schemaUtils.toPathSchema(retrievedSchema, "", formData);
      const fieldNames = this.getFieldNames(pathSchema, formData);
      return this.getUsedFormData(formData, fieldNames);
    });
    /** Allows a user to set a value for the provided `fieldPath`, which must be either a dotted path to the field OR a
     * `FieldPathList`. To set the root element, used either `''` or `[]` for the path. Passing undefined will clear the
     * value in the field.
     *
     * @param fieldPath - Either a dotted path to the field or the `FieldPathList` to the field
     * @param [newValue] - The new value for the field
     */
    __publicField(this, "setFieldValue", (fieldPath, newValue) => {
      const { registry } = this.state;
      const path = Array.isArray(fieldPath) ? fieldPath : fieldPath.split(".");
      const fieldPathId = toFieldPathId("", registry.globalFormOptions, path);
      this.onChange(newValue, path, void 0, fieldPathId[ID_KEY]);
    });
    /** Pushes the given change information into the `pendingChanges` array and then calls `processPendingChanges()` if
     * the array only contains a single pending change.
     *
     * @param newValue - The new form data from a change to a field
     * @param path - The path to the change into which to set the formData
     * @param [newErrorSchema] - The new `ErrorSchema` based on the field change
     * @param [id] - The id of the field that caused the change
     */
    __publicField(this, "onChange", (newValue, path, newErrorSchema, id) => {
      this.pendingChanges.push({ newValue, path, newErrorSchema, id });
      if (this.pendingChanges.length === 1) {
        this.processPendingChange();
      }
    });
    /**
     * Callback function to handle reset form data.
     * - Reset all fields with default values.
     * - Reset validations and errors
     *
     */
    __publicField(this, "reset", () => {
      const { formData: propsFormData, initialFormData = IS_RESET, onChange } = this.props;
      const newState = this.getStateFromProps(this.props, propsFormData ?? initialFormData, void 0, void 0, void 0, true);
      const newFormData = newState.formData;
      const state = {
        formData: newFormData,
        errorSchema: {},
        errors: [],
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {},
        initialDefaultsGenerated: false,
        customErrors: void 0
      };
      this.setState(state, () => onChange && onChange(toIChangeEvent({ ...this.state, ...state })));
    });
    /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
     * was provided. Also runs any live validation and/or live omit operations if the flags indicate they should happen
     * during `onBlur`.
     *
     * @param id - The unique `id` of the field that was blurred
     * @param data - The data associated with the field that was blurred
     */
    __publicField(this, "onBlur", (id, data) => {
      const { onBlur, omitExtraData, liveOmit, liveValidate } = this.props;
      if (onBlur) {
        onBlur(id, data);
      }
      if (omitExtraData === true && liveOmit === "onBlur" || liveValidate === "onBlur") {
        const { onChange, extraErrors } = this.props;
        const { formData } = this.state;
        let newFormData = formData;
        let state = { formData: newFormData };
        if (omitExtraData === true && liveOmit === "onBlur") {
          newFormData = this.omitExtraData(formData);
          state = { formData: newFormData };
        }
        if (liveValidate === "onBlur") {
          const { schema, schemaUtils, errorSchema, customErrors, retrievedSchema } = this.state;
          const liveValidation = this.liveValidate(schema, schemaUtils, errorSchema, newFormData, extraErrors, customErrors, retrievedSchema);
          state = { formData: newFormData, ...liveValidation, customErrors };
        }
        const hasChanges = Object.keys(state).filter((key) => !key.startsWith("schemaValidation")).some((key) => {
          const oldData = get_default(this.state, key);
          const newData = get_default(state, key);
          return !deepEquals(oldData, newData);
        });
        this.setState(state, () => {
          if (onChange && hasChanges) {
            onChange(toIChangeEvent({ ...this.state, ...state }), id);
          }
        });
      }
    });
    /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
     * was provided.
     *
     * @param id - The unique `id` of the field that was focused
     * @param data - The data associated with the field that was focused
     */
    __publicField(this, "onFocus", (id, data) => {
      const { onFocus } = this.props;
      if (onFocus) {
        onFocus(id, data);
      }
    });
    /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
     * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
     * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
     * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
     * back the `onSubmit` callback if it was provided.
     *
     * @param event - The submit HTML form event
     */
    __publicField(this, "onSubmit", (event) => {
      event.preventDefault();
      if (event.target !== event.currentTarget) {
        return;
      }
      event.persist();
      const { omitExtraData, extraErrors, noValidate, onSubmit } = this.props;
      let { formData: newFormData } = this.state;
      if (omitExtraData === true) {
        newFormData = this.omitExtraData(newFormData);
      }
      if (noValidate || this.validateFormWithFormData(newFormData)) {
        const errorSchema = extraErrors || {};
        const errors = extraErrors ? toErrorList(extraErrors) : [];
        this.setState({
          formData: newFormData,
          errors,
          errorSchema,
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        }, () => {
          if (onSubmit) {
            onSubmit(toIChangeEvent({ ...this.state, formData: newFormData }, "submitted"), event);
          }
        });
      }
    });
    /** Provides a function that can be used to programmatically submit the `Form` */
    __publicField(this, "submit", () => {
      if (this.formElement.current) {
        const submitCustomEvent = new CustomEvent("submit", {
          cancelable: true
        });
        submitCustomEvent.preventDefault();
        this.formElement.current.dispatchEvent(submitCustomEvent);
        this.formElement.current.requestSubmit();
      }
    });
    /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.
     * If `onError` is provided, then it will be called with the list of errors.
     *
     * @param formData - The form data to validate
     * @returns - True if the form is valid, false otherwise.
     */
    __publicField(this, "validateFormWithFormData", (formData) => {
      const { extraErrors, extraErrorsBlockSubmit, focusOnFirstError, onError } = this.props;
      const { errors: prevErrors } = this.state;
      const schemaValidation = this.validate(formData);
      let errors = schemaValidation.errors;
      let errorSchema = schemaValidation.errorSchema;
      const schemaValidationErrors = errors;
      const schemaValidationErrorSchema = errorSchema;
      const hasError = errors.length > 0 || extraErrors && extraErrorsBlockSubmit;
      if (hasError) {
        if (extraErrors) {
          const merged = validationDataMerge(schemaValidation, extraErrors);
          errorSchema = merged.errorSchema;
          errors = merged.errors;
        }
        if (focusOnFirstError) {
          if (typeof focusOnFirstError === "function") {
            focusOnFirstError(errors[0]);
          } else {
            this.focusOnError(errors[0]);
          }
        }
        this.setState({
          errors,
          errorSchema,
          schemaValidationErrors,
          schemaValidationErrorSchema
        }, () => {
          if (onError) {
            onError(errors);
          } else {
            console.error("Form validation failed", errors);
          }
        });
      } else if (prevErrors.length > 0) {
        this.setState({
          errors: [],
          errorSchema: {},
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        });
      }
      return !hasError;
    });
    if (!props.validator) {
      throw new Error("A validator is required for Form functionality to work");
    }
    const { formData: propsFormData, initialFormData, onChange } = props;
    const formData = propsFormData ?? initialFormData;
    this.state = this.getStateFromProps(props, formData, void 0, void 0, void 0, true);
    if (onChange && !deepEquals(this.state.formData, formData)) {
      onChange(toIChangeEvent(this.state));
    }
    this.formElement = (0, import_react21.createRef)();
  }
  /**
   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
   * they are potentially changed.
   *
   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
   * state ready to be applied in `componentDidUpdate`.
   *
   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
   * state update is not necessary.
   *
   * @param prevProps - The previous set of props before the update.
   * @param prevState - The previous state before the update.
   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
   *        with a flag indicating that an update is not necessary.
   */
  getSnapshotBeforeUpdate(prevProps, prevState) {
    if (!deepEquals(this.props, prevProps)) {
      const formDataChangedFields = getChangedFields(this.props.formData, prevProps.formData);
      const stateDataChangedFields = getChangedFields(this.props.formData, this.state.formData);
      const isSchemaChanged = !deepEquals(prevProps.schema, this.props.schema);
      const isFormDataChanged = formDataChangedFields.length > 0 || !deepEquals(prevProps.formData, this.props.formData);
      const isStateDataChanged = stateDataChangedFields.length > 0 || !deepEquals(this.state.formData, this.props.formData);
      const nextState = this.getStateFromProps(
        this.props,
        this.props.formData,
        // If the `schema` has changed, we need to update the retrieved schema.
        // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
        //  match one of the subSchemas, the retrieved schema must be updated.
        isSchemaChanged || isFormDataChanged ? void 0 : this.state.retrievedSchema,
        isSchemaChanged,
        formDataChangedFields,
        // Skip live validation for this request if no form data has changed from the last state
        !isStateDataChanged
      );
      const shouldUpdate = !deepEquals(nextState, prevState);
      return { nextState, shouldUpdate };
    }
    return { shouldUpdate: false };
  }
  /**
   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
   * not called for the initial render.
   *
   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
   * changes.
   *
   * @param _ - The previous set of props.
   * @param prevState - The previous state of the component before the update.
   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
   */
  componentDidUpdate(_2, prevState, snapshot) {
    if (snapshot.shouldUpdate) {
      const { nextState } = snapshot;
      if (!deepEquals(nextState.formData, this.props.formData) && !deepEquals(nextState.formData, prevState.formData) && this.props.onChange) {
        this.props.onChange(toIChangeEvent(nextState));
      }
      this.setState(nextState);
    }
  }
  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
   * validation process IF required by the `props`.
   *
   * @param props - The props passed to the `Form`
   * @param inputFormData - The new or current data for the `Form`
   * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
   * @param isSchemaChanged - A flag indicating whether the schema has changed.
   * @param formDataChangedFields - The changed fields of `formData`
   * @param skipLiveValidate - Optional flag, if true, means that we are not running live validation
   * @returns - The new state for the `Form`
   */
  getStateFromProps(props, inputFormData, retrievedSchema, isSchemaChanged = false, formDataChangedFields = [], skipLiveValidate = false) {
    var _a;
    const state = this.state || {};
    const schema = "schema" in props ? props.schema : this.props.schema;
    const validator = "validator" in props ? props.validator : this.props.validator;
    const uiSchema = ("uiSchema" in props ? props.uiSchema : this.props.uiSchema) || {};
    const isUncontrolled = props.formData === void 0 && this.props.formData === void 0;
    const edit = typeof inputFormData !== "undefined";
    const liveValidate = "liveValidate" in props ? props.liveValidate : this.props.liveValidate;
    const mustValidate = edit && !props.noValidate && liveValidate;
    const experimental_defaultFormStateBehavior = "experimental_defaultFormStateBehavior" in props ? props.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior;
    const experimental_customMergeAllOf = "experimental_customMergeAllOf" in props ? props.experimental_customMergeAllOf : this.props.experimental_customMergeAllOf;
    let schemaUtils = state.schemaUtils;
    if (!schemaUtils || schemaUtils.doesSchemaUtilsDiffer(validator, schema, experimental_defaultFormStateBehavior, experimental_customMergeAllOf)) {
      schemaUtils = createSchemaUtils(validator, schema, experimental_defaultFormStateBehavior, experimental_customMergeAllOf);
    }
    const rootSchema = schemaUtils.getRootSchema();
    let defaultsFormData = inputFormData;
    if (inputFormData === IS_RESET) {
      defaultsFormData = void 0;
    } else if (inputFormData === void 0 && isUncontrolled) {
      defaultsFormData = state.formData;
    }
    const formData = schemaUtils.getDefaultFormState(rootSchema, defaultsFormData, false, state.initialDefaultsGenerated);
    const _retrievedSchema = this.updateRetrievedSchema(retrievedSchema ?? schemaUtils.retrieveSchema(rootSchema, formData));
    const getCurrentErrors = () => {
      if (props.noValidate || isSchemaChanged) {
        return { errors: [], errorSchema: {} };
      } else if (!props.liveValidate) {
        return {
          errors: state.schemaValidationErrors || [],
          errorSchema: state.schemaValidationErrorSchema || {}
        };
      }
      return {
        errors: state.errors || [],
        errorSchema: state.errorSchema || {}
      };
    };
    let errors;
    let errorSchema;
    let schemaValidationErrors = state.schemaValidationErrors;
    let schemaValidationErrorSchema = state.schemaValidationErrorSchema;
    if (mustValidate && !skipLiveValidate) {
      const liveValidation = this.liveValidate(
        rootSchema,
        schemaUtils,
        state.errorSchema,
        formData,
        void 0,
        state.customErrors,
        retrievedSchema,
        // If retrievedSchema is undefined which means the schema or formData has changed, we do not merge state.
        // Else in the case where it hasn't changed,
        retrievedSchema !== void 0
      );
      errors = liveValidation.errors;
      errorSchema = liveValidation.errorSchema;
      schemaValidationErrors = liveValidation.schemaValidationErrors;
      schemaValidationErrorSchema = liveValidation.schemaValidationErrorSchema;
    } else {
      const currentErrors = getCurrentErrors();
      errors = currentErrors.errors;
      errorSchema = currentErrors.errorSchema;
      if (formDataChangedFields.length > 0 && !mustValidate) {
        const newErrorSchema = formDataChangedFields.reduce((acc, key) => {
          acc[key] = void 0;
          return acc;
        }, {});
        errorSchema = schemaValidationErrorSchema = mergeObjects(currentErrors.errorSchema, newErrorSchema, "preventDuplicates");
      }
      const mergedErrors = this.mergeErrors({ errorSchema, errors }, props.extraErrors, state.customErrors);
      errors = mergedErrors.errors;
      errorSchema = mergedErrors.errorSchema;
    }
    const newRegistry = this.getRegistry(props, rootSchema, schemaUtils);
    const registry = deepEquals(state.registry, newRegistry) ? state.registry : newRegistry;
    const fieldPathId = state.fieldPathId && ((_a = state.fieldPathId) == null ? void 0 : _a[ID_KEY]) === registry.globalFormOptions.idPrefix ? state.fieldPathId : toFieldPathId("", registry.globalFormOptions);
    const nextState = {
      schemaUtils,
      schema: rootSchema,
      uiSchema,
      fieldPathId,
      formData,
      edit,
      errors,
      errorSchema,
      schemaValidationErrors,
      schemaValidationErrorSchema,
      retrievedSchema: _retrievedSchema,
      initialDefaultsGenerated: true,
      registry
    };
    return nextState;
  }
  /** React lifecycle method that is used to determine whether component should be updated.
   *
   * @param nextProps - The next version of the props
   * @param nextState - The next version of the state
   * @returns - True if the component should be updated, false otherwise
   */
  shouldComponentUpdate(nextProps, nextState) {
    const { experimental_componentUpdateStrategy = "customDeep" } = this.props;
    return shouldRender(this, nextProps, nextState, experimental_componentUpdateStrategy);
  }
  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
   * `schemaUtils` in the state), returning the results.
   *
   * @param formData - The new form data to validate
   * @param schema - The schema used to validate against
   * @param [altSchemaUtils] - The alternate schemaUtils to use for validation
   * @param [retrievedSchema] - An optionally retrieved schema for per
   */
  validate(formData, schema = this.state.schema, altSchemaUtils, retrievedSchema) {
    const schemaUtils = altSchemaUtils ? altSchemaUtils : this.state.schemaUtils;
    const { customValidate, transformErrors, uiSchema } = this.props;
    const resolvedSchema = retrievedSchema ?? schemaUtils.retrieveSchema(schema, formData);
    return schemaUtils.getValidator().validateFormData(formData, resolvedSchema, customValidate, transformErrors, uiSchema);
  }
  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
  renderErrors(registry) {
    const { errors, errorSchema, schema, uiSchema } = this.state;
    const options = getUiOptions(uiSchema);
    const ErrorListTemplate = getTemplate("ErrorListTemplate", registry, options);
    if (errors && errors.length) {
      return (0, import_jsx_runtime58.jsx)(ErrorListTemplate, { errors, errorSchema: errorSchema || {}, schema, uiSchema, registry });
    }
    return null;
  }
  /** Merges any `extraErrors` or `customErrors` into the given `schemaValidation` object, returning the result
   *
   * @param schemaValidation - The `ValidationData` object into which additional errors are merged
   * @param [extraErrors] - The extra errors from the props
   * @param [customErrors] - The customErrors from custom components
   * @return - The `extraErrors` and `customErrors` merged into the `schemaValidation`
   * @private
   */
  mergeErrors(schemaValidation, extraErrors, customErrors) {
    let errorSchema = schemaValidation.errorSchema;
    let errors = schemaValidation.errors;
    if (extraErrors) {
      const merged = validationDataMerge(schemaValidation, extraErrors);
      errorSchema = merged.errorSchema;
      errors = merged.errors;
    }
    if (customErrors) {
      const merged = validationDataMerge(schemaValidation, customErrors.ErrorSchema, true);
      errorSchema = merged.errorSchema;
      errors = merged.errors;
    }
    return { errors, errorSchema };
  }
  /** Performs live validation and then updates and returns the errors and error schemas by potentially merging in
   * `extraErrors` and `customErrors`.
   *
   * @param rootSchema - The `rootSchema` from the state
   * @param schemaUtils - The `SchemaUtilsType` from the state
   * @param originalErrorSchema - The original `ErrorSchema` from the state
   * @param [formData] - The new form data to validate
   * @param [extraErrors] - The extra errors from the props
   * @param [customErrors] - The customErrors from custom components
   * @param [retrievedSchema] - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`
   * @param [mergeIntoOriginalErrorSchema=false] - Optional flag indicating whether we merge into original schema
   * @returns - An object containing `errorSchema`, `errors`, `schemaValidationErrors` and `schemaValidationErrorSchema`
   * @private
   */
  liveValidate(rootSchema, schemaUtils, originalErrorSchema, formData, extraErrors, customErrors, retrievedSchema, mergeIntoOriginalErrorSchema = false) {
    const schemaValidation = this.validate(formData, rootSchema, schemaUtils, retrievedSchema);
    const errors = schemaValidation.errors;
    let errorSchema = schemaValidation.errorSchema;
    if (mergeIntoOriginalErrorSchema) {
      errorSchema = mergeObjects(originalErrorSchema, schemaValidation.errorSchema, "preventDuplicates");
    }
    const schemaValidationErrors = errors;
    const schemaValidationErrorSchema = errorSchema;
    const mergedErrors = this.mergeErrors({ errorSchema, errors }, extraErrors, customErrors);
    return { ...mergedErrors, schemaValidationErrors, schemaValidationErrorSchema };
  }
  /** Function to handle changes made to a field in the `Form`. This handler gets the first change from the
   * `pendingChanges` list, containing the `newValue` for the `formData` and the `path` at which the `newValue` is to be
   * updated, along with a new, optional `ErrorSchema` for that same `path` and potentially the `id` of the field being
   * changed. It will first update the `formData` with any missing default fields and then, if `omitExtraData` and
   * `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not in a form field. Then, the
   * resulting `formData` will be validated if required. The state will be updated with the new updated (potentially
   * filtered) `formData`, any errors that resulted from validation. Finally the `onChange` callback will be called, if
   * specified, with the updated state and the `processPendingChange()` function is called again.
   */
  processPendingChange() {
    if (this.pendingChanges.length === 0) {
      return;
    }
    const { newValue, path, id } = this.pendingChanges[0];
    const { newErrorSchema } = this.pendingChanges[0];
    const { extraErrors, omitExtraData, liveOmit, noValidate, liveValidate, onChange } = this.props;
    const { formData: oldFormData, schemaUtils, schema, fieldPathId, schemaValidationErrorSchema, errors } = this.state;
    let { customErrors, errorSchema: originalErrorSchema } = this.state;
    const rootPathId = fieldPathId.path[0] || "";
    const isRootPath = !path || path.length === 0 || path.length === 1 && path[0] === rootPathId;
    let retrievedSchema = this.state.retrievedSchema;
    let formData = isRootPath ? newValue : cloneDeep_default(oldFormData);
    if (isObject(formData) || Array.isArray(formData)) {
      if (newValue === ADDITIONAL_PROPERTY_KEY_REMOVE) {
        unset_default(formData, path);
      } else if (!isRootPath) {
        set_default(formData, path, newValue);
      }
      const newState = this.getStateFromProps(this.props, formData, void 0, void 0, void 0, true);
      formData = newState.formData;
      retrievedSchema = newState.retrievedSchema;
    }
    const mustValidate = !noValidate && (liveValidate === true || liveValidate === "onChange");
    let state = { formData, schema };
    let newFormData = formData;
    if (omitExtraData === true && (liveOmit === true || liveOmit === "onChange")) {
      newFormData = this.omitExtraData(formData);
      state = {
        formData: newFormData
      };
    }
    if (newErrorSchema) {
      const oldValidationError = !isRootPath ? get_default(schemaValidationErrorSchema, path) : schemaValidationErrorSchema;
      if (!isEmpty_default(oldValidationError)) {
        if (!isRootPath) {
          set_default(originalErrorSchema, path, newErrorSchema);
        } else {
          originalErrorSchema = newErrorSchema;
        }
      } else {
        if (!customErrors) {
          customErrors = new ErrorSchemaBuilder();
        }
        if (isRootPath) {
          const errors2 = get_default(newErrorSchema, ERRORS_KEY);
          if (errors2) {
            customErrors.setErrors(errors2);
          }
        } else {
          set_default(customErrors.ErrorSchema, path, newErrorSchema);
        }
      }
    } else if (customErrors && get_default(customErrors.ErrorSchema, [...path, ERRORS_KEY])) {
      customErrors.clearErrors(path);
    }
    if (mustValidate && this.pendingChanges.length === 1) {
      const liveValidation = this.liveValidate(schema, schemaUtils, originalErrorSchema, newFormData, extraErrors, customErrors, retrievedSchema);
      state = { formData: newFormData, ...liveValidation, customErrors };
    } else if (!noValidate && newErrorSchema) {
      const mergedErrors = this.mergeErrors({ errorSchema: originalErrorSchema, errors }, extraErrors, customErrors);
      state = {
        formData: newFormData,
        ...mergedErrors,
        customErrors
      };
    }
    this.setState(state, () => {
      if (onChange) {
        onChange(toIChangeEvent({ ...this.state, ...state }), id);
      }
      this.pendingChanges.shift();
      this.processPendingChange();
    });
  }
  /**
   * If the retrievedSchema has changed the new retrievedSchema is returned.
   * Otherwise, the old retrievedSchema is returned to persist reference.
   * -  This ensures that AJV retrieves the schema from the cache when it has not changed,
   *    avoiding the performance cost of recompiling the schema.
   *
   * @param retrievedSchema The new retrieved schema.
   * @returns The new retrieved schema if it has changed, else the old retrieved schema.
   */
  updateRetrievedSchema(retrievedSchema) {
    var _a;
    const isTheSame = deepEquals(retrievedSchema, (_a = this.state) == null ? void 0 : _a.retrievedSchema);
    return isTheSame ? this.state.retrievedSchema : retrievedSchema;
  }
  /** Extracts the `GlobalFormOptions` from the given Form `props`
   *
   * @param props - The form props to extract the global form options from
   * @returns - The `GlobalFormOptions` from the props
   * @private
   */
  getGlobalFormOptions(props) {
    const { uiSchema = {}, experimental_componentUpdateStrategy, idSeparator = DEFAULT_ID_SEPARATOR, idPrefix = DEFAULT_ID_PREFIX, nameGenerator, useFallbackUiForUnsupportedType = false } = props;
    const rootFieldId = uiSchema["ui:rootFieldId"];
    return {
      idPrefix: rootFieldId || idPrefix,
      idSeparator,
      useFallbackUiForUnsupportedType,
      ...experimental_componentUpdateStrategy !== void 0 && { experimental_componentUpdateStrategy },
      ...nameGenerator !== void 0 && { nameGenerator }
    };
  }
  /** Computed the registry for the form using the given `props`, `schema` and `schemaUtils` */
  getRegistry(props, schema, schemaUtils) {
    var _a;
    const { translateString: customTranslateString, uiSchema = {} } = props;
    const { fields: fields2, templates: templates2, widgets: widgets2, formContext, translateString } = getDefaultRegistry();
    return {
      fields: { ...fields2, ...props.fields },
      templates: {
        ...templates2,
        ...props.templates,
        ButtonTemplates: {
          ...templates2.ButtonTemplates,
          ...(_a = props.templates) == null ? void 0 : _a.ButtonTemplates
        }
      },
      widgets: { ...widgets2, ...props.widgets },
      rootSchema: schema,
      formContext: props.formContext || formContext,
      schemaUtils,
      translateString: customTranslateString || translateString,
      globalUiOptions: uiSchema[UI_GLOBAL_OPTIONS_KEY],
      globalFormOptions: this.getGlobalFormOptions(props)
    };
  }
  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
   * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
   *
   * @param error - The error on which to focus
   */
  focusOnError(error) {
    const { idPrefix = "root", idSeparator = "_" } = this.props;
    const { property } = error;
    const path = toPath_default(property);
    if (path[0] === "") {
      path[0] = idPrefix;
    } else {
      path.unshift(idPrefix);
    }
    const elementId = path.join(idSeparator);
    let field = this.formElement.current.elements[elementId];
    if (!field) {
      field = this.formElement.current.querySelector(`input[id^="${elementId}"`);
    }
    if (field && field.length) {
      field = field[0];
    }
    if (field) {
      field.focus();
    }
  }
  /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
   * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
   * same way as would happen on form submission.
   *
   * @returns - True if the form is valid, false otherwise.
   */
  validateForm() {
    const { omitExtraData } = this.props;
    let { formData: newFormData } = this.state;
    if (omitExtraData === true) {
      newFormData = this.omitExtraData(newFormData);
    }
    return this.validateFormWithFormData(newFormData);
  }
  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
   * needed along with the submit button or any children of the form.
   */
  render() {
    const { children, id, className = "", tagName, name, method, target, action, autoComplete, enctype, acceptCharset, noHtml5Validate = false, disabled, readonly, showErrorList = "top", _internalFormWrapper } = this.props;
    const { schema, uiSchema, formData, errorSchema, fieldPathId, registry } = this.state;
    const { SchemaField: _SchemaField } = registry.fields;
    const { SubmitButton: SubmitButton2 } = registry.templates.ButtonTemplates;
    const as = _internalFormWrapper ? tagName : void 0;
    const FormTag = _internalFormWrapper || tagName || "form";
    let { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions = {} } = getUiOptions(uiSchema);
    if (disabled) {
      submitOptions = { ...submitOptions, props: { ...submitOptions.props, disabled: true } };
    }
    const submitUiSchema = { [UI_OPTIONS_KEY]: { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions } };
    return (0, import_jsx_runtime58.jsxs)(FormTag, { className: className ? className : "rjsf", id, name, method, target, action, autoComplete, encType: enctype, acceptCharset, noValidate: noHtml5Validate, onSubmit: this.onSubmit, as, ref: this.formElement, children: [showErrorList === "top" && this.renderErrors(registry), (0, import_jsx_runtime58.jsx)(_SchemaField, { name: "", schema, uiSchema, errorSchema, fieldPathId, formData, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry, disabled, readonly }), children ? children : (0, import_jsx_runtime58.jsx)(SubmitButton2, { uiSchema: submitUiSchema, registry }), showErrorList === "bottom" && this.renderErrors(registry)] });
  }
};

// node_modules/@rjsf/core/lib/withTheme.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);
function withTheme(themeProps) {
  return (0, import_react22.forwardRef)(({ fields: fields2, widgets: widgets2, templates: templates2, ...directProps }, ref) => {
    var _a;
    fields2 = { ...themeProps == null ? void 0 : themeProps.fields, ...fields2 };
    widgets2 = { ...themeProps == null ? void 0 : themeProps.widgets, ...widgets2 };
    templates2 = {
      ...themeProps == null ? void 0 : themeProps.templates,
      ...templates2,
      ButtonTemplates: {
        ...(_a = themeProps == null ? void 0 : themeProps.templates) == null ? void 0 : _a.ButtonTemplates,
        ...templates2 == null ? void 0 : templates2.ButtonTemplates
      }
    };
    return (0, import_jsx_runtime59.jsx)(Form, { ...themeProps, ...directProps, fields: fields2, widgets: widgets2, templates: templates2, ref });
  });
}

// node_modules/@rjsf/core/lib/getTestRegistry.js
function getTestRegistry(rootSchema, fields2 = {}, templates2 = {}, widgets2 = {}, formContext = {}, globalFormOptions = {
  idPrefix: DEFAULT_ID_PREFIX,
  idSeparator: DEFAULT_ID_SEPARATOR,
  useFallbackUiForUnsupportedType: false
}) {
  const defaults = getDefaultRegistry();
  const schemaUtils = createSchemaUtils(lib_default, rootSchema);
  return {
    fields: { ...defaults.fields, ...fields2 },
    templates: { ...defaults.templates, ...templates2 },
    widgets: { ...defaults.widgets, ...widgets2 },
    formContext,
    rootSchema,
    schemaUtils,
    translateString: englishStringTranslator,
    globalFormOptions
  };
}

// node_modules/@rjsf/core/lib/index.js
var lib_default2 = Form;
export {
  RichDescription,
  RichHelp,
  lib_default2 as default,
  getDefaultRegistry,
  getTestRegistry,
  withTheme
};
//# sourceMappingURL=@rjsf_core.js.map
