{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/ir.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/errors.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/builder/ref-proxy.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/builder/functions.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/utils/comparison.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/compiler/evaluators.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/utils.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/indexes/base-index.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/utils/btree.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/indexes/btree-index.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/SortedMap.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/indexes/lazy-index.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/proxy.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/deferred.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/scheduler.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/transactions.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/indexes/reverse-index.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/utils/index-optimization.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/indexes/auto-index.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/utils.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/hashing/murmur.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/hashing/hash.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/multiset.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/graph.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/d2.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/map.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/indexes.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/reduce.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/groupBy.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/tap.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/filter.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/output.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/consolidate.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/join.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/distinct.ts", "../../../../node_modules/.pnpm/fractional-indexing@3.2.0/node_modules/fractional-indexing/src/index.js", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/topKWithFractionalIndex.ts", "../../../../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/src/operators/orderBy.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/compiler/group-by.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/compiler/order-by.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/change-events.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/state.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/event-emitter.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/subscription.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/changes.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/utils/browser-polyfills.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/lifecycle.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/live/internal.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/sync.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/indexes.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/mutations.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/events.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/collection/index.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/utils/type-guards.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/optimistic-action.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/local-only.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/local-storage.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/paced-mutations.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/expression-helpers.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/builder/index.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/optimizer.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/compiler/joins.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/compiler/select.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/compiler/index.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/compiler/expressions.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/live/collection-subscriber.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/live/collection-registry.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/live/collection-config-builder.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/live-query-collection.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/predicate-utils.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/query/subset-dedupe.ts", "../../../../node_modules/.pnpm/@tanstack+pacer-lite@0.1.0/node_modules/@tanstack/pacer-lite/src/lite-debouncer.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/strategies/debounceStrategy.ts", "../../../../node_modules/.pnpm/@tanstack+pacer-lite@0.1.0/node_modules/@tanstack/pacer-lite/src/lite-queuer.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/strategies/queueStrategy.ts", "../../../../node_modules/.pnpm/@tanstack+pacer-lite@0.1.0/node_modules/@tanstack/pacer-lite/src/lite-throttler.ts", "../../../../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/src/strategies/throttleStrategy.ts"],
  "sourcesContent": ["/*\nThis is the intermediate representation of the query.\n*/\n\nimport type { CompareOptions } from \"./builder/types\"\nimport type { Collection, CollectionImpl } from \"../collection/index.js\"\nimport type { NamespacedRow } from \"../types\"\n\nexport interface QueryIR {\n  from: From\n  select?: Select\n  join?: Join\n  where?: Array<Where>\n  groupBy?: GroupBy\n  having?: Array<Having>\n  orderBy?: OrderBy\n  limit?: Limit\n  offset?: Offset\n  distinct?: true\n  singleResult?: true\n\n  // Functional variants\n  fnSelect?: (row: NamespacedRow) => any\n  fnWhere?: Array<(row: NamespacedRow) => any>\n  fnHaving?: Array<(row: NamespacedRow) => any>\n}\n\nexport type From = CollectionRef | QueryRef\n\nexport type Select = {\n  [alias: string]: BasicExpression | Aggregate | Select\n}\n\nexport type Join = Array<JoinClause>\n\nexport interface JoinClause {\n  from: CollectionRef | QueryRef\n  type: `left` | `right` | `inner` | `outer` | `full` | `cross`\n  left: BasicExpression\n  right: BasicExpression\n}\n\nexport type Where =\n  | BasicExpression<boolean>\n  | { expression: BasicExpression<boolean>; residual?: boolean }\n\nexport type GroupBy = Array<BasicExpression>\n\nexport type Having = Where\n\nexport type OrderBy = Array<OrderByClause>\n\nexport type OrderByClause = {\n  expression: BasicExpression\n  compareOptions: CompareOptions\n}\n\nexport type OrderByDirection = `asc` | `desc`\n\nexport type Limit = number\n\nexport type Offset = number\n\n/* Expressions */\n\nabstract class BaseExpression<T = any> {\n  public abstract type: string\n  /** @internal - Type brand for TypeScript inference */\n  declare readonly __returnType: T\n}\n\nexport class CollectionRef extends BaseExpression {\n  public type = `collectionRef` as const\n  constructor(\n    public collection: CollectionImpl,\n    public alias: string\n  ) {\n    super()\n  }\n}\n\nexport class QueryRef extends BaseExpression {\n  public type = `queryRef` as const\n  constructor(\n    public query: QueryIR,\n    public alias: string\n  ) {\n    super()\n  }\n}\n\nexport class PropRef<T = any> extends BaseExpression<T> {\n  public type = `ref` as const\n  constructor(\n    public path: Array<string> // path to the property in the collection, with the alias as the first element\n  ) {\n    super()\n  }\n}\n\nexport class Value<T = any> extends BaseExpression<T> {\n  public type = `val` as const\n  constructor(\n    public value: T // any js value\n  ) {\n    super()\n  }\n}\n\nexport class Func<T = any> extends BaseExpression<T> {\n  public type = `func` as const\n  constructor(\n    public name: string, // such as eq, gt, lt, upper, lower, etc.\n    public args: Array<BasicExpression>\n  ) {\n    super()\n  }\n}\n\n// This is the basic expression type that is used in the majority of expression\n// builder callbacks (select, where, groupBy, having, orderBy, etc.)\n// it doesn't include aggregate functions as those are only used in the select clause\nexport type BasicExpression<T = any> = PropRef<T> | Value<T> | Func<T>\n\nexport class Aggregate<T = any> extends BaseExpression<T> {\n  public type = `agg` as const\n  constructor(\n    public name: string, // such as count, avg, sum, min, max, etc.\n    public args: Array<BasicExpression>\n  ) {\n    super()\n  }\n}\n\n/**\n * Runtime helper to detect IR expression-like objects.\n * Prefer this over ad-hoc local implementations to keep behavior consistent.\n */\nexport function isExpressionLike(value: any): boolean {\n  return (\n    value instanceof Aggregate ||\n    value instanceof Func ||\n    value instanceof PropRef ||\n    value instanceof Value\n  )\n}\n\n/**\n * Helper functions for working with Where clauses\n */\n\n/**\n * Extract the expression from a Where clause\n */\nexport function getWhereExpression(where: Where): BasicExpression<boolean> {\n  return typeof where === `object` && `expression` in where\n    ? where.expression\n    : where\n}\n\n/**\n * Extract the expression from a HAVING clause\n * HAVING clauses can contain aggregates, unlike regular WHERE clauses\n */\nexport function getHavingExpression(\n  having: Having\n): BasicExpression | Aggregate {\n  return typeof having === `object` && `expression` in having\n    ? having.expression\n    : having\n}\n\n/**\n * Check if a Where clause is marked as residual\n */\nexport function isResidualWhere(where: Where): boolean {\n  return (\n    typeof where === `object` &&\n    `expression` in where &&\n    where.residual === true\n  )\n}\n\n/**\n * Create a residual Where clause from an expression\n */\nexport function createResidualWhere(\n  expression: BasicExpression<boolean>\n): Where {\n  return { expression, residual: true }\n}\n\nfunction getRefFromAlias(\n  query: QueryIR,\n  alias: string\n): CollectionRef | QueryRef | void {\n  if (query.from.alias === alias) {\n    return query.from\n  }\n\n  for (const join of query.join || []) {\n    if (join.from.alias === alias) {\n      return join.from\n    }\n  }\n}\n\n/**\n * Follows the given reference in a query\n * until its finds the root field the reference points to.\n * @returns The collection, its alias, and the path to the root field in this collection\n */\nexport function followRef(\n  query: QueryIR,\n  ref: PropRef<any>,\n  collection: Collection\n): { collection: Collection; path: Array<string> } | void {\n  if (ref.path.length === 0) {\n    return\n  }\n\n  if (ref.path.length === 1) {\n    // This field should be part of this collection\n    const field = ref.path[0]!\n    // is it part of the select clause?\n    if (query.select) {\n      const selectedField = query.select[field]\n      if (selectedField && selectedField.type === `ref`) {\n        return followRef(query, selectedField, collection)\n      }\n    }\n\n    // Either this field is not part of the select clause\n    // and thus it must be part of the collection itself\n    // or it is part of the select but is not a reference\n    // so we can stop here and don't have to follow it\n    return { collection, path: [field] }\n  }\n\n  if (ref.path.length > 1) {\n    // This is a nested field\n    const [alias, ...rest] = ref.path\n    const aliasRef = getRefFromAlias(query, alias!)\n    if (!aliasRef) {\n      return\n    }\n\n    if (aliasRef.type === `queryRef`) {\n      return followRef(aliasRef.query, new PropRef(rest), collection)\n    } else {\n      // This is a reference to a collection\n      // we can't follow it further\n      // so the field must be on the collection itself\n      return { collection: aliasRef.collection, path: rest }\n    }\n  }\n}\n", "// Root error class for all TanStack DB errors\nexport class TanStackDBError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = `TanStackDBError`\n  }\n}\n\n// Base error classes\nexport class NonRetriableError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `NonRetriableError`\n  }\n}\n\n// Schema validation error (exported from index for backward compatibility)\nexport class SchemaValidationError extends TanStackDBError {\n  type: `insert` | `update`\n  issues: ReadonlyArray<{\n    message: string\n    path?: ReadonlyArray<string | number | symbol>\n  }>\n\n  constructor(\n    type: `insert` | `update`,\n    issues: ReadonlyArray<{\n      message: string\n      path?: ReadonlyArray<string | number | symbol>\n    }>,\n    message?: string\n  ) {\n    const defaultMessage = `${type === `insert` ? `Insert` : `Update`} validation failed: ${issues\n      .map((issue) => `\\n- ${issue.message} - path: ${issue.path}`)\n      .join(``)}`\n\n    super(message || defaultMessage)\n    this.name = `SchemaValidationError`\n    this.type = type\n    this.issues = issues\n  }\n}\n\n// Module Instance Errors\nexport class DuplicateDbInstanceError extends TanStackDBError {\n  constructor() {\n    super(\n      `Multiple instances of @tanstack/db detected!\\n\\n` +\n        `This causes transaction context to be lost because each instance maintains ` +\n        `its own transaction stack.\\n\\n` +\n        `Common causes:\\n` +\n        `1. Different versions of @tanstack/db installed\\n` +\n        `2. Incompatible peer dependency versions in packages\\n` +\n        `3. Module resolution issues in bundler configuration\\n\\n` +\n        `To fix:\\n` +\n        `1. Check installed versions: npm list @tanstack/db (or pnpm/yarn list)\\n` +\n        `2. Force a single version using package manager overrides:\\n` +\n        `   - npm: \"overrides\" in package.json\\n` +\n        `   - pnpm: \"pnpm.overrides\" in package.json\\n` +\n        `   - yarn: \"resolutions\" in package.json\\n` +\n        `3. Clear node_modules and lockfile, then reinstall\\n\\n` +\n        `To temporarily disable this check (not recommended):\\n` +\n        `Set environment variable: TANSTACK_DB_DISABLE_DUP_CHECK=1\\n\\n` +\n        `See: https://tanstack.com/db/latest/docs/troubleshooting#duplicate-instances`\n    )\n    this.name = `DuplicateDbInstanceError`\n  }\n}\n\n// Collection Configuration Errors\nexport class CollectionConfigurationError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `CollectionConfigurationError`\n  }\n}\n\nexport class CollectionRequiresConfigError extends CollectionConfigurationError {\n  constructor() {\n    super(`Collection requires a config`)\n  }\n}\n\nexport class CollectionRequiresSyncConfigError extends CollectionConfigurationError {\n  constructor() {\n    super(`Collection requires a sync config`)\n  }\n}\n\nexport class InvalidSchemaError extends CollectionConfigurationError {\n  constructor() {\n    super(`Schema must implement the standard-schema interface`)\n  }\n}\n\nexport class SchemaMustBeSynchronousError extends CollectionConfigurationError {\n  constructor() {\n    super(`Schema validation must be synchronous`)\n  }\n}\n\n// Collection State Errors\nexport class CollectionStateError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `CollectionStateError`\n  }\n}\n\nexport class CollectionInErrorStateError extends CollectionStateError {\n  constructor(operation: string, collectionId: string) {\n    super(\n      `Cannot perform ${operation} on collection \"${collectionId}\" - collection is in error state. Try calling cleanup() and restarting the collection.`\n    )\n  }\n}\n\nexport class InvalidCollectionStatusTransitionError extends CollectionStateError {\n  constructor(from: string, to: string, collectionId: string) {\n    super(\n      `Invalid collection status transition from \"${from}\" to \"${to}\" for collection \"${collectionId}\"`\n    )\n  }\n}\n\nexport class CollectionIsInErrorStateError extends CollectionStateError {\n  constructor() {\n    super(`Collection is in error state`)\n  }\n}\n\nexport class NegativeActiveSubscribersError extends CollectionStateError {\n  constructor() {\n    super(`Active subscribers count is negative - this should never happen`)\n  }\n}\n\n// Collection Operation Errors\nexport class CollectionOperationError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `CollectionOperationError`\n  }\n}\n\nexport class UndefinedKeyError extends CollectionOperationError {\n  constructor(item: any) {\n    super(\n      `An object was created without a defined key: ${JSON.stringify(item)}`\n    )\n  }\n}\n\nexport class DuplicateKeyError extends CollectionOperationError {\n  constructor(key: string | number) {\n    super(\n      `Cannot insert document with ID \"${key}\" because it already exists in the collection`\n    )\n  }\n}\n\nexport class DuplicateKeySyncError extends CollectionOperationError {\n  constructor(\n    key: string | number,\n    collectionId: string,\n    options?: { hasCustomGetKey?: boolean; hasJoins?: boolean }\n  ) {\n    const baseMessage = `Cannot insert document with key \"${key}\" from sync because it already exists in the collection \"${collectionId}\"`\n\n    // Provide enhanced guidance when custom getKey is used with joins\n    if (options?.hasCustomGetKey && options.hasJoins) {\n      super(\n        `${baseMessage}. ` +\n          `This collection uses a custom getKey with joined queries. ` +\n          `Joined queries can produce multiple rows with the same key when relationships are not 1:1. ` +\n          `Consider: (1) using a composite key in your getKey function (e.g., \\`\\${item.key1}-\\${item.key2}\\`), ` +\n          `(2) ensuring your join produces unique rows per key, or (3) removing the custom getKey ` +\n          `to use the default composite key behavior.`\n      )\n    } else {\n      super(baseMessage)\n    }\n  }\n}\n\nexport class MissingUpdateArgumentError extends CollectionOperationError {\n  constructor() {\n    super(`The first argument to update is missing`)\n  }\n}\n\nexport class NoKeysPassedToUpdateError extends CollectionOperationError {\n  constructor() {\n    super(`No keys were passed to update`)\n  }\n}\n\nexport class UpdateKeyNotFoundError extends CollectionOperationError {\n  constructor(key: string | number) {\n    super(\n      `The key \"${key}\" was passed to update but an object for this key was not found in the collection`\n    )\n  }\n}\n\nexport class KeyUpdateNotAllowedError extends CollectionOperationError {\n  constructor(originalKey: string | number, newKey: string | number) {\n    super(\n      `Updating the key of an item is not allowed. Original key: \"${originalKey}\", Attempted new key: \"${newKey}\". Please delete the old item and create a new one if a key change is necessary.`\n    )\n  }\n}\n\nexport class NoKeysPassedToDeleteError extends CollectionOperationError {\n  constructor() {\n    super(`No keys were passed to delete`)\n  }\n}\n\nexport class DeleteKeyNotFoundError extends CollectionOperationError {\n  constructor(key: string | number) {\n    super(\n      `Collection.delete was called with key '${key}' but there is no item in the collection with this key`\n    )\n  }\n}\n\n// Collection Handler Errors\nexport class MissingHandlerError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `MissingHandlerError`\n  }\n}\n\nexport class MissingInsertHandlerError extends MissingHandlerError {\n  constructor() {\n    super(\n      `Collection.insert called directly (not within an explicit transaction) but no 'onInsert' handler is configured.`\n    )\n  }\n}\n\nexport class MissingUpdateHandlerError extends MissingHandlerError {\n  constructor() {\n    super(\n      `Collection.update called directly (not within an explicit transaction) but no 'onUpdate' handler is configured.`\n    )\n  }\n}\n\nexport class MissingDeleteHandlerError extends MissingHandlerError {\n  constructor() {\n    super(\n      `Collection.delete called directly (not within an explicit transaction) but no 'onDelete' handler is configured.`\n    )\n  }\n}\n\n// Transaction Errors\nexport class TransactionError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `TransactionError`\n  }\n}\n\nexport class MissingMutationFunctionError extends TransactionError {\n  constructor() {\n    super(`mutationFn is required when creating a transaction`)\n  }\n}\n\nexport class OnMutateMustBeSynchronousError extends TransactionError {\n  constructor() {\n    super(\n      `onMutate must be synchronous and cannot return a promise. Remove async/await or returned promises from onMutate.`\n    )\n    this.name = `OnMutateMustBeSynchronousError`\n  }\n}\n\nexport class TransactionNotPendingMutateError extends TransactionError {\n  constructor() {\n    super(\n      `You can no longer call .mutate() as the transaction is no longer pending`\n    )\n  }\n}\n\nexport class TransactionAlreadyCompletedRollbackError extends TransactionError {\n  constructor() {\n    super(\n      `You can no longer call .rollback() as the transaction is already completed`\n    )\n  }\n}\n\nexport class TransactionNotPendingCommitError extends TransactionError {\n  constructor() {\n    super(\n      `You can no longer call .commit() as the transaction is no longer pending`\n    )\n  }\n}\n\nexport class NoPendingSyncTransactionWriteError extends TransactionError {\n  constructor() {\n    super(`No pending sync transaction to write to`)\n  }\n}\n\nexport class SyncTransactionAlreadyCommittedWriteError extends TransactionError {\n  constructor() {\n    super(\n      `The pending sync transaction is already committed, you can't still write to it.`\n    )\n  }\n}\n\nexport class NoPendingSyncTransactionCommitError extends TransactionError {\n  constructor() {\n    super(`No pending sync transaction to commit`)\n  }\n}\n\nexport class SyncTransactionAlreadyCommittedError extends TransactionError {\n  constructor() {\n    super(\n      `The pending sync transaction is already committed, you can't commit it again.`\n    )\n  }\n}\n\n// Query Builder Errors\nexport class QueryBuilderError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `QueryBuilderError`\n  }\n}\n\nexport class OnlyOneSourceAllowedError extends QueryBuilderError {\n  constructor(context: string) {\n    super(`Only one source is allowed in the ${context}`)\n  }\n}\n\nexport class SubQueryMustHaveFromClauseError extends QueryBuilderError {\n  constructor(context: string) {\n    super(`A sub query passed to a ${context} must have a from clause itself`)\n  }\n}\n\nexport class InvalidSourceError extends QueryBuilderError {\n  constructor(alias: string) {\n    super(\n      `Invalid source for live query: The value provided for alias \"${alias}\" is not a Collection or subquery. Live queries only accept Collection instances or subqueries. Please ensure you're passing a valid Collection or QueryBuilder, not a plain array or other data type.`\n    )\n  }\n}\n\nexport class InvalidSourceTypeError extends QueryBuilderError {\n  constructor(context: string, type: string) {\n    super(\n      `Invalid source for ${context}: Expected an object with a single key-value pair like { alias: collection }. ` +\n        `For example: .from({ todos: todosCollection }). Got: ${type}`\n    )\n  }\n}\n\nexport class JoinConditionMustBeEqualityError extends QueryBuilderError {\n  constructor() {\n    super(`Join condition must be an equality expression`)\n  }\n}\n\nexport class QueryMustHaveFromClauseError extends QueryBuilderError {\n  constructor() {\n    super(`Query must have a from clause`)\n  }\n}\n\n// Query Compilation Errors\nexport class QueryCompilationError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `QueryCompilationError`\n  }\n}\n\nexport class DistinctRequiresSelectError extends QueryCompilationError {\n  constructor() {\n    super(`DISTINCT requires a SELECT clause.`)\n  }\n}\n\nexport class HavingRequiresGroupByError extends QueryCompilationError {\n  constructor() {\n    super(`HAVING clause requires GROUP BY clause`)\n  }\n}\n\nexport class LimitOffsetRequireOrderByError extends QueryCompilationError {\n  constructor() {\n    super(\n      `LIMIT and OFFSET require an ORDER BY clause to ensure deterministic results`\n    )\n  }\n}\n\n/**\n * Error thrown when a collection input stream is not found during query compilation.\n * In self-joins, each alias (e.g., 'employee', 'manager') requires its own input stream.\n */\nexport class CollectionInputNotFoundError extends QueryCompilationError {\n  constructor(\n    alias: string,\n    collectionId?: string,\n    availableKeys?: Array<string>\n  ) {\n    const details = collectionId\n      ? `alias \"${alias}\" (collection \"${collectionId}\")`\n      : `collection \"${alias}\"`\n    const availableKeysMsg = availableKeys?.length\n      ? `. Available keys: ${availableKeys.join(`, `)}`\n      : ``\n    super(`Input for ${details} not found in inputs map${availableKeysMsg}`)\n  }\n}\n\n/**\n * Error thrown when a subquery uses the same alias as its parent query.\n * This causes issues because parent and subquery would share the same input streams,\n * leading to empty results or incorrect data (aggregation cross-leaking).\n */\nexport class DuplicateAliasInSubqueryError extends QueryCompilationError {\n  constructor(alias: string, parentAliases: Array<string>) {\n    super(\n      `Subquery uses alias \"${alias}\" which is already used in the parent query. ` +\n        `Each alias must be unique across parent and subquery contexts. ` +\n        `Parent query aliases: ${parentAliases.join(`, `)}. ` +\n        `Please rename \"${alias}\" in either the parent query or subquery to avoid conflicts.`\n    )\n  }\n}\n\nexport class UnsupportedFromTypeError extends QueryCompilationError {\n  constructor(type: string) {\n    super(`Unsupported FROM type: ${type}`)\n  }\n}\n\nexport class UnknownExpressionTypeError extends QueryCompilationError {\n  constructor(type: string) {\n    super(`Unknown expression type: ${type}`)\n  }\n}\n\nexport class EmptyReferencePathError extends QueryCompilationError {\n  constructor() {\n    super(`Reference path cannot be empty`)\n  }\n}\n\nexport class UnknownFunctionError extends QueryCompilationError {\n  constructor(functionName: string) {\n    super(`Unknown function: ${functionName}`)\n  }\n}\n\nexport class JoinCollectionNotFoundError extends QueryCompilationError {\n  constructor(collectionId: string) {\n    super(`Collection \"${collectionId}\" not found during compilation of join`)\n  }\n}\n\n// JOIN Operation Errors\nexport class JoinError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `JoinError`\n  }\n}\n\nexport class UnsupportedJoinTypeError extends JoinError {\n  constructor(joinType: string) {\n    super(`Unsupported join type: ${joinType}`)\n  }\n}\n\nexport class InvalidJoinConditionSameSourceError extends JoinError {\n  constructor(sourceAlias: string) {\n    super(\n      `Invalid join condition: both expressions refer to the same source \"${sourceAlias}\"`\n    )\n  }\n}\n\nexport class InvalidJoinConditionSourceMismatchError extends JoinError {\n  constructor() {\n    super(`Invalid join condition: expressions must reference source aliases`)\n  }\n}\n\nexport class InvalidJoinConditionLeftSourceError extends JoinError {\n  constructor(sourceAlias: string) {\n    super(\n      `Invalid join condition: left expression refers to an unavailable source \"${sourceAlias}\"`\n    )\n  }\n}\n\nexport class InvalidJoinConditionRightSourceError extends JoinError {\n  constructor(sourceAlias: string) {\n    super(\n      `Invalid join condition: right expression does not refer to the joined source \"${sourceAlias}\"`\n    )\n  }\n}\n\nexport class InvalidJoinCondition extends JoinError {\n  constructor() {\n    super(`Invalid join condition`)\n  }\n}\n\nexport class UnsupportedJoinSourceTypeError extends JoinError {\n  constructor(type: string) {\n    super(`Unsupported join source type: ${type}`)\n  }\n}\n\n// GROUP BY and Aggregation Errors\nexport class GroupByError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `GroupByError`\n  }\n}\n\nexport class NonAggregateExpressionNotInGroupByError extends GroupByError {\n  constructor(alias: string) {\n    super(\n      `Non-aggregate expression '${alias}' in SELECT must also appear in GROUP BY clause`\n    )\n  }\n}\n\nexport class UnsupportedAggregateFunctionError extends GroupByError {\n  constructor(functionName: string) {\n    super(`Unsupported aggregate function: ${functionName}`)\n  }\n}\n\nexport class AggregateFunctionNotInSelectError extends GroupByError {\n  constructor(functionName: string) {\n    super(\n      `Aggregate function in HAVING clause must also be in SELECT clause: ${functionName}`\n    )\n  }\n}\n\nexport class UnknownHavingExpressionTypeError extends GroupByError {\n  constructor(type: string) {\n    super(`Unknown expression type in HAVING clause: ${type}`)\n  }\n}\n\n// Storage Errors\nexport class StorageError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `StorageError`\n  }\n}\n\nexport class SerializationError extends StorageError {\n  constructor(operation: string, originalError: string) {\n    super(\n      `Cannot ${operation} item because it cannot be JSON serialized: ${originalError}`\n    )\n  }\n}\n\n// LocalStorage Collection Errors\nexport class LocalStorageCollectionError extends StorageError {\n  constructor(message: string) {\n    super(message)\n    this.name = `LocalStorageCollectionError`\n  }\n}\n\nexport class StorageKeyRequiredError extends LocalStorageCollectionError {\n  constructor() {\n    super(`[LocalStorageCollection] storageKey must be provided.`)\n  }\n}\n\nexport class InvalidStorageDataFormatError extends LocalStorageCollectionError {\n  constructor(storageKey: string, key: string) {\n    super(\n      `[LocalStorageCollection] Invalid data format in storage key \"${storageKey}\" for key \"${key}\".`\n    )\n  }\n}\n\nexport class InvalidStorageObjectFormatError extends LocalStorageCollectionError {\n  constructor(storageKey: string) {\n    super(\n      `[LocalStorageCollection] Invalid data format in storage key \"${storageKey}\". Expected object format.`\n    )\n  }\n}\n\n// Sync Cleanup Errors\nexport class SyncCleanupError extends TanStackDBError {\n  constructor(collectionId: string, error: Error | string) {\n    const message = error instanceof Error ? error.message : String(error)\n    super(\n      `Collection \"${collectionId}\" sync cleanup function threw an error: ${message}`\n    )\n    this.name = `SyncCleanupError`\n  }\n}\n\n// Query Optimizer Errors\nexport class QueryOptimizerError extends TanStackDBError {\n  constructor(message: string) {\n    super(message)\n    this.name = `QueryOptimizerError`\n  }\n}\n\nexport class CannotCombineEmptyExpressionListError extends QueryOptimizerError {\n  constructor() {\n    super(`Cannot combine empty expression list`)\n  }\n}\n\n/**\n * Internal error when the query optimizer fails to convert a WHERE clause to a collection filter.\n */\nexport class WhereClauseConversionError extends QueryOptimizerError {\n  constructor(collectionId: string, alias: string) {\n    super(\n      `Failed to convert WHERE clause to collection filter for collection '${collectionId}' alias '${alias}'. This indicates a bug in the query optimization logic.`\n    )\n  }\n}\n\n/**\n * Error when a subscription cannot be found during lazy join processing.\n * For subqueries, aliases may be remapped (e.g., 'activeUser' â†’ 'user').\n */\nexport class SubscriptionNotFoundError extends QueryCompilationError {\n  constructor(\n    resolvedAlias: string,\n    originalAlias: string,\n    collectionId: string,\n    availableAliases: Array<string>\n  ) {\n    super(\n      `Internal error: subscription for alias '${resolvedAlias}' (remapped from '${originalAlias}', collection '${collectionId}') is missing in join pipeline. Available aliases: ${availableAliases.join(`, `)}. This indicates a bug in alias tracking.`\n    )\n  }\n}\n\n/**\n * Error thrown when aggregate expressions are used outside of a GROUP BY context.\n */\nexport class AggregateNotSupportedError extends QueryCompilationError {\n  constructor() {\n    super(\n      `Aggregate expressions are not supported in this context. Use GROUP BY clause for aggregates.`\n    )\n  }\n}\n\n/**\n * Internal error when the compiler returns aliases that don't have corresponding input streams.\n * This should never happen since all aliases come from user declarations.\n */\nexport class MissingAliasInputsError extends QueryCompilationError {\n  constructor(missingAliases: Array<string>) {\n    super(\n      `Internal error: compiler returned aliases without inputs: ${missingAliases.join(`, `)}. ` +\n        `This indicates a bug in query compilation. Please report this issue.`\n    )\n  }\n}\n\n/**\n * Error thrown when setWindow is called on a collection without an ORDER BY clause.\n */\nexport class SetWindowRequiresOrderByError extends QueryCompilationError {\n  constructor() {\n    super(\n      `setWindow() can only be called on collections with an ORDER BY clause. ` +\n        `Add .orderBy() to your query to enable window movement.`\n    )\n  }\n}\n", "import { PropRef, Value } from \"../ir.js\"\nimport type { BasicExpression } from \"../ir.js\"\nimport type { RefLeaf } from \"./types.js\"\n\nexport interface RefProxy<T = any> {\n  /** @internal */\n  readonly __refProxy: true\n  /** @internal */\n  readonly __path: Array<string>\n  /** @internal */\n  readonly __type: T\n}\n\n/**\n * Type for creating a RefProxy for a single row/type without namespacing\n * Used in collection indexes and where clauses\n */\nexport type SingleRowRefProxy<T> =\n  T extends Record<string, any>\n    ? {\n        [K in keyof T]: T[K] extends Record<string, any>\n          ? SingleRowRefProxy<T[K]> & RefProxy<T[K]>\n          : RefLeaf<T[K]>\n      } & RefProxy<T>\n    : RefProxy<T>\n\n/**\n * Creates a proxy object that records property access paths for a single row\n * Used in collection indexes and where clauses\n */\nexport function createSingleRowRefProxy<\n  T extends Record<string, any>,\n>(): SingleRowRefProxy<T> {\n  const cache = new Map<string, any>()\n\n  function createProxy(path: Array<string>): any {\n    const pathKey = path.join(`.`)\n    if (cache.has(pathKey)) {\n      return cache.get(pathKey)\n    }\n\n    const proxy = new Proxy({} as any, {\n      get(target, prop, receiver) {\n        if (prop === `__refProxy`) return true\n        if (prop === `__path`) return path\n        if (prop === `__type`) return undefined // Type is only for TypeScript inference\n        if (typeof prop === `symbol`) return Reflect.get(target, prop, receiver)\n\n        const newPath = [...path, String(prop)]\n        return createProxy(newPath)\n      },\n\n      has(target, prop) {\n        if (prop === `__refProxy` || prop === `__path` || prop === `__type`)\n          return true\n        return Reflect.has(target, prop)\n      },\n\n      ownKeys(target) {\n        return Reflect.ownKeys(target)\n      },\n\n      getOwnPropertyDescriptor(target, prop) {\n        if (prop === `__refProxy` || prop === `__path` || prop === `__type`) {\n          return { enumerable: false, configurable: true }\n        }\n        return Reflect.getOwnPropertyDescriptor(target, prop)\n      },\n    })\n\n    cache.set(pathKey, proxy)\n    return proxy\n  }\n\n  // Return the root proxy that starts with an empty path\n  return createProxy([]) as SingleRowRefProxy<T>\n}\n\n/**\n * Creates a proxy object that records property access paths\n * Used in callbacks like where, select, etc. to create type-safe references\n */\nexport function createRefProxy<T extends Record<string, any>>(\n  aliases: Array<string>\n): RefProxy<T> & T {\n  const cache = new Map<string, any>()\n  let accessId = 0 // Monotonic counter to record evaluation order\n\n  function createProxy(path: Array<string>): any {\n    const pathKey = path.join(`.`)\n    if (cache.has(pathKey)) {\n      return cache.get(pathKey)\n    }\n\n    const proxy = new Proxy({} as any, {\n      get(target, prop, receiver) {\n        if (prop === `__refProxy`) return true\n        if (prop === `__path`) return path\n        if (prop === `__type`) return undefined // Type is only for TypeScript inference\n        if (typeof prop === `symbol`) return Reflect.get(target, prop, receiver)\n\n        const newPath = [...path, String(prop)]\n        return createProxy(newPath)\n      },\n\n      has(target, prop) {\n        if (prop === `__refProxy` || prop === `__path` || prop === `__type`)\n          return true\n        return Reflect.has(target, prop)\n      },\n\n      ownKeys(target) {\n        const id = ++accessId\n        const sentinelKey = `__SPREAD_SENTINEL__${path.join(`.`)}__${id}`\n        if (!Object.prototype.hasOwnProperty.call(target, sentinelKey)) {\n          Object.defineProperty(target, sentinelKey, {\n            enumerable: true,\n            configurable: true,\n            value: true,\n          })\n        }\n        return Reflect.ownKeys(target)\n      },\n\n      getOwnPropertyDescriptor(target, prop) {\n        if (prop === `__refProxy` || prop === `__path` || prop === `__type`) {\n          return { enumerable: false, configurable: true }\n        }\n        return Reflect.getOwnPropertyDescriptor(target, prop)\n      },\n    })\n\n    cache.set(pathKey, proxy)\n    return proxy\n  }\n\n  // Create the root proxy with all aliases as top-level properties\n  const rootProxy = new Proxy({} as any, {\n    get(target, prop, receiver) {\n      if (prop === `__refProxy`) return true\n      if (prop === `__path`) return []\n      if (prop === `__type`) return undefined // Type is only for TypeScript inference\n      if (typeof prop === `symbol`) return Reflect.get(target, prop, receiver)\n\n      const propStr = String(prop)\n      if (aliases.includes(propStr)) {\n        return createProxy([propStr])\n      }\n\n      return undefined\n    },\n\n    has(target, prop) {\n      if (prop === `__refProxy` || prop === `__path` || prop === `__type`)\n        return true\n      if (typeof prop === `string` && aliases.includes(prop)) return true\n      return Reflect.has(target, prop)\n    },\n\n    ownKeys(_target) {\n      return [...aliases, `__refProxy`, `__path`, `__type`]\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      if (prop === `__refProxy` || prop === `__path` || prop === `__type`) {\n        return { enumerable: false, configurable: true }\n      }\n      if (typeof prop === `string` && aliases.includes(prop)) {\n        return { enumerable: true, configurable: true }\n      }\n      return undefined\n    },\n  })\n\n  return rootProxy\n}\n\n/**\n * Converts a value to an Expression\n * If it's a RefProxy, creates a Ref, otherwise creates a Value\n */\nexport function toExpression<T = any>(value: T): BasicExpression<T>\nexport function toExpression(value: RefProxy<any>): BasicExpression<any>\nexport function toExpression(value: any): BasicExpression<any> {\n  if (isRefProxy(value)) {\n    return new PropRef(value.__path)\n  }\n  // If it's already an Expression (Func, Ref, Value) or Agg, return it directly\n  if (\n    value &&\n    typeof value === `object` &&\n    `type` in value &&\n    (value.type === `func` ||\n      value.type === `ref` ||\n      value.type === `val` ||\n      value.type === `agg`)\n  ) {\n    return value\n  }\n  return new Value(value)\n}\n\n/**\n * Type guard to check if a value is a RefProxy\n */\nexport function isRefProxy(value: any): value is RefProxy {\n  return value && typeof value === `object` && value.__refProxy === true\n}\n\n/**\n * Helper to create a Value expression from a literal\n */\nexport function val<T>(value: T): BasicExpression<T> {\n  return new Value(value)\n}\n", "import { Aggregate, Func } from \"../ir\"\nimport { toExpression } from \"./ref-proxy.js\"\nimport type { BasicExpression } from \"../ir\"\nimport type { RefProxy } from \"./ref-proxy.js\"\nimport type { RefLeaf } from \"./types.js\"\n\ntype StringRef =\n  | RefLeaf<string>\n  | RefLeaf<string | null>\n  | RefLeaf<string | undefined>\ntype StringRefProxy =\n  | RefProxy<string>\n  | RefProxy<string | null>\n  | RefProxy<string | undefined>\ntype StringBasicExpression =\n  | BasicExpression<string>\n  | BasicExpression<string | null>\n  | BasicExpression<string | undefined>\ntype StringLike =\n  | StringRef\n  | StringRefProxy\n  | StringBasicExpression\n  | string\n  | null\n  | undefined\n\ntype ComparisonOperand<T> =\n  | RefProxy<T>\n  | RefLeaf<T>\n  | T\n  | BasicExpression<T>\n  | undefined\n  | null\ntype ComparisonOperandPrimitive<T extends string | number | boolean> =\n  | T\n  | BasicExpression<T>\n  | undefined\n  | null\n\n// Helper type for any expression-like value\ntype ExpressionLike = BasicExpression | RefProxy<any> | RefLeaf<any> | any\n\n// Helper type to extract the underlying type from various expression types\ntype ExtractType<T> =\n  T extends RefProxy<infer U>\n    ? U\n    : T extends RefLeaf<infer U>\n      ? U\n      : T extends BasicExpression<infer U>\n        ? U\n        : T\n\n// Helper type to determine aggregate return type based on input nullability\ntype AggregateReturnType<T> =\n  ExtractType<T> extends infer U\n    ? U extends number | undefined | null | Date | bigint\n      ? Aggregate<U>\n      : Aggregate<number | undefined | null | Date | bigint>\n    : Aggregate<number | undefined | null | Date | bigint>\n\n// Helper type to determine string function return type based on input nullability\ntype StringFunctionReturnType<T> =\n  ExtractType<T> extends infer U\n    ? U extends string | undefined | null\n      ? BasicExpression<U>\n      : BasicExpression<string | undefined | null>\n    : BasicExpression<string | undefined | null>\n\n// Helper type to determine numeric function return type based on input nullability\n// This handles string, array, and number inputs for functions like length()\ntype NumericFunctionReturnType<T> =\n  ExtractType<T> extends infer U\n    ? U extends string | Array<any> | undefined | null | number\n      ? BasicExpression<MapToNumber<U>>\n      : BasicExpression<number | undefined | null>\n    : BasicExpression<number | undefined | null>\n\n// Transform string/array types to number while preserving nullability\ntype MapToNumber<T> = T extends string | Array<any>\n  ? number\n  : T extends undefined\n    ? undefined\n    : T extends null\n      ? null\n      : T\n\n// Helper type for binary numeric operations (combines nullability of both operands)\ntype BinaryNumericReturnType<T1, T2> =\n  ExtractType<T1> extends infer U1\n    ? ExtractType<T2> extends infer U2\n      ? U1 extends number\n        ? U2 extends number\n          ? BasicExpression<number>\n          : U2 extends number | undefined\n            ? BasicExpression<number | undefined>\n            : U2 extends number | null\n              ? BasicExpression<number | null>\n              : BasicExpression<number | undefined | null>\n        : U1 extends number | undefined\n          ? U2 extends number\n            ? BasicExpression<number | undefined>\n            : U2 extends number | undefined\n              ? BasicExpression<number | undefined>\n              : BasicExpression<number | undefined | null>\n          : U1 extends number | null\n            ? U2 extends number\n              ? BasicExpression<number | null>\n              : BasicExpression<number | undefined | null>\n            : BasicExpression<number | undefined | null>\n      : BasicExpression<number | undefined | null>\n    : BasicExpression<number | undefined | null>\n\n// Operators\n\nexport function eq<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>\n): BasicExpression<boolean>\nexport function eq<T extends string | number | boolean>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>\n): BasicExpression<boolean>\nexport function eq<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function eq(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`eq`, [toExpression(left), toExpression(right)])\n}\n\nexport function gt<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>\n): BasicExpression<boolean>\nexport function gt<T extends string | number>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>\n): BasicExpression<boolean>\nexport function gt<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function gt(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`gt`, [toExpression(left), toExpression(right)])\n}\n\nexport function gte<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>\n): BasicExpression<boolean>\nexport function gte<T extends string | number>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>\n): BasicExpression<boolean>\nexport function gte<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function gte(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`gte`, [toExpression(left), toExpression(right)])\n}\n\nexport function lt<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>\n): BasicExpression<boolean>\nexport function lt<T extends string | number>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>\n): BasicExpression<boolean>\nexport function lt<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function lt(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`lt`, [toExpression(left), toExpression(right)])\n}\n\nexport function lte<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>\n): BasicExpression<boolean>\nexport function lte<T extends string | number>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>\n): BasicExpression<boolean>\nexport function lte<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function lte(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`lte`, [toExpression(left), toExpression(right)])\n}\n\n// Overloads for and() - support 2 or more arguments\nexport function and(\n  left: ExpressionLike,\n  right: ExpressionLike\n): BasicExpression<boolean>\nexport function and(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean>\nexport function and(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean> {\n  const allArgs = [left, right, ...rest]\n  return new Func(\n    `and`,\n    allArgs.map((arg) => toExpression(arg))\n  )\n}\n\n// Overloads for or() - support 2 or more arguments\nexport function or(\n  left: ExpressionLike,\n  right: ExpressionLike\n): BasicExpression<boolean>\nexport function or(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean>\nexport function or(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean> {\n  const allArgs = [left, right, ...rest]\n  return new Func(\n    `or`,\n    allArgs.map((arg) => toExpression(arg))\n  )\n}\n\nexport function not(value: ExpressionLike): BasicExpression<boolean> {\n  return new Func(`not`, [toExpression(value)])\n}\n\n// Null/undefined checking functions\nexport function isUndefined(value: ExpressionLike): BasicExpression<boolean> {\n  return new Func(`isUndefined`, [toExpression(value)])\n}\n\nexport function isNull(value: ExpressionLike): BasicExpression<boolean> {\n  return new Func(`isNull`, [toExpression(value)])\n}\n\nexport function inArray(\n  value: ExpressionLike,\n  array: ExpressionLike\n): BasicExpression<boolean> {\n  return new Func(`in`, [toExpression(value), toExpression(array)])\n}\n\nexport function like(\n  left: StringLike,\n  right: StringLike\n): BasicExpression<boolean>\nexport function like(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`like`, [toExpression(left), toExpression(right)])\n}\n\nexport function ilike(\n  left: StringLike,\n  right: StringLike\n): BasicExpression<boolean> {\n  return new Func(`ilike`, [toExpression(left), toExpression(right)])\n}\n\n// Functions\n\nexport function upper<T extends ExpressionLike>(\n  arg: T\n): StringFunctionReturnType<T> {\n  return new Func(`upper`, [toExpression(arg)]) as StringFunctionReturnType<T>\n}\n\nexport function lower<T extends ExpressionLike>(\n  arg: T\n): StringFunctionReturnType<T> {\n  return new Func(`lower`, [toExpression(arg)]) as StringFunctionReturnType<T>\n}\n\nexport function length<T extends ExpressionLike>(\n  arg: T\n): NumericFunctionReturnType<T> {\n  return new Func(`length`, [toExpression(arg)]) as NumericFunctionReturnType<T>\n}\n\nexport function concat(\n  ...args: Array<ExpressionLike>\n): BasicExpression<string> {\n  return new Func(\n    `concat`,\n    args.map((arg) => toExpression(arg))\n  )\n}\n\nexport function coalesce(...args: Array<ExpressionLike>): BasicExpression<any> {\n  return new Func(\n    `coalesce`,\n    args.map((arg) => toExpression(arg))\n  )\n}\n\nexport function add<T1 extends ExpressionLike, T2 extends ExpressionLike>(\n  left: T1,\n  right: T2\n): BinaryNumericReturnType<T1, T2> {\n  return new Func(`add`, [\n    toExpression(left),\n    toExpression(right),\n  ]) as BinaryNumericReturnType<T1, T2>\n}\n\n// Aggregates\n\nexport function count(arg: ExpressionLike): Aggregate<number> {\n  return new Aggregate(`count`, [toExpression(arg)])\n}\n\nexport function avg<T extends ExpressionLike>(arg: T): AggregateReturnType<T> {\n  return new Aggregate(`avg`, [toExpression(arg)]) as AggregateReturnType<T>\n}\n\nexport function sum<T extends ExpressionLike>(arg: T): AggregateReturnType<T> {\n  return new Aggregate(`sum`, [toExpression(arg)]) as AggregateReturnType<T>\n}\n\nexport function min<T extends ExpressionLike>(arg: T): AggregateReturnType<T> {\n  return new Aggregate(`min`, [toExpression(arg)]) as AggregateReturnType<T>\n}\n\nexport function max<T extends ExpressionLike>(arg: T): AggregateReturnType<T> {\n  return new Aggregate(`max`, [toExpression(arg)]) as AggregateReturnType<T>\n}\n\n/**\n * List of comparison function names that can be used with indexes\n */\nexport const comparisonFunctions = [\n  `eq`,\n  `gt`,\n  `gte`,\n  `lt`,\n  `lte`,\n  `in`,\n  `like`,\n  `ilike`,\n] as const\n\n/**\n * All supported operator names in TanStack DB expressions\n */\nexport const operators = [\n  // Comparison operators\n  `eq`,\n  `gt`,\n  `gte`,\n  `lt`,\n  `lte`,\n  `in`,\n  `like`,\n  `ilike`,\n  // Logical operators\n  `and`,\n  `or`,\n  `not`,\n  // Null checking\n  `isNull`,\n  `isUndefined`,\n  // String functions\n  `upper`,\n  `lower`,\n  `length`,\n  `concat`,\n  // Numeric functions\n  `add`,\n  // Utility functions\n  `coalesce`,\n  // Aggregate functions\n  `count`,\n  `avg`,\n  `sum`,\n  `min`,\n  `max`,\n] as const\n\nexport type OperatorName = (typeof operators)[number]\n", "import type { CompareOptions } from \"../query/builder/types\"\n\n// WeakMap to store stable IDs for objects\nconst objectIds = new WeakMap<object, number>()\nlet nextObjectId = 1\n\n/**\n * Get or create a stable ID for an object\n */\nfunction getObjectId(obj: object): number {\n  if (objectIds.has(obj)) {\n    return objectIds.get(obj)!\n  }\n  const id = nextObjectId++\n  objectIds.set(obj, id)\n  return id\n}\n\n/**\n * Universal comparison function for all data types\n * Handles null/undefined, strings, arrays, dates, objects, and primitives\n * Always sorts null/undefined values first\n */\nexport const ascComparator = (a: any, b: any, opts: CompareOptions): number => {\n  const { nulls } = opts\n\n  // Handle null/undefined\n  if (a == null && b == null) return 0\n  if (a == null) return nulls === `first` ? -1 : 1\n  if (b == null) return nulls === `first` ? 1 : -1\n\n  // if a and b are both strings, compare them based on locale\n  if (typeof a === `string` && typeof b === `string`) {\n    if (opts.stringSort === `locale`) {\n      return a.localeCompare(b, opts.locale, opts.localeOptions)\n    }\n    // For lexical sort we rely on direct comparison for primitive values\n  }\n\n  // if a and b are both arrays, compare them element by element\n  if (Array.isArray(a) && Array.isArray(b)) {\n    for (let i = 0; i < Math.min(a.length, b.length); i++) {\n      const result = ascComparator(a[i], b[i], opts)\n      if (result !== 0) {\n        return result\n      }\n    }\n    // All elements are equal up to the minimum length\n    return a.length - b.length\n  }\n\n  // If both are dates, compare them\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() - b.getTime()\n  }\n\n  // If at least one of the values is an object, use stable IDs for comparison\n  const aIsObject = typeof a === `object`\n  const bIsObject = typeof b === `object`\n\n  if (aIsObject || bIsObject) {\n    // If both are objects, compare their stable IDs\n    if (aIsObject && bIsObject) {\n      const aId = getObjectId(a)\n      const bId = getObjectId(b)\n      return aId - bId\n    }\n\n    // If only one is an object, objects come after primitives\n    if (aIsObject) return 1\n    if (bIsObject) return -1\n  }\n\n  // For primitive values, use direct comparison\n  if (a < b) return -1\n  if (a > b) return 1\n  return 0\n}\n\n/**\n * Descending comparator function for ordering values\n * Handles null/undefined as largest values (opposite of ascending)\n */\nexport const descComparator = (\n  a: unknown,\n  b: unknown,\n  opts: CompareOptions\n): number => {\n  return ascComparator(b, a, {\n    ...opts,\n    nulls: opts.nulls === `first` ? `last` : `first`,\n  })\n}\n\nexport function makeComparator(\n  opts: CompareOptions\n): (a: any, b: any) => number {\n  return (a, b) => {\n    if (opts.direction === `asc`) {\n      return ascComparator(a, b, opts)\n    } else {\n      return descComparator(a, b, opts)\n    }\n  }\n}\n\n/** Default comparator orders values in ascending order with nulls first and locale string comparison. */\nexport const defaultComparator = makeComparator({\n  direction: `asc`,\n  nulls: `first`,\n  stringSort: `locale`,\n})\n\n/**\n * Compare two Uint8Arrays for content equality\n */\nfunction areUint8ArraysEqual(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Threshold for normalizing Uint8Arrays to string representations.\n * Arrays larger than this will use reference equality to avoid memory overhead.\n * 128 bytes is enough for common ID formats (ULIDs are 16 bytes, UUIDs are 16 bytes)\n * while avoiding excessive string allocation for large binary data.\n */\nconst UINT8ARRAY_NORMALIZE_THRESHOLD = 128\n\n/**\n * Normalize a value for comparison and Map key usage\n * Converts values that can't be directly compared or used as Map keys\n * into comparable primitive representations\n */\nexport function normalizeValue(value: any): any {\n  if (value instanceof Date) {\n    return value.getTime()\n  }\n\n  // Normalize Uint8Arrays/Buffers to a string representation for Map key usage\n  // This enables content-based equality for binary data like ULIDs\n  const isUint8Array =\n    (typeof Buffer !== `undefined` && value instanceof Buffer) ||\n    value instanceof Uint8Array\n\n  if (isUint8Array) {\n    // Only normalize small arrays to avoid memory overhead for large binary data\n    if (value.byteLength <= UINT8ARRAY_NORMALIZE_THRESHOLD) {\n      // Convert to a string representation that can be used as a Map key\n      // Use a special prefix to avoid collisions with user strings\n      return `__u8__${Array.from(value).join(`,`)}`\n    }\n    // For large arrays, fall back to reference equality\n    // Users working with large binary data should use a derived key if needed\n  }\n\n  return value\n}\n\n/**\n * Compare two values for equality, with special handling for Uint8Arrays and Buffers\n */\nexport function areValuesEqual(a: any, b: any): boolean {\n  // Fast path for reference equality\n  if (a === b) {\n    return true\n  }\n\n  // Check for Uint8Array/Buffer comparison\n  const aIsUint8Array =\n    (typeof Buffer !== `undefined` && a instanceof Buffer) ||\n    a instanceof Uint8Array\n  const bIsUint8Array =\n    (typeof Buffer !== `undefined` && b instanceof Buffer) ||\n    b instanceof Uint8Array\n\n  // If both are Uint8Arrays, compare by content\n  if (aIsUint8Array && bIsUint8Array) {\n    return areUint8ArraysEqual(a, b)\n  }\n\n  // Different types or not Uint8Arrays\n  return false\n}\n", "import {\n  EmptyReferencePathError,\n  UnknownExpressionTypeError,\n  UnknownFunctionError,\n} from \"../../errors.js\"\nimport { areValuesEqual, normalizeValue } from \"../../utils/comparison.js\"\nimport type { BasicExpression, Func, PropRef } from \"../ir.js\"\nimport type { NamespacedRow } from \"../../types.js\"\n\n/**\n * Helper function to check if a value is null or undefined (represents UNKNOWN in 3-valued logic)\n */\nfunction isUnknown(value: any): boolean {\n  return value === null || value === undefined\n}\n\n/**\n * Converts a 3-valued logic result to a boolean for use in WHERE/HAVING filters.\n * In SQL, UNKNOWN (null) values in WHERE clauses exclude rows, matching false behavior.\n *\n * @param result - The 3-valued logic result: true, false, or null (UNKNOWN)\n * @returns true only if result is explicitly true, false otherwise\n *\n * Truth table:\n * - true â†’ true (include row)\n * - false â†’ false (exclude row)\n * - null (UNKNOWN) â†’ false (exclude row, matching SQL behavior)\n */\nexport function toBooleanPredicate(result: boolean | null): boolean {\n  return result === true\n}\n\n/**\n * Compiled expression evaluator function type\n */\nexport type CompiledExpression = (namespacedRow: NamespacedRow) => any\n\n/**\n * Compiled single-row expression evaluator function type\n */\nexport type CompiledSingleRowExpression = (item: Record<string, unknown>) => any\n\n/**\n * Compiles an expression into an optimized evaluator function.\n * This eliminates branching during evaluation by pre-compiling the expression structure.\n */\nexport function compileExpression(\n  expr: BasicExpression,\n  isSingleRow: boolean = false\n): CompiledExpression | CompiledSingleRowExpression {\n  const compiledFn = compileExpressionInternal(expr, isSingleRow)\n  return compiledFn\n}\n\n/**\n * Compiles a single-row expression into an optimized evaluator function.\n */\nexport function compileSingleRowExpression(\n  expr: BasicExpression\n): CompiledSingleRowExpression {\n  const compiledFn = compileExpressionInternal(expr, true)\n  return compiledFn as CompiledSingleRowExpression\n}\n\n/**\n * Internal unified expression compiler that handles both namespaced and single-row evaluation\n */\nfunction compileExpressionInternal(\n  expr: BasicExpression,\n  isSingleRow: boolean\n): (data: any) => any {\n  switch (expr.type) {\n    case `val`: {\n      // For constant values, return a function that just returns the value\n      const value = expr.value\n      return () => value\n    }\n\n    case `ref`: {\n      // For references, compile based on evaluation mode\n      return isSingleRow ? compileSingleRowRef(expr) : compileRef(expr)\n    }\n\n    case `func`: {\n      // For functions, use the unified compiler\n      return compileFunction(expr, isSingleRow)\n    }\n\n    default:\n      throw new UnknownExpressionTypeError((expr as any).type)\n  }\n}\n\n/**\n * Compiles a reference expression into an optimized evaluator\n */\nfunction compileRef(ref: PropRef): CompiledExpression {\n  const [tableAlias, ...propertyPath] = ref.path\n\n  if (!tableAlias) {\n    throw new EmptyReferencePathError()\n  }\n\n  // Pre-compile the property path navigation\n  if (propertyPath.length === 0) {\n    // Simple table reference\n    return (namespacedRow) => namespacedRow[tableAlias]\n  } else if (propertyPath.length === 1) {\n    // Single property access - most common case\n    const prop = propertyPath[0]!\n    return (namespacedRow) => {\n      const tableData = namespacedRow[tableAlias]\n      return tableData?.[prop]\n    }\n  } else {\n    // Multiple property navigation\n    return (namespacedRow) => {\n      const tableData = namespacedRow[tableAlias]\n      if (tableData === undefined) {\n        return undefined\n      }\n\n      let value: any = tableData\n      for (const prop of propertyPath) {\n        if (value == null) {\n          return value\n        }\n        value = value[prop]\n      }\n      return value\n    }\n  }\n}\n\n/**\n * Compiles a reference expression for single-row evaluation\n */\nfunction compileSingleRowRef(ref: PropRef): CompiledSingleRowExpression {\n  const propertyPath = ref.path\n\n  // This function works for all path lengths including empty path\n  return (item) => {\n    let value: any = item\n    for (const prop of propertyPath) {\n      if (value == null) {\n        return value\n      }\n      value = value[prop]\n    }\n    return value\n  }\n}\n\n/**\n * Compiles a function expression for both namespaced and single-row evaluation\n */\nfunction compileFunction(func: Func, isSingleRow: boolean): (data: any) => any {\n  // Pre-compile all arguments using the appropriate compiler\n  const compiledArgs = func.args.map((arg) =>\n    compileExpressionInternal(arg, isSingleRow)\n  )\n\n  switch (func.name) {\n    // Comparison operators\n    case `eq`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = normalizeValue(argA(data))\n        const b = normalizeValue(argB(data))\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        // Use areValuesEqual for proper Uint8Array/Buffer comparison\n        return areValuesEqual(a, b)\n      }\n    }\n    case `gt`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        return a > b\n      }\n    }\n    case `gte`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        return a >= b\n      }\n    }\n    case `lt`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        return a < b\n      }\n    }\n    case `lte`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        return a <= b\n      }\n    }\n\n    // Boolean operators\n    case `and`:\n      return (data) => {\n        // 3-valued logic for AND:\n        // - false AND anything = false (short-circuit)\n        // - null AND false = false\n        // - null AND anything (except false) = null\n        // - anything (except false) AND null = null\n        // - true AND true = true\n        let hasUnknown = false\n        for (const compiledArg of compiledArgs) {\n          const result = compiledArg(data)\n          if (result === false) {\n            return false\n          }\n          if (isUnknown(result)) {\n            hasUnknown = true\n          }\n        }\n        // If we got here, no operand was false\n        // If any operand was null, return null (UNKNOWN)\n        if (hasUnknown) {\n          return null\n        }\n\n        return true\n      }\n    case `or`:\n      return (data) => {\n        // 3-valued logic for OR:\n        // - true OR anything = true (short-circuit)\n        // - null OR anything (except true) = null\n        // - false OR false = false\n        let hasUnknown = false\n        for (const compiledArg of compiledArgs) {\n          const result = compiledArg(data)\n          if (result === true) {\n            return true\n          }\n          if (isUnknown(result)) {\n            hasUnknown = true\n          }\n        }\n        // If we got here, no operand was true\n        // If any operand was null, return null (UNKNOWN)\n        if (hasUnknown) {\n          return null\n        }\n\n        return false\n      }\n    case `not`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        // 3-valued logic for NOT:\n        // - NOT null = null\n        // - NOT true = false\n        // - NOT false = true\n        const result = arg(data)\n        if (isUnknown(result)) {\n          return null\n        }\n        return !result\n      }\n    }\n\n    // Array operators\n    case `in`: {\n      const valueEvaluator = compiledArgs[0]!\n      const arrayEvaluator = compiledArgs[1]!\n      return (data) => {\n        const value = valueEvaluator(data)\n        const array = arrayEvaluator(data)\n        // In 3-valued logic, if the value is null/undefined, return UNKNOWN\n        if (isUnknown(value)) {\n          return null\n        }\n        if (!Array.isArray(array)) {\n          return false\n        }\n        return array.includes(value)\n      }\n    }\n\n    // String operators\n    case `like`: {\n      const valueEvaluator = compiledArgs[0]!\n      const patternEvaluator = compiledArgs[1]!\n      return (data) => {\n        const value = valueEvaluator(data)\n        const pattern = patternEvaluator(data)\n        // In 3-valued logic, if value or pattern is null/undefined, return UNKNOWN\n        if (isUnknown(value) || isUnknown(pattern)) {\n          return null\n        }\n        return evaluateLike(value, pattern, false)\n      }\n    }\n    case `ilike`: {\n      const valueEvaluator = compiledArgs[0]!\n      const patternEvaluator = compiledArgs[1]!\n      return (data) => {\n        const value = valueEvaluator(data)\n        const pattern = patternEvaluator(data)\n        // In 3-valued logic, if value or pattern is null/undefined, return UNKNOWN\n        if (isUnknown(value) || isUnknown(pattern)) {\n          return null\n        }\n        return evaluateLike(value, pattern, true)\n      }\n    }\n\n    // String functions\n    case `upper`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return typeof value === `string` ? value.toUpperCase() : value\n      }\n    }\n    case `lower`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return typeof value === `string` ? value.toLowerCase() : value\n      }\n    }\n    case `length`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        if (typeof value === `string`) {\n          return value.length\n        }\n        if (Array.isArray(value)) {\n          return value.length\n        }\n        return 0\n      }\n    }\n    case `concat`:\n      return (data) => {\n        return compiledArgs\n          .map((evaluator) => {\n            const arg = evaluator(data)\n            try {\n              return String(arg ?? ``)\n            } catch {\n              try {\n                return JSON.stringify(arg) || ``\n              } catch {\n                return `[object]`\n              }\n            }\n          })\n          .join(``)\n      }\n    case `coalesce`:\n      return (data) => {\n        for (const evaluator of compiledArgs) {\n          const value = evaluator(data)\n          if (value !== null && value !== undefined) {\n            return value\n          }\n        }\n        return null\n      }\n\n    // Math functions\n    case `add`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return (a ?? 0) + (b ?? 0)\n      }\n    }\n    case `subtract`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return (a ?? 0) - (b ?? 0)\n      }\n    }\n    case `multiply`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return (a ?? 0) * (b ?? 0)\n      }\n    }\n    case `divide`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        const divisor = b ?? 0\n        return divisor !== 0 ? (a ?? 0) / divisor : null\n      }\n    }\n\n    // Null/undefined checking functions\n    case `isUndefined`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return value === undefined\n      }\n    }\n    case `isNull`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return value === null\n      }\n    }\n\n    default:\n      throw new UnknownFunctionError(func.name)\n  }\n}\n\n/**\n * Evaluates LIKE/ILIKE patterns\n */\nfunction evaluateLike(\n  value: any,\n  pattern: any,\n  caseInsensitive: boolean\n): boolean {\n  if (typeof value !== `string` || typeof pattern !== `string`) {\n    return false\n  }\n\n  const searchValue = caseInsensitive ? value.toLowerCase() : value\n  const searchPattern = caseInsensitive ? pattern.toLowerCase() : pattern\n\n  // Convert SQL LIKE pattern to regex\n  // First escape all regex special chars except % and _\n  let regexPattern = searchPattern.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\n\n  // Then convert SQL wildcards to regex\n  regexPattern = regexPattern.replace(/%/g, `.*`) // % matches any sequence\n  regexPattern = regexPattern.replace(/_/g, `.`) // _ matches any single char\n\n  const regex = new RegExp(`^${regexPattern}$`)\n  return regex.test(searchValue)\n}\n", "/**\n * Generic utility functions\n */\n\nimport type { CompareOptions } from \"./query/builder/types\"\n\ninterface TypedArray {\n  length: number\n  [index: number]: number\n}\n\n/**\n * Deep equality function that compares two values recursively\n * Handles primitives, objects, arrays, Date, RegExp, Map, Set, TypedArrays, and Temporal objects\n *\n * @param a - First value to compare\n * @param b - Second value to compare\n * @returns True if the values are deeply equal, false otherwise\n *\n * @example\n * ```typescript\n * deepEquals({ a: 1, b: 2 }, { b: 2, a: 1 }) // true (property order doesn't matter)\n * deepEquals([1, { x: 2 }], [1, { x: 2 }]) // true\n * deepEquals({ a: 1 }, { a: 2 }) // false\n * deepEquals(new Date('2023-01-01'), new Date('2023-01-01')) // true\n * deepEquals(new Map([['a', 1]]), new Map([['a', 1]])) // true\n * ```\n */\nexport function deepEquals(a: any, b: any): boolean {\n  return deepEqualsInternal(a, b, new Map())\n}\n\n/**\n * Internal implementation with cycle detection to prevent infinite recursion\n */\nfunction deepEqualsInternal(\n  a: any,\n  b: any,\n  visited: Map<object, object>\n): boolean {\n  // Handle strict equality (primitives, same reference)\n  if (a === b) return true\n\n  // Handle null/undefined\n  if (a == null || b == null) return false\n\n  // Handle different types\n  if (typeof a !== typeof b) return false\n\n  // Handle Date objects\n  if (a instanceof Date) {\n    if (!(b instanceof Date)) return false\n    return a.getTime() === b.getTime()\n  }\n\n  // Handle RegExp objects\n  if (a instanceof RegExp) {\n    if (!(b instanceof RegExp)) return false\n    return a.source === b.source && a.flags === b.flags\n  }\n\n  // Handle Map objects - only if both are Maps\n  if (a instanceof Map) {\n    if (!(b instanceof Map)) return false\n    if (a.size !== b.size) return false\n\n    // Check for circular references\n    if (visited.has(a)) {\n      return visited.get(a) === b\n    }\n    visited.set(a, b)\n\n    const entries = Array.from(a.entries())\n    const result = entries.every(([key, val]) => {\n      return b.has(key) && deepEqualsInternal(val, b.get(key), visited)\n    })\n\n    visited.delete(a)\n    return result\n  }\n\n  // Handle Set objects - only if both are Sets\n  if (a instanceof Set) {\n    if (!(b instanceof Set)) return false\n    if (a.size !== b.size) return false\n\n    // Check for circular references\n    if (visited.has(a)) {\n      return visited.get(a) === b\n    }\n    visited.set(a, b)\n\n    // Convert to arrays for comparison\n    const aValues = Array.from(a)\n    const bValues = Array.from(b)\n\n    // Simple comparison for primitive values\n    if (aValues.every((val) => typeof val !== `object`)) {\n      visited.delete(a)\n      return aValues.every((val) => b.has(val))\n    }\n\n    // For objects in sets, we need to do a more complex comparison\n    // This is a simplified approach and may not work for all cases\n    const result = aValues.length === bValues.length\n    visited.delete(a)\n    return result\n  }\n\n  // Handle TypedArrays\n  if (\n    ArrayBuffer.isView(a) &&\n    ArrayBuffer.isView(b) &&\n    !(a instanceof DataView) &&\n    !(b instanceof DataView)\n  ) {\n    const typedA = a as unknown as TypedArray\n    const typedB = b as unknown as TypedArray\n    if (typedA.length !== typedB.length) return false\n\n    for (let i = 0; i < typedA.length; i++) {\n      if (typedA[i] !== typedB[i]) return false\n    }\n\n    return true\n  }\n\n  // Handle Temporal objects\n  // Check if both are Temporal objects of the same type\n  if (isTemporal(a) && isTemporal(b)) {\n    const aTag = getStringTag(a)\n    const bTag = getStringTag(b)\n\n    // If they're different Temporal types, they're not equal\n    if (aTag !== bTag) return false\n\n    // Use Temporal's built-in equals method if available\n    if (typeof a.equals === `function`) {\n      return a.equals(b)\n    }\n\n    // Fallback to toString comparison for other types\n    return a.toString() === b.toString()\n  }\n\n  // Handle arrays\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) return false\n\n    // Check for circular references\n    if (visited.has(a)) {\n      return visited.get(a) === b\n    }\n    visited.set(a, b)\n\n    const result = a.every((item, index) =>\n      deepEqualsInternal(item, b[index], visited)\n    )\n    visited.delete(a)\n    return result\n  }\n\n  // Handle objects\n  if (typeof a === `object`) {\n    // Check for circular references\n    if (visited.has(a)) {\n      return visited.get(a) === b\n    }\n    visited.set(a, b)\n\n    // Get all keys from both objects\n    const keysA = Object.keys(a)\n    const keysB = Object.keys(b)\n\n    // Check if they have the same number of keys\n    if (keysA.length !== keysB.length) {\n      visited.delete(a)\n      return false\n    }\n\n    // Check if all keys exist in both objects and their values are equal\n    const result = keysA.every(\n      (key) => key in b && deepEqualsInternal(a[key], b[key], visited)\n    )\n\n    visited.delete(a)\n    return result\n  }\n\n  // For primitives that aren't strictly equal\n  return false\n}\n\nconst temporalTypes = [\n  `Temporal.Duration`,\n  `Temporal.Instant`,\n  `Temporal.PlainDate`,\n  `Temporal.PlainDateTime`,\n  `Temporal.PlainMonthDay`,\n  `Temporal.PlainTime`,\n  `Temporal.PlainYearMonth`,\n  `Temporal.ZonedDateTime`,\n]\n\nfunction getStringTag(a: any): any {\n  return a[Symbol.toStringTag]\n}\n\n/** Checks if the value is a Temporal object by checking for the Temporal brand */\nexport function isTemporal(a: any): boolean {\n  const tag = getStringTag(a)\n  return typeof tag === `string` && temporalTypes.includes(tag)\n}\n\nexport const DEFAULT_COMPARE_OPTIONS: CompareOptions = {\n  direction: `asc`,\n  nulls: `first`,\n  stringSort: `locale`,\n}\n", "import { compileSingleRowExpression } from \"../query/compiler/evaluators.js\"\nimport { comparisonFunctions } from \"../query/builder/functions.js\"\nimport { DEFAULT_COMPARE_OPTIONS, deepEquals } from \"../utils.js\"\nimport type { RangeQueryOptions } from \"./btree-index.js\"\nimport type { CompareOptions } from \"../query/builder/types.js\"\nimport type { BasicExpression, OrderByDirection } from \"../query/ir.js\"\n\n/**\n * Operations that indexes can support, imported from available comparison functions\n */\nexport const IndexOperation = comparisonFunctions\n\n/**\n * Type for index operation values\n */\nexport type IndexOperation = (typeof comparisonFunctions)[number]\n\n/**\n * Statistics about index usage and performance\n */\nexport interface IndexStats {\n  readonly entryCount: number\n  readonly lookupCount: number\n  readonly averageLookupTime: number\n  readonly lastUpdated: Date\n}\n\nexport interface IndexInterface<\n  TKey extends string | number = string | number,\n> {\n  add: (key: TKey, item: any) => void\n  remove: (key: TKey, item: any) => void\n  update: (key: TKey, oldItem: any, newItem: any) => void\n\n  build: (entries: Iterable<[TKey, any]>) => void\n  clear: () => void\n\n  lookup: (operation: IndexOperation, value: any) => Set<TKey>\n\n  equalityLookup: (value: any) => Set<TKey>\n  inArrayLookup: (values: Array<any>) => Set<TKey>\n\n  rangeQuery: (options: RangeQueryOptions) => Set<TKey>\n  rangeQueryReversed: (options: RangeQueryOptions) => Set<TKey>\n\n  take: (\n    n: number,\n    from?: TKey,\n    filterFn?: (key: TKey) => boolean\n  ) => Array<TKey>\n  takeReversed: (\n    n: number,\n    from?: TKey,\n    filterFn?: (key: TKey) => boolean\n  ) => Array<TKey>\n\n  get keyCount(): number\n  get orderedEntriesArray(): Array<[any, Set<TKey>]>\n  get orderedEntriesArrayReversed(): Array<[any, Set<TKey>]>\n\n  get indexedKeysSet(): Set<TKey>\n  get valueMapData(): Map<any, Set<TKey>>\n\n  supports: (operation: IndexOperation) => boolean\n\n  matchesField: (fieldPath: Array<string>) => boolean\n  matchesCompareOptions: (compareOptions: CompareOptions) => boolean\n  matchesDirection: (direction: OrderByDirection) => boolean\n\n  getStats: () => IndexStats\n}\n\n/**\n * Base abstract class that all index types extend\n */\nexport abstract class BaseIndex<TKey extends string | number = string | number>\n  implements IndexInterface<TKey>\n{\n  public readonly id: number\n  public readonly name?: string\n  public readonly expression: BasicExpression\n  public abstract readonly supportedOperations: Set<IndexOperation>\n\n  protected lookupCount = 0\n  protected totalLookupTime = 0\n  protected lastUpdated = new Date()\n  protected compareOptions: CompareOptions\n\n  constructor(\n    id: number,\n    expression: BasicExpression,\n    name?: string,\n    options?: any\n  ) {\n    this.id = id\n    this.expression = expression\n    this.compareOptions = DEFAULT_COMPARE_OPTIONS\n    this.name = name\n    this.initialize(options)\n  }\n\n  // Abstract methods that each index type must implement\n  abstract add(key: TKey, item: any): void\n  abstract remove(key: TKey, item: any): void\n  abstract update(key: TKey, oldItem: any, newItem: any): void\n  abstract build(entries: Iterable<[TKey, any]>): void\n  abstract clear(): void\n  abstract lookup(operation: IndexOperation, value: any): Set<TKey>\n  abstract take(\n    n: number,\n    from?: TKey,\n    filterFn?: (key: TKey) => boolean\n  ): Array<TKey>\n  abstract takeReversed(\n    n: number,\n    from?: TKey,\n    filterFn?: (key: TKey) => boolean\n  ): Array<TKey>\n  abstract get keyCount(): number\n  abstract equalityLookup(value: any): Set<TKey>\n  abstract inArrayLookup(values: Array<any>): Set<TKey>\n  abstract rangeQuery(options: RangeQueryOptions): Set<TKey>\n  abstract rangeQueryReversed(options: RangeQueryOptions): Set<TKey>\n  abstract get orderedEntriesArray(): Array<[any, Set<TKey>]>\n  abstract get orderedEntriesArrayReversed(): Array<[any, Set<TKey>]>\n  abstract get indexedKeysSet(): Set<TKey>\n  abstract get valueMapData(): Map<any, Set<TKey>>\n\n  // Common methods\n  supports(operation: IndexOperation): boolean {\n    return this.supportedOperations.has(operation)\n  }\n\n  matchesField(fieldPath: Array<string>): boolean {\n    return (\n      this.expression.type === `ref` &&\n      this.expression.path.length === fieldPath.length &&\n      this.expression.path.every((part, i) => part === fieldPath[i])\n    )\n  }\n\n  /**\n   * Checks if the compare options match the index's compare options.\n   * The direction is ignored because the index can be reversed if the direction is different.\n   */\n  matchesCompareOptions(compareOptions: CompareOptions): boolean {\n    const thisCompareOptionsWithoutDirection = {\n      ...this.compareOptions,\n      direction: undefined,\n    }\n    const compareOptionsWithoutDirection = {\n      ...compareOptions,\n      direction: undefined,\n    }\n\n    return deepEquals(\n      thisCompareOptionsWithoutDirection,\n      compareOptionsWithoutDirection\n    )\n  }\n\n  /**\n   * Checks if the index matches the provided direction.\n   */\n  matchesDirection(direction: OrderByDirection): boolean {\n    return this.compareOptions.direction === direction\n  }\n\n  getStats(): IndexStats {\n    return {\n      entryCount: this.keyCount,\n      lookupCount: this.lookupCount,\n      averageLookupTime:\n        this.lookupCount > 0 ? this.totalLookupTime / this.lookupCount : 0,\n      lastUpdated: this.lastUpdated,\n    }\n  }\n\n  // Protected methods for subclasses\n  protected abstract initialize(options?: any): void\n\n  protected evaluateIndexExpression(item: any): any {\n    const evaluator = compileSingleRowExpression(this.expression)\n    return evaluator(item as Record<string, unknown>)\n  }\n\n  protected trackLookup(startTime: number): void {\n    const duration = performance.now() - startTime\n    this.lookupCount++\n    this.totalLookupTime += duration\n  }\n\n  protected updateTimestamp(): void {\n    this.lastUpdated = new Date()\n  }\n}\n\n/**\n * Type for index constructor\n */\nexport type IndexConstructor<TKey extends string | number = string | number> =\n  new (\n    id: number,\n    expression: BasicExpression,\n    name?: string,\n    options?: any\n  ) => BaseIndex<TKey>\n\n/**\n * Index resolver can be either a class constructor or async loader\n */\nexport type IndexResolver<TKey extends string | number = string | number> =\n  | IndexConstructor<TKey>\n  | (() => Promise<IndexConstructor<TKey>>)\n", "// This file was copied from https://github.com/qwertie/btree-typescript/tree/master and adapted to our needs.\n// We removed methods that we don't need.\n\n// B+ tree by David Piepgrass. License: MIT\ntype EditRangeResult<V, R = number> = {\n  value?: V\n  break?: R\n  delete?: boolean\n}\n\ntype index = number\n\n// Informative microbenchmarks & stuff:\n// http://www.jayconrod.com/posts/52/a-tour-of-v8-object-representation (very educational)\n// https://blog.mozilla.org/luke/2012/10/02/optimizing-javascript-variable-access/ (local vars are faster than properties)\n// http://benediktmeurer.de/2017/12/13/an-introduction-to-speculative-optimization-in-v8/ (other stuff)\n// https://jsperf.com/js-in-operator-vs-alternatives (avoid 'in' operator; `.p!==undefined` faster than `hasOwnProperty('p')` in all browsers)\n// https://jsperf.com/instanceof-vs-typeof-vs-constructor-vs-member (speed of type tests varies wildly across browsers)\n// https://jsperf.com/detecting-arrays-new (a.constructor===Array is best across browsers, assuming a is an object)\n// https://jsperf.com/shallow-cloning-methods (a constructor is faster than Object.create; hand-written clone faster than Object.assign)\n// https://jsperf.com/ways-to-fill-an-array (slice-and-replace is fastest)\n// https://jsperf.com/math-min-max-vs-ternary-vs-if (Math.min/max is slow on Edge)\n// https://jsperf.com/array-vs-property-access-speed (v.x/v.y is faster than a[0]/a[1] in major browsers IF hidden class is constant)\n// https://jsperf.com/detect-not-null-or-undefined (`x==null` slightly slower than `x===null||x===undefined` on all browsers)\n// Overall, microbenchmarks suggest Firefox is the fastest browser for JavaScript and Edge is the slowest.\n// Lessons from https://v8project.blogspot.com/2017/09/elements-kinds-in-v8.html:\n//   - Avoid holes in arrays. Avoid `new Array(N)`, it will be \"holey\" permanently.\n//   - Don't read outside bounds of an array (it scans prototype chain).\n//   - Small integer arrays are stored differently from doubles\n//   - Adding non-numbers to an array deoptimizes it permanently into a general array\n//   - Objects can be used like arrays (e.g. have length property) but are slower\n//   - V8 source (NewElementsCapacity in src/objects.h): arrays grow by 50% + 16 elements\n\n/**\n * A reasonably fast collection of key-value pairs with a powerful API.\n * Largely compatible with the standard Map. BTree is a B+ tree data structure,\n * so the collection is sorted by key.\n *\n * B+ trees tend to use memory more efficiently than hashtables such as the\n * standard Map, especially when the collection contains a large number of\n * items. However, maintaining the sort order makes them modestly slower:\n * O(log size) rather than O(1). This B+ tree implementation supports O(1)\n * fast cloning. It also supports freeze(), which can be used to ensure that\n * a BTree is not changed accidentally.\n *\n * Confusingly, the ES6 Map.forEach(c) method calls c(value,key) instead of\n * c(key,value), in contrast to other methods such as set() and entries()\n * which put the key first. I can only assume that the order was reversed on\n * the theory that users would usually want to examine values and ignore keys.\n * BTree's forEach() therefore works the same way, but a second method\n * `.forEachPair((key,value)=>{...})` is provided which sends you the key\n * first and the value second; this method is slightly faster because it is\n * the \"native\" for-each method for this class.\n *\n * Out of the box, BTree supports keys that are numbers, strings, arrays of\n * numbers/strings, Date, and objects that have a valueOf() method returning a\n * number or string. Other data types, such as arrays of Date or custom\n * objects, require a custom comparator, which you must pass as the second\n * argument to the constructor (the first argument is an optional list of\n * initial items). Symbols cannot be used as keys because they are unordered\n * (one Symbol is never \"greater\" or \"less\" than another).\n *\n * @example\n * Given a {name: string, age: number} object, you can create a tree sorted by\n * name and then by age like this:\n *\n *     var tree = new BTree(undefined, (a, b) => {\n *       if (a.name > b.name)\n *         return 1; // Return a number >0 when a > b\n *       else if (a.name < b.name)\n *         return -1; // Return a number <0 when a < b\n *       else // names are equal (or incomparable)\n *         return a.age - b.age; // Return >0 when a.age > b.age\n *     });\n *\n *     tree.set({name:\"Bill\", age:17}, \"happy\");\n *     tree.set({name:\"Fran\", age:40}, \"busy & stressed\");\n *     tree.set({name:\"Bill\", age:55}, \"recently laid off\");\n *     tree.forEachPair((k, v) => {\n *       console.log(`Name: ${k.name} Age: ${k.age} Status: ${v}`);\n *     });\n *\n * @description\n * The \"range\" methods (`forEach, forRange, editRange`) will return the number\n * of elements that were scanned. In addition, the callback can return {break:R}\n * to stop early and return R from the outer function.\n *\n * - TODO: Test performance of preallocating values array at max size\n * - TODO: Add fast initialization when a sorted array is provided to constructor\n *\n * For more documentation see https://github.com/qwertie/btree-typescript\n *\n * Are you a C# developer? You might like the similar data structures I made for C#:\n * BDictionary, BList, etc. See http://core.loyc.net/collections/\n *\n * @author David Piepgrass\n */\nexport class BTree<K = any, V = any> {\n  private _root: BNode<K, V> = EmptyLeaf as BNode<K, V>\n  _size = 0\n  _maxNodeSize: number\n\n  /**\n   * provides a total order over keys (and a strict partial order over the type K)\n   * @returns a negative value if a < b, 0 if a === b and a positive value if a > b\n   */\n  _compare: (a: K, b: K) => number\n\n  /**\n   * Initializes an empty B+ tree.\n   * @param compare Custom function to compare pairs of elements in the tree.\n   *   If not specified, defaultComparator will be used which is valid as long as K extends DefaultComparable.\n   * @param entries A set of key-value pairs to initialize the tree\n   * @param maxNodeSize Branching factor (maximum items or children per node)\n   *   Must be in range 4..256. If undefined or <4 then default is used; if >256 then 256.\n   */\n  public constructor(\n    compare: (a: K, b: K) => number,\n    entries?: Array<[K, V]>,\n    maxNodeSize?: number\n  ) {\n    this._maxNodeSize = maxNodeSize! >= 4 ? Math.min(maxNodeSize!, 256) : 32\n    this._compare = compare\n    if (entries) this.setPairs(entries)\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // ES6 Map<K,V> methods /////////////////////////////////////////////////////\n\n  /** Gets the number of key-value pairs in the tree. */\n  get size() {\n    return this._size\n  }\n  /** Gets the number of key-value pairs in the tree. */\n  get length() {\n    return this._size\n  }\n  /** Returns true iff the tree contains no key-value pairs. */\n  get isEmpty() {\n    return this._size === 0\n  }\n\n  /** Releases the tree so that its size is 0. */\n  clear() {\n    this._root = EmptyLeaf as BNode<K, V>\n    this._size = 0\n  }\n\n  /**\n   * Finds a pair in the tree and returns the associated value.\n   * @param defaultValue a value to return if the key was not found.\n   * @returns the value, or defaultValue if the key was not found.\n   * @description Computational complexity: O(log size)\n   */\n  get(key: K, defaultValue?: V): V | undefined {\n    return this._root.get(key, defaultValue, this)\n  }\n\n  /**\n   * Adds or overwrites a key-value pair in the B+ tree.\n   * @param key the key is used to determine the sort order of\n   *        data in the tree.\n   * @param value data to associate with the key (optional)\n   * @param overwrite Whether to overwrite an existing key-value pair\n   *        (default: true). If this is false and there is an existing\n   *        key-value pair then this method has no effect.\n   * @returns true if a new key-value pair was added.\n   * @description Computational complexity: O(log size)\n   * Note: when overwriting a previous entry, the key is updated\n   * as well as the value. This has no effect unless the new key\n   * has data that does not affect its sort order.\n   */\n  set(key: K, value: V, overwrite?: boolean): boolean {\n    if (this._root.isShared) this._root = this._root.clone()\n    const result = this._root.set(key, value, overwrite, this)\n    if (result === true || result === false) return result\n    // Root node has split, so create a new root node.\n    this._root = new BNodeInternal<K, V>([this._root, result])\n    return true\n  }\n\n  /**\n   * Returns true if the key exists in the B+ tree, false if not.\n   * Use get() for best performance; use has() if you need to\n   * distinguish between \"undefined value\" and \"key not present\".\n   * @param key Key to detect\n   * @description Computational complexity: O(log size)\n   */\n  has(key: K): boolean {\n    return this.forRange(key, key, true, undefined) !== 0\n  }\n\n  /**\n   * Removes a single key-value pair from the B+ tree.\n   * @param key Key to find\n   * @returns true if a pair was found and removed, false otherwise.\n   * @description Computational complexity: O(log size)\n   */\n  delete(key: K): boolean {\n    return this.editRange(key, key, true, DeleteRange) !== 0\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Additional methods ///////////////////////////////////////////////////////\n\n  /** Returns the maximum number of children/values before nodes will split. */\n  get maxNodeSize() {\n    return this._maxNodeSize\n  }\n\n  /** Gets the lowest key in the tree. Complexity: O(log size) */\n  minKey(): K | undefined {\n    return this._root.minKey()\n  }\n\n  /** Gets the highest key in the tree. Complexity: O(1) */\n  maxKey(): K | undefined {\n    return this._root.maxKey()\n  }\n\n  /** Gets an array of all keys, sorted */\n  keysArray() {\n    const results: Array<K> = []\n    this._root.forRange(\n      this.minKey()!,\n      this.maxKey()!,\n      true,\n      false,\n      this,\n      0,\n      (k, _v) => {\n        results.push(k)\n      }\n    )\n    return results\n  }\n\n  /** Returns the next pair whose key is larger than the specified key (or undefined if there is none).\n   * If key === undefined, this function returns the lowest pair.\n   * @param key The key to search for.\n   * @param reusedArray Optional array used repeatedly to store key-value pairs, to\n   * avoid creating a new array on every iteration.\n   */\n  nextHigherPair(key: K | undefined, reusedArray?: [K, V]): [K, V] | undefined {\n    reusedArray = reusedArray || ([] as unknown as [K, V])\n    if (key === undefined) {\n      return this._root.minPair(reusedArray)\n    }\n    return this._root.getPairOrNextHigher(\n      key,\n      this._compare,\n      false,\n      reusedArray\n    )\n  }\n\n  /** Returns the next key larger than the specified key, or undefined if there is none.\n   *  Also, nextHigherKey(undefined) returns the lowest key.\n   */\n  nextHigherKey(key: K | undefined): K | undefined {\n    const p = this.nextHigherPair(key, ReusedArray as [K, V])\n    return p && p[0]\n  }\n\n  /** Returns the next pair whose key is smaller than the specified key (or undefined if there is none).\n   *  If key === undefined, this function returns the highest pair.\n   * @param key The key to search for.\n   * @param reusedArray Optional array used repeatedly to store key-value pairs, to\n   *        avoid creating a new array each time you call this method.\n   */\n  nextLowerPair(key: K | undefined, reusedArray?: [K, V]): [K, V] | undefined {\n    reusedArray = reusedArray || ([] as unknown as [K, V])\n    if (key === undefined) {\n      return this._root.maxPair(reusedArray)\n    }\n    return this._root.getPairOrNextLower(key, this._compare, false, reusedArray)\n  }\n\n  /** Returns the next key smaller than the specified key, or undefined if there is none.\n   *  Also, nextLowerKey(undefined) returns the highest key.\n   */\n  nextLowerKey(key: K | undefined): K | undefined {\n    const p = this.nextLowerPair(key, ReusedArray as [K, V])\n    return p && p[0]\n  }\n\n  /** Adds all pairs from a list of key-value pairs.\n   * @param pairs Pairs to add to this tree. If there are duplicate keys,\n   *        later pairs currently overwrite earlier ones (e.g. [[0,1],[0,7]]\n   *        associates 0 with 7.)\n   * @param overwrite Whether to overwrite pairs that already exist (if false,\n   *        pairs[i] is ignored when the key pairs[i][0] already exists.)\n   * @returns The number of pairs added to the collection.\n   * @description Computational complexity: O(pairs.length * log(size + pairs.length))\n   */\n  setPairs(pairs: Array<[K, V]>, overwrite?: boolean): number {\n    let added = 0\n    for (const pair of pairs) {\n      if (this.set(pair[0], pair[1], overwrite)) added++\n    }\n    return added\n  }\n\n  forRange(\n    low: K,\n    high: K,\n    includeHigh: boolean,\n    onFound?: (k: K, v: V, counter: number) => void,\n    initialCounter?: number\n  ): number\n\n  /**\n   * Scans the specified range of keys, in ascending order by key.\n   * Note: the callback `onFound` must not insert or remove items in the\n   * collection. Doing so may cause incorrect data to be sent to the\n   * callback afterward.\n   * @param low The first key scanned will be greater than or equal to `low`.\n   * @param high Scanning stops when a key larger than this is reached.\n   * @param includeHigh If the `high` key is present, `onFound` is called for\n   *        that final pair if and only if this parameter is true.\n   * @param onFound A function that is called for each key-value pair. This\n   *        function can return {break:R} to stop early with result R.\n   * @param initialCounter Initial third argument of onFound. This value\n   *        increases by one each time `onFound` is called. Default: 0\n   * @returns The number of values found, or R if the callback returned\n   *        `{break:R}` to stop early.\n   * @description Computational complexity: O(number of items scanned + log size)\n   */\n  forRange<R = number>(\n    low: K,\n    high: K,\n    includeHigh: boolean,\n    onFound?: (k: K, v: V, counter: number) => { break?: R } | void,\n    initialCounter?: number\n  ): R | number {\n    const r = this._root.forRange(\n      low,\n      high,\n      includeHigh,\n      false,\n      this,\n      initialCounter || 0,\n      onFound\n    )\n    return typeof r === `number` ? r : r.break!\n  }\n\n  /**\n   * Scans and potentially modifies values for a subsequence of keys.\n   * Note: the callback `onFound` should ideally be a pure function.\n   *   Specfically, it must not insert items, call clone(), or change\n   *   the collection except via return value; out-of-band editing may\n   *   cause an exception or may cause incorrect data to be sent to\n   *   the callback (duplicate or missed items). It must not cause a\n   *   clone() of the collection, otherwise the clone could be modified\n   *   by changes requested by the callback.\n   * @param low The first key scanned will be greater than or equal to `low`.\n   * @param high Scanning stops when a key larger than this is reached.\n   * @param includeHigh If the `high` key is present, `onFound` is called for\n   *        that final pair if and only if this parameter is true.\n   * @param onFound A function that is called for each key-value pair. This\n   *        function can return `{value:v}` to change the value associated\n   *        with the current key, `{delete:true}` to delete the current pair,\n   *        `{break:R}` to stop early with result R, or it can return nothing\n   *        (undefined or {}) to cause no effect and continue iterating.\n   *        `{break:R}` can be combined with one of the other two commands.\n   *        The third argument `counter` is the number of items iterated\n   *        previously; it equals 0 when `onFound` is called the first time.\n   * @returns The number of values scanned, or R if the callback returned\n   *        `{break:R}` to stop early.\n   * @description\n   *   Computational complexity: O(number of items scanned + log size)\n   *   Note: if the tree has been cloned with clone(), any shared\n   *   nodes are copied before `onFound` is called. This takes O(n) time\n   *   where n is proportional to the amount of shared data scanned.\n   */\n  editRange<R = V>(\n    low: K,\n    high: K,\n    includeHigh: boolean,\n    onFound: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void,\n    initialCounter?: number\n  ): R | number {\n    let root = this._root\n    if (root.isShared) this._root = root = root.clone()\n    try {\n      const r = root.forRange(\n        low,\n        high,\n        includeHigh,\n        true,\n        this,\n        initialCounter || 0,\n        onFound\n      )\n      return typeof r === `number` ? r : r.break!\n    } finally {\n      let isShared\n      while (root.keys.length <= 1 && !root.isLeaf) {\n        isShared ||= root.isShared\n        this._root = root =\n          root.keys.length === 0\n            ? EmptyLeaf\n            : (root as any as BNodeInternal<K, V>).children[0]!\n      }\n      // If any ancestor of the new root was shared, the new root must also be shared\n      if (isShared) {\n        root.isShared = true\n      }\n    }\n  }\n}\n\n/** Leaf node / base class. **************************************************/\nclass BNode<K, V> {\n  // If this is an internal node, _keys[i] is the highest key in children[i].\n  keys: Array<K>\n  values: Array<V>\n  // True if this node might be within multiple `BTree`s (or have multiple parents).\n  // If so, it must be cloned before being mutated to avoid changing an unrelated tree.\n  // This is transitive: if it's true, children are also shared even if `isShared!=true`\n  // in those children. (Certain operations will propagate isShared=true to children.)\n  isShared: true | undefined\n  get isLeaf() {\n    return (this as any).children === undefined\n  }\n\n  constructor(keys: Array<K> = [], values?: Array<V>) {\n    this.keys = keys\n    this.values = values || undefVals\n    this.isShared = undefined\n  }\n\n  // /////////////////////////////////////////////////////////////////////////\n  // Shared methods /////////////////////////////////////////////////////////\n\n  maxKey() {\n    return this.keys[this.keys.length - 1]\n  }\n\n  // If key not found, returns i^failXor where i is the insertion index.\n  // Callers that don't care whether there was a match will set failXor=0.\n  indexOf(key: K, failXor: number, cmp: (a: K, b: K) => number): index {\n    const keys = this.keys\n    let lo = 0,\n      hi = keys.length,\n      mid = hi >> 1\n    while (lo < hi) {\n      const c = cmp(keys[mid]!, key)\n      if (c < 0) lo = mid + 1\n      else if (c > 0)\n        // key < keys[mid]\n        hi = mid\n      else if (c === 0) return mid\n      else {\n        // c is NaN or otherwise invalid\n        if (key === key)\n          // at least the search key is not NaN\n          return keys.length\n        else throw new Error(`BTree: NaN was used as a key`)\n      }\n      mid = (lo + hi) >> 1\n    }\n    return mid ^ failXor\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Leaf Node: misc //////////////////////////////////////////////////////////\n\n  minKey(): K | undefined {\n    return this.keys[0]\n  }\n\n  minPair(reusedArray: [K, V]): [K, V] | undefined {\n    if (this.keys.length === 0) return undefined\n    reusedArray[0] = this.keys[0]!\n    reusedArray[1] = this.values[0]!\n    return reusedArray\n  }\n\n  maxPair(reusedArray: [K, V]): [K, V] | undefined {\n    if (this.keys.length === 0) return undefined\n    const lastIndex = this.keys.length - 1\n    reusedArray[0] = this.keys[lastIndex]!\n    reusedArray[1] = this.values[lastIndex]!\n    return reusedArray\n  }\n\n  clone(): BNode<K, V> {\n    const v = this.values\n    return new BNode<K, V>(this.keys.slice(0), v === undefVals ? v : v.slice(0))\n  }\n\n  get(key: K, defaultValue: V | undefined, tree: BTree<K, V>): V | undefined {\n    const i = this.indexOf(key, -1, tree._compare)\n    return i < 0 ? defaultValue : this.values[i]\n  }\n\n  getPairOrNextLower(\n    key: K,\n    compare: (a: K, b: K) => number,\n    inclusive: boolean,\n    reusedArray: [K, V]\n  ): [K, V] | undefined {\n    const i = this.indexOf(key, -1, compare)\n    const indexOrLower = i < 0 ? ~i - 1 : inclusive ? i : i - 1\n    if (indexOrLower >= 0) {\n      reusedArray[0] = this.keys[indexOrLower]!\n      reusedArray[1] = this.values[indexOrLower]!\n      return reusedArray\n    }\n    return undefined\n  }\n\n  getPairOrNextHigher(\n    key: K,\n    compare: (a: K, b: K) => number,\n    inclusive: boolean,\n    reusedArray: [K, V]\n  ): [K, V] | undefined {\n    const i = this.indexOf(key, -1, compare)\n    const indexOrLower = i < 0 ? ~i : inclusive ? i : i + 1\n    const keys = this.keys\n    if (indexOrLower < keys.length) {\n      reusedArray[0] = keys[indexOrLower]!\n      reusedArray[1] = this.values[indexOrLower]!\n      return reusedArray\n    }\n    return undefined\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Leaf Node: set & node splitting //////////////////////////////////////////\n\n  set(\n    key: K,\n    value: V,\n    overwrite: boolean | undefined,\n    tree: BTree<K, V>\n  ): boolean | BNode<K, V> {\n    let i = this.indexOf(key, -1, tree._compare)\n    if (i < 0) {\n      // key does not exist yet\n      i = ~i\n      tree._size++\n\n      if (this.keys.length < tree._maxNodeSize) {\n        return this.insertInLeaf(i, key, value, tree)\n      } else {\n        // This leaf node is full and must split\n        const newRightSibling = this.splitOffRightSide()\n        let target: BNode<K, V> = this\n        if (i > this.keys.length) {\n          i -= this.keys.length\n          target = newRightSibling\n        }\n        target.insertInLeaf(i, key, value, tree)\n        return newRightSibling\n      }\n    } else {\n      // Key already exists\n      if (overwrite !== false) {\n        if (value !== undefined) this.reifyValues()\n        // usually this is a no-op, but some users may wish to edit the key\n        this.keys[i] = key\n        this.values[i] = value\n      }\n      return false\n    }\n  }\n\n  reifyValues() {\n    if (this.values === undefVals)\n      return (this.values = this.values.slice(0, this.keys.length))\n    return this.values\n  }\n\n  insertInLeaf(i: index, key: K, value: V, tree: BTree<K, V>) {\n    this.keys.splice(i, 0, key)\n    if (this.values === undefVals) {\n      while (undefVals.length < tree._maxNodeSize) undefVals.push(undefined)\n      if (value === undefined) {\n        return true\n      } else {\n        this.values = undefVals.slice(0, this.keys.length - 1)\n      }\n    }\n    this.values.splice(i, 0, value)\n    return true\n  }\n\n  takeFromRight(rhs: BNode<K, V>) {\n    // Reminder: parent node must update its copy of key for this node\n    // assert: neither node is shared\n    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)\n    let v = this.values\n    if (rhs.values === undefVals) {\n      if (v !== undefVals) v.push(undefined as any)\n    } else {\n      v = this.reifyValues()\n      v.push(rhs.values.shift()!)\n    }\n    this.keys.push(rhs.keys.shift()!)\n  }\n\n  takeFromLeft(lhs: BNode<K, V>) {\n    // Reminder: parent node must update its copy of key for this node\n    // assert: neither node is shared\n    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)\n    let v = this.values\n    if (lhs.values === undefVals) {\n      if (v !== undefVals) v.unshift(undefined as any)\n    } else {\n      v = this.reifyValues()\n      v.unshift(lhs.values.pop()!)\n    }\n    this.keys.unshift(lhs.keys.pop()!)\n  }\n\n  splitOffRightSide(): BNode<K, V> {\n    // Reminder: parent node must update its copy of key for this node\n    const half = this.keys.length >> 1,\n      keys = this.keys.splice(half)\n    const values =\n      this.values === undefVals ? undefVals : this.values.splice(half)\n    return new BNode<K, V>(keys, values)\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Leaf Node: scanning & deletions //////////////////////////////////////////\n\n  forRange<R>(\n    low: K,\n    high: K,\n    includeHigh: boolean | undefined,\n    editMode: boolean,\n    tree: BTree<K, V>,\n    count: number,\n    onFound?: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void\n  ): EditRangeResult<V, R> | number {\n    const cmp = tree._compare\n    let iLow, iHigh\n    if (high === low) {\n      if (!includeHigh) return count\n      iHigh = (iLow = this.indexOf(low, -1, cmp)) + 1\n      if (iLow < 0) return count\n    } else {\n      iLow = this.indexOf(low, 0, cmp)\n      iHigh = this.indexOf(high, -1, cmp)\n      if (iHigh < 0) iHigh = ~iHigh\n      else if (includeHigh === true) iHigh++\n    }\n    const keys = this.keys,\n      values = this.values\n    if (onFound !== undefined) {\n      for (let i = iLow; i < iHigh; i++) {\n        const key = keys[i]!\n        const result = onFound(key, values[i]!, count++)\n        if (result !== undefined) {\n          if (editMode === true) {\n            if (key !== keys[i] || this.isShared === true)\n              throw new Error(`BTree illegally changed or cloned in editRange`)\n            if (result.delete) {\n              this.keys.splice(i, 1)\n              if (this.values !== undefVals) this.values.splice(i, 1)\n              tree._size--\n              i--\n              iHigh--\n            } else if (result.hasOwnProperty(`value`)) {\n              values[i] = result.value!\n            }\n          }\n          if (result.break !== undefined) return result\n        }\n      }\n    } else count += iHigh - iLow\n    return count\n  }\n\n  /** Adds entire contents of right-hand sibling (rhs is left unchanged) */\n  mergeSibling(rhs: BNode<K, V>, _: number) {\n    this.keys.push.apply(this.keys, rhs.keys)\n    if (this.values === undefVals) {\n      if (rhs.values === undefVals) return\n      this.values = this.values.slice(0, this.keys.length)\n    }\n    this.values.push.apply(this.values, rhs.reifyValues())\n  }\n}\n\n/** Internal node (non-leaf node) ********************************************/\nclass BNodeInternal<K, V> extends BNode<K, V> {\n  // Note: conventionally B+ trees have one fewer key than the number of\n  // children, but I find it easier to keep the array lengths equal: each\n  // keys[i] caches the value of children[i].maxKey().\n  children: Array<BNode<K, V>>\n\n  /**\n   * This does not mark `children` as shared, so it is the responsibility of the caller\n   * to ensure children are either marked shared, or aren't included in another tree.\n   */\n  constructor(children: Array<BNode<K, V>>, keys?: Array<K>) {\n    if (!keys) {\n      keys = []\n      for (let i = 0; i < children.length; i++) keys[i] = children[i]!.maxKey()!\n    }\n    super(keys)\n    this.children = children\n  }\n\n  minKey() {\n    return this.children[0]!.minKey()\n  }\n\n  minPair(reusedArray: [K, V]): [K, V] | undefined {\n    return this.children[0]!.minPair(reusedArray)\n  }\n\n  maxPair(reusedArray: [K, V]): [K, V] | undefined {\n    return this.children[this.children.length - 1]!.maxPair(reusedArray)\n  }\n\n  get(key: K, defaultValue: V | undefined, tree: BTree<K, V>): V | undefined {\n    const i = this.indexOf(key, 0, tree._compare),\n      children = this.children\n    return i < children.length\n      ? children[i]!.get(key, defaultValue, tree)\n      : undefined\n  }\n\n  getPairOrNextLower(\n    key: K,\n    compare: (a: K, b: K) => number,\n    inclusive: boolean,\n    reusedArray: [K, V]\n  ): [K, V] | undefined {\n    const i = this.indexOf(key, 0, compare),\n      children = this.children\n    if (i >= children.length) return this.maxPair(reusedArray)\n    const result = children[i]!.getPairOrNextLower(\n      key,\n      compare,\n      inclusive,\n      reusedArray\n    )\n    if (result === undefined && i > 0) {\n      return children[i - 1]!.maxPair(reusedArray)\n    }\n    return result\n  }\n\n  getPairOrNextHigher(\n    key: K,\n    compare: (a: K, b: K) => number,\n    inclusive: boolean,\n    reusedArray: [K, V]\n  ): [K, V] | undefined {\n    const i = this.indexOf(key, 0, compare),\n      children = this.children,\n      length = children.length\n    if (i >= length) return undefined\n    const result = children[i]!.getPairOrNextHigher(\n      key,\n      compare,\n      inclusive,\n      reusedArray\n    )\n    if (result === undefined && i < length - 1) {\n      return children[i + 1]!.minPair(reusedArray)\n    }\n    return result\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Internal Node: set & node splitting //////////////////////////////////////\n\n  set(\n    key: K,\n    value: V,\n    overwrite: boolean | undefined,\n    tree: BTree<K, V>\n  ): boolean | BNodeInternal<K, V> {\n    const c = this.children,\n      max = tree._maxNodeSize,\n      cmp = tree._compare\n    let i = Math.min(this.indexOf(key, 0, cmp), c.length - 1),\n      child = c[i]!\n\n    if (child.isShared) c[i] = child = child.clone()\n    if (child.keys.length >= max) {\n      // child is full; inserting anything else will cause a split.\n      // Shifting an item to the left or right sibling may avoid a split.\n      // We can do a shift if the adjacent node is not full and if the\n      // current key can still be placed in the same node after the shift.\n      let other: BNode<K, V> | undefined\n      if (\n        i > 0 &&\n        (other = c[i - 1]!).keys.length < max &&\n        cmp(child.keys[0]!, key) < 0\n      ) {\n        if (other.isShared) c[i - 1] = other = other.clone()\n        other.takeFromRight(child)\n        this.keys[i - 1] = other.maxKey()!\n      } else if (\n        (other = c[i + 1]) !== undefined &&\n        other.keys.length < max &&\n        cmp(child.maxKey()!, key) < 0\n      ) {\n        if (other.isShared) c[i + 1] = other = other.clone()\n        other.takeFromLeft(child)\n        this.keys[i] = c[i]!.maxKey()!\n      }\n    }\n\n    const result = child.set(key, value, overwrite, tree)\n    if (result === false) return false\n    this.keys[i] = child.maxKey()!\n    if (result === true) return true\n\n    // The child has split and `result` is a new right child... does it fit?\n    if (this.keys.length < max) {\n      // yes\n      this.insert(i + 1, result)\n      return true\n    } else {\n      // no, we must split also\n      const newRightSibling = this.splitOffRightSide()\n      let target: BNodeInternal<K, V> = this\n      if (cmp(result.maxKey()!, this.maxKey()!) > 0) {\n        target = newRightSibling\n        i -= this.keys.length\n      }\n      target.insert(i + 1, result)\n      return newRightSibling\n    }\n  }\n\n  /**\n   * Inserts `child` at index `i`.\n   * This does not mark `child` as shared, so it is the responsibility of the caller\n   * to ensure that either child is marked shared, or it is not included in another tree.\n   */\n  insert(i: index, child: BNode<K, V>) {\n    this.children.splice(i, 0, child)\n    this.keys.splice(i, 0, child.maxKey()!)\n  }\n\n  /**\n   * Split this node.\n   * Modifies this to remove the second half of the items, returning a separate node containing them.\n   */\n  splitOffRightSide() {\n    // assert !this.isShared;\n    const half = this.children.length >> 1\n    return new BNodeInternal<K, V>(\n      this.children.splice(half),\n      this.keys.splice(half)\n    )\n  }\n\n  takeFromRight(rhs: BNode<K, V>) {\n    // Reminder: parent node must update its copy of key for this node\n    // assert: neither node is shared\n    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)\n    this.keys.push(rhs.keys.shift()!)\n    this.children.push((rhs as BNodeInternal<K, V>).children.shift()!)\n  }\n\n  takeFromLeft(lhs: BNode<K, V>) {\n    // Reminder: parent node must update its copy of key for this node\n    // assert: neither node is shared\n    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)\n    this.keys.unshift(lhs.keys.pop()!)\n    this.children.unshift((lhs as BNodeInternal<K, V>).children.pop()!)\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Internal Node: scanning & deletions //////////////////////////////////////\n\n  // Note: `count` is the next value of the third argument to `onFound`.\n  //       A leaf node's `forRange` function returns a new value for this counter,\n  //       unless the operation is to stop early.\n  forRange<R>(\n    low: K,\n    high: K,\n    includeHigh: boolean | undefined,\n    editMode: boolean,\n    tree: BTree<K, V>,\n    count: number,\n    onFound?: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void\n  ): EditRangeResult<V, R> | number {\n    const cmp = tree._compare\n    const keys = this.keys,\n      children = this.children\n    let iLow = this.indexOf(low, 0, cmp),\n      i = iLow\n    const iHigh = Math.min(\n      high === low ? iLow : this.indexOf(high, 0, cmp),\n      keys.length - 1\n    )\n    if (!editMode) {\n      // Simple case\n      for (; i <= iHigh; i++) {\n        const result = children[i]!.forRange(\n          low,\n          high,\n          includeHigh,\n          editMode,\n          tree,\n          count,\n          onFound\n        )\n        if (typeof result !== `number`) return result\n        count = result\n      }\n    } else if (i <= iHigh) {\n      try {\n        for (; i <= iHigh; i++) {\n          if (children[i]!.isShared) children[i] = children[i]!.clone()\n          const result = children[i]!.forRange(\n            low,\n            high,\n            includeHigh,\n            editMode,\n            tree,\n            count,\n            onFound\n          )\n          // Note: if children[i] is empty then keys[i]=undefined.\n          //       This is an invalid state, but it is fixed below.\n          keys[i] = children[i]!.maxKey()!\n          if (typeof result !== `number`) return result\n          count = result\n        }\n      } finally {\n        // Deletions may have occurred, so look for opportunities to merge nodes.\n        const half = tree._maxNodeSize >> 1\n        if (iLow > 0) iLow--\n        for (i = iHigh; i >= iLow; i--) {\n          if (children[i]!.keys.length <= half) {\n            if (children[i]!.keys.length !== 0) {\n              this.tryMerge(i, tree._maxNodeSize)\n            } else {\n              // child is empty! delete it!\n              keys.splice(i, 1)\n              children.splice(i, 1)\n            }\n          }\n        }\n        if (children.length !== 0 && children[0]!.keys.length === 0)\n          check(false, `emptiness bug`)\n      }\n    }\n    return count\n  }\n\n  /** Merges child i with child i+1 if their combined size is not too large */\n  tryMerge(i: index, maxSize: number): boolean {\n    const children = this.children\n    if (i >= 0 && i + 1 < children.length) {\n      if (children[i]!.keys.length + children[i + 1]!.keys.length <= maxSize) {\n        if (children[i]!.isShared)\n          // cloned already UNLESS i is outside scan range\n          children[i] = children[i]!.clone()\n        children[i]!.mergeSibling(children[i + 1]!, maxSize)\n        children.splice(i + 1, 1)\n        this.keys.splice(i + 1, 1)\n        this.keys[i] = children[i]!.maxKey()!\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Move children from `rhs` into this.\n   * `rhs` must be part of this tree, and be removed from it after this call\n   * (otherwise isShared for its children could be incorrect).\n   */\n  mergeSibling(rhs: BNode<K, V>, maxNodeSize: number) {\n    // assert !this.isShared;\n    const oldLength = this.keys.length\n    this.keys.push.apply(this.keys, rhs.keys)\n    const rhsChildren = (rhs as any as BNodeInternal<K, V>).children\n    this.children.push.apply(this.children, rhsChildren)\n\n    if (rhs.isShared && !this.isShared) {\n      // All children of a shared node are implicitly shared, and since their new\n      // parent is not shared, they must now be explicitly marked as shared.\n      for (const child of rhsChildren) child.isShared = true\n    }\n\n    // If our children are themselves almost empty due to a mass-delete,\n    // they may need to be merged too (but only the oldLength-1 and its\n    // right sibling should need this).\n    this.tryMerge(oldLength - 1, maxNodeSize)\n  }\n}\n\n// Optimization: this array of `undefined`s is used instead of a normal\n// array of values in nodes where `undefined` is the only value.\n// Its length is extended to max node size on first use; since it can\n// be shared between trees with different maximums, its length can only\n// increase, never decrease. Its type should be undefined[] but strangely\n// TypeScript won't allow the comparison V[] === undefined[]. To prevent\n// users from making this array too large, BTree has a maximum node size.\n//\n// FAQ: undefVals[i] is already undefined, so why increase the array size?\n// Reading outside the bounds of an array is relatively slow because it\n// has the side effect of scanning the prototype chain.\nconst undefVals: Array<any> = []\n\nconst Delete = { delete: true },\n  DeleteRange = () => Delete\nconst EmptyLeaf = (function () {\n  const n = new BNode<any, any>()\n  n.isShared = true\n  return n\n})()\nconst ReusedArray: Array<any> = [] // assumed thread-local\n\nfunction check(fact: boolean, ...args: Array<any>) {\n  if (!fact) {\n    args.unshift(`B+ tree`) // at beginning of message\n    throw new Error(args.join(` `))\n  }\n}\n", "import { BTree } from \"../utils/btree.js\"\nimport { defaultComparator, normalizeValue } from \"../utils/comparison.js\"\nimport { BaseIndex } from \"./base-index.js\"\nimport type { CompareOptions } from \"../query/builder/types.js\"\nimport type { BasicExpression } from \"../query/ir.js\"\nimport type { IndexOperation } from \"./base-index.js\"\n\n/**\n * Options for Ordered index\n */\nexport interface BTreeIndexOptions {\n  compareFn?: (a: any, b: any) => number\n  compareOptions?: CompareOptions\n}\n\n/**\n * Options for range queries\n */\nexport interface RangeQueryOptions {\n  from?: any\n  to?: any\n  fromInclusive?: boolean\n  toInclusive?: boolean\n}\n\n/**\n * B+Tree index for sorted data with range queries\n * This maintains items in sorted order and provides efficient range operations\n */\nexport class BTreeIndex<\n  TKey extends string | number = string | number,\n> extends BaseIndex<TKey> {\n  public readonly supportedOperations = new Set<IndexOperation>([\n    `eq`,\n    `gt`,\n    `gte`,\n    `lt`,\n    `lte`,\n    `in`,\n  ])\n\n  // Internal data structures - private to hide implementation details\n  // The `orderedEntries` B+ tree is used for efficient range queries\n  // The `valueMap` is used for O(1) lookups of PKs by indexed value\n  private orderedEntries: BTree<any, undefined> // we don't associate values with the keys of the B+ tree (the keys are indexed values)\n  private valueMap = new Map<any, Set<TKey>>() // instead we store a mapping of indexed values to a set of PKs\n  private indexedKeys = new Set<TKey>()\n  private compareFn: (a: any, b: any) => number = defaultComparator\n\n  constructor(\n    id: number,\n    expression: BasicExpression,\n    name?: string,\n    options?: any\n  ) {\n    super(id, expression, name, options)\n    this.compareFn = options?.compareFn ?? defaultComparator\n    if (options?.compareOptions) {\n      this.compareOptions = options!.compareOptions\n    }\n    this.orderedEntries = new BTree(this.compareFn)\n  }\n\n  protected initialize(_options?: BTreeIndexOptions): void {}\n\n  /**\n   * Adds a value to the index\n   */\n  add(key: TKey, item: any): void {\n    let indexedValue: any\n    try {\n      indexedValue = this.evaluateIndexExpression(item)\n    } catch (error) {\n      throw new Error(\n        `Failed to evaluate index expression for key ${key}: ${error}`\n      )\n    }\n\n    // Normalize the value for Map key usage\n    const normalizedValue = normalizeValue(indexedValue)\n\n    // Check if this value already exists\n    if (this.valueMap.has(normalizedValue)) {\n      // Add to existing set\n      this.valueMap.get(normalizedValue)!.add(key)\n    } else {\n      // Create new set for this value\n      const keySet = new Set<TKey>([key])\n      this.valueMap.set(normalizedValue, keySet)\n      this.orderedEntries.set(normalizedValue, undefined)\n    }\n\n    this.indexedKeys.add(key)\n    this.updateTimestamp()\n  }\n\n  /**\n   * Removes a value from the index\n   */\n  remove(key: TKey, item: any): void {\n    let indexedValue: any\n    try {\n      indexedValue = this.evaluateIndexExpression(item)\n    } catch (error) {\n      console.warn(\n        `Failed to evaluate index expression for key ${key} during removal:`,\n        error\n      )\n      return\n    }\n\n    // Normalize the value for Map key usage\n    const normalizedValue = normalizeValue(indexedValue)\n\n    if (this.valueMap.has(normalizedValue)) {\n      const keySet = this.valueMap.get(normalizedValue)!\n      keySet.delete(key)\n\n      // If set is now empty, remove the entry entirely\n      if (keySet.size === 0) {\n        this.valueMap.delete(normalizedValue)\n\n        // Remove from ordered entries\n        this.orderedEntries.delete(normalizedValue)\n      }\n    }\n\n    this.indexedKeys.delete(key)\n    this.updateTimestamp()\n  }\n\n  /**\n   * Updates a value in the index\n   */\n  update(key: TKey, oldItem: any, newItem: any): void {\n    this.remove(key, oldItem)\n    this.add(key, newItem)\n  }\n\n  /**\n   * Builds the index from a collection of entries\n   */\n  build(entries: Iterable<[TKey, any]>): void {\n    this.clear()\n\n    for (const [key, item] of entries) {\n      this.add(key, item)\n    }\n  }\n\n  /**\n   * Clears all data from the index\n   */\n  clear(): void {\n    this.orderedEntries.clear()\n    this.valueMap.clear()\n    this.indexedKeys.clear()\n    this.updateTimestamp()\n  }\n\n  /**\n   * Performs a lookup operation\n   */\n  lookup(operation: IndexOperation, value: any): Set<TKey> {\n    const startTime = performance.now()\n\n    let result: Set<TKey>\n\n    switch (operation) {\n      case `eq`:\n        result = this.equalityLookup(value)\n        break\n      case `gt`:\n        result = this.rangeQuery({ from: value, fromInclusive: false })\n        break\n      case `gte`:\n        result = this.rangeQuery({ from: value, fromInclusive: true })\n        break\n      case `lt`:\n        result = this.rangeQuery({ to: value, toInclusive: false })\n        break\n      case `lte`:\n        result = this.rangeQuery({ to: value, toInclusive: true })\n        break\n      case `in`:\n        result = this.inArrayLookup(value)\n        break\n      default:\n        throw new Error(`Operation ${operation} not supported by BTreeIndex`)\n    }\n\n    this.trackLookup(startTime)\n    return result\n  }\n\n  /**\n   * Gets the number of indexed keys\n   */\n  get keyCount(): number {\n    return this.indexedKeys.size\n  }\n\n  // Public methods for backward compatibility (used by tests)\n\n  /**\n   * Performs an equality lookup\n   */\n  equalityLookup(value: any): Set<TKey> {\n    const normalizedValue = normalizeValue(value)\n    return new Set(this.valueMap.get(normalizedValue) ?? [])\n  }\n\n  /**\n   * Performs a range query with options\n   * This is more efficient for compound queries like \"WHERE a > 5 AND a < 10\"\n   */\n  rangeQuery(options: RangeQueryOptions = {}): Set<TKey> {\n    const { from, to, fromInclusive = true, toInclusive = true } = options\n    const result = new Set<TKey>()\n\n    const normalizedFrom = normalizeValue(from)\n    const normalizedTo = normalizeValue(to)\n    const fromKey = normalizedFrom ?? this.orderedEntries.minKey()\n    const toKey = normalizedTo ?? this.orderedEntries.maxKey()\n\n    this.orderedEntries.forRange(\n      fromKey,\n      toKey,\n      toInclusive,\n      (indexedValue, _) => {\n        if (!fromInclusive && this.compareFn(indexedValue, from) === 0) {\n          // the B+ tree `forRange` method does not support exclusive lower bounds\n          // so we need to exclude it manually\n          return\n        }\n\n        const keys = this.valueMap.get(indexedValue)\n        if (keys) {\n          keys.forEach((key) => result.add(key))\n        }\n      }\n    )\n\n    return result\n  }\n\n  /**\n   * Performs a reversed range query\n   */\n  rangeQueryReversed(options: RangeQueryOptions = {}): Set<TKey> {\n    const { from, to, fromInclusive = true, toInclusive = true } = options\n    return this.rangeQuery({\n      from: to ?? this.orderedEntries.maxKey(),\n      to: from ?? this.orderedEntries.minKey(),\n      fromInclusive: toInclusive,\n      toInclusive: fromInclusive,\n    })\n  }\n\n  private takeInternal(\n    n: number,\n    nextPair: (k?: any) => [any, any] | undefined,\n    from?: any,\n    filterFn?: (key: TKey) => boolean\n  ): Array<TKey> {\n    const keysInResult: Set<TKey> = new Set()\n    const result: Array<TKey> = []\n    let pair: [any, any] | undefined\n    let key = normalizeValue(from)\n\n    while ((pair = nextPair(key)) !== undefined && result.length < n) {\n      key = pair[0]\n      const keys = this.valueMap.get(key)\n      if (keys) {\n        const it = keys.values()\n        let ks: TKey | undefined\n        while (result.length < n && (ks = it.next().value)) {\n          if (!keysInResult.has(ks) && (filterFn?.(ks) ?? true)) {\n            result.push(ks)\n            keysInResult.add(ks)\n          }\n        }\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Returns the next n items after the provided item or the first n items if no from item is provided.\n   * @param n - The number of items to return\n   * @param from - The item to start from (exclusive). Starts from the smallest item (inclusive) if not provided.\n   * @returns The next n items after the provided key. Returns the first n items if no from item is provided.\n   */\n  take(n: number, from?: any, filterFn?: (key: TKey) => boolean): Array<TKey> {\n    const nextPair = (k?: any) => this.orderedEntries.nextHigherPair(k)\n    return this.takeInternal(n, nextPair, from, filterFn)\n  }\n\n  /**\n   * Returns the next n items **before** the provided item (in descending order) or the last n items if no from item is provided.\n   * @param n - The number of items to return\n   * @param from - The item to start from (exclusive). Starts from the largest item (inclusive) if not provided.\n   * @returns The next n items **before** the provided key. Returns the last n items if no from item is provided.\n   */\n  takeReversed(\n    n: number,\n    from?: any,\n    filterFn?: (key: TKey) => boolean\n  ): Array<TKey> {\n    const nextPair = (k?: any) => this.orderedEntries.nextLowerPair(k)\n    return this.takeInternal(n, nextPair, from, filterFn)\n  }\n\n  /**\n   * Performs an IN array lookup\n   */\n  inArrayLookup(values: Array<any>): Set<TKey> {\n    const result = new Set<TKey>()\n\n    for (const value of values) {\n      const normalizedValue = normalizeValue(value)\n      const keys = this.valueMap.get(normalizedValue)\n      if (keys) {\n        keys.forEach((key) => result.add(key))\n      }\n    }\n\n    return result\n  }\n\n  // Getter methods for testing compatibility\n  get indexedKeysSet(): Set<TKey> {\n    return this.indexedKeys\n  }\n\n  get orderedEntriesArray(): Array<[any, Set<TKey>]> {\n    return this.orderedEntries\n      .keysArray()\n      .map((key) => [key, this.valueMap.get(key) ?? new Set()])\n  }\n\n  get orderedEntriesArrayReversed(): Array<[any, Set<TKey>]> {\n    return this.takeReversed(this.orderedEntries.size).map((key) => [\n      key,\n      this.valueMap.get(key) ?? new Set(),\n    ])\n  }\n\n  get valueMapData(): Map<any, Set<TKey>> {\n    return this.valueMap\n  }\n}\n", "/**\n * A Map implementation that keeps its entries sorted based on a comparator function\n * @template TKey - The type of keys in the map\n * @template TValue - The type of values in the map\n */\nexport class SortedMap<TKey, TValue> {\n  private map: Map<TKey, TValue>\n  private sortedKeys: Array<TKey>\n  private comparator: (a: TValue, b: TValue) => number\n\n  /**\n   * Creates a new SortedMap instance\n   *\n   * @param comparator - Optional function to compare values for sorting\n   */\n  constructor(comparator?: (a: TValue, b: TValue) => number) {\n    this.map = new Map<TKey, TValue>()\n    this.sortedKeys = []\n    this.comparator = comparator || this.defaultComparator\n  }\n\n  /**\n   * Default comparator function used when none is provided\n   *\n   * @param a - First value to compare\n   * @param b - Second value to compare\n   * @returns -1 if a < b, 1 if a > b, 0 if equal\n   */\n  private defaultComparator(a: TValue, b: TValue): number {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  }\n\n  /**\n   * Finds the index where a key-value pair should be inserted to maintain sort order.\n   * Uses binary search to find the correct position based on the value.\n   * Hence, it is in O(log n) time.\n   *\n   * @param key - The key to find position for\n   * @param value - The value to compare against\n   * @returns The index where the key should be inserted\n   */\n  private indexOf(value: TValue): number {\n    let left = 0\n    let right = this.sortedKeys.length\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2)\n      const midKey = this.sortedKeys[mid]!\n      const midValue = this.map.get(midKey)!\n      const comparison = this.comparator(value, midValue)\n\n      if (comparison < 0) {\n        right = mid\n      } else if (comparison > 0) {\n        left = mid + 1\n      } else {\n        return mid\n      }\n    }\n\n    return left\n  }\n\n  /**\n   * Sets a key-value pair in the map and maintains sort order\n   *\n   * @param key - The key to set\n   * @param value - The value to associate with the key\n   * @returns This SortedMap instance for chaining\n   */\n  set(key: TKey, value: TValue): this {\n    if (this.map.has(key)) {\n      // Need to remove the old key from the sorted keys array\n      const oldValue = this.map.get(key)!\n      const oldIndex = this.indexOf(oldValue)\n      this.sortedKeys.splice(oldIndex, 1)\n    }\n\n    // Insert the new key at the correct position\n    const index = this.indexOf(value)\n    this.sortedKeys.splice(index, 0, key)\n\n    this.map.set(key, value)\n\n    return this\n  }\n\n  /**\n   * Gets a value by its key\n   *\n   * @param key - The key to look up\n   * @returns The value associated with the key, or undefined if not found\n   */\n  get(key: TKey): TValue | undefined {\n    return this.map.get(key)\n  }\n\n  /**\n   * Removes a key-value pair from the map\n   *\n   * @param key - The key to remove\n   * @returns True if the key was found and removed, false otherwise\n   */\n  delete(key: TKey): boolean {\n    if (this.map.has(key)) {\n      const oldValue = this.map.get(key)\n      const index = this.indexOf(oldValue!)\n      this.sortedKeys.splice(index, 1)\n      return this.map.delete(key)\n    }\n\n    return false\n  }\n\n  /**\n   * Checks if a key exists in the map\n   *\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n  has(key: TKey): boolean {\n    return this.map.has(key)\n  }\n\n  /**\n   * Removes all key-value pairs from the map\n   */\n  clear(): void {\n    this.map.clear()\n    this.sortedKeys = []\n  }\n\n  /**\n   * Gets the number of key-value pairs in the map\n   */\n  get size(): number {\n    return this.map.size\n  }\n\n  /**\n   * Default iterator that returns entries in sorted order\n   *\n   * @returns An iterator for the map's entries\n   */\n  *[Symbol.iterator](): IterableIterator<[TKey, TValue]> {\n    for (const key of this.sortedKeys) {\n      yield [key, this.map.get(key)!] as [TKey, TValue]\n    }\n  }\n\n  /**\n   * Returns an iterator for the map's entries in sorted order\n   *\n   * @returns An iterator for the map's entries\n   */\n  entries(): IterableIterator<[TKey, TValue]> {\n    return this[Symbol.iterator]()\n  }\n\n  /**\n   * Returns an iterator for the map's keys in sorted order\n   *\n   * @returns An iterator for the map's keys\n   */\n  keys(): IterableIterator<TKey> {\n    return this.sortedKeys[Symbol.iterator]()\n  }\n\n  /**\n   * Returns an iterator for the map's values in sorted order\n   *\n   * @returns An iterator for the map's values\n   */\n  values(): IterableIterator<TValue> {\n    return function* (this: SortedMap<TKey, TValue>) {\n      for (const key of this.sortedKeys) {\n        yield this.map.get(key)!\n      }\n    }.call(this)\n  }\n\n  /**\n   * Executes a callback function for each key-value pair in the map in sorted order\n   *\n   * @param callbackfn - Function to execute for each entry\n   */\n  forEach(\n    callbackfn: (value: TValue, key: TKey, map: Map<TKey, TValue>) => void\n  ): void {\n    for (const key of this.sortedKeys) {\n      callbackfn(this.map.get(key)!, key, this.map)\n    }\n  }\n}\n", "import type {\n  BaseIndex,\n  IndexConstructor,\n  IndexResolver,\n} from \"./base-index.js\"\nimport type { BasicExpression } from \"../query/ir.js\"\n\n/**\n * Utility to determine if a resolver is a constructor or async loader\n */\nfunction isConstructor<TKey extends string | number>(\n  resolver: IndexResolver<TKey>\n): resolver is IndexConstructor<TKey> {\n  // Check if it's a function with a prototype (constructor)\n  return (\n    typeof resolver === `function` &&\n    resolver.prototype !== undefined &&\n    resolver.prototype.constructor === resolver\n  )\n}\n\n/**\n * Resolve index constructor from resolver\n */\nasync function resolveIndexConstructor<TKey extends string | number>(\n  resolver: IndexResolver<TKey>\n): Promise<IndexConstructor<TKey>> {\n  if (isConstructor(resolver)) {\n    return resolver\n  } else {\n    // It's an async loader function\n    return await resolver()\n  }\n}\n\n/**\n * Wrapper that defers index creation until first sync\n */\nexport class LazyIndexWrapper<TKey extends string | number = string | number> {\n  private indexPromise: Promise<BaseIndex<TKey>> | null = null\n  private resolvedIndex: BaseIndex<TKey> | null = null\n\n  constructor(\n    private id: number,\n    private expression: BasicExpression,\n    private name: string | undefined,\n    private resolver: IndexResolver<TKey>,\n    private options: any,\n    private collectionEntries?: Iterable<[TKey, any]>\n  ) {\n    // For synchronous constructors, resolve immediately\n    if (isConstructor(this.resolver)) {\n      this.resolvedIndex = new this.resolver(\n        this.id,\n        this.expression,\n        this.name,\n        this.options\n      )\n      // Build with initial data if provided\n      if (this.collectionEntries) {\n        this.resolvedIndex.build(this.collectionEntries)\n      }\n    }\n  }\n\n  /**\n   * Resolve the actual index\n   */\n  async resolve(): Promise<BaseIndex<TKey>> {\n    if (this.resolvedIndex) {\n      return this.resolvedIndex\n    }\n\n    if (!this.indexPromise) {\n      this.indexPromise = this.createIndex()\n    }\n\n    this.resolvedIndex = await this.indexPromise\n    return this.resolvedIndex\n  }\n\n  /**\n   * Check if already resolved\n   */\n  isResolved(): boolean {\n    return this.resolvedIndex !== null\n  }\n\n  /**\n   * Get resolved index (throws if not ready)\n   */\n  getResolved(): BaseIndex<TKey> {\n    if (!this.resolvedIndex) {\n      throw new Error(\n        `Index ${this.id} has not been resolved yet. Ensure collection is synced.`\n      )\n    }\n    return this.resolvedIndex\n  }\n\n  /**\n   * Get the index ID\n   */\n  getId(): number {\n    return this.id\n  }\n\n  /**\n   * Get the index name\n   */\n  getName(): string | undefined {\n    return this.name\n  }\n\n  /**\n   * Get the index expression\n   */\n  getExpression(): BasicExpression {\n    return this.expression\n  }\n\n  private async createIndex(): Promise<BaseIndex<TKey>> {\n    const IndexClass = await resolveIndexConstructor(this.resolver)\n    return new IndexClass(this.id, this.expression, this.name, this.options)\n  }\n}\n\n/**\n * Proxy that provides synchronous interface while index loads asynchronously\n */\nexport class IndexProxy<TKey extends string | number = string | number> {\n  constructor(\n    private indexId: number,\n    private lazyIndex: LazyIndexWrapper<TKey>\n  ) {}\n\n  /**\n   * Get the resolved index (throws if not ready)\n   */\n  get index(): BaseIndex<TKey> {\n    return this.lazyIndex.getResolved()\n  }\n\n  /**\n   * Check if index is ready\n   */\n  get isReady(): boolean {\n    return this.lazyIndex.isResolved()\n  }\n\n  /**\n   * Wait for index to be ready\n   */\n  async whenReady(): Promise<BaseIndex<TKey>> {\n    return await this.lazyIndex.resolve()\n  }\n\n  /**\n   * Get the index ID\n   */\n  get id(): number {\n    return this.indexId\n  }\n\n  /**\n   * Get the index name (throws if not ready)\n   */\n  get name(): string | undefined {\n    if (this.isReady) {\n      return this.index.name\n    }\n    return this.lazyIndex.getName()\n  }\n\n  /**\n   * Get the index expression (available immediately)\n   */\n  get expression(): BasicExpression {\n    return this.lazyIndex.getExpression()\n  }\n\n  /**\n   * Check if index supports an operation (throws if not ready)\n   */\n  supports(operation: any): boolean {\n    return this.index.supports(operation)\n  }\n\n  /**\n   * Get index statistics (throws if not ready)\n   */\n  getStats() {\n    return this.index.getStats()\n  }\n\n  /**\n   * Check if index matches a field path (available immediately)\n   */\n  matchesField(fieldPath: Array<string>): boolean {\n    const expr = this.expression\n    return (\n      expr.type === `ref` &&\n      expr.path.length === fieldPath.length &&\n      expr.path.every((part, i) => part === fieldPath[i])\n    )\n  }\n\n  /**\n   * Get the key count (throws if not ready)\n   */\n  get keyCount(): number {\n    return this.index.keyCount\n  }\n\n  // Test compatibility properties - delegate to resolved index\n  get indexedKeysSet(): Set<TKey> {\n    const resolved = this.index as any\n    return resolved.indexedKeysSet\n  }\n\n  get orderedEntriesArray(): Array<[any, Set<TKey>]> {\n    const resolved = this.index as any\n    return resolved.orderedEntriesArray\n  }\n\n  get valueMapData(): Map<any, Set<TKey>> {\n    const resolved = this.index as any\n    return resolved.valueMapData\n  }\n\n  // BTreeIndex compatibility methods\n  equalityLookup(value: any): Set<TKey> {\n    const resolved = this.index as any\n    return resolved.equalityLookup?.(value) ?? new Set()\n  }\n\n  rangeQuery(options: any): Set<TKey> {\n    const resolved = this.index as any\n    return resolved.rangeQuery?.(options) ?? new Set()\n  }\n\n  inArrayLookup(values: Array<any>): Set<TKey> {\n    const resolved = this.index as any\n    return resolved.inArrayLookup?.(values) ?? new Set()\n  }\n\n  // Internal method for the collection to get the lazy wrapper\n  _getLazyWrapper(): LazyIndexWrapper<TKey> {\n    return this.lazyIndex\n  }\n}\n", "/**\n * A utility for creating a proxy that captures changes to an object\n * and provides a way to retrieve those changes.\n */\n\nimport { deepEquals, isTemporal } from \"./utils\"\n\n/**\n * Simple debug utility that only logs when debug mode is enabled\n * Set DEBUG to true in localStorage to enable debug logging\n */\nfunction debugLog(...args: Array<unknown>): void {\n  // Check if we're in a browser environment\n  const isBrowser =\n    typeof window !== `undefined` && typeof localStorage !== `undefined`\n\n  // In browser, check localStorage for debug flag\n  if (isBrowser && localStorage.getItem(`DEBUG`) === `true`) {\n    console.log(`[proxy]`, ...args)\n  }\n  // In Node.js environment, check for environment variable (though this is primarily for browser)\n  else if (\n    // true\n    !isBrowser &&\n    typeof process !== `undefined` &&\n    process.env.DEBUG === `true`\n  ) {\n    console.log(`[proxy]`, ...args)\n  }\n}\n\n// Add TypedArray interface with proper type\ninterface TypedArray {\n  length: number\n  [index: number]: number\n}\n\n// Update type for ChangeTracker\ninterface ChangeTracker<T extends object> {\n  originalObject: T\n  modified: boolean\n  copy_: T\n  proxyCount: number\n  assigned_: Record<string | symbol, boolean>\n  parent?:\n    | {\n        tracker: ChangeTracker<Record<string | symbol, unknown>>\n        prop: string | symbol\n      }\n    | {\n        tracker: ChangeTracker<Record<string | symbol, unknown>>\n        prop: string | symbol\n        updateMap: (newValue: unknown) => void\n      }\n    | {\n        tracker: ChangeTracker<Record<string | symbol, unknown>>\n        prop: unknown\n        updateSet: (newValue: unknown) => void\n      }\n  target: T\n}\n\n/**\n * Deep clones an object while preserving special types like Date and RegExp\n */\n\nfunction deepClone<T extends unknown>(\n  obj: T,\n  visited = new WeakMap<object, unknown>()\n): T {\n  // Handle null and undefined\n  if (obj === null || obj === undefined) {\n    return obj\n  }\n\n  // Handle primitive types\n  if (typeof obj !== `object`) {\n    return obj\n  }\n\n  // If we've already cloned this object, return the cached clone\n  if (visited.has(obj as object)) {\n    return visited.get(obj as object) as T\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime()) as unknown as T\n  }\n\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags) as unknown as T\n  }\n\n  if (Array.isArray(obj)) {\n    const arrayClone = [] as Array<unknown>\n    visited.set(obj as object, arrayClone)\n    obj.forEach((item, index) => {\n      arrayClone[index] = deepClone(item, visited)\n    })\n    return arrayClone as unknown as T\n  }\n\n  // Handle TypedArrays\n  if (ArrayBuffer.isView(obj) && !(obj instanceof DataView)) {\n    // Get the constructor to create a new instance of the same type\n    const TypedArrayConstructor = Object.getPrototypeOf(obj).constructor\n    const clone = new TypedArrayConstructor(\n      (obj as unknown as TypedArray).length\n    ) as unknown as TypedArray\n    visited.set(obj as object, clone)\n\n    // Copy the values\n    for (let i = 0; i < (obj as unknown as TypedArray).length; i++) {\n      clone[i] = (obj as unknown as TypedArray)[i]!\n    }\n\n    return clone as unknown as T\n  }\n\n  if (obj instanceof Map) {\n    const clone = new Map() as Map<unknown, unknown>\n    visited.set(obj as object, clone)\n    obj.forEach((value, key) => {\n      clone.set(key, deepClone(value, visited))\n    })\n    return clone as unknown as T\n  }\n\n  if (obj instanceof Set) {\n    const clone = new Set()\n    visited.set(obj as object, clone)\n    obj.forEach((value) => {\n      clone.add(deepClone(value, visited))\n    })\n    return clone as unknown as T\n  }\n\n  // Handle Temporal objects\n  if (isTemporal(obj)) {\n    // Temporal objects are immutable, so we can return them directly\n    // This preserves all their internal state correctly\n    return obj\n  }\n\n  const clone = {} as Record<string | symbol, unknown>\n  visited.set(obj as object, clone)\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clone[key] = deepClone(\n        (obj as Record<string | symbol, unknown>)[key],\n        visited\n      )\n    }\n  }\n\n  const symbolProps = Object.getOwnPropertySymbols(obj)\n  for (const sym of symbolProps) {\n    clone[sym] = deepClone(\n      (obj as Record<string | symbol, unknown>)[sym],\n      visited\n    )\n  }\n\n  return clone as T\n}\n\nlet count = 0\nfunction getProxyCount() {\n  count += 1\n  return count\n}\n\n/**\n * Creates a proxy that tracks changes to the target object\n *\n * @param target The object to proxy\n * @param parent Optional parent information\n * @returns An object containing the proxy and a function to get the changes\n */\nexport function createChangeProxy<\n  T extends Record<string | symbol, any | undefined>,\n>(\n  target: T,\n  parent?: {\n    tracker: ChangeTracker<Record<string | symbol, unknown>>\n    prop: string | symbol\n  }\n): {\n  proxy: T\n\n  getChanges: () => Record<string | symbol, any>\n} {\n  const changeProxyCache = new Map<object, object>()\n\n  function memoizedCreateChangeProxy<\n    TInner extends Record<string | symbol, any | undefined>,\n  >(\n    innerTarget: TInner,\n    innerParent?: {\n      tracker: ChangeTracker<Record<string | symbol, unknown>>\n      prop: string | symbol\n    }\n  ): {\n    proxy: TInner\n    getChanges: () => Record<string | symbol, any>\n  } {\n    debugLog(`Object ID:`, innerTarget.constructor.name)\n    if (changeProxyCache.has(innerTarget)) {\n      return changeProxyCache.get(innerTarget) as {\n        proxy: TInner\n        getChanges: () => Record<string | symbol, any>\n      }\n    } else {\n      const changeProxy = createChangeProxy(innerTarget, innerParent)\n      changeProxyCache.set(innerTarget, changeProxy)\n      return changeProxy\n    }\n  }\n  // Create a WeakMap to cache proxies for nested objects\n  // This prevents creating multiple proxies for the same object\n  // and handles circular references\n  const proxyCache = new Map<object, object>()\n\n  // Create a change tracker to track changes to the object\n  const changeTracker: ChangeTracker<T> = {\n    copy_: deepClone(target),\n    originalObject: deepClone(target),\n    proxyCount: getProxyCount(),\n    modified: false,\n    assigned_: {},\n    parent,\n    target, // Store reference to the target object\n  }\n\n  debugLog(\n    `createChangeProxy called for target`,\n    target,\n    changeTracker.proxyCount\n  )\n  // Mark this object and all its ancestors as modified\n  // Also propagate the actual changes up the chain\n  function markChanged(state: ChangeTracker<object>) {\n    if (!state.modified) {\n      state.modified = true\n    }\n\n    // Propagate the change up the parent chain\n    if (state.parent) {\n      debugLog(`propagating change to parent`)\n\n      // Check if this is a special Map parent with updateMap function\n      if (`updateMap` in state.parent) {\n        // Use the special updateMap function for Maps\n        state.parent.updateMap(state.copy_)\n      } else if (`updateSet` in state.parent) {\n        // Use the special updateSet function for Sets\n        state.parent.updateSet(state.copy_)\n      } else {\n        // Update parent's copy with this object's current state\n        state.parent.tracker.copy_[state.parent.prop] = state.copy_\n        state.parent.tracker.assigned_[state.parent.prop] = true\n      }\n\n      // Mark parent as changed\n      markChanged(state.parent.tracker)\n    }\n  }\n\n  // Check if all properties in the current state have reverted to original values\n  function checkIfReverted(\n    state: ChangeTracker<Record<string | symbol, unknown>>\n  ): boolean {\n    debugLog(\n      `checkIfReverted called with assigned keys:`,\n      Object.keys(state.assigned_)\n    )\n\n    // If there are no assigned properties, object is unchanged\n    if (\n      Object.keys(state.assigned_).length === 0 &&\n      Object.getOwnPropertySymbols(state.assigned_).length === 0\n    ) {\n      debugLog(`No assigned properties, returning true`)\n      return true\n    }\n\n    // Check each assigned regular property\n    for (const prop in state.assigned_) {\n      // If this property is marked as assigned\n      if (state.assigned_[prop] === true) {\n        const currentValue = state.copy_[prop]\n        const originalValue = (state.originalObject as any)[prop]\n\n        debugLog(\n          `Checking property ${String(prop)}, current:`,\n          currentValue,\n          `original:`,\n          originalValue\n        )\n\n        // If the value is not equal to original, something is still changed\n        if (!deepEquals(currentValue, originalValue)) {\n          debugLog(`Property ${String(prop)} is different, returning false`)\n          return false\n        }\n      } else if (state.assigned_[prop] === false) {\n        // Property was deleted, so it's different from original\n        debugLog(`Property ${String(prop)} was deleted, returning false`)\n        return false\n      }\n    }\n\n    // Check each assigned symbol property\n    const symbolProps = Object.getOwnPropertySymbols(state.assigned_)\n    for (const sym of symbolProps) {\n      if (state.assigned_[sym] === true) {\n        const currentValue = (state.copy_ as any)[sym]\n        const originalValue = (state.originalObject as any)[sym]\n\n        // If the value is not equal to original, something is still changed\n        if (!deepEquals(currentValue, originalValue)) {\n          debugLog(`Symbol property is different, returning false`)\n          return false\n        }\n      } else if (state.assigned_[sym] === false) {\n        // Property was deleted, so it's different from original\n        debugLog(`Symbol property was deleted, returning false`)\n        return false\n      }\n    }\n\n    debugLog(`All properties match original values, returning true`)\n    // All assigned properties match their original values\n    return true\n  }\n\n  // Update parent status based on child changes\n  function checkParentStatus(\n    parentState: ChangeTracker<Record<string | symbol, unknown>>,\n    childProp: string | symbol | unknown\n  ) {\n    debugLog(`checkParentStatus called for child prop:`, childProp)\n\n    // Check if all properties of the parent are reverted\n    const isReverted = checkIfReverted(parentState)\n    debugLog(`Parent checkIfReverted returned:`, isReverted)\n\n    if (isReverted) {\n      debugLog(`Parent is fully reverted, clearing tracking`)\n      // If everything is reverted, clear the tracking\n      parentState.modified = false\n      parentState.assigned_ = {}\n\n      // Continue up the chain\n      if (parentState.parent) {\n        debugLog(`Continuing up the parent chain`)\n        checkParentStatus(parentState.parent.tracker, parentState.parent.prop)\n      }\n    }\n  }\n\n  // Create a proxy for the target object\n  function createObjectProxy<TObj extends object>(obj: TObj): TObj {\n    debugLog(`createObjectProxy`, obj)\n    // If we've already created a proxy for this object, return it\n    if (proxyCache.has(obj)) {\n      debugLog(`proxyCache found match`)\n      return proxyCache.get(obj) as TObj\n    }\n\n    // Create a proxy for the object\n    const proxy = new Proxy(obj, {\n      get(ptarget, prop) {\n        debugLog(`get`, ptarget, prop)\n        const value =\n          changeTracker.copy_[prop as keyof T] ??\n          changeTracker.originalObject[prop as keyof T]\n\n        const originalValue = changeTracker.originalObject[prop as keyof T]\n\n        debugLog(`value (at top of proxy get)`, value)\n\n        // If it's a getter, return the value directly\n        const desc = Object.getOwnPropertyDescriptor(ptarget, prop)\n        if (desc?.get) {\n          return value\n        }\n\n        // If the value is a function, bind it to the ptarget\n        if (typeof value === `function`) {\n          // For Array methods that modify the array\n          if (Array.isArray(ptarget)) {\n            const methodName = prop.toString()\n            const modifyingMethods = new Set([\n              `pop`,\n              `push`,\n              `shift`,\n              `unshift`,\n              `splice`,\n              `sort`,\n              `reverse`,\n              `fill`,\n              `copyWithin`,\n            ])\n\n            if (modifyingMethods.has(methodName)) {\n              return function (...args: Array<unknown>) {\n                const result = value.apply(changeTracker.copy_, args)\n                markChanged(changeTracker)\n                return result\n              }\n            }\n          }\n\n          // For Map and Set methods that modify the collection\n          if (ptarget instanceof Map || ptarget instanceof Set) {\n            const methodName = prop.toString()\n            const modifyingMethods = new Set([\n              `set`,\n              `delete`,\n              `clear`,\n              `add`,\n              `pop`,\n              `push`,\n              `shift`,\n              `unshift`,\n              `splice`,\n              `sort`,\n              `reverse`,\n            ])\n\n            if (modifyingMethods.has(methodName)) {\n              return function (...args: Array<unknown>) {\n                const result = value.apply(changeTracker.copy_, args)\n                markChanged(changeTracker)\n                return result\n              }\n            }\n\n            // Handle iterator methods for Map and Set\n            const iteratorMethods = new Set([\n              `entries`,\n              `keys`,\n              `values`,\n              `forEach`,\n              Symbol.iterator,\n            ])\n\n            if (iteratorMethods.has(methodName) || prop === Symbol.iterator) {\n              return function (this: unknown, ...args: Array<unknown>) {\n                const result = value.apply(changeTracker.copy_, args)\n\n                // For forEach, we need to wrap the callback to track changes\n                if (methodName === `forEach`) {\n                  const callback = args[0]\n                  if (typeof callback === `function`) {\n                    // Replace the original callback with our wrapped version\n                    const wrappedCallback = function (\n                      this: unknown,\n                      // eslint-disable-next-line\n                      value: unknown,\n                      key: unknown,\n                      collection: unknown\n                    ) {\n                      // Call the original callback\n                      const cbresult = callback.call(\n                        this,\n                        value,\n                        key,\n                        collection\n                      )\n                      // Mark as changed since the callback might have modified the value\n                      markChanged(changeTracker)\n                      return cbresult\n                    }\n                    // Call forEach with our wrapped callback\n                    return value.apply(ptarget, [\n                      wrappedCallback,\n                      ...args.slice(1),\n                    ])\n                  }\n                }\n\n                // For iterators (entries, keys, values, Symbol.iterator)\n                if (\n                  methodName === `entries` ||\n                  methodName === `values` ||\n                  methodName === Symbol.iterator.toString() ||\n                  prop === Symbol.iterator\n                ) {\n                  // If it's an iterator, we need to wrap the returned iterator\n                  // to track changes when the values are accessed and potentially modified\n                  const originalIterator = result\n\n                  // For values() iterator on Maps, we need to create a value-to-key mapping\n                  const valueToKeyMap = new Map()\n                  if (methodName === `values` && ptarget instanceof Map) {\n                    // Build a mapping from value to key for reverse lookup\n                    // Use the copy_ (which is the current state) to build the mapping\n                    for (const [\n                      key,\n                      mapValue,\n                    ] of changeTracker.copy_.entries()) {\n                      valueToKeyMap.set(mapValue, key)\n                    }\n                  }\n\n                  // For Set iterators, we need to create an original-to-modified mapping\n                  const originalToModifiedMap = new Map()\n                  if (ptarget instanceof Set) {\n                    // Initialize with original values\n                    for (const setValue of changeTracker.copy_.values()) {\n                      originalToModifiedMap.set(setValue, setValue)\n                    }\n                  }\n\n                  // Create a proxy for the iterator that will mark changes when next() is called\n                  return {\n                    next() {\n                      const nextResult = originalIterator.next()\n\n                      // If we have a value and it's an object, we need to track it\n                      if (\n                        !nextResult.done &&\n                        nextResult.value &&\n                        typeof nextResult.value === `object`\n                      ) {\n                        // For entries, the value is a [key, value] pair\n                        if (\n                          methodName === `entries` &&\n                          Array.isArray(nextResult.value) &&\n                          nextResult.value.length === 2\n                        ) {\n                          // The value is at index 1 in the [key, value] pair\n                          if (\n                            nextResult.value[1] &&\n                            typeof nextResult.value[1] === `object`\n                          ) {\n                            const mapKey = nextResult.value[0]\n                            // Create a special parent tracker that knows how to update the Map\n                            const mapParent = {\n                              tracker: changeTracker,\n                              prop: mapKey,\n                              updateMap: (newValue: unknown) => {\n                                // Update the Map in the copy\n                                if (changeTracker.copy_ instanceof Map) {\n                                  changeTracker.copy_.set(mapKey, newValue)\n                                }\n                              },\n                            }\n\n                            // Create a proxy for the value and replace it in the result\n                            const { proxy: valueProxy } =\n                              memoizedCreateChangeProxy(\n                                nextResult.value[1],\n                                mapParent\n                              )\n                            nextResult.value[1] = valueProxy\n                          }\n                        } else if (\n                          methodName === `values` ||\n                          methodName === Symbol.iterator.toString() ||\n                          prop === Symbol.iterator\n                        ) {\n                          // If the value is an object, create a proxy for it\n                          if (\n                            typeof nextResult.value === `object` &&\n                            nextResult.value !== null\n                          ) {\n                            // For Map values(), try to find the key using our mapping\n                            if (\n                              methodName === `values` &&\n                              ptarget instanceof Map\n                            ) {\n                              const mapKey = valueToKeyMap.get(nextResult.value)\n                              if (mapKey !== undefined) {\n                                // Create a special parent tracker for this Map value\n                                const mapParent = {\n                                  tracker: changeTracker,\n                                  prop: mapKey,\n                                  updateMap: (newValue: unknown) => {\n                                    // Update the Map in the copy\n                                    if (changeTracker.copy_ instanceof Map) {\n                                      changeTracker.copy_.set(mapKey, newValue)\n                                    }\n                                  },\n                                }\n\n                                const { proxy: valueProxy } =\n                                  memoizedCreateChangeProxy(\n                                    nextResult.value,\n                                    mapParent\n                                  )\n                                nextResult.value = valueProxy\n                              }\n                            } else if (ptarget instanceof Set) {\n                              // For Set, we need to track modifications and update the Set accordingly\n                              const setOriginalValue = nextResult.value\n                              const setParent = {\n                                tracker: changeTracker,\n                                prop: setOriginalValue, // Use the original value as the prop\n                                updateSet: (newValue: unknown) => {\n                                  // Update the Set in the copy by removing old value and adding new one\n                                  if (changeTracker.copy_ instanceof Set) {\n                                    changeTracker.copy_.delete(setOriginalValue)\n                                    changeTracker.copy_.add(newValue)\n                                    // Update our mapping for future iterations\n                                    originalToModifiedMap.set(\n                                      setOriginalValue,\n                                      newValue\n                                    )\n                                  }\n                                },\n                              }\n\n                              const { proxy: valueProxy } =\n                                memoizedCreateChangeProxy(\n                                  nextResult.value,\n                                  setParent\n                                )\n                              nextResult.value = valueProxy\n                            } else {\n                              // For other cases, use a symbol as a placeholder\n                              const tempKey = Symbol(`iterator-value`)\n                              const { proxy: valueProxy } =\n                                memoizedCreateChangeProxy(nextResult.value, {\n                                  tracker: changeTracker,\n                                  prop: tempKey,\n                                })\n                              nextResult.value = valueProxy\n                            }\n                          }\n                        }\n                      }\n\n                      return nextResult\n                    },\n                    [Symbol.iterator]() {\n                      return this\n                    },\n                  }\n                }\n\n                return result\n              }\n            }\n          }\n          return value.bind(ptarget)\n        }\n\n        // If the value is an object (but not Date, RegExp, or Temporal), create a proxy for it\n        if (\n          value &&\n          typeof value === `object` &&\n          !((value as any) instanceof Date) &&\n          !((value as any) instanceof RegExp) &&\n          !isTemporal(value)\n        ) {\n          // Create a parent reference for the nested object\n          const nestedParent = {\n            tracker: changeTracker,\n            prop: String(prop),\n          }\n\n          // Create a proxy for the nested object\n          const { proxy: nestedProxy } = memoizedCreateChangeProxy(\n            originalValue,\n            nestedParent\n          )\n\n          // Cache the proxy\n          proxyCache.set(value, nestedProxy)\n\n          return nestedProxy\n        }\n\n        return value\n      },\n\n      set(_sobj, prop, value) {\n        const currentValue = changeTracker.copy_[prop as keyof T]\n        debugLog(\n          `set called for property ${String(prop)}, current:`,\n          currentValue,\n          `new:`,\n          value\n        )\n\n        // Only track the change if the value is actually different\n        if (!deepEquals(currentValue, value)) {\n          // Check if the new value is equal to the original value\n          // Important: Use the originalObject to get the true original value\n          const originalValue = changeTracker.originalObject[prop as keyof T]\n          const isRevertToOriginal = deepEquals(value, originalValue)\n          debugLog(\n            `value:`,\n            value,\n            `original:`,\n            originalValue,\n            `isRevertToOriginal:`,\n            isRevertToOriginal\n          )\n\n          if (isRevertToOriginal) {\n            debugLog(`Reverting property ${String(prop)} to original value`)\n            // If the value is reverted to its original state, remove it from changes\n            delete changeTracker.assigned_[prop.toString()]\n\n            // Make sure the copy is updated with the original value\n            debugLog(`Updating copy with original value for ${String(prop)}`)\n            changeTracker.copy_[prop as keyof T] = deepClone(originalValue)\n\n            // Check if all properties in this object have been reverted\n            debugLog(`Checking if all properties reverted`)\n            const allReverted = checkIfReverted(changeTracker)\n            debugLog(`All reverted:`, allReverted)\n\n            if (allReverted) {\n              debugLog(`All properties reverted, clearing tracking`)\n              // If all have been reverted, clear tracking\n              changeTracker.modified = false\n              changeTracker.assigned_ = {}\n\n              // If we're a nested object, check if the parent needs updating\n              if (parent) {\n                debugLog(`Updating parent for property:`, parent.prop)\n                checkParentStatus(parent.tracker, parent.prop)\n              }\n            } else {\n              // Some properties are still changed\n              debugLog(`Some properties still changed, keeping modified flag`)\n              changeTracker.modified = true\n            }\n          } else {\n            debugLog(`Setting new value for property ${String(prop)}`)\n\n            // Set the value on the copy\n            changeTracker.copy_[prop as keyof T] = value\n\n            // Track that this property was assigned - store using the actual property (symbol or string)\n            changeTracker.assigned_[prop.toString()] = true\n\n            // Mark this object and its ancestors as modified\n            debugLog(`Marking object and ancestors as modified`, changeTracker)\n            markChanged(changeTracker)\n          }\n        } else {\n          debugLog(`Value unchanged, not tracking`)\n        }\n\n        return true\n      },\n\n      defineProperty(_ptarget, prop, descriptor) {\n        // const result = Reflect.defineProperty(\n        //   changeTracker.copy_,\n        //   prop,\n        //   descriptor\n        // )\n        // if (result) {\n        if (`value` in descriptor) {\n          changeTracker.copy_[prop as keyof T] = deepClone(descriptor.value)\n          changeTracker.assigned_[prop.toString()] = true\n          markChanged(changeTracker)\n        }\n        // }\n        // return result\n        return true\n      },\n\n      deleteProperty(dobj, prop) {\n        debugLog(`deleteProperty`, dobj, prop)\n        const stringProp = typeof prop === `symbol` ? prop.toString() : prop\n\n        if (stringProp in dobj) {\n          // Check if the property exists in the original object\n          const hadPropertyInOriginal =\n            stringProp in changeTracker.originalObject\n\n          // Delete the property from the copy\n          // Use type assertion to tell TypeScript this is allowed\n          delete (changeTracker.copy_ as Record<string | symbol, unknown>)[prop]\n\n          // If the property didn't exist in the original object, removing it\n          // should revert to the original state\n          if (!hadPropertyInOriginal) {\n            delete changeTracker.copy_[stringProp]\n            delete changeTracker.assigned_[stringProp]\n\n            // If this is the last change and we're not a nested object,\n            // mark the object as unmodified\n            if (\n              Object.keys(changeTracker.assigned_).length === 0 &&\n              Object.getOwnPropertySymbols(changeTracker.assigned_).length === 0\n            ) {\n              changeTracker.modified = false\n            } else {\n              // We still have changes, keep as modified\n              changeTracker.modified = true\n            }\n          } else {\n            // Mark this property as deleted\n            changeTracker.assigned_[stringProp] = false\n            changeTracker.copy_[stringProp as keyof T] = undefined as T[keyof T]\n            markChanged(changeTracker)\n          }\n        }\n\n        return true\n      },\n    })\n\n    // Cache the proxy\n    proxyCache.set(obj, proxy)\n\n    return proxy\n  }\n\n  // Create a proxy for the target object\n  const proxy = createObjectProxy(target)\n\n  // Return the proxy and a function to get the changes\n  return {\n    proxy,\n    getChanges: () => {\n      debugLog(`getChanges called, modified:`, changeTracker.modified)\n      debugLog(changeTracker)\n\n      // First, check if the object is still considered modified\n      if (!changeTracker.modified) {\n        debugLog(`Object not modified, returning empty object`)\n        return {}\n      }\n\n      // If we have a copy, return it directly\n      // Check if valueObj is actually an object\n      if (\n        typeof changeTracker.copy_ !== `object` ||\n        Array.isArray(changeTracker.copy_)\n      ) {\n        return changeTracker.copy_\n      }\n\n      if (Object.keys(changeTracker.assigned_).length === 0) {\n        return changeTracker.copy_\n      }\n\n      const result: Record<string, any | undefined> = {}\n\n      // Iterate through keys in keyObj\n      for (const key in changeTracker.copy_) {\n        // If the key's value is true and the key exists in valueObj\n        if (\n          changeTracker.assigned_[key] === true &&\n          key in changeTracker.copy_\n        ) {\n          result[key] = changeTracker.copy_[key]\n        }\n      }\n      debugLog(`Returning copy:`, result)\n      return result as unknown as Record<string | symbol, unknown>\n    },\n  }\n}\n\n/**\n * Creates proxies for an array of objects and tracks changes to each\n *\n * @param targets Array of objects to proxy\n * @returns An object containing the array of proxies and a function to get all changes\n */\nexport function createArrayChangeProxy<T extends object>(\n  targets: Array<T>\n): {\n  proxies: Array<T>\n  getChanges: () => Array<Record<string | symbol, unknown>>\n} {\n  const proxiesWithChanges = targets.map((target) => createChangeProxy(target))\n\n  return {\n    proxies: proxiesWithChanges.map((p) => p.proxy),\n    getChanges: () => proxiesWithChanges.map((p) => p.getChanges()),\n  }\n}\n\n/**\n * Creates a proxy for an object, passes it to a callback function,\n * and returns the changes made by the callback\n *\n * @param target The object to proxy\n * @param callback Function that receives the proxy and can make changes to it\n * @returns The changes made to the object\n */\nexport function withChangeTracking<T extends object>(\n  target: T,\n  callback: (proxy: T) => void\n): Record<string | symbol, unknown> {\n  const { proxy, getChanges } = createChangeProxy(target)\n\n  callback(proxy)\n\n  return getChanges()\n}\n\n/**\n * Creates proxies for an array of objects, passes them to a callback function,\n * and returns the changes made by the callback for each object\n *\n * @param targets Array of objects to proxy\n * @param callback Function that receives the proxies and can make changes to them\n * @returns Array of changes made to each object\n */\nexport function withArrayChangeTracking<T extends object>(\n  targets: Array<T>,\n  callback: (proxies: Array<T>) => void\n): Array<Record<string | symbol, unknown>> {\n  const { proxies, getChanges } = createArrayChangeProxy(targets)\n\n  callback(proxies)\n\n  return getChanges()\n}\n", "/**\n * A Deferred object represents a Promise that can be resolved or rejected\n * from outside the Promise constructor.\n */\nexport interface Deferred<T> {\n  /** The Promise object being controlled */\n  promise: Promise<T>\n\n  /** Function to resolve the Promise with a value or another Promise */\n  resolve: (value: T | PromiseLike<T>) => void\n\n  /** Function to reject the Promise with an error */\n  reject: (reason?: Error | unknown) => void\n\n  /** Check if the Promise has been resolved or rejected */\n  isPending: () => boolean\n}\n\n/**\n * Creates a Deferred object containing a Promise and methods to control it.\n *\n * @returns A Deferred object with promise, resolve, reject, and isPending methods\n */\nexport function createDeferred<T>(): Deferred<T> {\n  let resolve!: (value: T | PromiseLike<T>) => void\n  let reject!: (reason?: Error | unknown) => void\n  let isPending = true\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = (value) => {\n      isPending = false\n      res(value)\n    }\n\n    reject = (reason) => {\n      isPending = false\n      rej(reason)\n    }\n  })\n\n  return {\n    promise,\n    resolve,\n    reject,\n    isPending: () => isPending,\n  }\n}\n", "/**\n * Identifier used to scope scheduled work. Maps to a transaction id for live queries.\n */\nexport type SchedulerContextId = string | symbol\n\n/**\n * Options for {@link Scheduler.schedule}. Jobs are identified by `jobId` within a context\n * and may declare dependencies.\n */\ninterface ScheduleOptions {\n  contextId?: SchedulerContextId\n  jobId: unknown\n  dependencies?: Iterable<unknown>\n  run: () => void\n}\n\n/**\n * State per context. Queue preserves order, jobs hold run functions, dependencies track\n * prerequisites, and completed records which jobs have run during the current flush.\n */\ninterface SchedulerContextState {\n  queue: Array<unknown>\n  jobs: Map<unknown, () => void>\n  dependencies: Map<unknown, Set<unknown>>\n  completed: Set<unknown>\n}\n\ninterface PendingAwareJob {\n  hasPendingGraphRun: (contextId: SchedulerContextId) => boolean\n}\n\nfunction isPendingAwareJob(dep: any): dep is PendingAwareJob {\n  return (\n    typeof dep === `object` &&\n    dep !== null &&\n    typeof dep.hasPendingGraphRun === `function`\n  )\n}\n\n/**\n * Scoped scheduler that coalesces work by context and job.\n *\n * - **context** (e.g. transaction id) defines the batching boundary; work is queued until flushed.\n * - **job id** deduplicates work within a context; scheduling the same job replaces the previous run function.\n * - Without a context id, work executes immediately.\n *\n * Callers manage their own state; the scheduler only orchestrates execution order.\n */\nexport class Scheduler {\n  private contexts = new Map<SchedulerContextId, SchedulerContextState>()\n  private clearListeners = new Set<(contextId: SchedulerContextId) => void>()\n\n  /**\n   * Get or create the state bucket for a context.\n   */\n  private getOrCreateContext(\n    contextId: SchedulerContextId\n  ): SchedulerContextState {\n    let context = this.contexts.get(contextId)\n    if (!context) {\n      context = {\n        queue: [],\n        jobs: new Map(),\n        dependencies: new Map(),\n        completed: new Set(),\n      }\n      this.contexts.set(contextId, context)\n    }\n    return context\n  }\n\n  /**\n   * Schedule work. Without a context id, executes immediately.\n   * Otherwise queues the job to be flushed once dependencies are satisfied.\n   * Scheduling the same jobId again replaces the previous run function.\n   */\n  schedule({ contextId, jobId, dependencies, run }: ScheduleOptions): void {\n    if (typeof contextId === `undefined`) {\n      run()\n      return\n    }\n\n    const context = this.getOrCreateContext(contextId)\n\n    // If this is a new job, add it to the queue\n    if (!context.jobs.has(jobId)) {\n      context.queue.push(jobId)\n    }\n\n    // Store or replace the run function\n    context.jobs.set(jobId, run)\n\n    // Update dependencies\n    if (dependencies) {\n      const depSet = new Set<unknown>(dependencies)\n      depSet.delete(jobId)\n      context.dependencies.set(jobId, depSet)\n    } else if (!context.dependencies.has(jobId)) {\n      context.dependencies.set(jobId, new Set())\n    }\n\n    // Clear completion status since we're rescheduling\n    context.completed.delete(jobId)\n  }\n\n  /**\n   * Flush all queued work for a context. Jobs with unmet dependencies are retried.\n   * Throws if a pass completes without running any job (dependency cycle).\n   */\n  flush(contextId: SchedulerContextId): void {\n    const context = this.contexts.get(contextId)\n    if (!context) return\n\n    const { queue, jobs, dependencies, completed } = context\n\n    while (queue.length > 0) {\n      let ranThisPass = false\n      const jobsThisPass = queue.length\n\n      for (let i = 0; i < jobsThisPass; i++) {\n        const jobId = queue.shift()!\n        const run = jobs.get(jobId)\n        if (!run) {\n          dependencies.delete(jobId)\n          completed.delete(jobId)\n          continue\n        }\n\n        const deps = dependencies.get(jobId)\n        let ready = !deps\n        if (deps) {\n          ready = true\n          for (const dep of deps) {\n            if (dep === jobId) continue\n\n            const depHasPending =\n              isPendingAwareJob(dep) && dep.hasPendingGraphRun(contextId)\n\n            // Treat dependencies as blocking if the dep has a pending run in this\n            // context or if it's enqueued and not yet complete. If the dep is\n            // neither pending nor enqueued, consider it satisfied to avoid deadlocks\n            // on lazy sources that never schedule work.\n            if (\n              (jobs.has(dep) && !completed.has(dep)) ||\n              (!jobs.has(dep) && depHasPending)\n            ) {\n              ready = false\n              break\n            }\n          }\n        }\n\n        if (ready) {\n          jobs.delete(jobId)\n          dependencies.delete(jobId)\n          // Run the job. If it throws, we don't mark it complete, allowing the\n          // error to propagate while maintaining scheduler state consistency.\n          run()\n          completed.add(jobId)\n          ranThisPass = true\n        } else {\n          queue.push(jobId)\n        }\n      }\n\n      if (!ranThisPass) {\n        throw new Error(\n          `Scheduler detected unresolved dependencies for context ${String(\n            contextId\n          )}.`\n        )\n      }\n    }\n\n    this.contexts.delete(contextId)\n  }\n\n  /**\n   * Flush all contexts with pending work. Useful during tear-down.\n   */\n  flushAll(): void {\n    for (const contextId of Array.from(this.contexts.keys())) {\n      this.flush(contextId)\n    }\n  }\n\n  /** Clear all scheduled jobs for a context. */\n  clear(contextId: SchedulerContextId): void {\n    this.contexts.delete(contextId)\n    // Notify listeners that this context was cleared\n    this.clearListeners.forEach((listener) => listener(contextId))\n  }\n\n  /** Register a listener to be notified when a context is cleared. */\n  onClear(listener: (contextId: SchedulerContextId) => void): () => void {\n    this.clearListeners.add(listener)\n    return () => this.clearListeners.delete(listener)\n  }\n\n  /** Check if a context has pending jobs. */\n  hasPendingJobs(contextId: SchedulerContextId): boolean {\n    const context = this.contexts.get(contextId)\n    return !!context && context.jobs.size > 0\n  }\n\n  /** Remove a single job from a context and clean up its dependencies. */\n  clearJob(contextId: SchedulerContextId, jobId: unknown): void {\n    const context = this.contexts.get(contextId)\n    if (!context) return\n\n    context.jobs.delete(jobId)\n    context.dependencies.delete(jobId)\n    context.completed.delete(jobId)\n    context.queue = context.queue.filter((id) => id !== jobId)\n\n    if (context.jobs.size === 0) {\n      this.contexts.delete(contextId)\n    }\n  }\n}\n\nexport const transactionScopedScheduler = new Scheduler()\n", "import { createDeferred } from \"./deferred\"\nimport \"./duplicate-instance-check\"\nimport {\n  MissingMutationFunctionError,\n  TransactionAlreadyCompletedRollbackError,\n  TransactionNotPendingCommitError,\n  TransactionNotPendingMutateError,\n} from \"./errors\"\nimport { transactionScopedScheduler } from \"./scheduler.js\"\nimport type { Deferred } from \"./deferred\"\nimport type {\n  MutationFn,\n  PendingMutation,\n  TransactionConfig,\n  TransactionState,\n  TransactionWithMutations,\n} from \"./types\"\n\nconst transactions: Array<Transaction<any>> = []\nlet transactionStack: Array<Transaction<any>> = []\n\nlet sequenceNumber = 0\n\n/**\n * Merges two pending mutations for the same item within a transaction\n *\n * Merge behavior truth table:\n * - (insert, update) â†’ insert (merge changes, keep empty original)\n * - (insert, delete) â†’ null (cancel both mutations)\n * - (update, delete) â†’ delete (delete dominates)\n * - (update, update) â†’ update (replace with latest, union changes)\n * - (delete, delete) â†’ delete (replace with latest)\n * - (insert, insert) â†’ insert (replace with latest)\n *\n * Note: (delete, update) and (delete, insert) should never occur as the collection\n * layer prevents operations on deleted items within the same transaction.\n *\n * @param existing - The existing mutation in the transaction\n * @param incoming - The new mutation being applied\n * @returns The merged mutation, or null if both should be removed\n */\nfunction mergePendingMutations<T extends object>(\n  existing: PendingMutation<T>,\n  incoming: PendingMutation<T>\n): PendingMutation<T> | null {\n  // Truth table implementation\n  switch (`${existing.type}-${incoming.type}` as const) {\n    case `insert-update`: {\n      // Update after insert: keep as insert but merge changes\n      // For insert-update, the key should remain the same since collections don't allow key changes\n      return {\n        ...existing,\n        type: `insert` as const,\n        original: {},\n        modified: incoming.modified,\n        changes: { ...existing.changes, ...incoming.changes },\n        // Keep existing keys (key changes not allowed in updates)\n        key: existing.key,\n        globalKey: existing.globalKey,\n        // Merge metadata (last-write-wins)\n        metadata: incoming.metadata ?? existing.metadata,\n        syncMetadata: { ...existing.syncMetadata, ...incoming.syncMetadata },\n        // Update tracking info\n        mutationId: incoming.mutationId,\n        updatedAt: incoming.updatedAt,\n      }\n    }\n\n    case `insert-delete`:\n      // Delete after insert: cancel both mutations\n      return null\n\n    case `update-delete`:\n      // Delete after update: delete dominates\n      return incoming\n\n    case `update-update`: {\n      // Update after update: replace with latest, union changes\n      return {\n        ...incoming,\n        // Keep original from first update\n        original: existing.original,\n        // Union the changes from both updates\n        changes: { ...existing.changes, ...incoming.changes },\n        // Merge metadata\n        metadata: incoming.metadata ?? existing.metadata,\n        syncMetadata: { ...existing.syncMetadata, ...incoming.syncMetadata },\n      }\n    }\n\n    case `delete-delete`:\n    case `insert-insert`:\n      // Same type: replace with latest\n      return incoming\n\n    default: {\n      // Exhaustiveness check\n      const _exhaustive: never = `${existing.type}-${incoming.type}` as never\n      throw new Error(`Unhandled mutation combination: ${_exhaustive}`)\n    }\n  }\n}\n\n/**\n * Creates a new transaction for grouping multiple collection operations\n * @param config - Transaction configuration with mutation function\n * @returns A new Transaction instance\n * @example\n * // Basic transaction usage\n * const tx = createTransaction({\n *   mutationFn: async ({ transaction }) => {\n *     // Send all mutations to API\n *     await api.saveChanges(transaction.mutations)\n *   }\n * })\n *\n * tx.mutate(() => {\n *   collection.insert({ id: \"1\", text: \"Buy milk\" })\n *   collection.update(\"2\", draft => { draft.completed = true })\n * })\n *\n * await tx.isPersisted.promise\n *\n * @example\n * // Handle transaction errors\n * try {\n *   const tx = createTransaction({\n *     mutationFn: async () => { throw new Error(\"API failed\") }\n *   })\n *\n *   tx.mutate(() => {\n *     collection.insert({ id: \"1\", text: \"New item\" })\n *   })\n *\n *   await tx.isPersisted.promise\n * } catch (error) {\n *   console.log('Transaction failed:', error)\n * }\n *\n * @example\n * // Manual commit control\n * const tx = createTransaction({\n *   autoCommit: false,\n *   mutationFn: async () => {\n *     // API call\n *   }\n * })\n *\n * tx.mutate(() => {\n *   collection.insert({ id: \"1\", text: \"Item\" })\n * })\n *\n * // Commit later\n * await tx.commit()\n */\nexport function createTransaction<T extends object = Record<string, unknown>>(\n  config: TransactionConfig<T>\n): Transaction<T> {\n  const newTransaction = new Transaction<T>(config)\n  transactions.push(newTransaction)\n  return newTransaction\n}\n\n/**\n * Gets the currently active ambient transaction, if any\n * Used internally by collection operations to join existing transactions\n * @returns The active transaction or undefined if none is active\n * @example\n * // Check if operations will join an ambient transaction\n * const ambientTx = getActiveTransaction()\n * if (ambientTx) {\n *   console.log('Operations will join transaction:', ambientTx.id)\n * }\n */\nexport function getActiveTransaction(): Transaction | undefined {\n  if (transactionStack.length > 0) {\n    return transactionStack.slice(-1)[0]\n  } else {\n    return undefined\n  }\n}\n\nfunction registerTransaction(tx: Transaction<any>) {\n  // Clear any stale work that may have been left behind if a previous mutate\n  // scope aborted before we could flush.\n  transactionScopedScheduler.clear(tx.id)\n  transactionStack.push(tx)\n}\n\nfunction unregisterTransaction(tx: Transaction<any>) {\n  // Always flush pending work for this transaction before removing it from\n  // the ambient stack â€“ this runs even if the mutate callback throws.\n  // If flush throws (e.g., due to a job error), we still clean up the stack.\n  try {\n    transactionScopedScheduler.flush(tx.id)\n  } finally {\n    transactionStack = transactionStack.filter((t) => t.id !== tx.id)\n  }\n}\n\nfunction removeFromPendingList(tx: Transaction<any>) {\n  const index = transactions.findIndex((t) => t.id === tx.id)\n  if (index !== -1) {\n    transactions.splice(index, 1)\n  }\n}\n\nclass Transaction<T extends object = Record<string, unknown>> {\n  public id: string\n  public state: TransactionState\n  public mutationFn: MutationFn<T>\n  public mutations: Array<PendingMutation<T>>\n  public isPersisted: Deferred<Transaction<T>>\n  public autoCommit: boolean\n  public createdAt: Date\n  public sequenceNumber: number\n  public metadata: Record<string, unknown>\n  public error?: {\n    message: string\n    error: Error\n  }\n\n  constructor(config: TransactionConfig<T>) {\n    if (typeof config.mutationFn === `undefined`) {\n      throw new MissingMutationFunctionError()\n    }\n    this.id = config.id ?? crypto.randomUUID()\n    this.mutationFn = config.mutationFn\n    this.state = `pending`\n    this.mutations = []\n    this.isPersisted = createDeferred<Transaction<T>>()\n    this.autoCommit = config.autoCommit ?? true\n    this.createdAt = new Date()\n    this.sequenceNumber = sequenceNumber++\n    this.metadata = config.metadata ?? {}\n  }\n\n  setState(newState: TransactionState) {\n    this.state = newState\n\n    if (newState === `completed` || newState === `failed`) {\n      removeFromPendingList(this)\n    }\n  }\n\n  /**\n   * Execute collection operations within this transaction\n   * @param callback - Function containing collection operations to group together. If the\n   * callback returns a Promise, the transaction context will remain active until the promise\n   * settles, allowing optimistic writes after `await` boundaries.\n   * @returns This transaction for chaining\n   * @example\n   * // Group multiple operations\n   * const tx = createTransaction({ mutationFn: async () => {\n   *   // Send to API\n   * }})\n   *\n   * tx.mutate(() => {\n   *   collection.insert({ id: \"1\", text: \"Buy milk\" })\n   *   collection.update(\"2\", draft => { draft.completed = true })\n   *   collection.delete(\"3\")\n   * })\n   *\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Handle mutate errors\n   * try {\n   *   tx.mutate(() => {\n   *     collection.insert({ id: \"invalid\" }) // This might throw\n   *   })\n   * } catch (error) {\n   *   console.log('Mutation failed:', error)\n   * }\n   *\n   * @example\n   * // Manual commit control\n   * const tx = createTransaction({ autoCommit: false, mutationFn: async () => {} })\n   *\n   * tx.mutate(() => {\n   *   collection.insert({ id: \"1\", text: \"Item\" })\n   * })\n   *\n   * // Commit later when ready\n   * await tx.commit()\n   */\n  mutate(callback: () => void): Transaction<T> {\n    if (this.state !== `pending`) {\n      throw new TransactionNotPendingMutateError()\n    }\n\n    registerTransaction(this)\n\n    try {\n      callback()\n    } finally {\n      unregisterTransaction(this)\n    }\n\n    if (this.autoCommit) {\n      this.commit().catch(() => {\n        // Errors from autoCommit are handled via isPersisted.promise\n        // This catch prevents unhandled promise rejections\n      })\n    }\n\n    return this\n  }\n\n  /**\n   * Apply new mutations to this transaction, intelligently merging with existing mutations\n   *\n   * When mutations operate on the same item (same globalKey), they are merged according to\n   * the following rules:\n   *\n   * - **insert + update** â†’ insert (merge changes, keep empty original)\n   * - **insert + delete** â†’ removed (mutations cancel each other out)\n   * - **update + delete** â†’ delete (delete dominates)\n   * - **update + update** â†’ update (union changes, keep first original)\n   * - **same type** â†’ replace with latest\n   *\n   * This merging reduces over-the-wire churn and keeps the optimistic local view\n   * aligned with user intent.\n   *\n   * @param mutations - Array of new mutations to apply\n   */\n  applyMutations(mutations: Array<PendingMutation<any>>): void {\n    for (const newMutation of mutations) {\n      const existingIndex = this.mutations.findIndex(\n        (m) => m.globalKey === newMutation.globalKey\n      )\n\n      if (existingIndex >= 0) {\n        const existingMutation = this.mutations[existingIndex]!\n        const mergeResult = mergePendingMutations(existingMutation, newMutation)\n\n        if (mergeResult === null) {\n          // Remove the mutation (e.g., delete after insert cancels both)\n          this.mutations.splice(existingIndex, 1)\n        } else {\n          // Replace with merged mutation\n          this.mutations[existingIndex] = mergeResult\n        }\n      } else {\n        // Insert new mutation\n        this.mutations.push(newMutation)\n      }\n    }\n  }\n\n  /**\n   * Rollback the transaction and any conflicting transactions\n   * @param config - Configuration for rollback behavior\n   * @returns This transaction for chaining\n   * @example\n   * // Manual rollback\n   * const tx = createTransaction({ mutationFn: async () => {\n   *   // Send to API\n   * }})\n   *\n   * tx.mutate(() => {\n   *   collection.insert({ id: \"1\", text: \"Buy milk\" })\n   * })\n   *\n   * // Rollback if needed\n   * if (shouldCancel) {\n   *   tx.rollback()\n   * }\n   *\n   * @example\n   * // Handle rollback cascade (automatic)\n   * const tx1 = createTransaction({ mutationFn: async () => {} })\n   * const tx2 = createTransaction({ mutationFn: async () => {} })\n   *\n   * tx1.mutate(() => collection.update(\"1\", draft => { draft.value = \"A\" }))\n   * tx2.mutate(() => collection.update(\"1\", draft => { draft.value = \"B\" })) // Same item\n   *\n   * tx1.rollback() // This will also rollback tx2 due to conflict\n   *\n   * @example\n   * // Handle rollback in error scenarios\n   * try {\n   *   await tx.isPersisted.promise\n   * } catch (error) {\n   *   console.log('Transaction was rolled back:', error)\n   *   // Transaction automatically rolled back on mutation function failure\n   * }\n   */\n  rollback(config?: { isSecondaryRollback?: boolean }): Transaction<T> {\n    const isSecondaryRollback = config?.isSecondaryRollback ?? false\n    if (this.state === `completed`) {\n      throw new TransactionAlreadyCompletedRollbackError()\n    }\n\n    this.setState(`failed`)\n\n    // See if there's any other transactions w/ mutations on the same ids\n    // and roll them back as well.\n    if (!isSecondaryRollback) {\n      const mutationIds = new Set()\n      this.mutations.forEach((m) => mutationIds.add(m.globalKey))\n      for (const t of transactions) {\n        t.state === `pending` &&\n          t.mutations.some((m) => mutationIds.has(m.globalKey)) &&\n          t.rollback({ isSecondaryRollback: true })\n      }\n    }\n\n    // Reject the promise\n    this.isPersisted.reject(this.error?.error)\n    this.touchCollection()\n\n    return this\n  }\n\n  // Tell collection that something has changed with the transaction\n  touchCollection(): void {\n    const hasCalled = new Set()\n    for (const mutation of this.mutations) {\n      if (!hasCalled.has(mutation.collection.id)) {\n        mutation.collection._state.onTransactionStateChange()\n\n        // Only call commitPendingTransactions if there are pending sync transactions\n        if (mutation.collection._state.pendingSyncedTransactions.length > 0) {\n          mutation.collection._state.commitPendingTransactions()\n        }\n\n        hasCalled.add(mutation.collection.id)\n      }\n    }\n  }\n\n  /**\n   * Commit the transaction and execute the mutation function\n   * @returns Promise that resolves to this transaction when complete\n   * @example\n   * // Manual commit (when autoCommit is false)\n   * const tx = createTransaction({\n   *   autoCommit: false,\n   *   mutationFn: async ({ transaction }) => {\n   *     await api.saveChanges(transaction.mutations)\n   *   }\n   * })\n   *\n   * tx.mutate(() => {\n   *   collection.insert({ id: \"1\", text: \"Buy milk\" })\n   * })\n   *\n   * await tx.commit() // Manually commit\n   *\n   * @example\n   * // Handle commit errors\n   * try {\n   *   const tx = createTransaction({\n   *     mutationFn: async () => { throw new Error(\"API failed\") }\n   *   })\n   *\n   *   tx.mutate(() => {\n   *     collection.insert({ id: \"1\", text: \"Item\" })\n   *   })\n   *\n   *   await tx.commit()\n   * } catch (error) {\n   *   console.log('Commit failed, transaction rolled back:', error)\n   * }\n   *\n   * @example\n   * // Check transaction state after commit\n   * await tx.commit()\n   * console.log(tx.state) // \"completed\" or \"failed\"\n   */\n  async commit(): Promise<Transaction<T>> {\n    if (this.state !== `pending`) {\n      throw new TransactionNotPendingCommitError()\n    }\n\n    this.setState(`persisting`)\n\n    if (this.mutations.length === 0) {\n      this.setState(`completed`)\n      this.isPersisted.resolve(this)\n\n      return this\n    }\n\n    // Run mutationFn\n    try {\n      // At this point we know there's at least one mutation\n      // We've already verified mutations is non-empty, so this cast is safe\n      // Use a direct type assertion instead of object spreading to preserve the original type\n      await this.mutationFn({\n        transaction: this as unknown as TransactionWithMutations<T>,\n      })\n\n      this.setState(`completed`)\n      this.touchCollection()\n\n      this.isPersisted.resolve(this)\n    } catch (error) {\n      // Preserve the original error for rethrowing\n      const originalError =\n        error instanceof Error ? error : new Error(String(error))\n\n      // Update transaction with error information\n      this.error = {\n        message: originalError.message,\n        error: originalError,\n      }\n\n      // rollback the transaction\n      this.rollback()\n\n      // Re-throw the original error to preserve identity and stack\n      throw originalError\n    }\n\n    return this\n  }\n\n  /**\n   * Compare two transactions by their createdAt time and sequence number in order\n   * to sort them in the order they were created.\n   * @param other - The other transaction to compare to\n   * @returns -1 if this transaction was created before the other, 1 if it was created after, 0 if they were created at the same time\n   */\n  compareCreatedAt(other: Transaction<any>): number {\n    const createdAtComparison =\n      this.createdAt.getTime() - other.createdAt.getTime()\n    if (createdAtComparison !== 0) {\n      return createdAtComparison\n    }\n    return this.sequenceNumber - other.sequenceNumber\n  }\n}\n\nexport type { Transaction }\n", "import type { CompareOptions } from \"../query/builder/types\"\nimport type { OrderByDirection } from \"../query/ir\"\nimport type { IndexInterface, IndexOperation, IndexStats } from \"./base-index\"\nimport type { RangeQueryOptions } from \"./btree-index\"\n\nexport class ReverseIndex<TKey extends string | number>\n  implements IndexInterface<TKey>\n{\n  private originalIndex: IndexInterface<TKey>\n\n  constructor(index: IndexInterface<TKey>) {\n    this.originalIndex = index\n  }\n\n  // Define the reversed operations\n\n  lookup(operation: IndexOperation, value: any): Set<TKey> {\n    const reverseOperation =\n      operation === `gt`\n        ? `lt`\n        : operation === `gte`\n          ? `lte`\n          : operation === `lt`\n            ? `gt`\n            : operation === `lte`\n              ? `gte`\n              : operation\n    return this.originalIndex.lookup(reverseOperation, value)\n  }\n\n  rangeQuery(options: RangeQueryOptions = {}): Set<TKey> {\n    return this.originalIndex.rangeQueryReversed(options)\n  }\n\n  rangeQueryReversed(options: RangeQueryOptions = {}): Set<TKey> {\n    return this.originalIndex.rangeQuery(options)\n  }\n\n  take(n: number, from?: any, filterFn?: (key: TKey) => boolean): Array<TKey> {\n    return this.originalIndex.takeReversed(n, from, filterFn)\n  }\n\n  takeReversed(\n    n: number,\n    from?: any,\n    filterFn?: (key: TKey) => boolean\n  ): Array<TKey> {\n    return this.originalIndex.take(n, from, filterFn)\n  }\n\n  get orderedEntriesArray(): Array<[any, Set<TKey>]> {\n    return this.originalIndex.orderedEntriesArrayReversed\n  }\n\n  get orderedEntriesArrayReversed(): Array<[any, Set<TKey>]> {\n    return this.originalIndex.orderedEntriesArray\n  }\n\n  // All operations below delegate to the original index\n\n  supports(operation: IndexOperation): boolean {\n    return this.originalIndex.supports(operation)\n  }\n\n  matchesField(fieldPath: Array<string>): boolean {\n    return this.originalIndex.matchesField(fieldPath)\n  }\n\n  matchesCompareOptions(compareOptions: CompareOptions): boolean {\n    return this.originalIndex.matchesCompareOptions(compareOptions)\n  }\n\n  matchesDirection(direction: OrderByDirection): boolean {\n    return this.originalIndex.matchesDirection(direction)\n  }\n\n  getStats(): IndexStats {\n    return this.originalIndex.getStats()\n  }\n\n  add(key: TKey, item: any): void {\n    this.originalIndex.add(key, item)\n  }\n\n  remove(key: TKey, item: any): void {\n    this.originalIndex.remove(key, item)\n  }\n\n  update(key: TKey, oldItem: any, newItem: any): void {\n    this.originalIndex.update(key, oldItem, newItem)\n  }\n\n  build(entries: Iterable<[TKey, any]>): void {\n    this.originalIndex.build(entries)\n  }\n\n  clear(): void {\n    this.originalIndex.clear()\n  }\n\n  get keyCount(): number {\n    return this.originalIndex.keyCount\n  }\n\n  equalityLookup(value: any): Set<TKey> {\n    return this.originalIndex.equalityLookup(value)\n  }\n\n  inArrayLookup(values: Array<any>): Set<TKey> {\n    return this.originalIndex.inArrayLookup(values)\n  }\n\n  get indexedKeysSet(): Set<TKey> {\n    return this.originalIndex.indexedKeysSet\n  }\n\n  get valueMapData(): Map<any, Set<TKey>> {\n    return this.originalIndex.valueMapData\n  }\n}\n", "/**\n * # Index-Based Query Optimization\n *\n * This module provides utilities for optimizing query expressions by leveraging\n * available indexes to quickly find matching keys instead of scanning all data.\n *\n * This is different from the query structure optimizer in `query/optimizer.ts`\n * which rewrites query IR structure. This module focuses on using indexes during\n * query execution to speed up data filtering.\n *\n * ## Key Features:\n * - Uses indexes to find matching keys for WHERE conditions\n * - Supports AND/OR logic with set operations\n * - Handles range queries (eq, gt, gte, lt, lte)\n * - Optimizes IN array expressions\n */\n\nimport { DEFAULT_COMPARE_OPTIONS } from \"../utils.js\"\nimport { ReverseIndex } from \"../indexes/reverse-index.js\"\nimport type { CompareOptions } from \"../query/builder/types.js\"\nimport type { IndexInterface, IndexOperation } from \"../indexes/base-index.js\"\nimport type { BasicExpression } from \"../query/ir.js\"\nimport type { CollectionLike } from \"../types.js\"\n\n/**\n * Result of index-based query optimization\n */\nexport interface OptimizationResult<TKey> {\n  canOptimize: boolean\n  matchingKeys: Set<TKey>\n}\n\n/**\n * Finds an index that matches a given field path\n */\nexport function findIndexForField<TKey extends string | number>(\n  collection: CollectionLike<any, TKey>,\n  fieldPath: Array<string>,\n  compareOptions?: CompareOptions\n): IndexInterface<TKey> | undefined {\n  const compareOpts = compareOptions ?? {\n    ...DEFAULT_COMPARE_OPTIONS,\n    ...collection.compareOptions,\n  }\n\n  for (const index of collection.indexes.values()) {\n    if (\n      index.matchesField(fieldPath) &&\n      index.matchesCompareOptions(compareOpts)\n    ) {\n      if (!index.matchesDirection(compareOpts.direction)) {\n        return new ReverseIndex(index)\n      }\n      return index\n    }\n  }\n  return undefined\n}\n\n/**\n * Intersects multiple sets (AND logic)\n */\nexport function intersectSets<T>(sets: Array<Set<T>>): Set<T> {\n  if (sets.length === 0) return new Set()\n  if (sets.length === 1) return new Set(sets[0])\n\n  let result = new Set(sets[0])\n  for (let i = 1; i < sets.length; i++) {\n    const newResult = new Set<T>()\n    for (const item of result) {\n      if (sets[i]!.has(item)) {\n        newResult.add(item)\n      }\n    }\n    result = newResult\n  }\n  return result\n}\n\n/**\n * Unions multiple sets (OR logic)\n */\nexport function unionSets<T>(sets: Array<Set<T>>): Set<T> {\n  const result = new Set<T>()\n  for (const set of sets) {\n    for (const item of set) {\n      result.add(item)\n    }\n  }\n  return result\n}\n\n/**\n * Optimizes a query expression using available indexes to find matching keys\n */\nexport function optimizeExpressionWithIndexes<\n  T extends object,\n  TKey extends string | number,\n>(\n  expression: BasicExpression,\n  collection: CollectionLike<T, TKey>\n): OptimizationResult<TKey> {\n  return optimizeQueryRecursive(expression, collection)\n}\n\n/**\n * Recursively optimizes query expressions\n */\nfunction optimizeQueryRecursive<T extends object, TKey extends string | number>(\n  expression: BasicExpression,\n  collection: CollectionLike<T, TKey>\n): OptimizationResult<TKey> {\n  if (expression.type === `func`) {\n    switch (expression.name) {\n      case `eq`:\n      case `gt`:\n      case `gte`:\n      case `lt`:\n      case `lte`:\n        return optimizeSimpleComparison(expression, collection)\n\n      case `and`:\n        return optimizeAndExpression(expression, collection)\n\n      case `or`:\n        return optimizeOrExpression(expression, collection)\n\n      case `in`:\n        return optimizeInArrayExpression(expression, collection)\n    }\n  }\n\n  return { canOptimize: false, matchingKeys: new Set() }\n}\n\n/**\n * Checks if an expression can be optimized\n */\nexport function canOptimizeExpression<\n  T extends object,\n  TKey extends string | number,\n>(expression: BasicExpression, collection: CollectionLike<T, TKey>): boolean {\n  if (expression.type === `func`) {\n    switch (expression.name) {\n      case `eq`:\n      case `gt`:\n      case `gte`:\n      case `lt`:\n      case `lte`:\n        return canOptimizeSimpleComparison(expression, collection)\n\n      case `and`:\n        return canOptimizeAndExpression(expression, collection)\n\n      case `or`:\n        return canOptimizeOrExpression(expression, collection)\n\n      case `in`:\n        return canOptimizeInArrayExpression(expression, collection)\n    }\n  }\n\n  return false\n}\n\n/**\n * Optimizes compound range queries on the same field\n * Example: WHERE age > 5 AND age < 10\n */\nfunction optimizeCompoundRangeQuery<\n  T extends object,\n  TKey extends string | number,\n>(\n  expression: BasicExpression,\n  collection: CollectionLike<T, TKey>\n): OptimizationResult<TKey> {\n  if (expression.type !== `func` || expression.args.length < 2) {\n    return { canOptimize: false, matchingKeys: new Set() }\n  }\n\n  // Group range operations by field\n  const fieldOperations = new Map<\n    string,\n    Array<{\n      operation: `gt` | `gte` | `lt` | `lte`\n      value: any\n    }>\n  >()\n\n  // Collect all range operations from AND arguments\n  for (const arg of expression.args) {\n    if (arg.type === `func` && [`gt`, `gte`, `lt`, `lte`].includes(arg.name)) {\n      const rangeOp = arg as any\n      if (rangeOp.args.length === 2) {\n        const leftArg = rangeOp.args[0]!\n        const rightArg = rangeOp.args[1]!\n\n        // Check both directions: field op value AND value op field\n        let fieldArg: BasicExpression | null = null\n        let valueArg: BasicExpression | null = null\n        let operation = rangeOp.name as `gt` | `gte` | `lt` | `lte`\n\n        if (leftArg.type === `ref` && rightArg.type === `val`) {\n          // field op value\n          fieldArg = leftArg\n          valueArg = rightArg\n        } else if (leftArg.type === `val` && rightArg.type === `ref`) {\n          // value op field - need to flip the operation\n          fieldArg = rightArg\n          valueArg = leftArg\n\n          // Flip the operation for reverse comparison\n          switch (operation) {\n            case `gt`:\n              operation = `lt`\n              break\n            case `gte`:\n              operation = `lte`\n              break\n            case `lt`:\n              operation = `gt`\n              break\n            case `lte`:\n              operation = `gte`\n              break\n          }\n        }\n\n        if (fieldArg && valueArg) {\n          const fieldPath = (fieldArg as any).path\n          const fieldKey = fieldPath.join(`.`)\n          const value = (valueArg as any).value\n\n          if (!fieldOperations.has(fieldKey)) {\n            fieldOperations.set(fieldKey, [])\n          }\n          fieldOperations.get(fieldKey)!.push({ operation, value })\n        }\n      }\n    }\n  }\n\n  // Check if we have multiple operations on the same field\n  for (const [fieldKey, operations] of fieldOperations) {\n    if (operations.length >= 2) {\n      const fieldPath = fieldKey.split(`.`)\n      const index = findIndexForField(collection, fieldPath)\n\n      if (index && index.supports(`gt`) && index.supports(`lt`)) {\n        // Build range query options\n        let from: any = undefined\n        let to: any = undefined\n        let fromInclusive = true\n        let toInclusive = true\n\n        for (const { operation, value } of operations) {\n          switch (operation) {\n            case `gt`:\n              if (from === undefined || value > from) {\n                from = value\n                fromInclusive = false\n              }\n              break\n            case `gte`:\n              if (from === undefined || value > from) {\n                from = value\n                fromInclusive = true\n              }\n              break\n            case `lt`:\n              if (to === undefined || value < to) {\n                to = value\n                toInclusive = false\n              }\n              break\n            case `lte`:\n              if (to === undefined || value < to) {\n                to = value\n                toInclusive = true\n              }\n              break\n          }\n        }\n\n        const matchingKeys = (index as any).rangeQuery({\n          from,\n          to,\n          fromInclusive,\n          toInclusive,\n        })\n\n        return { canOptimize: true, matchingKeys }\n      }\n    }\n  }\n\n  return { canOptimize: false, matchingKeys: new Set() }\n}\n\n/**\n * Optimizes simple comparison expressions (eq, gt, gte, lt, lte)\n */\nfunction optimizeSimpleComparison<\n  T extends object,\n  TKey extends string | number,\n>(\n  expression: BasicExpression,\n  collection: CollectionLike<T, TKey>\n): OptimizationResult<TKey> {\n  if (expression.type !== `func` || expression.args.length !== 2) {\n    return { canOptimize: false, matchingKeys: new Set() }\n  }\n\n  const leftArg = expression.args[0]!\n  const rightArg = expression.args[1]!\n\n  // Check both directions: field op value AND value op field\n  let fieldArg: BasicExpression | null = null\n  let valueArg: BasicExpression | null = null\n  let operation = expression.name as `eq` | `gt` | `gte` | `lt` | `lte`\n\n  if (leftArg.type === `ref` && rightArg.type === `val`) {\n    // field op value\n    fieldArg = leftArg\n    valueArg = rightArg\n  } else if (leftArg.type === `val` && rightArg.type === `ref`) {\n    // value op field - need to flip the operation\n    fieldArg = rightArg\n    valueArg = leftArg\n\n    // Flip the operation for reverse comparison\n    switch (operation) {\n      case `gt`:\n        operation = `lt`\n        break\n      case `gte`:\n        operation = `lte`\n        break\n      case `lt`:\n        operation = `gt`\n        break\n      case `lte`:\n        operation = `gte`\n        break\n      // eq stays the same\n    }\n  }\n\n  if (fieldArg && valueArg) {\n    const fieldPath = (fieldArg as any).path\n    const index = findIndexForField(collection, fieldPath)\n\n    if (index) {\n      const queryValue = (valueArg as any).value\n\n      // Map operation to IndexOperation enum\n      const indexOperation = operation as IndexOperation\n\n      // Check if the index supports this operation\n      if (!index.supports(indexOperation)) {\n        return { canOptimize: false, matchingKeys: new Set() }\n      }\n\n      const matchingKeys = index.lookup(indexOperation, queryValue)\n      return { canOptimize: true, matchingKeys }\n    }\n  }\n\n  return { canOptimize: false, matchingKeys: new Set() }\n}\n\n/**\n * Checks if a simple comparison can be optimized\n */\nfunction canOptimizeSimpleComparison<\n  T extends object,\n  TKey extends string | number,\n>(expression: BasicExpression, collection: CollectionLike<T, TKey>): boolean {\n  if (expression.type !== `func` || expression.args.length !== 2) {\n    return false\n  }\n\n  const leftArg = expression.args[0]!\n  const rightArg = expression.args[1]!\n\n  // Check both directions: field op value AND value op field\n  let fieldPath: Array<string> | null = null\n\n  if (leftArg.type === `ref` && rightArg.type === `val`) {\n    fieldPath = (leftArg as any).path\n  } else if (leftArg.type === `val` && rightArg.type === `ref`) {\n    fieldPath = (rightArg as any).path\n  }\n\n  if (fieldPath) {\n    const index = findIndexForField(collection, fieldPath)\n    return index !== undefined\n  }\n\n  return false\n}\n\n/**\n * Optimizes AND expressions\n */\nfunction optimizeAndExpression<T extends object, TKey extends string | number>(\n  expression: BasicExpression,\n  collection: CollectionLike<T, TKey>\n): OptimizationResult<TKey> {\n  if (expression.type !== `func` || expression.args.length < 2) {\n    return { canOptimize: false, matchingKeys: new Set() }\n  }\n\n  // First, try to optimize compound range queries on the same field\n  const compoundRangeResult = optimizeCompoundRangeQuery(expression, collection)\n  if (compoundRangeResult.canOptimize) {\n    return compoundRangeResult\n  }\n\n  const results: Array<OptimizationResult<TKey>> = []\n\n  // Try to optimize each part, keep the optimizable ones\n  for (const arg of expression.args) {\n    const result = optimizeQueryRecursive(arg, collection)\n    if (result.canOptimize) {\n      results.push(result)\n    }\n  }\n\n  if (results.length > 0) {\n    // Use intersectSets utility for AND logic\n    const allMatchingSets = results.map((r) => r.matchingKeys)\n    const intersectedKeys = intersectSets(allMatchingSets)\n    return { canOptimize: true, matchingKeys: intersectedKeys }\n  }\n\n  return { canOptimize: false, matchingKeys: new Set() }\n}\n\n/**\n * Checks if an AND expression can be optimized\n */\nfunction canOptimizeAndExpression<\n  T extends object,\n  TKey extends string | number,\n>(expression: BasicExpression, collection: CollectionLike<T, TKey>): boolean {\n  if (expression.type !== `func` || expression.args.length < 2) {\n    return false\n  }\n\n  // If any argument can be optimized, we can gain some speedup\n  return expression.args.some((arg) => canOptimizeExpression(arg, collection))\n}\n\n/**\n * Optimizes OR expressions\n */\nfunction optimizeOrExpression<T extends object, TKey extends string | number>(\n  expression: BasicExpression,\n  collection: CollectionLike<T, TKey>\n): OptimizationResult<TKey> {\n  if (expression.type !== `func` || expression.args.length < 2) {\n    return { canOptimize: false, matchingKeys: new Set() }\n  }\n\n  const results: Array<OptimizationResult<TKey>> = []\n\n  // Try to optimize each part, keep the optimizable ones\n  for (const arg of expression.args) {\n    const result = optimizeQueryRecursive(arg, collection)\n    if (result.canOptimize) {\n      results.push(result)\n    }\n  }\n\n  if (results.length > 0) {\n    // Use unionSets utility for OR logic\n    const allMatchingSets = results.map((r) => r.matchingKeys)\n    const unionedKeys = unionSets(allMatchingSets)\n    return { canOptimize: true, matchingKeys: unionedKeys }\n  }\n\n  return { canOptimize: false, matchingKeys: new Set() }\n}\n\n/**\n * Checks if an OR expression can be optimized\n */\nfunction canOptimizeOrExpression<\n  T extends object,\n  TKey extends string | number,\n>(expression: BasicExpression, collection: CollectionLike<T, TKey>): boolean {\n  if (expression.type !== `func` || expression.args.length < 2) {\n    return false\n  }\n\n  // If any argument can be optimized, we can gain some speedup\n  return expression.args.some((arg) => canOptimizeExpression(arg, collection))\n}\n\n/**\n * Optimizes IN array expressions\n */\nfunction optimizeInArrayExpression<\n  T extends object,\n  TKey extends string | number,\n>(\n  expression: BasicExpression,\n  collection: CollectionLike<T, TKey>\n): OptimizationResult<TKey> {\n  if (expression.type !== `func` || expression.args.length !== 2) {\n    return { canOptimize: false, matchingKeys: new Set() }\n  }\n\n  const fieldArg = expression.args[0]!\n  const arrayArg = expression.args[1]!\n\n  if (\n    fieldArg.type === `ref` &&\n    arrayArg.type === `val` &&\n    Array.isArray((arrayArg as any).value)\n  ) {\n    const fieldPath = (fieldArg as any).path\n    const values = (arrayArg as any).value\n    const index = findIndexForField(collection, fieldPath)\n\n    if (index) {\n      // Check if the index supports IN operation\n      if (index.supports(`in`)) {\n        const matchingKeys = index.lookup(`in`, values)\n        return { canOptimize: true, matchingKeys }\n      } else if (index.supports(`eq`)) {\n        // Fallback to multiple equality lookups\n        const matchingKeys = new Set<TKey>()\n        for (const value of values) {\n          const keysForValue = index.lookup(`eq`, value)\n          for (const key of keysForValue) {\n            matchingKeys.add(key)\n          }\n        }\n        return { canOptimize: true, matchingKeys }\n      }\n    }\n  }\n\n  return { canOptimize: false, matchingKeys: new Set() }\n}\n\n/**\n * Checks if an IN array expression can be optimized\n */\nfunction canOptimizeInArrayExpression<\n  T extends object,\n  TKey extends string | number,\n>(expression: BasicExpression, collection: CollectionLike<T, TKey>): boolean {\n  if (expression.type !== `func` || expression.args.length !== 2) {\n    return false\n  }\n\n  const fieldArg = expression.args[0]!\n  const arrayArg = expression.args[1]!\n\n  if (\n    fieldArg.type === `ref` &&\n    arrayArg.type === `val` &&\n    Array.isArray((arrayArg as any).value)\n  ) {\n    const fieldPath = (fieldArg as any).path\n    const index = findIndexForField(collection, fieldPath)\n    return index !== undefined\n  }\n\n  return false\n}\n", "import { DEFAULT_COMPARE_OPTIONS } from \"../utils\"\nimport { BTreeIndex } from \"./btree-index\"\nimport type { CompareOptions } from \"../query/builder/types\"\nimport type { BasicExpression } from \"../query/ir\"\nimport type { CollectionImpl } from \"../collection/index.js\"\n\nexport interface AutoIndexConfig {\n  autoIndex?: `off` | `eager`\n}\n\nfunction shouldAutoIndex(collection: CollectionImpl<any, any, any, any, any>) {\n  // Only proceed if auto-indexing is enabled\n  if (collection.config.autoIndex !== `eager`) {\n    return false\n  }\n\n  return true\n}\n\nexport function ensureIndexForField<\n  T extends Record<string, any>,\n  TKey extends string | number,\n>(\n  fieldName: string,\n  fieldPath: Array<string>,\n  collection: CollectionImpl<T, TKey, any, any, any>,\n  compareOptions?: CompareOptions,\n  compareFn?: (a: any, b: any) => number\n) {\n  if (!shouldAutoIndex(collection)) {\n    return\n  }\n\n  const compareOpts = compareOptions ?? {\n    ...DEFAULT_COMPARE_OPTIONS,\n    ...collection.compareOptions,\n  }\n\n  // Check if we already have an index for this field\n  const existingIndex = Array.from(collection.indexes.values()).find(\n    (index) =>\n      index.matchesField(fieldPath) && index.matchesCompareOptions(compareOpts)\n  )\n\n  if (existingIndex) {\n    return // Index already exists\n  }\n\n  // Create a new index for this field using the collection's createIndex method\n  try {\n    // Use the proxy-based approach to create the proper accessor for nested paths\n    collection.createIndex(\n      (row) => {\n        // Navigate through the field path\n        let current: any = row\n        for (const part of fieldPath) {\n          current = current[part]\n        }\n        return current\n      },\n      {\n        name: `auto:${fieldPath.join(`.`)}`,\n        indexType: BTreeIndex,\n        options: compareFn ? { compareFn, compareOptions: compareOpts } : {},\n      }\n    )\n  } catch (error) {\n    console.warn(\n      `${collection.id ? `[${collection.id}] ` : ``}Failed to create auto-index for field path \"${fieldPath.join(`.`)}\":`,\n      error\n    )\n  }\n}\n\n/**\n * Analyzes a where expression and creates indexes for all simple operations on single fields\n */\nexport function ensureIndexForExpression<\n  T extends Record<string, any>,\n  TKey extends string | number,\n>(\n  expression: BasicExpression,\n  collection: CollectionImpl<T, TKey, any, any, any>\n): void {\n  if (!shouldAutoIndex(collection)) {\n    return\n  }\n\n  // Extract all indexable expressions and create indexes for them\n  const indexableExpressions = extractIndexableExpressions(expression)\n\n  for (const { fieldName, fieldPath } of indexableExpressions) {\n    ensureIndexForField(fieldName, fieldPath, collection)\n  }\n}\n\n/**\n * Extracts all indexable expressions from a where expression\n */\nfunction extractIndexableExpressions(\n  expression: BasicExpression\n): Array<{ fieldName: string; fieldPath: Array<string> }> {\n  const results: Array<{ fieldName: string; fieldPath: Array<string> }> = []\n\n  function extractFromExpression(expr: BasicExpression): void {\n    if (expr.type !== `func`) {\n      return\n    }\n\n    const func = expr as any\n\n    // Handle 'and' expressions by recursively processing all arguments\n    if (func.name === `and`) {\n      for (const arg of func.args) {\n        extractFromExpression(arg)\n      }\n      return\n    }\n\n    // Check if this is a supported operation\n    const supportedOperations = [`eq`, `gt`, `gte`, `lt`, `lte`, `in`]\n    if (!supportedOperations.includes(func.name)) {\n      return\n    }\n\n    // Check if the first argument is a property reference\n    if (func.args.length < 1 || func.args[0].type !== `ref`) {\n      return\n    }\n\n    const fieldRef = func.args[0]\n    const fieldPath = fieldRef.path\n\n    // Skip if the path is empty\n    if (fieldPath.length === 0) {\n      return\n    }\n\n    // For nested paths, use the full path joined with underscores as the field name\n    // For simple paths, use the first (and only) element\n    const fieldName = fieldPath.join(`_`)\n    results.push({ fieldName, fieldPath })\n  }\n\n  extractFromExpression(expression)\n  return results\n}\n", "/**\n * Simple assertion function for runtime checks.\n * Throws an error if the condition is false.\n */\nexport function assert(\n  condition: unknown,\n  message?: string\n): asserts condition {\n  if (!condition) {\n    throw new Error(message || `Assertion failed`)\n  }\n}\n\n/**\n * A map that returns a default value for keys that are not present.\n */\nexport class DefaultMap<K, V> extends Map<K, V> {\n  constructor(\n    private defaultValue: () => V,\n    entries?: Iterable<[K, V]>\n  ) {\n    super(entries)\n  }\n\n  get(key: K): V {\n    if (!this.has(key)) {\n      // this.set(key, this.defaultValue())\n      return this.defaultValue()\n    }\n    return super.get(key)!\n  }\n\n  /**\n   * Update the value for a key using a function.\n   */\n  update(key: K, updater: (value: V) => V): V {\n    const value = this.get(key)\n    const newValue = updater(value)\n    this.set(key, newValue)\n    return newValue\n  }\n}\n\n// JS engines have various limits on how many args can be passed to a function\n// with a spread operator, so we need to split the operation into chunks\n// 32767 is the max for Chrome 14, all others are higher\n// TODO: investigate the performance of this and other approaches\nconst chunkSize = 30000\nexport function chunkedArrayPush(array: Array<unknown>, other: Array<unknown>) {\n  if (other.length <= chunkSize) {\n    array.push(...other)\n  } else {\n    for (let i = 0; i < other.length; i += chunkSize) {\n      const chunk = other.slice(i, i + chunkSize)\n      array.push(...chunk)\n    }\n  }\n}\n\nexport function binarySearch<T>(\n  array: Array<T>,\n  value: T,\n  comparator: (a: T, b: T) => number\n): number {\n  let low = 0\n  let high = array.length\n  while (low < high) {\n    const mid = Math.floor((low + high) / 2)\n    const comparison = comparator(array[mid]!, value)\n    if (comparison < 0) {\n      low = mid + 1\n    } else if (comparison > 0) {\n      high = mid\n    } else {\n      return mid\n    }\n  }\n  return low\n}\n\n/**\n * Utility for generating unique IDs for objects and values.\n * Uses WeakMap for object reference tracking and consistent hashing for primitives.\n */\nexport class ObjectIdGenerator {\n  private objectIds = new WeakMap<object, number>()\n  private nextId = 0\n\n  /**\n   * Get a unique identifier for any value.\n   * - Objects: Uses WeakMap for reference-based identity\n   * - Primitives: Uses consistent string-based hashing\n   */\n  getId(value: any): number {\n    // For primitives, use a simple hash of their string representation\n    if (typeof value !== `object` || value === null) {\n      const str = String(value)\n      let hashValue = 0\n      for (let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i)\n        hashValue = (hashValue << 5) - hashValue + char\n        hashValue = hashValue & hashValue // Convert to 32-bit integer\n      }\n      return hashValue\n    }\n\n    // For objects, use WeakMap to assign unique IDs\n    if (!this.objectIds.has(value)) {\n      this.objectIds.set(value, this.nextId++)\n    }\n    return this.objectIds.get(value)!\n  }\n\n  /**\n   * Get a string representation of the ID for use in composite keys.\n   */\n  getStringId(value: any): string {\n    if (value === null) return `null`\n    if (value === undefined) return `undefined`\n    if (typeof value !== `object`) return `str_${String(value)}`\n\n    return `obj_${this.getId(value)}`\n  }\n}\n\n/**\n * Global instance for cases where a shared object ID space is needed.\n */\nexport const globalObjectIdGenerator = new ObjectIdGenerator()\n\nexport function* concatIterable<T>(\n  ...iterables: Array<Iterable<T>>\n): Iterable<T> {\n  for (const iterable of iterables) {\n    yield* iterable\n  }\n}\n\nexport function* mapIterable<T, U>(\n  it: Iterable<T>,\n  fn: (t: T) => U\n): Iterable<U> {\n  for (const t of it) {\n    yield fn(t)\n  }\n}\n\nexport type HRange = [number, number] // half-open [start, end[ i.e. end is exclusive\n\n/**\n * Computes the difference between two half-open ranges.\n * @param a - The first half-open range\n * @param b - The second half-open range\n * @returns The difference between the two ranges\n */\nexport function diffHalfOpen(a: HRange, b: HRange) {\n  const [a1, a2] = a\n  const [b1, b2] = b\n\n  // A \\ B can be up to two segments (left and right of the overlap)\n  const onlyInA: Array<number> = [\n    ...range(a1, Math.min(a2, b1)), // left side of A outside B\n    ...range(Math.max(a1, b2), a2), // right side of A outside B\n  ]\n\n  // B \\ A similarly\n  const onlyInB: Array<number> = [\n    ...range(b1, Math.min(b2, a1)),\n    ...range(Math.max(b1, a2), b2),\n  ]\n\n  return { onlyInA, onlyInB }\n}\n\nfunction range(start: number, end: number): Array<number> {\n  const out: Array<number> = []\n  for (let i = start; i < end; i++) out.push(i)\n  return out\n}\n", "/*\n * Implementation of murmur hash based on the Composites polyfill implementation:\n * https://github.com/tc39/proposal-composites\n */\n\nconst RANDOM_SEED = randomHash()\nconst STRING_MARKER = randomHash()\nconst BIG_INT_MARKER = randomHash()\nconst NEG_BIG_INT_MARKER = randomHash()\nconst SYMBOL_MARKER = randomHash()\n\nexport type Hash = number\n\nexport function randomHash() {\n  return (Math.random() * (2 ** 31 - 1)) >>> 0\n}\n\nexport interface Hasher {\n  update: (val: symbol | string | number | bigint) => void\n  digest: () => number\n}\n\n// Allocate these once, outside the hot path\nconst buf = new ArrayBuffer(8)\n// dv and u8 are 2 different views on the same buffer `buf`\nconst dv = new DataView(buf)\nconst u8 = new Uint8Array(buf)\n\n/**\n * This implementation of Murmur hash uses a random initial seed and random markers.\n * This means that hashes aren't deterministic across app restarts.\n * This is intentional in the composites polyfill to be resistent to hash-flooding attacks\n * where malicious users would precompute lots of different objects whose hashes collide with each other.\n *\n * Currently, for ts/db-ivm this is fine because we don't persist client state.\n * However, when we will introduce persistence we will either need to store the seeds or remove the randomness\n * to ensure deterministic hashes across app restarts.\n */\nexport class MurmurHashStream implements Hasher {\n  private hash: number = RANDOM_SEED\n  private length = 0\n  private carry = 0\n  private carryBytes = 0\n\n  private _mix(k1: number): void {\n    k1 = Math.imul(k1, 0xcc9e2d51)\n    k1 = (k1 << 15) | (k1 >>> 17)\n    k1 = Math.imul(k1, 0x1b873593)\n    this.hash ^= k1\n    this.hash = (this.hash << 13) | (this.hash >>> 19)\n    this.hash = Math.imul(this.hash, 5) + 0xe6546b64\n  }\n\n  writeByte(byte: number): void {\n    this.carry |= (byte & 0xff) << (8 * this.carryBytes)\n    this.carryBytes++\n    this.length++\n\n    if (this.carryBytes === 4) {\n      this._mix(this.carry >>> 0)\n      this.carry = 0\n      this.carryBytes = 0\n    }\n  }\n\n  update(chunk: symbol | string | number | bigint): void {\n    switch (typeof chunk) {\n      case `symbol`: {\n        this.update(SYMBOL_MARKER)\n        const description = chunk.description\n        if (!description) {\n          return\n        }\n\n        for (let i = 0; i < description.length; i++) {\n          const code = description.charCodeAt(i)\n          this.writeByte(code & 0xff)\n          this.writeByte((code >>> 8) & 0xff)\n        }\n        return\n      }\n      case `string`:\n        this.update(STRING_MARKER)\n        for (let i = 0; i < chunk.length; i++) {\n          const code = chunk.charCodeAt(i)\n          this.writeByte(code & 0xff)\n          this.writeByte((code >>> 8) & 0xff)\n        }\n        return\n      case `number`:\n        dv.setFloat64(0, chunk, true) // fixed little-endian\n        this.writeByte(u8[0]!)\n        this.writeByte(u8[1]!)\n        this.writeByte(u8[2]!)\n        this.writeByte(u8[3]!)\n        this.writeByte(u8[4]!)\n        this.writeByte(u8[5]!)\n        this.writeByte(u8[6]!)\n        this.writeByte(u8[7]!)\n        return\n      case `bigint`: {\n        let value = chunk\n        if (value < 0n) {\n          value = -value\n          this.update(NEG_BIG_INT_MARKER)\n        } else {\n          this.update(BIG_INT_MARKER)\n        }\n        while (value > 0n) {\n          this.writeByte(Number(value & 0xffn))\n          value >>= 8n\n        }\n        if (chunk === 0n) this.writeByte(0)\n        return\n      }\n      default:\n        throw new TypeError(`Unsupported input type: ${typeof chunk}`)\n    }\n  }\n\n  digest(): number {\n    if (this.carryBytes > 0) {\n      let k1 = this.carry >>> 0\n      k1 = Math.imul(k1, 0xcc9e2d51)\n      k1 = (k1 << 15) | (k1 >>> 17)\n      k1 = Math.imul(k1, 0x1b873593)\n      this.hash ^= k1\n    }\n\n    this.hash ^= this.length\n    this.hash ^= this.hash >>> 16\n    this.hash = Math.imul(this.hash, 0x85ebca6b)\n    this.hash ^= this.hash >>> 13\n    this.hash = Math.imul(this.hash, 0xc2b2ae35)\n    this.hash ^= this.hash >>> 16\n\n    return this.hash >>> 0\n  }\n}\n", "import { MurmurHashStream, randomHash } from \"./murmur.js\"\nimport type { Hasher } from \"./murmur.js\"\n\n/*\n * Implementation of structural hashing based on the Composites polyfill implementation:\n * https://github.com/tc39/proposal-composites\n */\n\nconst TRUE = randomHash()\nconst FALSE = randomHash()\nconst NULL = randomHash()\nconst UNDEFINED = randomHash()\nconst KEY = randomHash()\nconst FUNCTIONS = randomHash()\nconst DATE_MARKER = randomHash()\nconst OBJECT_MARKER = randomHash()\nconst ARRAY_MARKER = randomHash()\nconst MAP_MARKER = randomHash()\nconst SET_MARKER = randomHash()\nconst UINT8ARRAY_MARKER = randomHash()\n\n// Maximum byte length for Uint8Arrays to hash by content instead of reference\n// Arrays smaller than this will be hashed by content, allowing proper equality comparisons\n// for small arrays like ULIDs (16 bytes) while still avoiding performance costs for large arrays\nconst UINT8ARRAY_CONTENT_HASH_THRESHOLD = 128\n\nconst hashCache = new WeakMap<object, number>()\n\nexport function hash(input: any): number {\n  const hasher = new MurmurHashStream()\n  updateHasher(hasher, input)\n  return hasher.digest()\n}\n\nfunction hashObject(input: object): number {\n  const cachedHash = hashCache.get(input)\n  if (cachedHash !== undefined) {\n    return cachedHash\n  }\n\n  let valueHash: number | undefined\n  if (input instanceof Date) {\n    valueHash = hashDate(input)\n  } else if (\n    // Check if input is a Uint8Array or Buffer\n    (typeof Buffer !== `undefined` && input instanceof Buffer) ||\n    input instanceof Uint8Array\n  ) {\n    // For small Uint8Arrays/Buffers (e.g., ULIDs, UUIDs), hash by content\n    // to enable proper equality comparisons. For large arrays, hash by reference\n    // to avoid performance costs.\n    if (input.byteLength <= UINT8ARRAY_CONTENT_HASH_THRESHOLD) {\n      valueHash = hashUint8Array(input)\n    } else {\n      // Deeply hashing large arrays would be too costly\n      // so we track them by reference and cache them in a weak map\n      return cachedReferenceHash(input)\n    }\n  } else if (input instanceof File) {\n    // Files are always hashed by reference due to their potentially large size\n    return cachedReferenceHash(input)\n  } else {\n    let plainObjectInput = input\n    let marker = OBJECT_MARKER\n\n    if (input instanceof Array) {\n      marker = ARRAY_MARKER\n    }\n\n    if (input instanceof Map) {\n      marker = MAP_MARKER\n      plainObjectInput = [...input.entries()]\n    }\n\n    if (input instanceof Set) {\n      marker = SET_MARKER\n      plainObjectInput = [...input.entries()]\n    }\n\n    valueHash = hashPlainObject(plainObjectInput, marker)\n  }\n\n  hashCache.set(input, valueHash)\n  return valueHash\n}\n\nfunction hashDate(input: Date): number {\n  const hasher = new MurmurHashStream()\n  hasher.update(DATE_MARKER)\n  hasher.update(input.getTime())\n  return hasher.digest()\n}\n\nfunction hashUint8Array(input: Uint8Array): number {\n  const hasher = new MurmurHashStream()\n  hasher.update(UINT8ARRAY_MARKER)\n  // Hash the byte length first to differentiate arrays of different sizes\n  hasher.update(input.byteLength)\n  // Hash each byte in the array\n  for (let i = 0; i < input.byteLength; i++) {\n    hasher.writeByte(input[i]!)\n  }\n  return hasher.digest()\n}\n\nfunction hashPlainObject(input: object, marker: number): number {\n  const hasher = new MurmurHashStream()\n\n  // Mark the type of the input\n  hasher.update(marker)\n  const keys = Object.keys(input)\n  keys.sort(keySort)\n  for (const key of keys) {\n    hasher.update(KEY)\n    hasher.update(key)\n    updateHasher(hasher, input[key as keyof typeof input])\n  }\n\n  return hasher.digest()\n}\n\nfunction updateHasher(hasher: Hasher, input: unknown): void {\n  if (input === null) {\n    hasher.update(NULL)\n    return\n  }\n  switch (typeof input) {\n    case `undefined`:\n      hasher.update(UNDEFINED)\n      return\n    case `boolean`:\n      hasher.update(input ? TRUE : FALSE)\n      return\n    case `number`:\n      // Normalize NaNs and -0\n      hasher.update(isNaN(input) ? NaN : input === 0 ? 0 : input)\n      return\n    case `bigint`:\n    case `string`:\n    case `symbol`:\n      hasher.update(input)\n      return\n    case `object`:\n      hasher.update(getCachedHash(input))\n      return\n    case `function`:\n      // Functions are assigned a globally unique ID\n      // and that ID is cached in the weak map\n      hasher.update(cachedReferenceHash(input))\n      return\n    default:\n      console.warn(\n        `Ignored input during hashing because it is of type ${typeof input} which is not supported`\n      )\n  }\n}\n\nfunction getCachedHash(input: object): number {\n  let valueHash = hashCache.get(input)\n  if (valueHash === undefined) {\n    valueHash = hashObject(input)\n  }\n  return valueHash\n}\n\nlet nextRefId = 1\nfunction cachedReferenceHash(fn: object): number {\n  let valueHash = hashCache.get(fn)\n  if (valueHash === undefined) {\n    valueHash = nextRefId ^ FUNCTIONS\n    nextRefId++\n    hashCache.set(fn, valueHash)\n  }\n  return valueHash\n}\n\n/**\n * Strings sorted lexicographically.\n */\nfunction keySort(a: string, b: string): number {\n  return a.localeCompare(b)\n}\n", "import {\n  DefaultMap,\n  chunkedArrayPush,\n  globalObjectIdGenerator,\n} from \"./utils.js\"\nimport { hash } from \"./hashing/index.js\"\n\nexport type MultiSetArray<T> = Array<[T, number]>\nexport type KeyedData<T> = [key: string, value: T]\n\n/**\n * A multiset of data.\n */\nexport class MultiSet<T> {\n  #inner: MultiSetArray<T>\n\n  constructor(data: MultiSetArray<T> = []) {\n    this.#inner = data\n  }\n\n  toString(indent = false): string {\n    return `MultiSet(${JSON.stringify(this.#inner, null, indent ? 2 : undefined)})`\n  }\n\n  toJSON(): string {\n    return JSON.stringify(Array.from(this.getInner()))\n  }\n\n  static fromJSON<U>(json: string): MultiSet<U> {\n    return new MultiSet(JSON.parse(json))\n  }\n\n  /**\n   * Apply a function to all records in the collection.\n   */\n  map<U>(f: (data: T) => U): MultiSet<U> {\n    return new MultiSet(\n      this.#inner.map(([data, multiplicity]) => [f(data), multiplicity])\n    )\n  }\n\n  /**\n   * Filter out records for which a function f(record) evaluates to False.\n   */\n  filter(f: (data: T) => boolean): MultiSet<T> {\n    return new MultiSet(this.#inner.filter(([data, _]) => f(data)))\n  }\n\n  /**\n   * Negate all multiplicities in the collection.\n   */\n  negate(): MultiSet<T> {\n    return new MultiSet(\n      this.#inner.map(([data, multiplicity]) => [data, -multiplicity])\n    )\n  }\n\n  /**\n   * Concatenate two collections together.\n   */\n  concat(other: MultiSet<T>): MultiSet<T> {\n    const out: MultiSetArray<T> = []\n    chunkedArrayPush(out, this.#inner)\n    chunkedArrayPush(out, other.getInner())\n    return new MultiSet(out)\n  }\n\n  /**\n   * Produce as output a collection that is logically equivalent to the input\n   * but which combines identical instances of the same record into one\n   * (record, multiplicity) pair.\n   */\n  consolidate(): MultiSet<T> {\n    // Check if this looks like a keyed multiset (first item is a tuple of length 2)\n    if (this.#inner.length > 0) {\n      const firstItem = this.#inner[0]?.[0]\n      if (Array.isArray(firstItem) && firstItem.length === 2) {\n        return this.#consolidateKeyed()\n      }\n    }\n\n    // Fall back to original method for unkeyed data\n    return this.#consolidateUnkeyed()\n  }\n\n  /**\n   * Private method for consolidating keyed multisets where keys are strings/numbers\n   * and values are compared by reference equality.\n   *\n   * This method provides significant performance improvements over the hash-based approach\n   * by using WeakMap for object reference tracking and avoiding expensive serialization.\n   *\n   * Special handling for join operations: When values are tuples of length 2 (common in joins),\n   * we unpack them and compare each element individually to maintain proper equality semantics.\n   */\n  #consolidateKeyed(): MultiSet<T> {\n    const consolidated = new Map<string, number>()\n    const values = new Map<string, T>()\n\n    // Use global object ID generator for consistent reference equality\n\n    /**\n     * Special handler for tuples (arrays of length 2) commonly produced by join operations.\n     * Unpacks the tuple and generates an ID based on both elements to ensure proper\n     * consolidation of join results like ['A', null] and [null, 'X'].\n     */\n    const getTupleId = (tuple: Array<any>): string => {\n      if (tuple.length !== 2) {\n        throw new Error(`Expected tuple of length 2`)\n      }\n      const [first, second] = tuple\n      return `${globalObjectIdGenerator.getStringId(first)}|${globalObjectIdGenerator.getStringId(second)}`\n    }\n\n    // Process each item in the multiset\n    for (const [data, multiplicity] of this.#inner) {\n      // Verify this is still a keyed item (should be [key, value] pair)\n      if (!Array.isArray(data) || data.length !== 2) {\n        // Found non-keyed item, fall back to unkeyed consolidation\n        return this.#consolidateUnkeyed()\n      }\n\n      const [key, value] = data\n\n      // Verify key is string or number as expected for keyed multisets\n      if (typeof key !== `string` && typeof key !== `number`) {\n        // Found non-string/number key, fall back to unkeyed consolidation\n        return this.#consolidateUnkeyed()\n      }\n\n      // Generate value ID with special handling for join tuples\n      let valueId: string\n      if (Array.isArray(value) && value.length === 2) {\n        // Special case: value is a tuple from join operations\n        valueId = getTupleId(value)\n      } else {\n        // Regular case: use reference/value equality\n        valueId = globalObjectIdGenerator.getStringId(value)\n      }\n\n      // Create composite key and consolidate\n      const compositeKey = key + `|` + valueId\n      consolidated.set(\n        compositeKey,\n        (consolidated.get(compositeKey) || 0) + multiplicity\n      )\n\n      // Store the original data for the first occurrence\n      if (!values.has(compositeKey)) {\n        values.set(compositeKey, data as T)\n      }\n    }\n\n    // Build result array, filtering out zero multiplicities\n    const result: MultiSetArray<T> = []\n    for (const [compositeKey, multiplicity] of consolidated) {\n      if (multiplicity !== 0) {\n        result.push([values.get(compositeKey)!, multiplicity])\n      }\n    }\n\n    return new MultiSet(result)\n  }\n\n  /**\n   * Private method for consolidating unkeyed multisets using the original approach.\n   */\n  #consolidateUnkeyed(): MultiSet<T> {\n    const consolidated = new DefaultMap<string | number, number>(() => 0)\n    const values = new Map<string, any>()\n\n    let hasString = false\n    let hasNumber = false\n    let hasOther = false\n    for (const [data, _] of this.#inner) {\n      if (typeof data === `string`) {\n        hasString = true\n      } else if (typeof data === `number`) {\n        hasNumber = true\n      } else {\n        hasOther = true\n        break\n      }\n    }\n\n    const requireJson = hasOther || (hasString && hasNumber)\n\n    for (const [data, multiplicity] of this.#inner) {\n      const key = requireJson ? hash(data) : (data as string | number)\n      if (requireJson && !values.has(key as string)) {\n        values.set(key as string, data)\n      }\n      consolidated.update(key, (count) => count + multiplicity)\n    }\n\n    const result: MultiSetArray<T> = []\n    for (const [key, multiplicity] of consolidated.entries()) {\n      if (multiplicity !== 0) {\n        const parsedKey = requireJson ? values.get(key as string) : key\n        result.push([parsedKey as T, multiplicity])\n      }\n    }\n\n    return new MultiSet(result)\n  }\n\n  extend(other: MultiSet<T> | MultiSetArray<T>): void {\n    const otherArray = other instanceof MultiSet ? other.getInner() : other\n    chunkedArrayPush(this.#inner, otherArray)\n  }\n\n  add(item: T, multiplicity: number): void {\n    if (multiplicity !== 0) {\n      this.#inner.push([item, multiplicity])\n    }\n  }\n\n  getInner(): MultiSetArray<T> {\n    return this.#inner\n  }\n}\n", "import { MultiSet } from \"./multiset.js\"\nimport type { MultiSetArray } from \"./multiset.js\"\nimport type {\n  IDifferenceStreamReader,\n  IDifferenceStreamWriter,\n  IOperator,\n} from \"./types.js\"\n\n/**\n * A read handle to a dataflow edge that receives data from a writer.\n */\nexport class DifferenceStreamReader<T> implements IDifferenceStreamReader<T> {\n  #queue: Array<MultiSet<T>>\n\n  constructor(queue: Array<MultiSet<T>>) {\n    this.#queue = queue\n  }\n\n  drain(): Array<MultiSet<T>> {\n    const out = [...this.#queue].reverse()\n    this.#queue.length = 0\n    return out\n  }\n\n  isEmpty(): boolean {\n    return this.#queue.length === 0\n  }\n}\n\n/**\n * A write handle to a dataflow edge that is allowed to publish data.\n */\nexport class DifferenceStreamWriter<T> implements IDifferenceStreamWriter<T> {\n  #queues: Array<Array<MultiSet<T>>> = []\n\n  sendData(collection: MultiSet<T> | MultiSetArray<T>): void {\n    if (!(collection instanceof MultiSet)) {\n      collection = new MultiSet(collection)\n    }\n\n    for (const q of this.#queues) {\n      q.unshift(collection)\n    }\n  }\n\n  newReader(): DifferenceStreamReader<T> {\n    const q: Array<MultiSet<T>> = []\n    this.#queues.push(q)\n    return new DifferenceStreamReader(q)\n  }\n}\n\n/**\n * A generic implementation of a dataflow operator (node) that has multiple incoming edges (read handles) and\n * one outgoing edge (write handle).\n */\nexport abstract class Operator<T> implements IOperator<T> {\n  protected inputs: Array<DifferenceStreamReader<T>>\n  protected output: DifferenceStreamWriter<T>\n\n  constructor(\n    public id: number,\n    inputs: Array<DifferenceStreamReader<T>>,\n    output: DifferenceStreamWriter<T>\n  ) {\n    this.inputs = inputs\n    this.output = output\n  }\n\n  abstract run(): void\n\n  hasPendingWork(): boolean {\n    return this.inputs.some((input) => !input.isEmpty())\n  }\n}\n\n/**\n * A convenience implementation of a dataflow operator that has a handle to one\n * incoming stream of data, and one handle to an outgoing stream of data.\n */\nexport abstract class UnaryOperator<Tin, Tout = Tin> extends Operator<\n  Tin | Tout\n> {\n  constructor(\n    public id: number,\n    inputA: DifferenceStreamReader<Tin>,\n    output: DifferenceStreamWriter<Tout>\n  ) {\n    super(id, [inputA], output)\n  }\n\n  inputMessages(): Array<MultiSet<Tin>> {\n    return this.inputs[0]!.drain() as Array<MultiSet<Tin>>\n  }\n}\n\n/**\n * A convenience implementation of a dataflow operator that has a handle to two\n * incoming streams of data, and one handle to an outgoing stream of data.\n */\nexport abstract class BinaryOperator<T> extends Operator<T> {\n  constructor(\n    public id: number,\n    inputA: DifferenceStreamReader<T>,\n    inputB: DifferenceStreamReader<T>,\n    output: DifferenceStreamWriter<T>\n  ) {\n    super(id, [inputA, inputB], output)\n  }\n\n  inputAMessages(): Array<MultiSet<T>> {\n    return this.inputs[0]!.drain()\n  }\n\n  inputBMessages(): Array<MultiSet<T>> {\n    return this.inputs[1]!.drain()\n  }\n}\n\n/**\n * Base class for operators that process a single input stream\n */\nexport abstract class LinearUnaryOperator<T, U> extends UnaryOperator<T | U> {\n  abstract inner(collection: MultiSet<T | U>): MultiSet<U>\n\n  run(): void {\n    for (const message of this.inputMessages()) {\n      this.output.sendData(this.inner(message))\n    }\n  }\n}\n", "import { DifferenceStreamWriter } from \"./graph.js\"\nimport type {\n  BinaryOperator,\n  DifferenceStreamReader,\n  UnaryOperator,\n} from \"./graph.js\"\nimport type { MultiSet, MultiSetArray } from \"./multiset.js\"\nimport type { ID2, IStreamBuilder, PipedOperator } from \"./types.js\"\n\nexport class D2 implements ID2 {\n  #operators: Array<UnaryOperator<any> | BinaryOperator<any>> = []\n  #nextOperatorId = 0\n  #finalized = false\n\n  constructor() {}\n\n  #checkNotFinalized(): void {\n    if (this.#finalized) {\n      throw new Error(`Graph already finalized`)\n    }\n  }\n\n  getNextOperatorId(): number {\n    this.#checkNotFinalized()\n    return this.#nextOperatorId++\n  }\n\n  newInput<T>(): RootStreamBuilder<T> {\n    this.#checkNotFinalized()\n    const writer = new DifferenceStreamWriter<T>()\n    // Use the root stream builder that exposes the sendData and sendFrontier methods\n    const streamBuilder = new RootStreamBuilder<T>(this, writer)\n    return streamBuilder\n  }\n\n  addOperator(operator: UnaryOperator<any> | BinaryOperator<any>): void {\n    this.#checkNotFinalized()\n    this.#operators.push(operator)\n  }\n\n  finalize() {\n    this.#checkNotFinalized()\n    this.#finalized = true\n  }\n\n  step(): void {\n    if (!this.#finalized) {\n      throw new Error(`Graph not finalized`)\n    }\n    for (const op of this.#operators) {\n      op.run()\n    }\n  }\n\n  pendingWork(): boolean {\n    return this.#operators.some((op) => op.hasPendingWork())\n  }\n\n  run(): void {\n    while (this.pendingWork()) {\n      this.step()\n    }\n  }\n}\n\nexport class StreamBuilder<T> implements IStreamBuilder<T> {\n  #graph: ID2\n  #writer: DifferenceStreamWriter<T>\n\n  constructor(graph: ID2, writer: DifferenceStreamWriter<T>) {\n    this.#graph = graph\n    this.#writer = writer\n  }\n\n  connectReader(): DifferenceStreamReader<T> {\n    return this.#writer.newReader()\n  }\n\n  get writer(): DifferenceStreamWriter<T> {\n    return this.#writer\n  }\n\n  get graph(): ID2 {\n    return this.#graph\n  }\n\n  // Don't judge, this is the only way to type this function.\n  // rxjs has very similar code to type its pipe function\n  // https://github.com/ReactiveX/rxjs/blob/master/packages/rxjs/src/internal/util/pipe.ts\n  // We go to 20 operators deep, because surly that's enough for anyone...\n  // A user can always split the pipe into multiple pipes to get around this.\n  pipe<O>(o1: PipedOperator<T, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, T12>, o12: PipedOperator<T12, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, T12>, o12: PipedOperator<T12, T13>, o13: PipedOperator<T13, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, T12>, o12: PipedOperator<T12, T13>, o13: PipedOperator<T13, T14>, o14: PipedOperator<T14, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, T12>, o12: PipedOperator<T12, T13>, o13: PipedOperator<T13, T14>, o14: PipedOperator<T14, T15>, o15: PipedOperator<T15, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, T12>, o12: PipedOperator<T12, T13>, o13: PipedOperator<T13, T14>, o14: PipedOperator<T14, T15>, o15: PipedOperator<T15, T16>, o16: PipedOperator<T16, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, T12>, o12: PipedOperator<T12, T13>, o13: PipedOperator<T13, T14>, o14: PipedOperator<T14, T15>, o15: PipedOperator<T15, T16>, o16: PipedOperator<T16, T17>, o17: PipedOperator<T17, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, T12>, o12: PipedOperator<T12, T13>, o13: PipedOperator<T13, T14>, o14: PipedOperator<T14, T15>, o15: PipedOperator<T15, T16>, o16: PipedOperator<T16, T17>, o17: PipedOperator<T17, T18>, o18: PipedOperator<T18, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, T12>, o12: PipedOperator<T12, T13>, o13: PipedOperator<T13, T14>, o14: PipedOperator<T14, T15>, o15: PipedOperator<T15, T16>, o16: PipedOperator<T16, T17>, o17: PipedOperator<T17, T18>, o18: PipedOperator<T18, T19>, o19: PipedOperator<T19, O>): IStreamBuilder<O>\n  // prettier-ignore\n  pipe<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, O>(o1: PipedOperator<T, T2>, o2: PipedOperator<T2, T3>, o3: PipedOperator<T3, T4>, o4: PipedOperator<T4, T5>, o5: PipedOperator<T5, T6>, o6: PipedOperator<T6, T7>, o7: PipedOperator<T7, T8>, o8: PipedOperator<T8, T9>, o9: PipedOperator<T9, T10>, o10: PipedOperator<T10, T11>, o11: PipedOperator<T11, T12>, o12: PipedOperator<T12, T13>, o13: PipedOperator<T13, T14>, o14: PipedOperator<T14, T15>, o15: PipedOperator<T15, T16>, o16: PipedOperator<T16, T17>, o17: PipedOperator<T17, T18>, o18: PipedOperator<T18, T19>, o19: PipedOperator<T19, T20>, o20: PipedOperator<T20, O>): IStreamBuilder<O>\n\n  pipe(...operators: Array<PipedOperator<any, any>>): IStreamBuilder<any> {\n    return operators.reduce((stream, operator) => {\n      return operator(stream)\n    }, this as IStreamBuilder<any>)\n  }\n}\n\nexport class RootStreamBuilder<T> extends StreamBuilder<T> {\n  sendData(collection: MultiSet<T> | MultiSetArray<T>): void {\n    this.writer.sendData(collection)\n  }\n}\n", "import { DifferenceStreamWriter, LinearUnaryOperator } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport type { IStreamBuilder, PipedOperator } from \"../types.js\"\nimport type { DifferenceStreamReader } from \"../graph.js\"\nimport type { MultiSet } from \"../multiset.js\"\n\n/**\n * Operator that applies a function to each element in the input stream\n */\nexport class MapOperator<T, U> extends LinearUnaryOperator<T, U> {\n  #f: (data: T) => U\n\n  constructor(\n    id: number,\n    inputA: DifferenceStreamReader<T>,\n    output: DifferenceStreamWriter<U>,\n    f: (data: T) => U\n  ) {\n    super(id, inputA, output)\n    this.#f = f\n  }\n\n  inner(collection: MultiSet<T>): MultiSet<U> {\n    return collection.map(this.#f)\n  }\n}\n\n/**\n * Applies a function to each element in the input stream\n * @param f - The function to apply to each element\n */\nexport function map<T, O>(f: (data: T) => O): PipedOperator<T, O> {\n  return (stream: IStreamBuilder<T>): IStreamBuilder<O> => {\n    const output = new StreamBuilder<O>(\n      stream.graph,\n      new DifferenceStreamWriter<O>()\n    )\n    const operator = new MapOperator<T, O>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader(),\n      output.writer,\n      f\n    )\n    stream.graph.addOperator(operator)\n    return output\n  }\n}\n", "/**\n * # Optimized Index Data Structure\n *\n * Multi-level index that adapts storage strategy based on data patterns to minimize memory\n * usage, eliminate wasteful lookups, and avoid hashing whenever possible.\n *\n * ## Storage Strategy\n *\n * **Single value**: `IndexMap['key'] â†’ [value, multiplicity]` (no hashing needed)\n *\n * **Multiple unprefixed values**: Direct ValueMap (avoids NO_PREFIX lookup)\n * ```\n * IndexMap['key'] â†’ ValueMap { hash(value1) â†’ [value1, mult1], ... }\n * ```\n *\n * **Values with prefixes**: PrefixMap uses prefix keys directly (no hashing)\n * ```\n * IndexMap['key'] â†’ PrefixMap { 'prefix1' â†’ [value1, mult1], NO_PREFIX â†’ ValueMap{...} }\n * ```\n *\n * **Multiple values per prefix**: ValueMap within PrefixMap (hash only suffixes)\n * ```\n * PrefixMap['prefix'] â†’ ValueMap { hash(suffix1) â†’ [full_value1, mult1], ... }\n * ```\n *\n * ## Dynamic Evolution\n *\n * Structure automatically evolves as data is added:\n * - Single â†’ ValueMap (when both values unprefixed)\n * - Single â†’ PrefixMap (when at least one prefixed)\n * - ValueMap â†’ PrefixMap (adding prefixed value to unprefixed)\n *\n * Prefixes extracted from array values: `['prefix', 'suffix']` â†’ prefix='prefix'\n */\n\nimport { MultiSet } from \"./multiset.js\"\nimport { hash } from \"./hashing/index.js\"\nimport type { Hash } from \"./hashing/index.js\"\n\n// We use a symbol to represent the absence of a prefix, unprefixed values a stored\n// against this key.\nconst NO_PREFIX = Symbol(`NO_PREFIX`)\ntype NO_PREFIX = typeof NO_PREFIX\n\n// A single value is a tuple of the value and the multiplicity.\ntype SingleValue<TValue> = [TValue, number]\n\n// Base map type for the index. Stores single values, prefix maps, or value maps against a key.\ntype IndexMap<TKey, TValue, TPrefix> = Map<\n  TKey,\n  SingleValue<TValue> | PrefixMap<TValue, TPrefix> | ValueMap<TValue>\n>\n\n// Second level map type for the index, stores single values or value maps against a prefix.\nclass PrefixMap<TValue, TPrefix> extends Map<\n  TPrefix | NO_PREFIX,\n  SingleValue<TValue> | ValueMap<TValue>\n> {\n  /**\n   * Add a value to the PrefixMap. Returns true if the map becomes empty after the operation.\n   */\n  addValue(value: TValue, multiplicity: number): boolean {\n    if (multiplicity === 0) return this.size === 0\n\n    const prefix = getPrefix<TValue, TPrefix>(value)\n    const valueMapOrSingleValue = this.get(prefix)\n\n    if (isSingleValue(valueMapOrSingleValue)) {\n      const [currentValue, currentMultiplicity] = valueMapOrSingleValue\n      const currentPrefix = getPrefix<TValue, TPrefix>(currentValue)\n\n      if (currentPrefix !== prefix) {\n        throw new Error(`Mismatching prefixes, this should never happen`)\n      }\n\n      if (currentValue === value || hash(currentValue) === hash(value)) {\n        // Same value, update multiplicity\n        const newMultiplicity = currentMultiplicity + multiplicity\n        if (newMultiplicity === 0) {\n          this.delete(prefix)\n        } else {\n          this.set(prefix, [value, newMultiplicity])\n        }\n      } else {\n        // Different suffixes, need to create ValueMap\n        const valueMap = new ValueMap<TValue>()\n        valueMap.set(hash(currentValue), valueMapOrSingleValue)\n        valueMap.set(hash(value), [value, multiplicity])\n        this.set(prefix, valueMap)\n      }\n    } else if (valueMapOrSingleValue === undefined) {\n      // No existing value for this prefix\n      this.set(prefix, [value, multiplicity])\n    } else {\n      // Existing ValueMap\n      const isEmpty = valueMapOrSingleValue.addValue(value, multiplicity)\n      if (isEmpty) {\n        this.delete(prefix)\n      }\n    }\n\n    return this.size === 0\n  }\n}\n\n// Third level map type for the index, stores single values or value maps against a hash.\nclass ValueMap<TValue> extends Map<Hash, [TValue, number]> {\n  /**\n   * Add a value to the ValueMap. Returns true if the map becomes empty after the operation.\n   * @param value - The full value to store\n   * @param multiplicity - The multiplicity to add\n   * @param hashKey - Optional hash key to use instead of hashing the full value (used when in PrefixMap context)\n   */\n  addValue(value: TValue, multiplicity: number): boolean {\n    if (multiplicity === 0) return this.size === 0\n\n    const key = hash(value)\n    const currentValue = this.get(key)\n\n    if (currentValue) {\n      const [, currentMultiplicity] = currentValue\n      const newMultiplicity = currentMultiplicity + multiplicity\n      if (newMultiplicity === 0) {\n        this.delete(key)\n      } else {\n        this.set(key, [value, newMultiplicity])\n      }\n    } else {\n      this.set(key, [value, multiplicity])\n    }\n\n    return this.size === 0\n  }\n}\n\n/**\n * A map from a difference collection trace's keys -> (value, multiplicities) that changed.\n * Used in operations like join and reduce where the operation needs to\n * exploit the key-value structure of the data to run efficiently.\n */\nexport class Index<TKey, TValue, TPrefix = any> {\n  /*\n   * This index maintains a nested map of keys -> (value, multiplicities), where:\n   * - initially the values are stored against the key as a single value tuple\n   * - when a key gets additional values, the values are stored against the key in a\n   *   prefix map\n   * - the prefix is extract where possible from values that are structured as\n   *   [rowPrimaryKey, rowValue], as they are in the Tanstack DB query pipeline.\n   * - only when there are multiple values for a given prefix do we fall back to a\n   *   hash to identify identical values, storing them in a third level value map.\n   */\n  #inner: IndexMap<TKey, TValue, TPrefix>\n  #consolidatedMultiplicity: Map<TKey, number> = new Map() // sum of multiplicities per key\n\n  constructor() {\n    this.#inner = new Map()\n  }\n\n  /**\n   * Create an Index from multiple MultiSet messages.\n   * @param messages - Array of MultiSet messages to build the index from.\n   * @returns A new Index containing all the data from the messages.\n   */\n  static fromMultiSets<K, V>(messages: Array<MultiSet<[K, V]>>): Index<K, V> {\n    const index = new Index<K, V>()\n\n    for (const message of messages) {\n      for (const [item, multiplicity] of message.getInner()) {\n        const [key, value] = item\n        index.addValue(key, [value, multiplicity])\n      }\n    }\n\n    return index\n  }\n\n  /**\n   * This method returns a string representation of the index.\n   * @param indent - Whether to indent the string representation.\n   * @returns A string representation of the index.\n   */\n  toString(indent = false): string {\n    return `Index(${JSON.stringify(\n      [...this.entries()],\n      undefined,\n      indent ? 2 : undefined\n    )})`\n  }\n\n  /**\n   * The size of the index.\n   */\n  get size(): number {\n    return this.#inner.size\n  }\n\n  /**\n   * This method checks if the index has a given key.\n   * @param key - The key to check.\n   * @returns True if the index has the key, false otherwise.\n   */\n  has(key: TKey): boolean {\n    return this.#inner.has(key)\n  }\n\n  /**\n   * Check if a key has presence (non-zero consolidated multiplicity).\n   * @param key - The key to check.\n   * @returns True if the key has non-zero consolidated multiplicity, false otherwise.\n   */\n  hasPresence(key: TKey): boolean {\n    return (this.#consolidatedMultiplicity.get(key) || 0) !== 0\n  }\n\n  /**\n   * Get the consolidated multiplicity (sum of multiplicities) for a key.\n   * @param key - The key to get the consolidated multiplicity for.\n   * @returns The consolidated multiplicity for the key.\n   */\n  getConsolidatedMultiplicity(key: TKey): number {\n    return this.#consolidatedMultiplicity.get(key) || 0\n  }\n\n  /**\n   * Get all keys that have presence (non-zero consolidated multiplicity).\n   * @returns An iterator of keys with non-zero consolidated multiplicity.\n   */\n  getPresenceKeys(): Iterable<TKey> {\n    return this.#consolidatedMultiplicity.keys()\n  }\n\n  /**\n   * This method returns all values for a given key.\n   * @param key - The key to get the values for.\n   * @returns An array of value tuples [value, multiplicity].\n   */\n  get(key: TKey): Array<[TValue, number]> {\n    return [...this.getIterator(key)]\n  }\n\n  /**\n   * This method returns an iterator over all values for a given key.\n   * @param key - The key to get the values for.\n   * @returns An iterator of value tuples [value, multiplicity].\n   */\n  *getIterator(key: TKey): Iterable<[TValue, number]> {\n    const mapOrSingleValue = this.#inner.get(key)\n    if (isSingleValue(mapOrSingleValue)) {\n      yield mapOrSingleValue\n    } else if (mapOrSingleValue === undefined) {\n      return\n    } else if (mapOrSingleValue instanceof ValueMap) {\n      // Direct ValueMap - all values have NO_PREFIX\n      for (const valueTuple of mapOrSingleValue.values()) {\n        yield valueTuple\n      }\n    } else {\n      // PrefixMap - iterate through all prefixes\n      for (const singleValueOrValueMap of mapOrSingleValue.values()) {\n        if (isSingleValue(singleValueOrValueMap)) {\n          yield singleValueOrValueMap\n        } else {\n          for (const valueTuple of singleValueOrValueMap.values()) {\n            yield valueTuple\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This returns an iterator that iterates over all key-value pairs.\n   * @returns An iterable of all key-value pairs (and their multiplicities) in the index.\n   */\n  *entries(): Iterable<[TKey, [TValue, number]]> {\n    for (const key of this.#inner.keys()) {\n      for (const valueTuple of this.getIterator(key)) {\n        yield [key, valueTuple]\n      }\n    }\n  }\n\n  /**\n   * This method only iterates over the keys and not over the values.\n   * Hence, it is more efficient than the `#entries` method.\n   * It returns an iterator that you can use if you need to iterate over the values for a given key.\n   * @returns An iterator of all *keys* in the index and their corresponding value iterator.\n   */\n  *entriesIterators(): Iterable<[TKey, Iterable<[TValue, number]>]> {\n    for (const key of this.#inner.keys()) {\n      yield [key, this.getIterator(key)]\n    }\n  }\n\n  /**\n   * This method adds a value to the index.\n   * @param key - The key to add the value to.\n   * @param valueTuple - The value tuple [value, multiplicity] to add to the index.\n   */\n  addValue(key: TKey, valueTuple: SingleValue<TValue>) {\n    const [value, multiplicity] = valueTuple\n    // If the multiplicity is 0, do nothing\n    if (multiplicity === 0) return\n\n    // Update consolidated multiplicity tracking\n    const newConsolidatedMultiplicity =\n      (this.#consolidatedMultiplicity.get(key) || 0) + multiplicity\n    if (newConsolidatedMultiplicity === 0) {\n      this.#consolidatedMultiplicity.delete(key)\n    } else {\n      this.#consolidatedMultiplicity.set(key, newConsolidatedMultiplicity)\n    }\n\n    const mapOrSingleValue = this.#inner.get(key)\n\n    if (mapOrSingleValue === undefined) {\n      // First value for this key\n      this.#inner.set(key, valueTuple)\n      return\n    }\n\n    if (isSingleValue(mapOrSingleValue)) {\n      // Handle transition from single value to map\n      this.#handleSingleValueTransition(\n        key,\n        mapOrSingleValue,\n        value,\n        multiplicity\n      )\n      return\n    }\n\n    if (mapOrSingleValue instanceof ValueMap) {\n      // Handle existing ValueMap\n      const prefix = getPrefix<TValue, TPrefix>(value)\n      if (prefix !== NO_PREFIX) {\n        // Convert ValueMap to PrefixMap since we have a prefixed value\n        const prefixMap = new PrefixMap<TValue, TPrefix>()\n        prefixMap.set(NO_PREFIX, mapOrSingleValue)\n        prefixMap.set(prefix, valueTuple)\n        this.#inner.set(key, prefixMap)\n      } else {\n        // Add to existing ValueMap\n        const isEmpty = mapOrSingleValue.addValue(value, multiplicity)\n        if (isEmpty) {\n          this.#inner.delete(key)\n        }\n      }\n    } else {\n      // Handle existing PrefixMap\n      const isEmpty = mapOrSingleValue.addValue(value, multiplicity)\n      if (isEmpty) {\n        this.#inner.delete(key)\n      }\n    }\n  }\n\n  /**\n   * Handle the transition from a single value to either a ValueMap or PrefixMap\n   */\n  #handleSingleValueTransition(\n    key: TKey,\n    currentSingleValue: SingleValue<TValue>,\n    newValue: TValue,\n    multiplicity: number\n  ) {\n    const [currentValue, currentMultiplicity] = currentSingleValue\n\n    // Check for exact same value (reference equality)\n    if (currentValue === newValue) {\n      const newMultiplicity = currentMultiplicity + multiplicity\n      if (newMultiplicity === 0) {\n        this.#inner.delete(key)\n      } else {\n        this.#inner.set(key, [newValue, newMultiplicity])\n      }\n      return\n    }\n\n    // Get prefixes for both values\n    const newPrefix = getPrefix<TValue, TPrefix>(newValue)\n    const currentPrefix = getPrefix<TValue, TPrefix>(currentValue)\n\n    // Check if they're the same value by prefix/suffix comparison\n    if (\n      currentPrefix === newPrefix &&\n      (currentValue === newValue || hash(currentValue) === hash(newValue))\n    ) {\n      const newMultiplicity = currentMultiplicity + multiplicity\n      if (newMultiplicity === 0) {\n        this.#inner.delete(key)\n      } else {\n        this.#inner.set(key, [newValue, newMultiplicity])\n      }\n      return\n    }\n\n    // Different values - choose appropriate map type\n    if (currentPrefix === NO_PREFIX && newPrefix === NO_PREFIX) {\n      // Both have NO_PREFIX, use ValueMap directly\n      const valueMap = new ValueMap<TValue>()\n      valueMap.set(hash(currentValue), currentSingleValue)\n      valueMap.set(hash(newValue), [newValue, multiplicity])\n      this.#inner.set(key, valueMap)\n    } else {\n      // At least one has a prefix, use PrefixMap\n      const prefixMap = new PrefixMap<TValue, TPrefix>()\n\n      if (currentPrefix === newPrefix) {\n        // Same prefix, different suffixes - need ValueMap within PrefixMap\n        const valueMap = new ValueMap<TValue>()\n        valueMap.set(hash(currentValue), currentSingleValue)\n        valueMap.set(hash(newValue), [newValue, multiplicity])\n        prefixMap.set(currentPrefix, valueMap)\n      } else {\n        // Different prefixes - store as separate single values\n        prefixMap.set(currentPrefix, currentSingleValue)\n        prefixMap.set(newPrefix, [newValue, multiplicity])\n      }\n\n      this.#inner.set(key, prefixMap)\n    }\n  }\n\n  /**\n   * This method appends another index to the current index.\n   * @param other - The index to append to the current index.\n   */\n  append(other: Index<TKey, TValue>): void {\n    for (const [key, value] of other.entries()) {\n      this.addValue(key, value)\n    }\n  }\n\n  /**\n   * This method joins two indexes.\n   * @param other - The index to join with the current index.\n   * @returns A multiset of the joined values.\n   */\n  join<TValue2>(\n    other: Index<TKey, TValue2>\n  ): MultiSet<[TKey, [TValue, TValue2]]> {\n    const result: Array<[[TKey, [TValue, TValue2]], number]> = []\n    // We want to iterate over the smaller of the two indexes to reduce the\n    // number of operations we need to do.\n    if (this.size <= other.size) {\n      for (const [key, valueIt] of this.entriesIterators()) {\n        if (!other.has(key)) continue\n        const otherValues = other.get(key)\n        for (const [val1, mul1] of valueIt) {\n          for (const [val2, mul2] of otherValues) {\n            if (mul1 !== 0 && mul2 !== 0) {\n              result.push([[key, [val1, val2]], mul1 * mul2])\n            }\n          }\n        }\n      }\n    } else {\n      for (const [key, otherValueIt] of other.entriesIterators()) {\n        if (!this.has(key)) continue\n        const values = this.get(key)\n        for (const [val2, mul2] of otherValueIt) {\n          for (const [val1, mul1] of values) {\n            if (mul1 !== 0 && mul2 !== 0) {\n              result.push([[key, [val1, val2]], mul1 * mul2])\n            }\n          }\n        }\n      }\n    }\n\n    return new MultiSet(result)\n  }\n}\n\n/**\n * This function extracts the prefix from a value.\n * @param value - The value to extract the prefix from.\n * @returns The prefix and the suffix.\n */\nfunction getPrefix<TValue, TPrefix>(value: TValue): TPrefix | NO_PREFIX {\n  // If the value is an array and the first element is a string or number, then the\n  // first element is the prefix. This is used to distinguish between values without\n  // the need for hashing unless there are multiple values for the same prefix.\n  if (\n    Array.isArray(value) &&\n    (typeof value[0] === `string` ||\n      typeof value[0] === `number` ||\n      typeof value[0] === `bigint`)\n  ) {\n    return value[0] as TPrefix\n  }\n  return NO_PREFIX\n}\n\n/**\n * This function checks if a value is a single value.\n * @param value - The value to check.\n * @returns True if the value is a single value, false otherwise.\n */\nfunction isSingleValue<TValue>(\n  value: SingleValue<TValue> | unknown\n): value is SingleValue<TValue> {\n  return Array.isArray(value)\n}\n", "import { DifferenceStreamWriter, UnaryOperator } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport { MultiSet } from \"../multiset.js\"\nimport { Index } from \"../indexes.js\"\nimport type { DifferenceStreamReader } from \"../graph.js\"\nimport type { IStreamBuilder, KeyValue } from \"../types.js\"\n\n/**\n * Base operator for reduction operations (version-free)\n */\nexport class ReduceOperator<K, V1, V2> extends UnaryOperator<[K, V1], [K, V2]> {\n  #index = new Index<K, V1>()\n  #indexOut = new Index<K, V2>()\n  #f: (values: Array<[V1, number]>) => Array<[V2, number]>\n\n  constructor(\n    id: number,\n    inputA: DifferenceStreamReader<[K, V1]>,\n    output: DifferenceStreamWriter<[K, V2]>,\n    f: (values: Array<[V1, number]>) => Array<[V2, number]>\n  ) {\n    super(id, inputA, output)\n    this.#f = f\n  }\n\n  run(): void {\n    // Collect all input messages and update the index\n    const keysTodo = new Set<K>()\n    for (const message of this.inputMessages()) {\n      for (const [item, multiplicity] of message.getInner()) {\n        const [key, value] = item\n        this.#index.addValue(key, [value, multiplicity])\n        keysTodo.add(key)\n      }\n    }\n\n    // For each key, compute the reduction and delta\n    const result: Array<[[K, V2], number]> = []\n    for (const key of keysTodo) {\n      const curr = this.#index.get(key)\n      const currOut = this.#indexOut.get(key)\n      const out = this.#f(curr)\n\n      // Create maps for current and previous outputs using values directly as keys\n      const newOutputMap = new Map<V2, number>()\n      const oldOutputMap = new Map<V2, number>()\n\n      // Process new output\n      for (const [value, multiplicity] of out) {\n        const existing = newOutputMap.get(value) ?? 0\n        newOutputMap.set(value, existing + multiplicity)\n      }\n\n      // Process previous output\n      for (const [value, multiplicity] of currOut) {\n        const existing = oldOutputMap.get(value) ?? 0\n        oldOutputMap.set(value, existing + multiplicity)\n      }\n\n      // First, emit removals for old values that are no longer present\n      for (const [value, multiplicity] of oldOutputMap) {\n        if (!newOutputMap.has(value)) {\n          // Remove the old value entirely\n          result.push([[key, value], -multiplicity])\n          this.#indexOut.addValue(key, [value, -multiplicity])\n        }\n      }\n\n      // Then, emit additions for new values that are not present in old\n      for (const [value, multiplicity] of newOutputMap) {\n        if (!oldOutputMap.has(value)) {\n          // Add the new value only if it has non-zero multiplicity\n          if (multiplicity !== 0) {\n            result.push([[key, value], multiplicity])\n            this.#indexOut.addValue(key, [value, multiplicity])\n          }\n        }\n      }\n\n      // Finally, emit multiplicity changes for values that were present and are still present\n      for (const [value, newMultiplicity] of newOutputMap) {\n        const oldMultiplicity = oldOutputMap.get(value)\n        if (oldMultiplicity !== undefined) {\n          const delta = newMultiplicity - oldMultiplicity\n          // Only emit actual changes, i.e. non-zero deltas\n          if (delta !== 0) {\n            result.push([[key, value], delta])\n            this.#indexOut.addValue(key, [value, delta])\n          }\n        }\n      }\n    }\n\n    if (result.length > 0) {\n      this.output.sendData(new MultiSet(result))\n    }\n  }\n}\n\n/**\n * Reduces the elements in the stream by key (version-free)\n */\nexport function reduce<\n  KType extends T extends KeyValue<infer K, infer _V> ? K : never,\n  V1Type extends T extends KeyValue<KType, infer V> ? V : never,\n  R,\n  T,\n>(f: (values: Array<[V1Type, number]>) => Array<[R, number]>) {\n  return (stream: IStreamBuilder<T>): IStreamBuilder<KeyValue<KType, R>> => {\n    const output = new StreamBuilder<KeyValue<KType, R>>(\n      stream.graph,\n      new DifferenceStreamWriter<KeyValue<KType, R>>()\n    )\n    const operator = new ReduceOperator<KType, V1Type, R>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader() as DifferenceStreamReader<KeyValue<KType, V1Type>>,\n      output.writer,\n      f\n    )\n    stream.graph.addOperator(operator)\n    return output\n  }\n}\n", "import { map } from \"./map.js\"\nimport { reduce } from \"./reduce.js\"\nimport type { IStreamBuilder, KeyValue } from \"../types.js\"\n\ntype GroupKey = Record<string, unknown>\n\ntype BasicAggregateFunction<T, R, V = unknown> = {\n  preMap: (data: T) => V\n  reduce: (values: Array<[V, number]>) => V\n  postMap?: (result: V) => R\n}\n\ntype PipedAggregateFunction<T, R> = {\n  pipe: (stream: IStreamBuilder<T>) => IStreamBuilder<KeyValue<string, R>>\n}\n\ntype AggregateFunction<T, R, V = unknown> =\n  | BasicAggregateFunction<T, R, V>\n  | PipedAggregateFunction<T, R>\n\ntype ExtractAggregateReturnType<T, A> =\n  A extends AggregateFunction<T, infer R, any> ? R : never\n\ntype AggregatesReturnType<T, A> = {\n  [K in keyof A]: ExtractAggregateReturnType<T, A[K]>\n}\n\nfunction isPipedAggregateFunction<T, R>(\n  aggregate: AggregateFunction<T, R>\n): aggregate is PipedAggregateFunction<T, R> {\n  return `pipe` in aggregate\n}\n\n/**\n * Groups data by key and applies multiple aggregate operations\n * @param keyExtractor Function to extract grouping key from data\n * @param aggregates Object mapping aggregate names to aggregate functions\n */\nexport function groupBy<\n  T,\n  K extends GroupKey,\n  A extends Record<string, AggregateFunction<T, any, any>>,\n>(keyExtractor: (data: T) => K, aggregates: A = {} as A) {\n  type ResultType = K & AggregatesReturnType<T, A>\n\n  const basicAggregates = Object.fromEntries(\n    Object.entries(aggregates).filter(\n      ([_, aggregate]) => !isPipedAggregateFunction(aggregate)\n    )\n  ) as Record<string, BasicAggregateFunction<T, any, any>>\n\n  // @ts-expect-error - TODO: we don't use this yet, but we will\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const pipedAggregates = Object.fromEntries(\n    Object.entries(aggregates).filter(([_, aggregate]) =>\n      isPipedAggregateFunction(aggregate)\n    )\n  ) as Record<string, PipedAggregateFunction<T, any>>\n\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<KeyValue<string, ResultType>> => {\n    // Special key to store the original key object\n    const KEY_SENTINEL = `__original_key__`\n\n    // First map to extract keys and pre-aggregate values\n    const withKeysAndValues = stream.pipe(\n      map((data) => {\n        const key = keyExtractor(data)\n        const keyString = JSON.stringify(key)\n\n        // Create values object with pre-aggregated values\n        const values: Record<string, unknown> = {}\n\n        // Store the original key object\n        values[KEY_SENTINEL] = key\n\n        // Add pre-aggregated values\n        for (const [name, aggregate] of Object.entries(basicAggregates)) {\n          values[name] = aggregate.preMap(data)\n        }\n\n        return [keyString, values] as KeyValue<string, Record<string, unknown>>\n      })\n    )\n\n    // Then reduce to compute aggregates\n    const reduced = withKeysAndValues.pipe(\n      reduce((values) => {\n        // Calculate total multiplicity to check if the group should exist\n        let totalMultiplicity = 0\n        for (const [_, multiplicity] of values) {\n          totalMultiplicity += multiplicity\n        }\n\n        // If total multiplicity is 0 or negative, the group should be removed completely\n        if (totalMultiplicity <= 0) {\n          return []\n        }\n\n        const result: Record<string, unknown> = {}\n\n        // Get the original key from first value in group\n        const originalKey = values[0]?.[0]?.[KEY_SENTINEL]\n        result[KEY_SENTINEL] = originalKey\n\n        // Apply each aggregate function\n        for (const [name, aggregate] of Object.entries(basicAggregates)) {\n          const preValues = values.map(\n            ([v, m]) => [v[name], m] as [any, number]\n          )\n          result[name] = aggregate.reduce(preValues)\n        }\n\n        return [[result, 1]]\n      })\n    )\n\n    // Finally map to extract the key and include all values\n    return reduced.pipe(\n      map(([keyString, values]) => {\n        // Extract the original key\n        const key = values[KEY_SENTINEL] as K\n\n        // Create intermediate result with key values and aggregate results\n        const result: Record<string, unknown> = {}\n\n        // Add key properties to result\n        Object.assign(result, key)\n\n        // Apply postMap if provided\n        for (const [name, aggregate] of Object.entries(basicAggregates)) {\n          if (aggregate.postMap) {\n            result[name] = aggregate.postMap(values[name])\n          } else {\n            result[name] = values[name]\n          }\n        }\n\n        // Return with the string key instead of the object\n        return [keyString, result] as KeyValue<string, ResultType>\n      })\n    )\n  }\n}\n\n/**\n * Creates a sum aggregate function\n */\nexport function sum<T>(\n  valueExtractor: (value: T) => number = (v) => v as unknown as number\n): AggregateFunction<T, number, number> {\n  return {\n    preMap: (data: T) => valueExtractor(data),\n    reduce: (values: Array<[number, number]>) => {\n      let total = 0\n      for (const [value, multiplicity] of values) {\n        total += value * multiplicity\n      }\n      return total\n    },\n  }\n}\n\n/**\n * Creates a count aggregate function\n */\nexport function count<T>(\n  valueExtractor: (value: T) => any = (v) => v\n): AggregateFunction<T, number, number> {\n  return {\n    // Count only not-null values (the `== null` comparison gives true for both null and undefined)\n    preMap: (data: T) => (valueExtractor(data) == null ? 0 : 1),\n    reduce: (values: Array<[number, number]>) => {\n      let totalCount = 0\n      for (const [nullMultiplier, multiplicity] of values) {\n        totalCount += nullMultiplier * multiplicity\n      }\n      return totalCount\n    },\n  }\n}\n\n/**\n * Creates an average aggregate function\n */\nexport function avg<T>(\n  valueExtractor: (value: T) => number = (v) => v as unknown as number\n): AggregateFunction<T, number, { sum: number; count: number }> {\n  return {\n    preMap: (data: T) => ({\n      sum: valueExtractor(data),\n      count: 0,\n    }),\n    reduce: (values: Array<[{ sum: number; count: number }, number]>) => {\n      let totalSum = 0\n      let totalCount = 0\n      for (const [value, multiplicity] of values) {\n        totalSum += value.sum * multiplicity\n        totalCount += multiplicity\n      }\n      return {\n        sum: totalSum,\n        count: totalCount,\n      }\n    },\n    postMap: (result: { sum: number; count: number }) => {\n      return result.sum / result.count\n    },\n  }\n}\n\ntype CanMinMax = number | Date | bigint\n\n/**\n * Creates a min aggregate function that computes the minimum value in a group\n * @param valueExtractor Function to extract a comparable value from each data entry\n */\nexport function min<T extends CanMinMax>(): AggregateFunction<\n  T,\n  T | undefined,\n  T | undefined\n>\nexport function min<T, V extends CanMinMax>(\n  valueExtractor: (value: T) => V\n): AggregateFunction<T, V | undefined, V | undefined>\nexport function min<T, V extends CanMinMax>(\n  valueExtractor?: (value: T) => V\n): AggregateFunction<T, V | undefined, V | undefined> {\n  const extractor = valueExtractor ?? ((v: T) => v as unknown as V)\n  return {\n    preMap: (data: T) => extractor(data),\n    reduce: (values) => {\n      let minValue: V | undefined\n      for (const [value, _multiplicity] of values) {\n        if (!minValue || (value && value < minValue)) {\n          minValue = value\n        }\n      }\n      return minValue\n    },\n  }\n}\n\n/**\n * Creates a max aggregate function that computes the maximum value in a group\n * @param valueExtractor Function to extract a comparable value from each data entry\n */\nexport function max<T extends CanMinMax>(): AggregateFunction<\n  T,\n  T | undefined,\n  T | undefined\n>\nexport function max<T, V extends CanMinMax>(\n  valueExtractor: (value: T) => V\n): AggregateFunction<T, V | undefined, V | undefined>\nexport function max<T, V extends CanMinMax>(\n  valueExtractor?: (value: T) => V\n): AggregateFunction<T, V | undefined, V | undefined> {\n  const extractor = valueExtractor ?? ((v: T) => v as unknown as V)\n  return {\n    preMap: (data: T) => extractor(data),\n    reduce: (values) => {\n      let maxValue: V | undefined\n      for (const [value, _multiplicity] of values) {\n        if (!maxValue || (value && value > maxValue)) {\n          maxValue = value\n        }\n      }\n      return maxValue\n    },\n  }\n}\n\n/**\n * Creates a median aggregate function that computes the middle value in a sorted group\n * If there's an even number of values, returns the average of the two middle values\n * @param valueExtractor Function to extract a numeric value from each data entry\n */\nexport function median<T>(\n  valueExtractor: (value: T) => number = (v) => v as unknown as number\n): AggregateFunction<T, number, Array<number>> {\n  return {\n    preMap: (data: T) => [valueExtractor(data)],\n    reduce: (values: Array<[Array<number>, number]>) => {\n      // Flatten all values, taking multiplicity into account\n      const allValues: Array<number> = []\n      for (const [valueArray, multiplicity] of values) {\n        for (const value of valueArray) {\n          // Add each value multiple times based on multiplicity\n          for (let i = 0; i < multiplicity; i++) {\n            allValues.push(value)\n          }\n        }\n      }\n\n      // Return empty array if no values\n      if (allValues.length === 0) {\n        return []\n      }\n\n      // Sort values\n      allValues.sort((a, b) => a - b)\n\n      return allValues\n    },\n    postMap: (result: Array<number>) => {\n      if (result.length === 0) return 0\n\n      const mid = Math.floor(result.length / 2)\n\n      // If even number of values, average the two middle values\n      if (result.length % 2 === 0) {\n        return (result[mid - 1]! + result[mid]!) / 2\n      }\n\n      // If odd number of values, return the middle value\n      return result[mid]!\n    },\n  }\n}\n\n/**\n * Creates a mode aggregate function that computes the most frequent value in a group\n * If multiple values have the same highest frequency, returns the first one encountered\n * @param valueExtractor Function to extract a value from each data entry\n */\nexport function mode<T>(\n  valueExtractor: (value: T) => number = (v) => v as unknown as number\n): AggregateFunction<T, number, Map<number, number>> {\n  return {\n    preMap: (data: T) => {\n      const value = valueExtractor(data)\n      const frequencyMap = new Map<number, number>()\n      frequencyMap.set(value, 1)\n      return frequencyMap\n    },\n    reduce: (values: Array<[Map<number, number>, number]>) => {\n      // Combine all frequency maps\n      const combinedMap = new Map<number, number>()\n\n      for (const [frequencyMap, multiplicity] of values) {\n        for (const [value, frequencyCount] of frequencyMap.entries()) {\n          const currentCount = combinedMap.get(value) || 0\n          combinedMap.set(value, currentCount + frequencyCount * multiplicity)\n        }\n      }\n\n      return combinedMap\n    },\n    postMap: (result: Map<number, number>) => {\n      if (result.size === 0) return 0\n\n      let modeValue = 0\n      let maxFrequency = 0\n\n      for (const [value, frequency] of result.entries()) {\n        if (frequency > maxFrequency) {\n          maxFrequency = frequency\n          modeValue = value\n        }\n      }\n\n      return modeValue\n    },\n  }\n}\n\nexport const groupByOperators = {\n  sum,\n  count,\n  avg,\n  min,\n  max,\n  median,\n  mode,\n}\n", "import { DifferenceStreamWriter, LinearUnaryOperator } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport type { IStreamBuilder, PipedOperator } from \"../types.js\"\nimport type { DifferenceStreamReader } from \"../graph.js\"\nimport type { MultiSet } from \"../multiset.js\"\n\n/**\n * Operator that applies a function to each multi-set in the input stream\n */\nexport class TapOperator<T> extends LinearUnaryOperator<T, T> {\n  #f: (data: MultiSet<T>) => void\n\n  constructor(\n    id: number,\n    inputA: DifferenceStreamReader<T>,\n    output: DifferenceStreamWriter<T>,\n    f: (data: MultiSet<T>) => void\n  ) {\n    super(id, inputA, output)\n    this.#f = f\n  }\n\n  inner(collection: MultiSet<T>): MultiSet<T> {\n    this.#f(collection)\n    return collection\n  }\n}\n\n/**\n * Invokes a function for each multi-set in the input stream.\n * This operator doesn't modify the stream and is used to perform side effects.\n * @param f - The function to invoke on each multi-set\n * @returns The input stream\n */\nexport function tap<T>(f: (data: MultiSet<T>) => void): PipedOperator<T, T> {\n  return (stream: IStreamBuilder<T>): IStreamBuilder<T> => {\n    const output = new StreamBuilder<T>(\n      stream.graph,\n      new DifferenceStreamWriter<T>()\n    )\n    const operator = new TapOperator<T>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader(),\n      output.writer,\n      f\n    )\n    stream.graph.addOperator(operator)\n    return output\n  }\n}\n", "import { DifferenceStreamWriter, LinearUnaryOperator } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport type { IStreamBuilder, PipedOperator } from \"../types.js\"\nimport type { DifferenceStreamReader } from \"../graph.js\"\nimport type { MultiSet } from \"../multiset.js\"\n\n/**\n * Operator that filters elements from the input stream\n */\nexport class FilterOperator<T> extends LinearUnaryOperator<T, T> {\n  #f: (data: T) => boolean\n\n  constructor(\n    id: number,\n    inputA: DifferenceStreamReader<T>,\n    output: DifferenceStreamWriter<T>,\n    f: (data: T) => boolean\n  ) {\n    super(id, inputA, output)\n    this.#f = f\n  }\n\n  inner(collection: MultiSet<T>): MultiSet<T> {\n    return collection.filter(this.#f)\n  }\n}\n\n/**\n * Filters elements from the input stream\n * @param f - The predicate to filter elements\n */\nexport function filter<T>(f: (data: T) => boolean): PipedOperator<T, T> {\n  return (stream: IStreamBuilder<T>): IStreamBuilder<T> => {\n    const output = new StreamBuilder<T>(\n      stream.graph,\n      new DifferenceStreamWriter<T>()\n    )\n    const operator = new FilterOperator<T>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader(),\n      output.writer,\n      f\n    )\n    stream.graph.addOperator(operator)\n    return output\n  }\n}\n", "import { DifferenceStreamWriter, UnaryOperator } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport type { IStreamBuilder, PipedOperator } from \"../types.js\"\nimport type { DifferenceStreamReader } from \"../graph.js\"\nimport type { MultiSet } from \"../multiset.js\"\n\n/**\n * Operator that outputs the messages in the stream\n */\nexport class OutputOperator<T> extends UnaryOperator<T> {\n  #fn: (data: MultiSet<T>) => void\n\n  constructor(\n    id: number,\n    inputA: DifferenceStreamReader<T>,\n    outputWriter: DifferenceStreamWriter<T>,\n    fn: (data: MultiSet<T>) => void\n  ) {\n    super(id, inputA, outputWriter)\n    this.#fn = fn\n  }\n\n  run(): void {\n    for (const message of this.inputMessages()) {\n      this.#fn(message)\n      this.output.sendData(message)\n    }\n  }\n}\n\n/**\n * Outputs the messages in the stream\n * @param fn - The function to call with each message\n */\nexport function output<T>(\n  fn: (data: MultiSet<T>) => void\n): PipedOperator<T, T> {\n  return (stream: IStreamBuilder<T>): IStreamBuilder<T> => {\n    const outputStream = new StreamBuilder<T>(\n      stream.graph,\n      new DifferenceStreamWriter<T>()\n    )\n    const operator = new OutputOperator<T>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader(),\n      outputStream.writer,\n      fn\n    )\n    stream.graph.addOperator(operator)\n    return outputStream\n  }\n}\n", "import { DifferenceStreamWriter, UnaryOperator } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport { MultiSet } from \"../multiset.js\"\nimport type { IStreamBuilder, PipedOperator } from \"../types.js\"\n\n/**\n * Operator that consolidates collections\n */\nexport class ConsolidateOperator<T> extends UnaryOperator<T> {\n  run(): void {\n    const messages = this.inputMessages()\n    if (messages.length === 0) {\n      return\n    }\n\n    // Combine all messages into a single MultiSet\n    const combined = new MultiSet<T>()\n    for (const message of messages) {\n      combined.extend(message)\n    }\n\n    // Consolidate the combined MultiSet\n    const consolidated = combined.consolidate()\n\n    // Only send if there are results\n    if (consolidated.getInner().length > 0) {\n      this.output.sendData(consolidated)\n    }\n  }\n}\n\n/**\n * Consolidates the elements in the stream\n */\nexport function consolidate<T>(): PipedOperator<T, T> {\n  return (stream: IStreamBuilder<T>): IStreamBuilder<T> => {\n    const output = new StreamBuilder<T>(\n      stream.graph,\n      new DifferenceStreamWriter<T>()\n    )\n    const operator = new ConsolidateOperator<T>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader(),\n      output.writer\n    )\n    stream.graph.addOperator(operator)\n    return output\n  }\n}\n", "/**\n * # Direct Join Algorithms for Incremental View Maintenance\n *\n * High-performance join operations implementing all join types (inner, left, right, full, anti)\n * with minimal state and optimized performance.\n *\n * ## Algorithm\n *\n * For each tick, the algorithm processes incoming changes (deltas) and emits join results:\n *\n * 1. **Build deltas**: Create delta indexes from input messages using `Index.fromMultiSet()`\n * 2. **Inner results**: Emit `Î”Aâ‹ˆB_old + A_oldâ‹ˆÎ”B + Î”Aâ‹ˆÎ”B` (matched pairs)\n * 3. **Outer results**: For unmatched rows, emit null-extended tuples:\n *    - New unmatched rows from deltas (when opposite side empty)\n *    - Presence transitions: when key goes `0â†’>0` (retract nulls) or `>0â†’0` (emit nulls)\n * 4. **Update state**: Append deltas to indexes (consolidated multiplicity tracking automatic)\n *\n * **Consolidated multiplicity tracking** enables O(1) presence checks instead of scanning index buckets.\n *\n * ## State\n *\n * **Indexes** store the actual data:\n * - `indexA: Index<K, V1>` - all left-side rows accumulated over time\n * - `indexB: Index<K, V2>` - all right-side rows accumulated over time\n *\n * **Consolidated multiplicity tracking** (built into Index):\n * - Each Index maintains sum of multiplicities per key internally\n * - Provides O(1) presence checks: `index.hasPresence(key)` and `index.getConsolidatedMultiplicity(key)`\n * - Avoids scanning entire index buckets just to check if key has any rows\n *\n * ## Join Types\n *\n * - **Inner**: Standard delta terms only\n * - **Outer**: Inner results + null-extended unmatched rows with transition handling\n * - **Anti**: Unmatched rows only (no inner results)\n *\n * ## Key Optimizations\n *\n * - **No temp copying**: Uses `(AâŠŽÎ”A)â‹ˆÎ”B = Aâ‹ˆÎ”B âŠŽ Î”Aâ‹ˆÎ”B` distributive property\n * - **Early-out checks**: Skip phases when no deltas present\n * - **Zero-entry pruning**: Keep maps compact, O(distinct keys) memory\n * - **Final presence logic**: Avoid emitâ†’retract churn within same tick\n *\n * ## Correctness\n *\n * - **Ordering**: Pre-append snapshots for emissions, post-emit state updates\n * - **Presence**: Key matched iff mass â‰  0, transitions trigger null handling\n * - **Bag semantics**: Proper multiplicity handling including negatives\n */\n\nimport { BinaryOperator, DifferenceStreamWriter } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport { MultiSet } from \"../multiset.js\"\nimport { Index } from \"../indexes.js\"\nimport type { DifferenceStreamReader } from \"../graph.js\"\nimport type { IStreamBuilder, KeyValue, PipedOperator } from \"../types.js\"\n\n/**\n * Type of join to perform\n */\nexport type JoinType = `inner` | `left` | `right` | `full` | `anti`\n\n/**\n * Operator that joins two input streams using direct join algorithms\n */\nexport class JoinOperator<K, V1, V2> extends BinaryOperator<\n  [K, V1] | [K, V2] | [K, [V1, V2]] | [K, [V1 | null, V2 | null]]\n> {\n  #indexA = new Index<K, V1>()\n  #indexB = new Index<K, V2>()\n  #mode: JoinType\n\n  constructor(\n    id: number,\n    inputA: DifferenceStreamReader<[K, V1]>,\n    inputB: DifferenceStreamReader<[K, V2]>,\n    output: DifferenceStreamWriter<any>,\n    mode: JoinType = `inner`\n  ) {\n    super(id, inputA, inputB, output)\n    this.#mode = mode\n  }\n\n  run(): void {\n    // Build deltas from input messages\n    const deltaA = Index.fromMultiSets<K, V1>(\n      this.inputAMessages() as Array<MultiSet<[K, V1]>>\n    )\n    const deltaB = Index.fromMultiSets<K, V2>(\n      this.inputBMessages() as Array<MultiSet<[K, V2]>>\n    )\n\n    // Early-out if nothing changed\n    if (deltaA.size === 0 && deltaB.size === 0) return\n\n    const results = new MultiSet<any>()\n\n    // Emit inner results (all modes except anti)\n    if (this.#mode !== `anti`) {\n      this.emitInnerResults(deltaA, deltaB, results)\n    }\n\n    // Emit left outer/anti results\n    if (\n      this.#mode === `left` ||\n      this.#mode === `full` ||\n      this.#mode === `anti`\n    ) {\n      this.emitLeftOuterResults(deltaA, deltaB, results)\n    }\n\n    // Emit right outer results\n    if (this.#mode === `right` || this.#mode === `full`) {\n      this.emitRightOuterResults(deltaA, deltaB, results)\n    }\n\n    // Update state and send results\n    // IMPORTANT: All emissions use pre-append snapshots of indexA/indexB.\n    // Now append ALL deltas to indices - this happens unconditionally for every key,\n    // regardless of whether presence flipped. Consolidated multiplicity tracking is automatic.\n    this.#indexA.append(deltaA)\n    this.#indexB.append(deltaB)\n\n    // Send results\n    if (results.getInner().length > 0) {\n      this.output.sendData(results)\n    }\n  }\n\n  private emitInnerResults(\n    deltaA: Index<K, V1>,\n    deltaB: Index<K, V2>,\n    results: MultiSet<any>\n  ): void {\n    // Emit the three standard delta terms: Î”Aâ‹ˆB_old, A_oldâ‹ˆÎ”B, Î”Aâ‹ˆÎ”B\n    if (deltaA.size > 0) results.extend(deltaA.join(this.#indexB))\n    if (deltaB.size > 0) results.extend(this.#indexA.join(deltaB))\n    if (deltaA.size > 0 && deltaB.size > 0) results.extend(deltaA.join(deltaB))\n  }\n\n  private emitLeftOuterResults(\n    deltaA: Index<K, V1>,\n    deltaB: Index<K, V2>,\n    results: MultiSet<any>\n  ): void {\n    // Emit unmatched left rows from deltaA\n    if (deltaA.size > 0) {\n      for (const [key, valueIterator] of deltaA.entriesIterators()) {\n        const currentMultiplicityB =\n          this.#indexB.getConsolidatedMultiplicity(key)\n        const deltaMultiplicityB = deltaB.getConsolidatedMultiplicity(key)\n        const finalMultiplicityB = currentMultiplicityB + deltaMultiplicityB\n\n        if (finalMultiplicityB === 0) {\n          for (const [value, multiplicity] of valueIterator) {\n            if (multiplicity !== 0) {\n              results.add([key, [value, null]], multiplicity)\n            }\n          }\n        }\n      }\n    }\n\n    // Handle presence transitions from right side changes\n    if (deltaB.size > 0) {\n      for (const key of deltaB.getPresenceKeys()) {\n        const before = this.#indexB.getConsolidatedMultiplicity(key)\n        const deltaMult = deltaB.getConsolidatedMultiplicity(key)\n        if (deltaMult === 0) continue\n        const after = before + deltaMult\n\n        // Skip transition handling if presence doesn't flip (both zero or both non-zero)\n        // Note: Index updates happen later regardless - we're only skipping null-extension emissions here\n        if ((before === 0) === (after === 0)) continue\n\n        // Determine the type of transition:\n        // - 0 â†’ non-zero: Right becomes non-empty, left rows transition from unmatched to matched\n        //   â†’ RETRACT previously emitted null-extended rows (emit with negative multiplicity)\n        // - non-zero â†’ 0: Right becomes empty, left rows transition from matched to unmatched\n        //   â†’ EMIT new null-extended rows (emit with positive multiplicity)\n        const transitioningToMatched = before === 0\n\n        for (const [value, multiplicity] of this.#indexA.getIterator(key)) {\n          if (multiplicity !== 0) {\n            results.add(\n              [key, [value, null]],\n              transitioningToMatched ? -multiplicity : +multiplicity\n            )\n          }\n        }\n      }\n    }\n  }\n\n  private emitRightOuterResults(\n    deltaA: Index<K, V1>,\n    deltaB: Index<K, V2>,\n    results: MultiSet<any>\n  ): void {\n    // Emit unmatched right rows from deltaB\n    if (deltaB.size > 0) {\n      for (const [key, valueIterator] of deltaB.entriesIterators()) {\n        const currentMultiplicityA =\n          this.#indexA.getConsolidatedMultiplicity(key)\n        const deltaMultiplicityA = deltaA.getConsolidatedMultiplicity(key)\n        const finalMultiplicityA = currentMultiplicityA + deltaMultiplicityA\n\n        if (finalMultiplicityA === 0) {\n          for (const [value, multiplicity] of valueIterator) {\n            if (multiplicity !== 0) {\n              results.add([key, [null, value]], multiplicity)\n            }\n          }\n        }\n      }\n    }\n\n    // Handle presence transitions from left side changes\n    if (deltaA.size > 0) {\n      for (const key of deltaA.getPresenceKeys()) {\n        const before = this.#indexA.getConsolidatedMultiplicity(key)\n        const deltaMult = deltaA.getConsolidatedMultiplicity(key)\n        if (deltaMult === 0) continue\n        const after = before + deltaMult\n\n        // Skip transition handling if presence doesn't flip (both zero or both non-zero)\n        // Note: Index updates happen later regardless - we're only skipping null-extension emissions here\n        if ((before === 0) === (after === 0)) continue\n\n        // Determine the type of transition:\n        // - 0 â†’ non-zero: Left becomes non-empty, right rows transition from unmatched to matched\n        //   â†’ RETRACT previously emitted null-extended rows (emit with negative multiplicity)\n        // - non-zero â†’ 0: Left becomes empty, right rows transition from matched to unmatched\n        //   â†’ EMIT new null-extended rows (emit with positive multiplicity)\n        const transitioningToMatched = before === 0\n\n        for (const [value, multiplicity] of this.#indexB.getIterator(key)) {\n          if (multiplicity !== 0) {\n            results.add(\n              [key, [null, value]],\n              transitioningToMatched ? -multiplicity : +multiplicity\n            )\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Joins two input streams\n * @param other - The other stream to join with\n * @param type - The type of join to perform\n */\nexport function join<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>,\n  type: JoinType = `inner`\n): PipedOperator<T, KeyValue<K, [V1 | null, V2 | null]>> {\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<KeyValue<K, [V1 | null, V2 | null]>> => {\n    if (stream.graph !== other.graph) {\n      throw new Error(`Cannot join streams from different graphs`)\n    }\n    const output = new StreamBuilder<KeyValue<K, [V1 | null, V2 | null]>>(\n      stream.graph,\n      new DifferenceStreamWriter<KeyValue<K, [V1 | null, V2 | null]>>()\n    )\n    const operator = new JoinOperator<K, V1, V2>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader() as DifferenceStreamReader<KeyValue<K, V1>>,\n      other.connectReader(),\n      output.writer,\n      type\n    )\n    stream.graph.addOperator(operator)\n    return output\n  }\n}\n\n/**\n * Joins two input streams (inner join)\n * @param other - The other stream to join with\n */\nexport function innerJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1, V2]>> {\n  return join(other, `inner`) as unknown as PipedOperator<\n    T,\n    KeyValue<K, [V1, V2]>\n  >\n}\n\n/**\n * Joins two input streams (anti join)\n * @param other - The other stream to join with\n */\nexport function antiJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1, null]>> {\n  return join(other, `anti`) as unknown as PipedOperator<\n    T,\n    KeyValue<K, [V1, null]>\n  >\n}\n\n/**\n * Joins two input streams (left join)\n * @param other - The other stream to join with\n */\nexport function leftJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1, V2 | null]>> {\n  return join(other, `left`) as unknown as PipedOperator<\n    T,\n    KeyValue<K, [V1, V2 | null]>\n  >\n}\n\n/**\n * Joins two input streams (right join)\n * @param other - The other stream to join with\n */\nexport function rightJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1 | null, V2]>> {\n  return join(other, `right`) as unknown as PipedOperator<\n    T,\n    KeyValue<K, [V1 | null, V2]>\n  >\n}\n\n/**\n * Joins two input streams (full join)\n * @param other - The other stream to join with\n */\nexport function fullJoin<\n  K,\n  V1 extends T extends KeyValue<infer _KT, infer VT> ? VT : never,\n  V2,\n  T,\n>(\n  other: IStreamBuilder<KeyValue<K, V2>>\n): PipedOperator<T, KeyValue<K, [V1 | null, V2 | null]>> {\n  return join(other, `full`) as unknown as PipedOperator<\n    T,\n    KeyValue<K, [V1 | null, V2 | null]>\n  >\n}\n", "import { DifferenceStreamWriter, UnaryOperator } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport { hash } from \"../hashing/index.js\"\nimport { MultiSet } from \"../multiset.js\"\nimport type { Hash } from \"../hashing/index.js\"\nimport type { DifferenceStreamReader } from \"../graph.js\"\nimport type { IStreamBuilder, KeyValue } from \"../types.js\"\n\ntype Multiplicity = number\n\ntype GetValue<T> = T extends KeyValue<any, infer V> ? V : never\n\n/**\n * Operator that removes duplicates\n */\nexport class DistinctOperator<\n  T extends KeyValue<any, any>,\n> extends UnaryOperator<T, KeyValue<number, GetValue<T>>> {\n  #by: (value: T) => any\n  #values: Map<Hash, Multiplicity> // keeps track of the number of times each value has been seen\n\n  constructor(\n    id: number,\n    input: DifferenceStreamReader<T>,\n    output: DifferenceStreamWriter<KeyValue<number, GetValue<T>>>,\n    by: (value: T) => any = (value: T) => value\n  ) {\n    super(id, input, output)\n    this.#by = by\n    this.#values = new Map()\n  }\n\n  run(): void {\n    const updatedValues = new Map<Hash, [Multiplicity, T]>()\n\n    // Compute the new multiplicity for each value\n    for (const message of this.inputMessages()) {\n      for (const [value, diff] of message.getInner()) {\n        const hashedValue = hash(this.#by(value))\n\n        const oldMultiplicity =\n          updatedValues.get(hashedValue)?.[0] ??\n          this.#values.get(hashedValue) ??\n          0\n        const newMultiplicity = oldMultiplicity + diff\n        updatedValues.set(hashedValue, [newMultiplicity, value])\n      }\n    }\n\n    const result: Array<[KeyValue<number, GetValue<T>>, number]> = []\n\n    // Check which values became visible or disappeared\n    for (const [\n      hashedValue,\n      [newMultiplicity, value],\n    ] of updatedValues.entries()) {\n      const oldMultiplicity = this.#values.get(hashedValue) ?? 0\n\n      if (newMultiplicity === 0) {\n        this.#values.delete(hashedValue)\n      } else {\n        this.#values.set(hashedValue, newMultiplicity)\n      }\n\n      if (oldMultiplicity <= 0 && newMultiplicity > 0) {\n        // The value wasn't present in the stream\n        // but with this change it is now present in the stream\n        result.push([[hash(this.#by(value)), value[1]], 1])\n      } else if (oldMultiplicity > 0 && newMultiplicity <= 0) {\n        // The value was present in the stream\n        // but with this change it is no longer present in the stream\n        result.push([[hash(this.#by(value)), value[1]], -1])\n      }\n    }\n\n    if (result.length > 0) {\n      this.output.sendData(new MultiSet(result))\n    }\n  }\n}\n\n/**\n * Removes duplicate values\n */\nexport function distinct<T extends KeyValue<any, any>>(\n  by: (value: T) => any = (value: T) => value\n) {\n  return (stream: IStreamBuilder<T>): IStreamBuilder<T> => {\n    const output = new StreamBuilder<T>(\n      stream.graph,\n      new DifferenceStreamWriter<T>()\n    )\n    const operator = new DistinctOperator<T>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader(),\n      output.writer,\n      by\n    )\n    stream.graph.addOperator(operator)\n    return output\n  }\n}\n", "// License: CC0 (no rights reserved).\n\n// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing\n\nexport const BASE_62_DIGITS =\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n// `a` may be empty string, `b` is null or non-empty string.\n// `a < b` lexicographically if `b` is non-null.\n// no trailing zeros allowed.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string} a\n * @param {string | null | undefined} b\n * @param {string} digits\n * @returns {string}\n */\nfunction midpoint(a, b, digits) {\n  const zero = digits[0];\n  if (b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {\n    throw new Error(\"trailing zero\");\n  }\n  if (b) {\n    // remove longest common prefix.  pad `a` with 0s as we\n    // go.  note that we don't need to pad `b`, because it can't\n    // end before `a` while traversing the common prefix.\n    let n = 0;\n    while ((a[n] || zero) === b[n]) {\n      n++;\n    }\n    if (n > 0) {\n      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);\n    }\n  }\n  // first digits (or lack of digit) are different\n  const digitA = a ? digits.indexOf(a[0]) : 0;\n  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;\n  if (digitB - digitA > 1) {\n    const midDigit = Math.round(0.5 * (digitA + digitB));\n    return digits[midDigit];\n  } else {\n    // first digits are consecutive\n    if (b && b.length > 1) {\n      return b.slice(0, 1);\n    } else {\n      // `b` is null or has length 1 (a single digit).\n      // the first digit of `a` is the previous digit to `b`,\n      // or 9 if `b` is null.\n      // given, for example, midpoint('49', '5'), return\n      // '4' + midpoint('9', null), which will become\n      // '4' + '9' + midpoint('', null), which is '495'\n      return digits[digitA] + midpoint(a.slice(1), null, digits);\n    }\n  }\n}\n\n/**\n * @param {string} int\n * @return {void}\n */\n\nfunction validateInteger(int) {\n  if (int.length !== getIntegerLength(int[0])) {\n    throw new Error(\"invalid integer part of order key: \" + int);\n  }\n}\n\n/**\n * @param {string} head\n * @return {number}\n */\n\nfunction getIntegerLength(head) {\n  if (head >= \"a\" && head <= \"z\") {\n    return head.charCodeAt(0) - \"a\".charCodeAt(0) + 2;\n  } else if (head >= \"A\" && head <= \"Z\") {\n    return \"Z\".charCodeAt(0) - head.charCodeAt(0) + 2;\n  } else {\n    throw new Error(\"invalid order key head: \" + head);\n  }\n}\n\n/**\n * @param {string} key\n * @return {string}\n */\n\nfunction getIntegerPart(key) {\n  const integerPartLength = getIntegerLength(key[0]);\n  if (integerPartLength > key.length) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  return key.slice(0, integerPartLength);\n}\n\n/**\n * @param {string} key\n * @param {string} digits\n * @return {void}\n */\n\nfunction validateOrderKey(key, digits) {\n  if (key === \"A\" + digits[0].repeat(26)) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  // getIntegerPart will throw if the first character is bad,\n  // or the key is too short.  we'd call it to check these things\n  // even if we didn't need the result\n  const i = getIntegerPart(key);\n  const f = key.slice(i.length);\n  if (f.slice(-1) === digits[0]) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n}\n\n// note that this may return null, as there is a largest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\nfunction incrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let carry = true;\n  for (let i = digs.length - 1; carry && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) + 1;\n    if (d === digits.length) {\n      digs[i] = digits[0];\n    } else {\n      digs[i] = digits[d];\n      carry = false;\n    }\n  }\n  if (carry) {\n    if (head === \"Z\") {\n      return \"a\" + digits[0];\n    }\n    if (head === \"z\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) + 1);\n    if (h > \"a\") {\n      digs.push(digits[0]);\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// note that this may return null, as there is a smallest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\n\nfunction decrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let borrow = true;\n  for (let i = digs.length - 1; borrow && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) - 1;\n    if (d === -1) {\n      digs[i] = digits.slice(-1);\n    } else {\n      digs[i] = digits[d];\n      borrow = false;\n    }\n  }\n  if (borrow) {\n    if (head === \"a\") {\n      return \"Z\" + digits.slice(-1);\n    }\n    if (head === \"A\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) - 1);\n    if (h < \"Z\") {\n      digs.push(digits.slice(-1));\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// `a` is an order key or null (START).\n// `b` is an order key or null (END).\n// `a < b` lexicographically if both are non-null.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {string=} digits\n * @return {string}\n */\nexport function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {\n  if (a != null) {\n    validateOrderKey(a, digits);\n  }\n  if (b != null) {\n    validateOrderKey(b, digits);\n  }\n  if (a != null && b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a == null) {\n    if (b == null) {\n      return \"a\" + digits[0];\n    }\n\n    const ib = getIntegerPart(b);\n    const fb = b.slice(ib.length);\n    if (ib === \"A\" + digits[0].repeat(26)) {\n      return ib + midpoint(\"\", fb, digits);\n    }\n    if (ib < b) {\n      return ib;\n    }\n    const res = decrementInteger(ib, digits);\n    if (res == null) {\n      throw new Error(\"cannot decrement any more\");\n    }\n    return res;\n  }\n\n  if (b == null) {\n    const ia = getIntegerPart(a);\n    const fa = a.slice(ia.length);\n    const i = incrementInteger(ia, digits);\n    return i == null ? ia + midpoint(fa, null, digits) : i;\n  }\n\n  const ia = getIntegerPart(a);\n  const fa = a.slice(ia.length);\n  const ib = getIntegerPart(b);\n  const fb = b.slice(ib.length);\n  if (ia === ib) {\n    return ia + midpoint(fa, fb, digits);\n  }\n  const i = incrementInteger(ia, digits);\n  if (i == null) {\n    throw new Error(\"cannot increment any more\");\n  }\n  if (i < b) {\n    return i;\n  }\n  return ia + midpoint(fa, null, digits);\n}\n\n/**\n * same preconditions as generateKeysBetween.\n * n >= 0.\n * Returns an array of n distinct keys in sorted order.\n * If a and b are both null, returns [a0, a1, ...]\n * If one or the other is null, returns consecutive \"integer\"\n * keys.  Otherwise, returns relatively short keys between\n * a and b.\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {number} n\n * @param {string} digits\n * @return {string[]}\n */\nexport function generateNKeysBetween(a, b, n, digits = BASE_62_DIGITS) {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [generateKeyBetween(a, b, digits)];\n  }\n  if (b == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(c, b, digits);\n      result.push(c);\n    }\n    return result;\n  }\n  if (a == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(a, c, digits);\n      result.push(c);\n    }\n    result.reverse();\n    return result;\n  }\n  const mid = Math.floor(n / 2);\n  const c = generateKeyBetween(a, b, digits);\n  return [\n    ...generateNKeysBetween(a, c, mid, digits),\n    c,\n    ...generateNKeysBetween(c, b, n - mid - 1, digits),\n  ];\n}\n", "import { generateKeyBetween } from \"fractional-indexing\"\nimport { DifferenceStreamWriter, UnaryOperator } from \"../graph.js\"\nimport { StreamBuilder } from \"../d2.js\"\nimport { MultiSet } from \"../multiset.js\"\nimport {\n  binarySearch,\n  diffHalfOpen,\n  globalObjectIdGenerator,\n} from \"../utils.js\"\nimport type { HRange } from \"../utils.js\"\nimport type { DifferenceStreamReader } from \"../graph.js\"\nimport type { IStreamBuilder, PipedOperator } from \"../types.js\"\n\nexport interface TopKWithFractionalIndexOptions {\n  limit?: number\n  offset?: number\n  setSizeCallback?: (getSize: () => number) => void\n  setWindowFn?: (\n    windowFn: (options: { offset?: number; limit?: number }) => void\n  ) => void\n}\n\nexport type TopKChanges<V> = {\n  /** Indicates which element moves into the topK (if any) */\n  moveIn: IndexedValue<V> | null\n  /** Indicates which element moves out of the topK (if any) */\n  moveOut: IndexedValue<V> | null\n}\n\nexport type TopKMoveChanges<V> = {\n  /** Flag that marks whether there were any changes to the topK */\n  changes: boolean\n  /** Indicates which elements move into the topK (if any) */\n  moveIns: Array<IndexedValue<V>>\n  /** Indicates which elements move out of the topK (if any) */\n  moveOuts: Array<IndexedValue<V>>\n}\n\n/**\n * A topK data structure that supports insertions and deletions\n * and returns changes to the topK.\n */\nexport interface TopK<V> {\n  size: number\n  insert: (value: V) => TopKChanges<V>\n  delete: (value: V) => TopKChanges<V>\n}\n\n/**\n * Implementation of a topK data structure.\n * Uses a sorted array internally to store the values and keeps a topK window over that array.\n * Inserts and deletes are O(n) operations because worst case an element is inserted/deleted\n * at the start of the array which causes all the elements to shift to the right/left.\n */\nclass TopKArray<V> implements TopK<V> {\n  #sortedValues: Array<IndexedValue<V>> = []\n  #comparator: (a: V, b: V) => number\n  #topKStart: number\n  #topKEnd: number\n\n  constructor(\n    offset: number,\n    limit: number,\n    comparator: (a: V, b: V) => number\n  ) {\n    this.#topKStart = offset\n    this.#topKEnd = offset + limit\n    this.#comparator = comparator\n  }\n\n  get size(): number {\n    const offset = this.#topKStart\n    const limit = this.#topKEnd - this.#topKStart\n    const available = this.#sortedValues.length - offset\n    return Math.max(0, Math.min(limit, available))\n  }\n\n  /**\n   * Moves the topK window\n   */\n  move({\n    offset,\n    limit,\n  }: {\n    offset?: number\n    limit?: number\n  }): TopKMoveChanges<V> {\n    const oldOffset = this.#topKStart\n    const oldLimit = this.#topKEnd - this.#topKStart\n\n    // `this.#topKEnd` can be `Infinity` if it has no limit\n    // but `diffHalfOpen` expects a finite range\n    // so we restrict it to the size of the topK if topKEnd is infinite\n    const oldRange: HRange = [\n      this.#topKStart,\n      this.#topKEnd === Infinity ? this.#topKStart + this.size : this.#topKEnd,\n    ]\n\n    this.#topKStart = offset ?? oldOffset\n    this.#topKEnd = this.#topKStart + (limit ?? oldLimit) // can be `Infinity` if limit is `Infinity`\n\n    // Also handle `Infinity` in the newRange\n    const newRange: HRange = [\n      this.#topKStart,\n      this.#topKEnd === Infinity\n        ? Math.max(this.#topKStart + this.size, oldRange[1]) // since the new limit is Infinity we need to take everything (so we need to take the biggest (finite) topKEnd)\n        : this.#topKEnd,\n    ]\n    const { onlyInA, onlyInB } = diffHalfOpen(oldRange, newRange)\n\n    const moveIns: Array<IndexedValue<V>> = []\n    onlyInB.forEach((index) => {\n      const value = this.#sortedValues[index]\n      if (value) {\n        moveIns.push(value)\n      }\n    })\n\n    const moveOuts: Array<IndexedValue<V>> = []\n    onlyInA.forEach((index) => {\n      const value = this.#sortedValues[index]\n      if (value) {\n        moveOuts.push(value)\n      }\n    })\n\n    // It could be that there are changes (i.e. moveIns or moveOuts)\n    // but that the collection is lazy so we don't have the data yet that needs to move in/out\n    // so `moveIns` and `moveOuts` will be empty but `changes` will be true\n    // this will tell the caller that it needs to run the graph to load more data\n    return { moveIns, moveOuts, changes: onlyInA.length + onlyInB.length > 0 }\n  }\n\n  insert(value: V): TopKChanges<V> {\n    const result: TopKChanges<V> = { moveIn: null, moveOut: null }\n\n    // Lookup insert position\n    const index = this.#findIndex(value)\n    // Generate fractional index based on the fractional indices of the elements before and after it\n    const indexBefore =\n      index === 0 ? null : getIndex(this.#sortedValues[index - 1]!)\n    const indexAfter =\n      index === this.#sortedValues.length\n        ? null\n        : getIndex(this.#sortedValues[index]!)\n    const fractionalIndex = generateKeyBetween(indexBefore, indexAfter)\n\n    // Insert the value at the correct position\n    const val = indexedValue(value, fractionalIndex)\n    // Splice is O(n) where n = all elements in the collection (i.e. n >= k) !\n    this.#sortedValues.splice(index, 0, val)\n\n    // Check if the topK changed\n    if (index < this.#topKEnd) {\n      // The inserted element is either before the top K or within the top K\n      // If it is before the top K then it moves the element that was right before the topK into the topK\n      // If it is within the top K then the inserted element moves into the top K\n      // In both cases the last element of the old top K now moves out of the top K\n      const moveInIndex = Math.max(index, this.#topKStart)\n      if (moveInIndex < this.#sortedValues.length) {\n        // We actually have a topK\n        // because in some cases there may not be enough elements in the array to reach the start of the topK\n        // e.g. [1, 2, 3] with K = 2 and offset = 3 does not have a topK\n        result.moveIn = this.#sortedValues[moveInIndex]!\n\n        // We need to remove the element that falls out of the top K\n        // The element that falls out of the top K has shifted one to the right\n        // because of the element we inserted, so we find it at index topKEnd\n        if (this.#topKEnd < this.#sortedValues.length) {\n          result.moveOut = this.#sortedValues[this.#topKEnd]!\n        }\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Deletes a value that may or may not be in the topK.\n   * IMPORTANT: this assumes that the value is present in the collection\n   *            if it's not the case it will remove the element\n   *            that is on the position where the provided `value` would be.\n   */\n  delete(value: V): TopKChanges<V> {\n    const result: TopKChanges<V> = { moveIn: null, moveOut: null }\n\n    // Lookup delete position\n    const index = this.#findIndex(value)\n    // Remove the value at that position\n    const [removedElem] = this.#sortedValues.splice(index, 1)\n\n    // Check if the topK changed\n    if (index < this.#topKEnd) {\n      // The removed element is either before the top K or within the top K\n      // If it is before the top K then the first element of the topK moves out of the topK\n      // If it is within the top K then the removed element moves out of the topK\n      result.moveOut = removedElem!\n      if (index < this.#topKStart) {\n        // The removed element is before the topK\n        // so actually, the first element of the topK moves out of the topK\n        // and not the element that we removed\n        // The first element of the topK is now at index topKStart - 1\n        // since we removed an element before the topK\n        const moveOutIndex = this.#topKStart - 1\n        if (moveOutIndex < this.#sortedValues.length) {\n          result.moveOut = this.#sortedValues[moveOutIndex]!\n        } else {\n          // No value is moving out of the topK\n          // because there are no elements in the topK\n          result.moveOut = null\n        }\n      }\n\n      // Since we removed an element that was before or in the topK\n      // the first element after the topK moved one position to the left\n      // and thus falls into the topK now\n      const moveInIndex = this.#topKEnd - 1\n      if (moveInIndex < this.#sortedValues.length) {\n        result.moveIn = this.#sortedValues[moveInIndex]!\n      }\n    }\n\n    return result\n  }\n\n  // TODO: see if there is a way to refactor the code for insert and delete in the topK above\n  //       because they are very similar, one is shifting the topK window to the left and the other is shifting it to the right\n  //       so i have the feeling there is a common pattern here and we can implement both cases using that pattern\n\n  #findIndex(value: V): number {\n    return binarySearch(this.#sortedValues, indexedValue(value, ``), (a, b) =>\n      this.#comparator(getValue(a), getValue(b))\n    )\n  }\n}\n\n/**\n * Operator for fractional indexed topK operations\n * This operator maintains fractional indices for sorted elements\n * and only updates indices when elements move position\n */\nexport class TopKWithFractionalIndexOperator<K, T> extends UnaryOperator<\n  [K, T],\n  [K, IndexedValue<T>]\n> {\n  #index: Map<K, number> = new Map() // maps keys to their multiplicity\n\n  /**\n   * topK data structure that supports insertions and deletions\n   * and returns changes to the topK.\n   */\n  #topK: TopK<TaggedValue<K, T>>\n\n  constructor(\n    id: number,\n    inputA: DifferenceStreamReader<[K, T]>,\n    output: DifferenceStreamWriter<[K, IndexedValue<T>]>,\n    comparator: (a: T, b: T) => number,\n    options: TopKWithFractionalIndexOptions\n  ) {\n    super(id, inputA, output)\n    const limit = options.limit ?? Infinity\n    const offset = options.offset ?? 0\n    const compareTaggedValues = (\n      a: TaggedValue<K, T>,\n      b: TaggedValue<K, T>\n    ) => {\n      // First compare on the value\n      const valueComparison = comparator(getVal(a), getVal(b))\n      if (valueComparison !== 0) {\n        return valueComparison\n      }\n      // If the values are equal, compare on the tag (object identity)\n      const tieBreakerA = getTag(a)\n      const tieBreakerB = getTag(b)\n      return tieBreakerA - tieBreakerB\n    }\n    this.#topK = this.createTopK(offset, limit, compareTaggedValues)\n    options.setSizeCallback?.(() => this.#topK.size)\n    options.setWindowFn?.(this.moveTopK.bind(this))\n  }\n\n  protected createTopK(\n    offset: number,\n    limit: number,\n    comparator: (a: TaggedValue<K, T>, b: TaggedValue<K, T>) => number\n  ): TopK<TaggedValue<K, T>> {\n    return new TopKArray(offset, limit, comparator)\n  }\n\n  /**\n   * Moves the topK window based on the provided offset and limit.\n   * Any changes to the topK are sent to the output.\n   */\n  moveTopK({ offset, limit }: { offset?: number; limit?: number }) {\n    if (!(this.#topK instanceof TopKArray)) {\n      throw new Error(\n        `Cannot move B+-tree implementation of TopK with fractional index`\n      )\n    }\n\n    const result: Array<[[K, IndexedValue<T>], number]> = []\n\n    const diff = this.#topK.move({ offset, limit })\n\n    diff.moveIns.forEach((moveIn) => this.handleMoveIn(moveIn, result))\n    diff.moveOuts.forEach((moveOut) => this.handleMoveOut(moveOut, result))\n\n    if (diff.changes) {\n      // There are changes to the topK\n      // it could be that moveIns and moveOuts are empty\n      // because the collection is lazy, so we will run the graph again to load the data\n      this.output.sendData(new MultiSet(result))\n    }\n  }\n\n  run(): void {\n    const result: Array<[[K, IndexedValue<T>], number]> = []\n    for (const message of this.inputMessages()) {\n      for (const [item, multiplicity] of message.getInner()) {\n        const [key, value] = item\n        this.processElement(key, value, multiplicity, result)\n      }\n    }\n\n    if (result.length > 0) {\n      this.output.sendData(new MultiSet(result))\n    }\n  }\n\n  processElement(\n    key: K,\n    value: T,\n    multiplicity: number,\n    result: Array<[[K, IndexedValue<T>], number]>\n  ): void {\n    const { oldMultiplicity, newMultiplicity } = this.addKey(key, multiplicity)\n\n    let res: TopKChanges<TaggedValue<K, T>> = {\n      moveIn: null,\n      moveOut: null,\n    }\n    if (oldMultiplicity <= 0 && newMultiplicity > 0) {\n      // The value was invisible but should now be visible\n      // Need to insert it into the array of sorted values\n      const taggedValue = tagValue(key, value)\n      res = this.#topK.insert(taggedValue)\n    } else if (oldMultiplicity > 0 && newMultiplicity <= 0) {\n      // The value was visible but should now be invisible\n      // Need to remove it from the array of sorted values\n      const taggedValue = tagValue(key, value)\n      res = this.#topK.delete(taggedValue)\n    } else {\n      // The value was invisible and it remains invisible\n      // or it was visible and remains visible\n      // so it doesn't affect the topK\n    }\n\n    this.handleMoveIn(res.moveIn, result)\n    this.handleMoveOut(res.moveOut, result)\n\n    return\n  }\n\n  private handleMoveIn(\n    moveIn: IndexedValue<TaggedValue<K, T>> | null,\n    result: Array<[[K, IndexedValue<T>], number]>\n  ) {\n    if (moveIn) {\n      const index = getIndex(moveIn)\n      const taggedValue = getValue(moveIn)\n      const k = getKey(taggedValue)\n      const val = getVal(taggedValue)\n      result.push([[k, [val, index]], 1])\n    }\n  }\n\n  private handleMoveOut(\n    moveOut: IndexedValue<TaggedValue<K, T>> | null,\n    result: Array<[[K, IndexedValue<T>], number]>\n  ) {\n    if (moveOut) {\n      const index = getIndex(moveOut)\n      const taggedValue = getValue(moveOut)\n      const k = getKey(taggedValue)\n      const val = getVal(taggedValue)\n      result.push([[k, [val, index]], -1])\n    }\n  }\n\n  private getMultiplicity(key: K): number {\n    return this.#index.get(key) ?? 0\n  }\n\n  private addKey(\n    key: K,\n    multiplicity: number\n  ): { oldMultiplicity: number; newMultiplicity: number } {\n    const oldMultiplicity = this.getMultiplicity(key)\n    const newMultiplicity = oldMultiplicity + multiplicity\n    if (newMultiplicity === 0) {\n      this.#index.delete(key)\n    } else {\n      this.#index.set(key, newMultiplicity)\n    }\n    return { oldMultiplicity, newMultiplicity }\n  }\n}\n\n/**\n * Limits the number of results based on a comparator, with optional offset.\n * Uses fractional indexing to minimize the number of changes when elements move positions.\n * Each element is assigned a fractional index that is lexicographically sortable.\n * When elements move, only the indices of the moved elements are updated, not all elements.\n *\n * @param comparator - A function that compares two elements\n * @param options - An optional object containing limit and offset properties\n * @returns A piped operator that orders the elements and limits the number of results\n */\nexport function topKWithFractionalIndex<KType, T>(\n  comparator: (a: T, b: T) => number,\n  options?: TopKWithFractionalIndexOptions\n): PipedOperator<[KType, T], [KType, IndexedValue<T>]> {\n  const opts = options || {}\n\n  return (\n    stream: IStreamBuilder<[KType, T]>\n  ): IStreamBuilder<[KType, IndexedValue<T>]> => {\n    const output = new StreamBuilder<[KType, IndexedValue<T>]>(\n      stream.graph,\n      new DifferenceStreamWriter<[KType, IndexedValue<T>]>()\n    )\n    const operator = new TopKWithFractionalIndexOperator<KType, T>(\n      stream.graph.getNextOperatorId(),\n      stream.connectReader(),\n      output.writer,\n      comparator,\n      opts\n    )\n    stream.graph.addOperator(operator)\n    return output\n  }\n}\n\n// Abstraction for fractionally indexed values\nexport type FractionalIndex = string\nexport type IndexedValue<V> = [V, FractionalIndex]\n\nexport function indexedValue<V>(\n  value: V,\n  index: FractionalIndex\n): IndexedValue<V> {\n  return [value, index]\n}\n\nexport function getValue<V>(indexedVal: IndexedValue<V>): V {\n  return indexedVal[0]\n}\n\nexport function getIndex<V>(indexedVal: IndexedValue<V>): FractionalIndex {\n  return indexedVal[1]\n}\n\nexport type Tag = number\nexport type TaggedValue<K, V> = [K, V, Tag]\n\nfunction tagValue<K, V>(key: K, value: V): TaggedValue<K, V> {\n  return [key, value, globalObjectIdGenerator.getId(key)]\n}\n\nfunction getKey<K, V>(tieBreakerTaggedValue: TaggedValue<K, V>): K {\n  return tieBreakerTaggedValue[0]\n}\n\nfunction getVal<K, V>(tieBreakerTaggedValue: TaggedValue<K, V>): V {\n  return tieBreakerTaggedValue[1]\n}\n\nfunction getTag<K, V>(tieBreakerTaggedValue: TaggedValue<K, V>): Tag {\n  return tieBreakerTaggedValue[2]\n}\n", "import { topK, topKWithIndex } from \"./topK.js\"\nimport { topKWithFractionalIndex } from \"./topKWithFractionalIndex.js\"\nimport { map } from \"./map.js\"\nimport { innerJoin } from \"./join.js\"\nimport { consolidate } from \"./consolidate.js\"\nimport type { IStreamBuilder, KeyValue } from \"../types.js\"\n\nexport interface OrderByOptions<Ve> {\n  comparator?: (a: Ve, b: Ve) => number\n  limit?: number\n  offset?: number\n}\n\ntype OrderByWithFractionalIndexOptions<Ve> = OrderByOptions<Ve> & {\n  setSizeCallback?: (getSize: () => number) => void\n  setWindowFn?: (\n    windowFn: (options: { offset?: number; limit?: number }) => void\n  ) => void\n}\n\n/**\n * Orders the elements and limits the number of results, with optional offset\n * This requires a keyed stream, and uses the `topK` operator to order all the elements.\n *\n * @param valueExtractor - A function that extracts the value to order by from the element\n * @param options - An optional object containing comparator, limit and offset properties\n * @returns A piped operator that orders the elements and limits the number of results\n */\nexport function orderBy<T extends KeyValue<unknown, unknown>, Ve = unknown>(\n  valueExtractor: (\n    value: T extends KeyValue<unknown, infer V> ? V : never\n  ) => Ve,\n  options?: OrderByOptions<Ve>\n) {\n  const limit = options?.limit ?? Infinity\n  const offset = options?.offset ?? 0\n  const comparator =\n    options?.comparator ??\n    ((a, b) => {\n      // Default to JS like ordering\n      if (a === b) return 0\n      if (a < b) return -1\n      return 1\n    })\n\n  return (stream: IStreamBuilder<T>): IStreamBuilder<T> => {\n    type KeyType = T extends KeyValue<infer K, unknown> ? K : never\n\n    return stream.pipe(\n      map(\n        ([key, value]) =>\n          [\n            null,\n            [\n              key,\n              valueExtractor(\n                value as T extends KeyValue<unknown, infer V> ? V : never\n              ),\n            ],\n          ] as KeyValue<null, [KeyType, Ve]>\n      ),\n      topK((a, b) => comparator(a[1], b[1]), { limit, offset }),\n      map(([_, [key]]) => [key, null] as KeyValue<KeyType, null>),\n      innerJoin(stream),\n      map(([key, value]) => {\n        return [key, value[1]] as T\n      }),\n      consolidate()\n    )\n  }\n}\n\n/**\n * Orders the elements and limits the number of results, with optional offset and\n * annotates the value with the index.\n * This requires a keyed stream, and uses the `topKWithIndex` operator to order all the elements.\n *\n * @param valueExtractor - A function that extracts the value to order by from the element\n * @param options - An optional object containing comparator, limit and offset properties\n * @returns A piped operator that orders the elements and limits the number of results\n */\nexport function orderByWithIndex<\n  T extends KeyValue<unknown, unknown>,\n  Ve = unknown,\n>(\n  valueExtractor: (\n    value: T extends KeyValue<unknown, infer V> ? V : never\n  ) => Ve,\n  options?: OrderByOptions<Ve>\n) {\n  const limit = options?.limit ?? Infinity\n  const offset = options?.offset ?? 0\n  const comparator =\n    options?.comparator ??\n    ((a, b) => {\n      // Default to JS like ordering\n      if (a === b) return 0\n      if (a < b) return -1\n      return 1\n    })\n\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<\n    KeyValue<\n      T extends KeyValue<infer K, unknown> ? K : never,\n      [T extends KeyValue<unknown, infer V> ? V : never, number]\n    >\n  > => {\n    type KeyType = T extends KeyValue<infer K, unknown> ? K : never\n    type ValueType = T extends KeyValue<unknown, infer V> ? V : never\n\n    return stream.pipe(\n      map(\n        ([key, value]) =>\n          [\n            null,\n            [\n              key,\n              valueExtractor(\n                value as T extends KeyValue<unknown, infer V> ? V : never\n              ),\n            ],\n          ] as KeyValue<null, [KeyType, Ve]>\n      ),\n      topKWithIndex((a, b) => comparator(a[1], b[1]), { limit, offset }),\n      map(([_, [[key], index]]) => [key, index] as KeyValue<KeyType, number>),\n      innerJoin(stream),\n      map(([key, [index, value]]) => {\n        return [key, [value, index]] as KeyValue<KeyType, [ValueType, number]>\n      }),\n      consolidate()\n    )\n  }\n}\n\nexport function orderByWithFractionalIndexBase<\n  T extends KeyValue<unknown, unknown>,\n  Ve = unknown,\n>(\n  topKFunction: typeof topKWithFractionalIndex,\n  valueExtractor: (\n    value: T extends KeyValue<unknown, infer V> ? V : never\n  ) => Ve,\n  options?: OrderByWithFractionalIndexOptions<Ve>\n) {\n  type KeyType = T extends KeyValue<infer K, unknown> ? K : never\n  type ValueType = T extends KeyValue<unknown, infer V> ? V : never\n\n  const limit = options?.limit ?? Infinity\n  const offset = options?.offset ?? 0\n  const setSizeCallback = options?.setSizeCallback\n  const setWindowFn = options?.setWindowFn\n  const comparator =\n    options?.comparator ??\n    ((a, b) => {\n      // Default to JS like ordering\n      if (a === b) return 0\n      if (a < b) return -1\n      return 1\n    })\n\n  return (\n    stream: IStreamBuilder<T>\n  ): IStreamBuilder<[KeyType, [ValueType, string]]> => {\n    return stream.pipe(\n      topKFunction(\n        (a: ValueType, b: ValueType) =>\n          comparator(valueExtractor(a), valueExtractor(b)),\n        {\n          limit,\n          offset,\n          setSizeCallback,\n          setWindowFn,\n        }\n      ),\n      consolidate()\n    )\n  }\n}\n\n/**\n * Orders the elements and limits the number of results, with optional offset and\n * annotates the value with a fractional index.\n * This requires a keyed stream, and uses the `topKWithFractionalIndex` operator to order all the elements.\n *\n * @param valueExtractor - A function that extracts the value to order by from the element\n * @param options - An optional object containing comparator, limit and offset properties\n * @returns A piped operator that orders the elements and limits the number of results\n */\nexport function orderByWithFractionalIndex<\n  T extends KeyValue<unknown, unknown>,\n  Ve = unknown,\n>(\n  valueExtractor: (\n    value: T extends KeyValue<unknown, infer V> ? V : never\n  ) => Ve,\n  options?: OrderByWithFractionalIndexOptions<Ve>\n) {\n  return orderByWithFractionalIndexBase(\n    topKWithFractionalIndex,\n    valueExtractor,\n    options\n  )\n}\n", "import { filter, groupBy, groupByOperators, map } from \"@tanstack/db-ivm\"\nimport { Func, PropRef, getHavingExpression } from \"../ir.js\"\nimport {\n  AggregateFunctionNotInSelectError,\n  NonAggregateExpressionNotInGroupByError,\n  UnknownHavingExpressionTypeError,\n  UnsupportedAggregateFunctionError,\n} from \"../../errors.js\"\nimport { compileExpression, toBooleanPredicate } from \"./evaluators.js\"\nimport type {\n  Aggregate,\n  BasicExpression,\n  GroupBy,\n  Having,\n  Select,\n} from \"../ir.js\"\nimport type { NamespacedAndKeyedStream, NamespacedRow } from \"../../types.js\"\n\nconst { sum, count, avg, min, max } = groupByOperators\n\n/**\n * Interface for caching the mapping between GROUP BY expressions and SELECT expressions\n */\ninterface GroupBySelectMapping {\n  selectToGroupByIndex: Map<string, number> // Maps SELECT alias to GROUP BY expression index\n  groupByExpressions: Array<any> // The GROUP BY expressions for reference\n}\n\n/**\n * Validates that all non-aggregate expressions in SELECT are present in GROUP BY\n * and creates a cached mapping for efficient lookup during processing\n */\nfunction validateAndCreateMapping(\n  groupByClause: GroupBy,\n  selectClause?: Select\n): GroupBySelectMapping {\n  const selectToGroupByIndex = new Map<string, number>()\n  const groupByExpressions = [...groupByClause]\n\n  if (!selectClause) {\n    return { selectToGroupByIndex, groupByExpressions }\n  }\n\n  // Validate each SELECT expression\n  for (const [alias, expr] of Object.entries(selectClause)) {\n    if (expr.type === `agg`) {\n      // Aggregate expressions are allowed and don't need to be in GROUP BY\n      continue\n    }\n\n    // Non-aggregate expression must be in GROUP BY\n    const groupIndex = groupByExpressions.findIndex((groupExpr) =>\n      expressionsEqual(expr, groupExpr)\n    )\n\n    if (groupIndex === -1) {\n      throw new NonAggregateExpressionNotInGroupByError(alias)\n    }\n\n    // Cache the mapping\n    selectToGroupByIndex.set(alias, groupIndex)\n  }\n\n  return { selectToGroupByIndex, groupByExpressions }\n}\n\n/**\n * Processes the GROUP BY clause with optional HAVING and SELECT\n * Works with the new __select_results structure from early SELECT processing\n */\nexport function processGroupBy(\n  pipeline: NamespacedAndKeyedStream,\n  groupByClause: GroupBy,\n  havingClauses?: Array<Having>,\n  selectClause?: Select,\n  fnHavingClauses?: Array<(row: any) => any>\n): NamespacedAndKeyedStream {\n  // Handle empty GROUP BY (single-group aggregation)\n  if (groupByClause.length === 0) {\n    // For single-group aggregation, create a single group with all data\n    const aggregates: Record<string, any> = {}\n\n    if (selectClause) {\n      // Scan the SELECT clause for aggregate functions\n      for (const [alias, expr] of Object.entries(selectClause)) {\n        if (expr.type === `agg`) {\n          const aggExpr = expr\n          aggregates[alias] = getAggregateFunction(aggExpr)\n        }\n      }\n    }\n\n    // Use a constant key for single group\n    const keyExtractor = () => ({ __singleGroup: true })\n\n    // Apply the groupBy operator with single group\n    pipeline = pipeline.pipe(\n      groupBy(keyExtractor, aggregates)\n    ) as NamespacedAndKeyedStream\n\n    // Update __select_results to include aggregate values\n    pipeline = pipeline.pipe(\n      map(([, aggregatedRow]) => {\n        // Start with the existing __select_results from early SELECT processing\n        const selectResults = (aggregatedRow as any).__select_results || {}\n        const finalResults: Record<string, any> = { ...selectResults }\n\n        if (selectClause) {\n          // Update with aggregate results\n          for (const [alias, expr] of Object.entries(selectClause)) {\n            if (expr.type === `agg`) {\n              finalResults[alias] = aggregatedRow[alias]\n            }\n            // Non-aggregates keep their original values from early SELECT processing\n          }\n        }\n\n        // Use a single key for the result and update __select_results\n        return [\n          `single_group`,\n          {\n            ...aggregatedRow,\n            __select_results: finalResults,\n          },\n        ] as [unknown, Record<string, any>]\n      })\n    )\n\n    // Apply HAVING clauses if present\n    if (havingClauses && havingClauses.length > 0) {\n      for (const havingClause of havingClauses) {\n        const havingExpression = getHavingExpression(havingClause)\n        const transformedHavingClause = replaceAggregatesByRefs(\n          havingExpression,\n          selectClause || {}\n        )\n        const compiledHaving = compileExpression(transformedHavingClause)\n\n        pipeline = pipeline.pipe(\n          filter(([, row]) => {\n            // Create a namespaced row structure for HAVING evaluation\n            const namespacedRow = { result: (row as any).__select_results }\n            return toBooleanPredicate(compiledHaving(namespacedRow))\n          })\n        )\n      }\n    }\n\n    // Apply functional HAVING clauses if present\n    if (fnHavingClauses && fnHavingClauses.length > 0) {\n      for (const fnHaving of fnHavingClauses) {\n        pipeline = pipeline.pipe(\n          filter(([, row]) => {\n            // Create a namespaced row structure for functional HAVING evaluation\n            const namespacedRow = { result: (row as any).__select_results }\n            return toBooleanPredicate(fnHaving(namespacedRow))\n          })\n        )\n      }\n    }\n\n    return pipeline\n  }\n\n  // Multi-group aggregation logic...\n  // Validate and create mapping for non-aggregate expressions in SELECT\n  const mapping = validateAndCreateMapping(groupByClause, selectClause)\n\n  // Pre-compile groupBy expressions\n  const compiledGroupByExpressions = groupByClause.map((e) =>\n    compileExpression(e)\n  )\n\n  // Create a key extractor function using simple __key_X format\n  const keyExtractor = ([, row]: [\n    string,\n    NamespacedRow & { __select_results?: any },\n  ]) => {\n    // Use the original namespaced row for GROUP BY expressions, not __select_results\n    const namespacedRow = { ...row }\n    delete (namespacedRow as any).__select_results\n\n    const key: Record<string, unknown> = {}\n\n    // Use simple __key_X format for each groupBy expression\n    for (let i = 0; i < groupByClause.length; i++) {\n      const compiledExpr = compiledGroupByExpressions[i]!\n      const value = compiledExpr(namespacedRow)\n      key[`__key_${i}`] = value\n    }\n\n    return key\n  }\n\n  // Create aggregate functions for any aggregated columns in the SELECT clause\n  const aggregates: Record<string, any> = {}\n\n  if (selectClause) {\n    // Scan the SELECT clause for aggregate functions\n    for (const [alias, expr] of Object.entries(selectClause)) {\n      if (expr.type === `agg`) {\n        const aggExpr = expr\n        aggregates[alias] = getAggregateFunction(aggExpr)\n      }\n    }\n  }\n\n  // Apply the groupBy operator\n  pipeline = pipeline.pipe(groupBy(keyExtractor, aggregates))\n\n  // Update __select_results to handle GROUP BY results\n  pipeline = pipeline.pipe(\n    map(([, aggregatedRow]) => {\n      // Start with the existing __select_results from early SELECT processing\n      const selectResults = (aggregatedRow as any).__select_results || {}\n      const finalResults: Record<string, any> = {}\n\n      if (selectClause) {\n        // Process each SELECT expression\n        for (const [alias, expr] of Object.entries(selectClause)) {\n          if (expr.type !== `agg`) {\n            // Use cached mapping to get the corresponding __key_X for non-aggregates\n            const groupIndex = mapping.selectToGroupByIndex.get(alias)\n            if (groupIndex !== undefined) {\n              finalResults[alias] = aggregatedRow[`__key_${groupIndex}`]\n            } else {\n              // Fallback to original SELECT results\n              finalResults[alias] = selectResults[alias]\n            }\n          } else {\n            // Use aggregate results\n            finalResults[alias] = aggregatedRow[alias]\n          }\n        }\n      } else {\n        // No SELECT clause - just use the group keys\n        for (let i = 0; i < groupByClause.length; i++) {\n          finalResults[`__key_${i}`] = aggregatedRow[`__key_${i}`]\n        }\n      }\n\n      // Generate a simple key for the live collection using group values\n      let finalKey: unknown\n      if (groupByClause.length === 1) {\n        finalKey = aggregatedRow[`__key_0`]\n      } else {\n        const keyParts: Array<unknown> = []\n        for (let i = 0; i < groupByClause.length; i++) {\n          keyParts.push(aggregatedRow[`__key_${i}`])\n        }\n        finalKey = JSON.stringify(keyParts)\n      }\n\n      return [\n        finalKey,\n        {\n          ...aggregatedRow,\n          __select_results: finalResults,\n        },\n      ] as [unknown, Record<string, any>]\n    })\n  )\n\n  // Apply HAVING clauses if present\n  if (havingClauses && havingClauses.length > 0) {\n    for (const havingClause of havingClauses) {\n      const havingExpression = getHavingExpression(havingClause)\n      const transformedHavingClause = replaceAggregatesByRefs(\n        havingExpression,\n        selectClause || {}\n      )\n      const compiledHaving = compileExpression(transformedHavingClause)\n\n      pipeline = pipeline.pipe(\n        filter(([, row]) => {\n          // Create a namespaced row structure for HAVING evaluation\n          const namespacedRow = { result: (row as any).__select_results }\n          return compiledHaving(namespacedRow)\n        })\n      )\n    }\n  }\n\n  // Apply functional HAVING clauses if present\n  if (fnHavingClauses && fnHavingClauses.length > 0) {\n    for (const fnHaving of fnHavingClauses) {\n      pipeline = pipeline.pipe(\n        filter(([, row]) => {\n          // Create a namespaced row structure for functional HAVING evaluation\n          const namespacedRow = { result: (row as any).__select_results }\n          return toBooleanPredicate(fnHaving(namespacedRow))\n        })\n      )\n    }\n  }\n\n  return pipeline\n}\n\n/**\n * Helper function to check if two expressions are equal\n */\nfunction expressionsEqual(expr1: any, expr2: any): boolean {\n  if (!expr1 || !expr2) return false\n  if (expr1.type !== expr2.type) return false\n\n  switch (expr1.type) {\n    case `ref`:\n      // Compare paths as arrays\n      if (!expr1.path || !expr2.path) return false\n      if (expr1.path.length !== expr2.path.length) return false\n      return expr1.path.every(\n        (segment: string, i: number) => segment === expr2.path[i]\n      )\n    case `val`:\n      return expr1.value === expr2.value\n    case `func`:\n      return (\n        expr1.name === expr2.name &&\n        expr1.args?.length === expr2.args?.length &&\n        (expr1.args || []).every((arg: any, i: number) =>\n          expressionsEqual(arg, expr2.args[i])\n        )\n      )\n    case `agg`:\n      return (\n        expr1.name === expr2.name &&\n        expr1.args?.length === expr2.args?.length &&\n        (expr1.args || []).every((arg: any, i: number) =>\n          expressionsEqual(arg, expr2.args[i])\n        )\n      )\n    default:\n      return false\n  }\n}\n\n/**\n * Helper function to get an aggregate function based on the Agg expression\n */\nfunction getAggregateFunction(aggExpr: Aggregate) {\n  // Pre-compile the value extractor expression\n  const compiledExpr = compileExpression(aggExpr.args[0]!)\n\n  // Create a value extractor function for the expression to aggregate\n  const valueExtractor = ([, namespacedRow]: [string, NamespacedRow]) => {\n    const value = compiledExpr(namespacedRow)\n    // Ensure we return a number for numeric aggregate functions\n    return typeof value === `number` ? value : value != null ? Number(value) : 0\n  }\n\n  // Create a value extractor function for the expression to aggregate\n  const valueExtractorWithDate = ([, namespacedRow]: [\n    string,\n    NamespacedRow,\n  ]) => {\n    const value = compiledExpr(namespacedRow)\n    return typeof value === `number` || value instanceof Date\n      ? value\n      : value != null\n        ? Number(value)\n        : 0\n  }\n\n  // Create a raw value extractor function for the expression to aggregate\n  const rawValueExtractor = ([, namespacedRow]: [string, NamespacedRow]) => {\n    return compiledExpr(namespacedRow)\n  }\n\n  // Return the appropriate aggregate function\n  switch (aggExpr.name.toLowerCase()) {\n    case `sum`:\n      return sum(valueExtractor)\n    case `count`:\n      return count(rawValueExtractor)\n    case `avg`:\n      return avg(valueExtractor)\n    case `min`:\n      return min(valueExtractorWithDate)\n    case `max`:\n      return max(valueExtractorWithDate)\n    default:\n      throw new UnsupportedAggregateFunctionError(aggExpr.name)\n  }\n}\n\n/**\n * Transforms basic expressions and aggregates to replace Agg expressions with references to computed values\n */\nexport function replaceAggregatesByRefs(\n  havingExpr: BasicExpression | Aggregate,\n  selectClause: Select,\n  resultAlias: string = `result`\n): BasicExpression {\n  switch (havingExpr.type) {\n    case `agg`: {\n      const aggExpr = havingExpr\n      // Find matching aggregate in SELECT clause\n      for (const [alias, selectExpr] of Object.entries(selectClause)) {\n        if (selectExpr.type === `agg` && aggregatesEqual(aggExpr, selectExpr)) {\n          // Replace with a reference to the computed aggregate\n          return new PropRef([resultAlias, alias])\n        }\n      }\n      // If no matching aggregate found in SELECT, throw error\n      throw new AggregateFunctionNotInSelectError(aggExpr.name)\n    }\n\n    case `func`: {\n      const funcExpr = havingExpr\n      // Transform function arguments recursively\n      const transformedArgs = funcExpr.args.map(\n        (arg: BasicExpression | Aggregate) =>\n          replaceAggregatesByRefs(arg, selectClause)\n      )\n      return new Func(funcExpr.name, transformedArgs)\n    }\n\n    case `ref`: {\n      // Non-aggregate refs are passed through unchanged (they reference table columns)\n      return havingExpr as BasicExpression\n    }\n\n    case `val`:\n      // Return as-is\n      return havingExpr as BasicExpression\n\n    default:\n      throw new UnknownHavingExpressionTypeError((havingExpr as any).type)\n  }\n}\n\n/**\n * Checks if two aggregate expressions are equal\n */\nfunction aggregatesEqual(agg1: Aggregate, agg2: Aggregate): boolean {\n  return (\n    agg1.name === agg2.name &&\n    agg1.args.length === agg2.args.length &&\n    agg1.args.every((arg, i) => expressionsEqual(arg, agg2.args[i]))\n  )\n}\n", "import { orderByWithFractionalIndex } from \"@tanstack/db-ivm\"\nimport { defaultComparator, makeComparator } from \"../../utils/comparison.js\"\nimport { PropRef, followRef } from \"../ir.js\"\nimport { ensureIndexForField } from \"../../indexes/auto-index.js\"\nimport { findIndexForField } from \"../../utils/index-optimization.js\"\nimport { compileExpression } from \"./evaluators.js\"\nimport { replaceAggregatesByRefs } from \"./group-by.js\"\nimport type { CompareOptions } from \"../builder/types.js\"\nimport type { WindowOptions } from \"./types.js\"\nimport type { CompiledSingleRowExpression } from \"./evaluators.js\"\nimport type { OrderBy, OrderByClause, QueryIR, Select } from \"../ir.js\"\nimport type {\n  CollectionLike,\n  NamespacedAndKeyedStream,\n  NamespacedRow,\n} from \"../../types.js\"\nimport type { IStreamBuilder, KeyValue } from \"@tanstack/db-ivm\"\nimport type { IndexInterface } from \"../../indexes/base-index.js\"\nimport type { Collection } from \"../../collection/index.js\"\n\nexport type OrderByOptimizationInfo = {\n  alias: string\n  orderBy: OrderBy\n  offset: number\n  limit: number\n  comparator: (\n    a: Record<string, unknown> | null | undefined,\n    b: Record<string, unknown> | null | undefined\n  ) => number\n  valueExtractorForRawRow: (row: Record<string, unknown>) => any\n  index: IndexInterface<string | number>\n  dataNeeded?: () => number\n}\n\n/**\n * Processes the ORDER BY clause\n * Works with the new structure that has both namespaced row data and __select_results\n * Always uses fractional indexing and adds the index as __ordering_index to the result\n */\nexport function processOrderBy(\n  rawQuery: QueryIR,\n  pipeline: NamespacedAndKeyedStream,\n  orderByClause: Array<OrderByClause>,\n  selectClause: Select,\n  collection: Collection,\n  optimizableOrderByCollections: Record<string, OrderByOptimizationInfo>,\n  setWindowFn: (windowFn: (options: WindowOptions) => void) => void,\n  limit?: number,\n  offset?: number\n): IStreamBuilder<KeyValue<unknown, [NamespacedRow, string]>> {\n  // Pre-compile all order by expressions\n  const compiledOrderBy = orderByClause.map((clause) => {\n    const clauseWithoutAggregates = replaceAggregatesByRefs(\n      clause.expression,\n      selectClause,\n      `__select_results`\n    )\n\n    return {\n      compiledExpression: compileExpression(clauseWithoutAggregates),\n      compareOptions: buildCompareOptions(clause, collection),\n    }\n  })\n\n  // Create a value extractor function for the orderBy operator\n  const valueExtractor = (row: NamespacedRow & { __select_results?: any }) => {\n    // The namespaced row contains:\n    // 1. Table aliases as top-level properties (e.g., row[\"tableName\"])\n    // 2. SELECT results in __select_results (e.g., row.__select_results[\"aggregateAlias\"])\n    // The replaceAggregatesByRefs function has already transformed any aggregate expressions\n    // that match SELECT aggregates to use the __select_results namespace.\n    const orderByContext = row\n\n    if (orderByClause.length > 1) {\n      // For multiple orderBy columns, create a composite key\n      return compiledOrderBy.map((compiled) =>\n        compiled.compiledExpression(orderByContext)\n      )\n    } else if (orderByClause.length === 1) {\n      // For a single orderBy column, use the value directly\n      const compiled = compiledOrderBy[0]!\n      return compiled.compiledExpression(orderByContext)\n    }\n\n    // Default case - no ordering\n    return null\n  }\n\n  // Create a multi-property comparator that respects the order and direction of each property\n  const compare = (a: unknown, b: unknown) => {\n    // If we're comparing arrays (multiple properties), compare each property in order\n    if (orderByClause.length > 1) {\n      const arrayA = a as Array<unknown>\n      const arrayB = b as Array<unknown>\n      for (let i = 0; i < orderByClause.length; i++) {\n        const clause = compiledOrderBy[i]!\n        const compareFn = makeComparator(clause.compareOptions)\n        const result = compareFn(arrayA[i], arrayB[i])\n        if (result !== 0) {\n          return result\n        }\n      }\n      return arrayA.length - arrayB.length\n    }\n\n    // Single property comparison\n    if (orderByClause.length === 1) {\n      const clause = compiledOrderBy[0]!\n      const compareFn = makeComparator(clause.compareOptions)\n      return compareFn(a, b)\n    }\n\n    return defaultComparator(a, b)\n  }\n\n  let setSizeCallback: ((getSize: () => number) => void) | undefined\n\n  let orderByOptimizationInfo: OrderByOptimizationInfo | undefined\n\n  // Optimize the orderBy operator to lazily load elements\n  // by using the range index of the collection.\n  // Only for orderBy clause on a single column for now (no composite ordering)\n  if (limit && orderByClause.length === 1) {\n    const clause = orderByClause[0]!\n    const orderByExpression = clause.expression\n\n    if (orderByExpression.type === `ref`) {\n      const followRefResult = followRef(\n        rawQuery,\n        orderByExpression,\n        collection\n      )!\n\n      const followRefCollection = followRefResult.collection\n      const fieldName = followRefResult.path[0]\n      const compareOpts = buildCompareOptions(clause, followRefCollection)\n      if (fieldName) {\n        ensureIndexForField(\n          fieldName,\n          followRefResult.path,\n          followRefCollection,\n          compareOpts,\n          compare\n        )\n      }\n\n      const valueExtractorForRawRow = compileExpression(\n        new PropRef(followRefResult.path),\n        true\n      ) as CompiledSingleRowExpression\n\n      const comparator = (\n        a: Record<string, unknown> | null | undefined,\n        b: Record<string, unknown> | null | undefined\n      ) => {\n        const extractedA = a ? valueExtractorForRawRow(a) : a\n        const extractedB = b ? valueExtractorForRawRow(b) : b\n        return compare(extractedA, extractedB)\n      }\n\n      const index: IndexInterface<string | number> | undefined =\n        findIndexForField(\n          followRefCollection,\n          followRefResult.path,\n          compareOpts\n        )\n\n      if (index && index.supports(`gt`)) {\n        // We found an index that we can use to lazily load ordered data\n        const orderByAlias =\n          orderByExpression.path.length > 1\n            ? String(orderByExpression.path[0])\n            : rawQuery.from.alias\n\n        orderByOptimizationInfo = {\n          alias: orderByAlias,\n          offset: offset ?? 0,\n          limit,\n          comparator,\n          valueExtractorForRawRow,\n          index,\n          orderBy: orderByClause,\n        }\n\n        optimizableOrderByCollections[followRefCollection.id] =\n          orderByOptimizationInfo\n\n        setSizeCallback = (getSize: () => number) => {\n          optimizableOrderByCollections[followRefCollection.id]![`dataNeeded`] =\n            () => {\n              const size = getSize()\n              return Math.max(0, orderByOptimizationInfo!.limit - size)\n            }\n        }\n      }\n    }\n  }\n\n  // Use fractional indexing and return the tuple [value, index]\n  return pipeline.pipe(\n    orderByWithFractionalIndex(valueExtractor, {\n      limit,\n      offset,\n      comparator: compare,\n      setSizeCallback,\n      setWindowFn: (\n        windowFn: (options: { offset?: number; limit?: number }) => void\n      ) => {\n        setWindowFn(\n          // We wrap the move function such that we update the orderByOptimizationInfo\n          // because that is used by the `dataNeeded` callback to determine if we need to load more data\n          (options) => {\n            windowFn(options)\n            if (orderByOptimizationInfo) {\n              orderByOptimizationInfo.offset =\n                options.offset ?? orderByOptimizationInfo.offset\n              orderByOptimizationInfo.limit =\n                options.limit ?? orderByOptimizationInfo.limit\n            }\n          }\n        )\n      },\n    })\n    // orderByWithFractionalIndex returns [key, [value, index]] - we keep this format\n  )\n}\n\n/**\n * Builds a comparison configuration object that uses the values provided in the orderBy clause.\n * If no string sort configuration is provided it defaults to the collection's string sort configuration.\n */\nexport function buildCompareOptions(\n  clause: OrderByClause,\n  collection: CollectionLike<any, any>\n): CompareOptions {\n  if (clause.compareOptions.stringSort !== undefined) {\n    return clause.compareOptions\n  }\n\n  return {\n    ...collection.compareOptions,\n    direction: clause.compareOptions.direction,\n    nulls: clause.compareOptions.nulls,\n  }\n}\n", "import {\n  createSingleRowRefProxy,\n  toExpression,\n} from \"../query/builder/ref-proxy\"\nimport {\n  compileSingleRowExpression,\n  toBooleanPredicate,\n} from \"../query/compiler/evaluators.js\"\nimport {\n  findIndexForField,\n  optimizeExpressionWithIndexes,\n} from \"../utils/index-optimization.js\"\nimport { ensureIndexForField } from \"../indexes/auto-index.js\"\nimport { makeComparator } from \"../utils/comparison.js\"\nimport { buildCompareOptions } from \"../query/compiler/order-by\"\nimport type {\n  ChangeMessage,\n  CollectionLike,\n  CurrentStateAsChangesOptions,\n  SubscribeChangesOptions,\n} from \"../types\"\nimport type { CollectionImpl } from \"./index.js\"\nimport type { SingleRowRefProxy } from \"../query/builder/ref-proxy\"\nimport type { BasicExpression, OrderBy } from \"../query/ir.js\"\n\n/**\n * Returns the current state of the collection as an array of changes\n * @param collection - The collection to get changes from\n * @param options - Options including optional where filter, orderBy, and limit\n * @returns An array of changes\n * @example\n * // Get all items as changes\n * const allChanges = currentStateAsChanges(collection)\n *\n * // Get only items matching a condition\n * const activeChanges = currentStateAsChanges(collection, {\n *   where: (row) => row.status === 'active'\n * })\n *\n * // Get only items using a pre-compiled expression\n * const activeChanges = currentStateAsChanges(collection, {\n *   where: eq(row.status, 'active')\n * })\n *\n * // Get items ordered by name with limit\n * const topUsers = currentStateAsChanges(collection, {\n *   orderBy: [{ expression: row.name, compareOptions: { direction: 'asc' } }],\n *   limit: 10\n * })\n *\n * // Get active users ordered by score (highest score first)\n * const topActiveUsers = currentStateAsChanges(collection, {\n *   where: eq(row.status, 'active'),\n *   orderBy: [{ expression: row.score, compareOptions: { direction: 'desc' } }],\n * })\n */\nexport function currentStateAsChanges<\n  T extends object,\n  TKey extends string | number,\n>(\n  collection: CollectionLike<T, TKey>,\n  options: CurrentStateAsChangesOptions = {}\n): Array<ChangeMessage<T>> | void {\n  // Helper function to collect filtered results\n  const collectFilteredResults = (\n    filterFn?: (value: T) => boolean\n  ): Array<ChangeMessage<T>> => {\n    const result: Array<ChangeMessage<T>> = []\n    for (const [key, value] of collection.entries()) {\n      // If no filter function is provided, include all items\n      if (filterFn?.(value) ?? true) {\n        result.push({\n          type: `insert`,\n          key,\n          value,\n        })\n      }\n    }\n    return result\n  }\n\n  // Validate that limit without orderBy doesn't happen\n  if (options.limit !== undefined && !options.orderBy) {\n    throw new Error(`limit cannot be used without orderBy`)\n  }\n\n  // First check if orderBy is present (optionally with limit)\n  if (options.orderBy) {\n    // Create where filter function if present\n    const whereFilter = options.where\n      ? createFilterFunctionFromExpression(options.where)\n      : undefined\n\n    // Get ordered keys using index optimization when possible\n    const orderedKeys = getOrderedKeys(\n      collection,\n      options.orderBy,\n      options.limit,\n      whereFilter,\n      options.optimizedOnly\n    )\n\n    if (orderedKeys === undefined) {\n      // `getOrderedKeys` returned undefined because we asked for `optimizedOnly` and there was no index to use\n      return\n    }\n\n    // Convert keys to change messages\n    const result: Array<ChangeMessage<T>> = []\n    for (const key of orderedKeys) {\n      const value = collection.get(key)\n      if (value !== undefined) {\n        result.push({\n          type: `insert`,\n          key,\n          value,\n        })\n      }\n    }\n    return result\n  }\n\n  // If no orderBy OR orderBy optimization failed, use where clause optimization\n  if (!options.where) {\n    // No filtering, return all items\n    return collectFilteredResults()\n  }\n\n  // There's a where clause, let's see if we can use an index\n  try {\n    const expression: BasicExpression<boolean> = options.where\n\n    // Try to optimize the query using indexes\n    const optimizationResult = optimizeExpressionWithIndexes(\n      expression,\n      collection\n    )\n\n    if (optimizationResult.canOptimize) {\n      // Use index optimization\n      const result: Array<ChangeMessage<T>> = []\n      for (const key of optimizationResult.matchingKeys) {\n        const value = collection.get(key)\n        if (value !== undefined) {\n          result.push({\n            type: `insert`,\n            key,\n            value,\n          })\n        }\n      }\n      return result\n    } else {\n      if (options.optimizedOnly) {\n        return\n      }\n\n      const filterFn = createFilterFunctionFromExpression(expression)\n      return collectFilteredResults(filterFn)\n    }\n  } catch (error) {\n    // If anything goes wrong with the where clause, fall back to full scan\n    console.warn(\n      `${collection.id ? `[${collection.id}] ` : ``}Error processing where clause, falling back to full scan:`,\n      error\n    )\n\n    const filterFn = createFilterFunctionFromExpression(options.where)\n\n    if (options.optimizedOnly) {\n      return\n    }\n\n    return collectFilteredResults(filterFn)\n  }\n}\n\n/**\n * Creates a filter function from a where callback\n * @param whereCallback - The callback function that defines the filter condition\n * @returns A function that takes an item and returns true if it matches the filter\n */\nexport function createFilterFunction<T extends object>(\n  whereCallback: (row: SingleRowRefProxy<T>) => any\n): (item: T) => boolean {\n  return (item: T): boolean => {\n    try {\n      // First try the RefProxy approach for query builder functions\n      const singleRowRefProxy = createSingleRowRefProxy<T>()\n      const whereExpression = whereCallback(singleRowRefProxy)\n      const expression = toExpression(whereExpression)\n      const evaluator = compileSingleRowExpression(expression)\n      const result = evaluator(item as Record<string, unknown>)\n      // WHERE clauses should always evaluate to boolean predicates (Kevin's feedback)\n      return toBooleanPredicate(result)\n    } catch {\n      // If RefProxy approach fails (e.g., arithmetic operations), fall back to direct evaluation\n      try {\n        // Create a simple proxy that returns actual values for arithmetic operations\n        const simpleProxy = new Proxy(item as any, {\n          get(target, prop) {\n            return target[prop]\n          },\n        }) as SingleRowRefProxy<T>\n\n        const result = whereCallback(simpleProxy)\n        return toBooleanPredicate(result)\n      } catch {\n        // If both approaches fail, exclude the item\n        return false\n      }\n    }\n  }\n}\n\n/**\n * Creates a filter function from a pre-compiled expression\n * @param expression - The pre-compiled expression to evaluate\n * @returns A function that takes an item and returns true if it matches the filter\n */\nexport function createFilterFunctionFromExpression<T extends object>(\n  expression: BasicExpression<boolean>\n): (item: T) => boolean {\n  return (item: T): boolean => {\n    try {\n      const evaluator = compileSingleRowExpression(expression)\n      const result = evaluator(item as Record<string, unknown>)\n      return toBooleanPredicate(result)\n    } catch {\n      // If evaluation fails, exclude the item\n      return false\n    }\n  }\n}\n\n/**\n * Creates a filtered callback that only calls the original callback with changes that match the where clause\n * @param originalCallback - The original callback to filter\n * @param options - The subscription options containing the where clause\n * @returns A filtered callback function\n */\nexport function createFilteredCallback<T extends object>(\n  originalCallback: (changes: Array<ChangeMessage<T>>) => void,\n  options: SubscribeChangesOptions\n): (changes: Array<ChangeMessage<T>>) => void {\n  const filterFn = createFilterFunctionFromExpression(options.whereExpression!)\n\n  return (changes: Array<ChangeMessage<T>>) => {\n    const filteredChanges: Array<ChangeMessage<T>> = []\n\n    for (const change of changes) {\n      if (change.type === `insert`) {\n        // For inserts, check if the new value matches the filter\n        if (filterFn(change.value)) {\n          filteredChanges.push(change)\n        }\n      } else if (change.type === `update`) {\n        // For updates, we need to check both old and new values\n        const newValueMatches = filterFn(change.value)\n        const oldValueMatches = change.previousValue\n          ? filterFn(change.previousValue)\n          : false\n\n        if (newValueMatches && oldValueMatches) {\n          // Both old and new match: emit update\n          filteredChanges.push(change)\n        } else if (newValueMatches && !oldValueMatches) {\n          // New matches but old didn't: emit insert\n          filteredChanges.push({\n            ...change,\n            type: `insert`,\n          })\n        } else if (!newValueMatches && oldValueMatches) {\n          // Old matched but new doesn't: emit delete\n          filteredChanges.push({\n            ...change,\n            type: `delete`,\n            value: change.previousValue!, // Use the previous value for the delete\n          })\n        }\n        // If neither matches, don't emit anything\n      } else {\n        // For deletes, include if the previous value would have matched\n        // (so subscribers know something they were tracking was deleted)\n        if (filterFn(change.value)) {\n          filteredChanges.push(change)\n        }\n      }\n    }\n\n    // Always call the original callback if we have filtered changes OR\n    // if the original changes array was empty (which indicates a ready signal)\n    if (filteredChanges.length > 0 || changes.length === 0) {\n      originalCallback(filteredChanges)\n    }\n  }\n}\n\n/**\n * Gets ordered keys from a collection using index optimization when possible\n * @param collection - The collection to get keys from\n * @param orderBy - The order by clause\n * @param limit - Optional limit on number of keys to return\n * @param whereFilter - Optional filter function to apply while traversing\n * @returns Array of keys in sorted order\n */\nfunction getOrderedKeys<T extends object, TKey extends string | number>(\n  collection: CollectionLike<T, TKey>,\n  orderBy: OrderBy,\n  limit?: number,\n  whereFilter?: (item: T) => boolean,\n  optimizedOnly?: boolean\n): Array<TKey> | undefined {\n  // For single-column orderBy on a ref expression, try index optimization\n  if (orderBy.length === 1) {\n    const clause = orderBy[0]!\n    const orderByExpression = clause.expression\n\n    if (orderByExpression.type === `ref`) {\n      const propRef = orderByExpression\n      const fieldPath = propRef.path\n      const compareOpts = buildCompareOptions(clause, collection)\n\n      // Ensure index exists for this field\n      ensureIndexForField(\n        fieldPath[0]!,\n        fieldPath,\n        collection as CollectionImpl<T, TKey>,\n        compareOpts\n      )\n\n      // Find the index\n      const index = findIndexForField(collection, fieldPath, compareOpts)\n\n      if (index && index.supports(`gt`)) {\n        // Use index optimization\n        const filterFn = (key: TKey): boolean => {\n          const value = collection.get(key)\n          if (value === undefined) {\n            return false\n          }\n          return whereFilter?.(value) ?? true\n        }\n\n        // Take the keys that match the filter and limit\n        // if no limit is provided `index.keyCount` is used,\n        // i.e. we will take all keys that match the filter\n        return index.take(limit ?? index.keyCount, undefined, filterFn)\n      }\n    }\n  }\n\n  if (optimizedOnly) {\n    return\n  }\n\n  // Fallback: collect all items and sort in memory\n  const allItems: Array<{ key: TKey; value: T }> = []\n  for (const [key, value] of collection.entries()) {\n    if (whereFilter?.(value) ?? true) {\n      allItems.push({ key, value })\n    }\n  }\n\n  // Sort using makeComparator\n  const compare = (a: { key: TKey; value: T }, b: { key: TKey; value: T }) => {\n    for (const clause of orderBy) {\n      const compareFn = makeComparator(clause.compareOptions)\n\n      // Extract values for comparison\n      const aValue = extractValueFromItem(a.value, clause.expression)\n      const bValue = extractValueFromItem(b.value, clause.expression)\n\n      const result = compareFn(aValue, bValue)\n      if (result !== 0) {\n        return result\n      }\n    }\n    return 0\n  }\n\n  allItems.sort(compare)\n  const sortedKeys = allItems.map((item) => item.key)\n\n  // Apply limit if provided\n  if (limit !== undefined) {\n    return sortedKeys.slice(0, limit)\n  }\n\n  // if no limit is provided, we will return all keys\n  return sortedKeys\n}\n\n/**\n * Helper function to extract a value from an item based on an expression\n */\nfunction extractValueFromItem(item: any, expression: BasicExpression): any {\n  if (expression.type === `ref`) {\n    const propRef = expression\n    let value = item\n    for (const pathPart of propRef.path) {\n      value = value?.[pathPart]\n    }\n    return value\n  } else if (expression.type === `val`) {\n    return expression.value\n  } else {\n    // It must be a function\n    const evaluator = compileSingleRowExpression(expression)\n    return evaluator(item as Record<string, unknown>)\n  }\n}\n", "import { deepEquals } from \"../utils\"\nimport { SortedMap } from \"../SortedMap\"\nimport type { Transaction } from \"../transactions\"\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport type {\n  ChangeMessage,\n  CollectionConfig,\n  OptimisticChangeMessage,\n} from \"../types\"\nimport type { CollectionImpl } from \"./index.js\"\nimport type { CollectionLifecycleManager } from \"./lifecycle\"\nimport type { CollectionChangesManager } from \"./changes\"\nimport type { CollectionIndexesManager } from \"./indexes\"\n\ninterface PendingSyncedTransaction<\n  T extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n> {\n  committed: boolean\n  operations: Array<OptimisticChangeMessage<T>>\n  truncate?: boolean\n  deletedKeys: Set<string | number>\n  optimisticSnapshot?: {\n    upserts: Map<TKey, T>\n    deletes: Set<TKey>\n  }\n}\n\nexport class CollectionStateManager<\n  TOutput extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n  TSchema extends StandardSchemaV1 = StandardSchemaV1,\n  TInput extends object = TOutput,\n> {\n  public config!: CollectionConfig<TOutput, TKey, TSchema>\n  public collection!: CollectionImpl<TOutput, TKey, any, TSchema, TInput>\n  public lifecycle!: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n  public changes!: CollectionChangesManager<TOutput, TKey, TSchema, TInput>\n  public indexes!: CollectionIndexesManager<TOutput, TKey, TSchema, TInput>\n\n  // Core state - make public for testing\n  public transactions: SortedMap<string, Transaction<any>>\n  public pendingSyncedTransactions: Array<\n    PendingSyncedTransaction<TOutput, TKey>\n  > = []\n  public syncedData: Map<TKey, TOutput> | SortedMap<TKey, TOutput>\n  public syncedMetadata = new Map<TKey, unknown>()\n\n  // Optimistic state tracking - make public for testing\n  public optimisticUpserts = new Map<TKey, TOutput>()\n  public optimisticDeletes = new Set<TKey>()\n\n  // Cached size for performance\n  public size = 0\n\n  // State used for computing the change events\n  public syncedKeys = new Set<TKey>()\n  public preSyncVisibleState = new Map<TKey, TOutput>()\n  public recentlySyncedKeys = new Set<TKey>()\n  public hasReceivedFirstCommit = false\n  public isCommittingSyncTransactions = false\n\n  /**\n   * Creates a new CollectionState manager\n   */\n  constructor(config: CollectionConfig<TOutput, TKey, TSchema>) {\n    this.config = config\n    this.transactions = new SortedMap<string, Transaction<any>>((a, b) =>\n      a.compareCreatedAt(b)\n    )\n\n    // Set up data storage with optional comparison function\n    if (config.compare) {\n      this.syncedData = new SortedMap<TKey, TOutput>(config.compare)\n    } else {\n      this.syncedData = new Map<TKey, TOutput>()\n    }\n  }\n\n  setDeps(deps: {\n    collection: CollectionImpl<TOutput, TKey, any, TSchema, TInput>\n    lifecycle: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n    changes: CollectionChangesManager<TOutput, TKey, TSchema, TInput>\n    indexes: CollectionIndexesManager<TOutput, TKey, TSchema, TInput>\n  }) {\n    this.collection = deps.collection\n    this.lifecycle = deps.lifecycle\n    this.changes = deps.changes\n    this.indexes = deps.indexes\n  }\n\n  /**\n   * Get the current value for a key (virtual derived state)\n   */\n  public get(key: TKey): TOutput | undefined {\n    const { optimisticDeletes, optimisticUpserts, syncedData } = this\n    // Check if optimistically deleted\n    if (optimisticDeletes.has(key)) {\n      return undefined\n    }\n\n    // Check optimistic upserts first\n    if (optimisticUpserts.has(key)) {\n      return optimisticUpserts.get(key)\n    }\n\n    // Fall back to synced data\n    return syncedData.get(key)\n  }\n\n  /**\n   * Check if a key exists in the collection (virtual derived state)\n   */\n  public has(key: TKey): boolean {\n    const { optimisticDeletes, optimisticUpserts, syncedData } = this\n    // Check if optimistically deleted\n    if (optimisticDeletes.has(key)) {\n      return false\n    }\n\n    // Check optimistic upserts first\n    if (optimisticUpserts.has(key)) {\n      return true\n    }\n\n    // Fall back to synced data\n    return syncedData.has(key)\n  }\n\n  /**\n   * Get all keys (virtual derived state)\n   */\n  public *keys(): IterableIterator<TKey> {\n    const { syncedData, optimisticDeletes, optimisticUpserts } = this\n    // Yield keys from synced data, skipping any that are deleted.\n    for (const key of syncedData.keys()) {\n      if (!optimisticDeletes.has(key)) {\n        yield key\n      }\n    }\n    // Yield keys from upserts that were not already in synced data.\n    for (const key of optimisticUpserts.keys()) {\n      if (!syncedData.has(key) && !optimisticDeletes.has(key)) {\n        // The optimisticDeletes check is technically redundant if inserts/updates always remove from deletes,\n        // but it's safer to keep it.\n        yield key\n      }\n    }\n  }\n\n  /**\n   * Get all values (virtual derived state)\n   */\n  public *values(): IterableIterator<TOutput> {\n    for (const key of this.keys()) {\n      const value = this.get(key)\n      if (value !== undefined) {\n        yield value\n      }\n    }\n  }\n\n  /**\n   * Get all entries (virtual derived state)\n   */\n  public *entries(): IterableIterator<[TKey, TOutput]> {\n    for (const key of this.keys()) {\n      const value = this.get(key)\n      if (value !== undefined) {\n        yield [key, value]\n      }\n    }\n  }\n\n  /**\n   * Get all entries (virtual derived state)\n   */\n  public *[Symbol.iterator](): IterableIterator<[TKey, TOutput]> {\n    for (const [key, value] of this.entries()) {\n      yield [key, value]\n    }\n  }\n\n  /**\n   * Execute a callback for each entry in the collection\n   */\n  public forEach(\n    callbackfn: (value: TOutput, key: TKey, index: number) => void\n  ): void {\n    let index = 0\n    for (const [key, value] of this.entries()) {\n      callbackfn(value, key, index++)\n    }\n  }\n\n  /**\n   * Create a new array with the results of calling a function for each entry in the collection\n   */\n  public map<U>(\n    callbackfn: (value: TOutput, key: TKey, index: number) => U\n  ): Array<U> {\n    const result: Array<U> = []\n    let index = 0\n    for (const [key, value] of this.entries()) {\n      result.push(callbackfn(value, key, index++))\n    }\n    return result\n  }\n\n  /**\n   * Check if the given collection is this collection\n   * @param collection The collection to check\n   * @returns True if the given collection is this collection, false otherwise\n   */\n  private isThisCollection(\n    collection: CollectionImpl<any, any, any, any, any>\n  ): boolean {\n    return collection === this.collection\n  }\n\n  /**\n   * Recompute optimistic state from active transactions\n   */\n  public recomputeOptimisticState(\n    triggeredByUserAction: boolean = false\n  ): void {\n    // Skip redundant recalculations when we're in the middle of committing sync transactions\n    // While the sync pipeline is replaying a large batch we still want to honour\n    // fresh optimistic mutations from the UI. Only skip recompute for the\n    // internal sync-driven redraws; user-triggered work (triggeredByUserAction)\n    // must run so live queries stay responsive during long commits.\n    if (this.isCommittingSyncTransactions && !triggeredByUserAction) {\n      return\n    }\n\n    const previousState = new Map(this.optimisticUpserts)\n    const previousDeletes = new Set(this.optimisticDeletes)\n\n    // Clear current optimistic state\n    this.optimisticUpserts.clear()\n    this.optimisticDeletes.clear()\n\n    const activeTransactions: Array<Transaction<any>> = []\n\n    for (const transaction of this.transactions.values()) {\n      if (![`completed`, `failed`].includes(transaction.state)) {\n        activeTransactions.push(transaction)\n      }\n    }\n\n    // Apply active transactions only (completed transactions are handled by sync operations)\n    for (const transaction of activeTransactions) {\n      for (const mutation of transaction.mutations) {\n        if (this.isThisCollection(mutation.collection) && mutation.optimistic) {\n          switch (mutation.type) {\n            case `insert`:\n            case `update`:\n              this.optimisticUpserts.set(\n                mutation.key,\n                mutation.modified as TOutput\n              )\n              this.optimisticDeletes.delete(mutation.key)\n              break\n            case `delete`:\n              this.optimisticUpserts.delete(mutation.key)\n              this.optimisticDeletes.add(mutation.key)\n              break\n          }\n        }\n      }\n    }\n\n    // Update cached size\n    this.size = this.calculateSize()\n\n    // Collect events for changes\n    const events: Array<ChangeMessage<TOutput, TKey>> = []\n    this.collectOptimisticChanges(previousState, previousDeletes, events)\n\n    // Filter out events for recently synced keys to prevent duplicates\n    // BUT: Only filter out events that are actually from sync operations\n    // New user transactions should NOT be filtered even if the key was recently synced\n    const filteredEventsBySyncStatus = events.filter((event) => {\n      if (!this.recentlySyncedKeys.has(event.key)) {\n        return true // Key not recently synced, allow event through\n      }\n\n      // Key was recently synced - allow if this is a user-triggered action\n      if (triggeredByUserAction) {\n        return true\n      }\n\n      // Otherwise filter out duplicate sync events\n      return false\n    })\n\n    // Filter out redundant delete events if there are pending sync transactions\n    // that will immediately restore the same data, but only for completed transactions\n    // IMPORTANT: Skip complex filtering for user-triggered actions to prevent UI blocking\n    if (this.pendingSyncedTransactions.length > 0 && !triggeredByUserAction) {\n      const pendingSyncKeys = new Set<TKey>()\n\n      // Collect keys from pending sync operations\n      for (const transaction of this.pendingSyncedTransactions) {\n        for (const operation of transaction.operations) {\n          pendingSyncKeys.add(operation.key as TKey)\n        }\n      }\n\n      // Only filter out delete events for keys that:\n      // 1. Have pending sync operations AND\n      // 2. Are from completed transactions (being cleaned up)\n      const filteredEvents = filteredEventsBySyncStatus.filter((event) => {\n        if (event.type === `delete` && pendingSyncKeys.has(event.key)) {\n          // Check if this delete is from clearing optimistic state of completed transactions\n          // We can infer this by checking if we have no remaining optimistic mutations for this key\n          const hasActiveOptimisticMutation = activeTransactions.some((tx) =>\n            tx.mutations.some(\n              (m) => this.isThisCollection(m.collection) && m.key === event.key\n            )\n          )\n\n          if (!hasActiveOptimisticMutation) {\n            return false // Skip this delete event as sync will restore the data\n          }\n        }\n        return true\n      })\n\n      // Update indexes for the filtered events\n      if (filteredEvents.length > 0) {\n        this.indexes.updateIndexes(filteredEvents)\n      }\n      this.changes.emitEvents(filteredEvents, triggeredByUserAction)\n    } else {\n      // Update indexes for all events\n      if (filteredEventsBySyncStatus.length > 0) {\n        this.indexes.updateIndexes(filteredEventsBySyncStatus)\n      }\n      // Emit all events if no pending sync transactions\n      this.changes.emitEvents(filteredEventsBySyncStatus, triggeredByUserAction)\n    }\n  }\n\n  /**\n   * Calculate the current size based on synced data and optimistic changes\n   */\n  private calculateSize(): number {\n    const syncedSize = this.syncedData.size\n    const deletesFromSynced = Array.from(this.optimisticDeletes).filter(\n      (key) => this.syncedData.has(key) && !this.optimisticUpserts.has(key)\n    ).length\n    const upsertsNotInSynced = Array.from(this.optimisticUpserts.keys()).filter(\n      (key) => !this.syncedData.has(key)\n    ).length\n\n    return syncedSize - deletesFromSynced + upsertsNotInSynced\n  }\n\n  /**\n   * Collect events for optimistic changes\n   */\n  private collectOptimisticChanges(\n    previousUpserts: Map<TKey, TOutput>,\n    previousDeletes: Set<TKey>,\n    events: Array<ChangeMessage<TOutput, TKey>>\n  ): void {\n    const allKeys = new Set([\n      ...previousUpserts.keys(),\n      ...this.optimisticUpserts.keys(),\n      ...previousDeletes,\n      ...this.optimisticDeletes,\n    ])\n\n    for (const key of allKeys) {\n      const currentValue = this.get(key)\n      const previousValue = this.getPreviousValue(\n        key,\n        previousUpserts,\n        previousDeletes\n      )\n\n      if (previousValue !== undefined && currentValue === undefined) {\n        events.push({ type: `delete`, key, value: previousValue })\n      } else if (previousValue === undefined && currentValue !== undefined) {\n        events.push({ type: `insert`, key, value: currentValue })\n      } else if (\n        previousValue !== undefined &&\n        currentValue !== undefined &&\n        previousValue !== currentValue\n      ) {\n        events.push({\n          type: `update`,\n          key,\n          value: currentValue,\n          previousValue,\n        })\n      }\n    }\n  }\n\n  /**\n   * Get the previous value for a key given previous optimistic state\n   */\n  private getPreviousValue(\n    key: TKey,\n    previousUpserts: Map<TKey, TOutput>,\n    previousDeletes: Set<TKey>\n  ): TOutput | undefined {\n    if (previousDeletes.has(key)) {\n      return undefined\n    }\n    if (previousUpserts.has(key)) {\n      return previousUpserts.get(key)\n    }\n    return this.syncedData.get(key)\n  }\n\n  /**\n   * Attempts to commit pending synced transactions if there are no active transactions\n   * This method processes operations from pending transactions and applies them to the synced data\n   */\n  commitPendingTransactions = () => {\n    // Check if there are any persisting transaction\n    let hasPersistingTransaction = false\n    for (const transaction of this.transactions.values()) {\n      if (transaction.state === `persisting`) {\n        hasPersistingTransaction = true\n        break\n      }\n    }\n\n    // pending synced transactions could be either `committed` or still open.\n    // we only want to process `committed` transactions here\n    const {\n      committedSyncedTransactions,\n      uncommittedSyncedTransactions,\n      hasTruncateSync,\n    } = this.pendingSyncedTransactions.reduce(\n      (acc, t) => {\n        if (t.committed) {\n          acc.committedSyncedTransactions.push(t)\n          if (t.truncate === true) {\n            acc.hasTruncateSync = true\n          }\n        } else {\n          acc.uncommittedSyncedTransactions.push(t)\n        }\n        return acc\n      },\n      {\n        committedSyncedTransactions: [] as Array<\n          PendingSyncedTransaction<TOutput, TKey>\n        >,\n        uncommittedSyncedTransactions: [] as Array<\n          PendingSyncedTransaction<TOutput, TKey>\n        >,\n        hasTruncateSync: false,\n      }\n    )\n\n    if (!hasPersistingTransaction || hasTruncateSync) {\n      // Set flag to prevent redundant optimistic state recalculations\n      this.isCommittingSyncTransactions = true\n\n      // Get the optimistic snapshot from the truncate transaction (captured when truncate() was called)\n      const truncateOptimisticSnapshot = hasTruncateSync\n        ? committedSyncedTransactions.find((t) => t.truncate)\n            ?.optimisticSnapshot\n        : null\n\n      // First collect all keys that will be affected by sync operations\n      const changedKeys = new Set<TKey>()\n      for (const transaction of committedSyncedTransactions) {\n        for (const operation of transaction.operations) {\n          changedKeys.add(operation.key as TKey)\n        }\n      }\n\n      // Use pre-captured state if available (from optimistic scenarios),\n      // otherwise capture current state (for pure sync scenarios)\n      let currentVisibleState = this.preSyncVisibleState\n      if (currentVisibleState.size === 0) {\n        // No pre-captured state, capture it now for pure sync operations\n        currentVisibleState = new Map<TKey, TOutput>()\n        for (const key of changedKeys) {\n          const currentValue = this.get(key)\n          if (currentValue !== undefined) {\n            currentVisibleState.set(key, currentValue)\n          }\n        }\n      }\n\n      const events: Array<ChangeMessage<TOutput, TKey>> = []\n      const rowUpdateMode = this.config.sync.rowUpdateMode || `partial`\n\n      for (const transaction of committedSyncedTransactions) {\n        // Handle truncate operations first\n        if (transaction.truncate) {\n          // TRUNCATE PHASE\n          // 1) Emit a delete for every visible key (synced + optimistic) so downstream listeners/indexes\n          //    observe a clear-before-rebuild. We intentionally skip keys already in\n          //    optimisticDeletes because their delete was previously emitted by the user.\n          // Use the snapshot to ensure we emit deletes for all items that existed at truncate start.\n          const visibleKeys = new Set([\n            ...this.syncedData.keys(),\n            ...(truncateOptimisticSnapshot?.upserts.keys() || []),\n          ])\n          for (const key of visibleKeys) {\n            if (truncateOptimisticSnapshot?.deletes.has(key)) continue\n            const previousValue =\n              truncateOptimisticSnapshot?.upserts.get(key) ||\n              this.syncedData.get(key)\n            if (previousValue !== undefined) {\n              events.push({ type: `delete`, key, value: previousValue })\n            }\n          }\n\n          // 2) Clear the authoritative synced base. Subsequent server ops in this\n          //    same commit will rebuild the base atomically.\n          this.syncedData.clear()\n          this.syncedMetadata.clear()\n          this.syncedKeys.clear()\n\n          // 3) Clear currentVisibleState for truncated keys to ensure subsequent operations\n          //    are compared against the post-truncate state (undefined) rather than pre-truncate state\n          //    This ensures that re-inserted keys are emitted as INSERT events, not UPDATE events\n          for (const key of changedKeys) {\n            currentVisibleState.delete(key)\n          }\n        }\n\n        for (const operation of transaction.operations) {\n          const key = operation.key as TKey\n          this.syncedKeys.add(key)\n\n          // Update metadata\n          switch (operation.type) {\n            case `insert`:\n              this.syncedMetadata.set(key, operation.metadata)\n              break\n            case `update`:\n              this.syncedMetadata.set(\n                key,\n                Object.assign(\n                  {},\n                  this.syncedMetadata.get(key),\n                  operation.metadata\n                )\n              )\n              break\n            case `delete`:\n              this.syncedMetadata.delete(key)\n              break\n          }\n\n          // Update synced data\n          switch (operation.type) {\n            case `insert`:\n              this.syncedData.set(key, operation.value)\n              break\n            case `update`: {\n              if (rowUpdateMode === `partial`) {\n                const updatedValue = Object.assign(\n                  {},\n                  this.syncedData.get(key),\n                  operation.value\n                )\n                this.syncedData.set(key, updatedValue)\n              } else {\n                this.syncedData.set(key, operation.value)\n              }\n              break\n            }\n            case `delete`:\n              this.syncedData.delete(key)\n              break\n          }\n        }\n      }\n\n      // After applying synced operations, if this commit included a truncate,\n      // re-apply optimistic mutations on top of the fresh synced base. This ensures\n      // the UI preserves local intent while respecting server rebuild semantics.\n      // Ordering: deletes (above) -> server ops (just applied) -> optimistic upserts.\n      if (hasTruncateSync) {\n        // Avoid duplicating keys that were inserted/updated by synced operations in this commit\n        const syncedInsertedOrUpdatedKeys = new Set<TKey>()\n        for (const t of committedSyncedTransactions) {\n          for (const op of t.operations) {\n            if (op.type === `insert` || op.type === `update`) {\n              syncedInsertedOrUpdatedKeys.add(op.key as TKey)\n            }\n          }\n        }\n\n        // Build re-apply sets from the snapshot taken at the start of this function.\n        // This prevents losing optimistic state if transactions complete during truncate processing.\n        const reapplyUpserts = new Map<TKey, TOutput>(\n          truncateOptimisticSnapshot!.upserts\n        )\n        const reapplyDeletes = new Set<TKey>(\n          truncateOptimisticSnapshot!.deletes\n        )\n\n        // Emit inserts for re-applied upserts, skipping any keys that have an optimistic delete.\n        // If the server also inserted/updated the same key in this batch, override that value\n        // with the optimistic value to preserve local intent.\n        for (const [key, value] of reapplyUpserts) {\n          if (reapplyDeletes.has(key)) continue\n          if (syncedInsertedOrUpdatedKeys.has(key)) {\n            let foundInsert = false\n            for (let i = events.length - 1; i >= 0; i--) {\n              const evt = events[i]!\n              if (evt.key === key && evt.type === `insert`) {\n                evt.value = value\n                foundInsert = true\n                break\n              }\n            }\n            if (!foundInsert) {\n              events.push({ type: `insert`, key, value })\n            }\n          } else {\n            events.push({ type: `insert`, key, value })\n          }\n        }\n\n        // Finally, ensure we do NOT insert keys that have an outstanding optimistic delete.\n        if (events.length > 0 && reapplyDeletes.size > 0) {\n          const filtered: Array<ChangeMessage<TOutput, TKey>> = []\n          for (const evt of events) {\n            if (evt.type === `insert` && reapplyDeletes.has(evt.key)) {\n              continue\n            }\n            filtered.push(evt)\n          }\n          events.length = 0\n          events.push(...filtered)\n        }\n\n        // Ensure listeners are active before emitting this critical batch\n        if (this.lifecycle.status !== `ready`) {\n          this.lifecycle.markReady()\n        }\n      }\n\n      // Maintain optimistic state appropriately\n      // Clear optimistic state since sync operations will now provide the authoritative data.\n      // Any still-active user transactions will be re-applied below in recompute.\n      this.optimisticUpserts.clear()\n      this.optimisticDeletes.clear()\n\n      // Reset flag and recompute optimistic state for any remaining active transactions\n      this.isCommittingSyncTransactions = false\n\n      // If we had a truncate, restore the preserved optimistic state from the snapshot\n      // This includes items from transactions that may have completed during processing\n      if (hasTruncateSync && truncateOptimisticSnapshot) {\n        for (const [key, value] of truncateOptimisticSnapshot.upserts) {\n          this.optimisticUpserts.set(key, value)\n        }\n        for (const key of truncateOptimisticSnapshot.deletes) {\n          this.optimisticDeletes.add(key)\n        }\n      }\n\n      // Always overlay any still-active optimistic transactions so mutations that started\n      // after the truncate snapshot are preserved.\n      for (const transaction of this.transactions.values()) {\n        if (![`completed`, `failed`].includes(transaction.state)) {\n          for (const mutation of transaction.mutations) {\n            if (\n              this.isThisCollection(mutation.collection) &&\n              mutation.optimistic\n            ) {\n              switch (mutation.type) {\n                case `insert`:\n                case `update`:\n                  this.optimisticUpserts.set(\n                    mutation.key,\n                    mutation.modified as TOutput\n                  )\n                  this.optimisticDeletes.delete(mutation.key)\n                  break\n                case `delete`:\n                  this.optimisticUpserts.delete(mutation.key)\n                  this.optimisticDeletes.add(mutation.key)\n                  break\n              }\n            }\n          }\n        }\n      }\n\n      // Check for redundant sync operations that match completed optimistic operations\n      const completedOptimisticOps = new Map<TKey, any>()\n\n      for (const transaction of this.transactions.values()) {\n        if (transaction.state === `completed`) {\n          for (const mutation of transaction.mutations) {\n            if (\n              mutation.optimistic &&\n              this.isThisCollection(mutation.collection) &&\n              changedKeys.has(mutation.key)\n            ) {\n              completedOptimisticOps.set(mutation.key, {\n                type: mutation.type,\n                value: mutation.modified,\n              })\n            }\n          }\n        }\n      }\n\n      // Now check what actually changed in the final visible state\n      for (const key of changedKeys) {\n        const previousVisibleValue = currentVisibleState.get(key)\n        const newVisibleValue = this.get(key) // This returns the new derived state\n\n        // Check if this sync operation is redundant with a completed optimistic operation\n        const completedOp = completedOptimisticOps.get(key)\n        let isRedundantSync = false\n\n        if (completedOp) {\n          if (\n            completedOp.type === `delete` &&\n            previousVisibleValue !== undefined &&\n            newVisibleValue === undefined &&\n            deepEquals(completedOp.value, previousVisibleValue)\n          ) {\n            isRedundantSync = true\n          } else if (\n            newVisibleValue !== undefined &&\n            deepEquals(completedOp.value, newVisibleValue)\n          ) {\n            isRedundantSync = true\n          }\n        }\n\n        if (!isRedundantSync) {\n          if (\n            previousVisibleValue === undefined &&\n            newVisibleValue !== undefined\n          ) {\n            events.push({\n              type: `insert`,\n              key,\n              value: newVisibleValue,\n            })\n          } else if (\n            previousVisibleValue !== undefined &&\n            newVisibleValue === undefined\n          ) {\n            events.push({\n              type: `delete`,\n              key,\n              value: previousVisibleValue,\n            })\n          } else if (\n            previousVisibleValue !== undefined &&\n            newVisibleValue !== undefined &&\n            !deepEquals(previousVisibleValue, newVisibleValue)\n          ) {\n            events.push({\n              type: `update`,\n              key,\n              value: newVisibleValue,\n              previousValue: previousVisibleValue,\n            })\n          }\n        }\n      }\n\n      // Update cached size after synced data changes\n      this.size = this.calculateSize()\n\n      // Update indexes for all events before emitting\n      if (events.length > 0) {\n        this.indexes.updateIndexes(events)\n      }\n\n      // End batching and emit all events (combines any batched events with sync events)\n      this.changes.emitEvents(events, true)\n\n      this.pendingSyncedTransactions = uncommittedSyncedTransactions\n\n      // Clear the pre-sync state since sync operations are complete\n      this.preSyncVisibleState.clear()\n\n      // Clear recently synced keys after a microtask to allow recomputeOptimisticState to see them\n      Promise.resolve().then(() => {\n        this.recentlySyncedKeys.clear()\n      })\n\n      // Mark that we've received the first commit (for tracking purposes)\n      if (!this.hasReceivedFirstCommit) {\n        this.hasReceivedFirstCommit = true\n      }\n    }\n  }\n\n  /**\n   * Schedule cleanup of a transaction when it completes\n   */\n  public scheduleTransactionCleanup(transaction: Transaction<any>): void {\n    // Only schedule cleanup for transactions that aren't already completed\n    if (transaction.state === `completed`) {\n      this.transactions.delete(transaction.id)\n      return\n    }\n\n    // Schedule cleanup when the transaction completes\n    transaction.isPersisted.promise\n      .then(() => {\n        // Transaction completed successfully, remove it immediately\n        this.transactions.delete(transaction.id)\n      })\n      .catch(() => {\n        // Transaction failed, but we want to keep failed transactions for reference\n        // so don't remove it.\n        // This empty catch block is necessary to prevent unhandled promise rejections.\n      })\n  }\n\n  /**\n   * Capture visible state for keys that will be affected by pending sync operations\n   * This must be called BEFORE onTransactionStateChange clears optimistic state\n   */\n  public capturePreSyncVisibleState(): void {\n    if (this.pendingSyncedTransactions.length === 0) return\n\n    // Get all keys that will be affected by sync operations\n    const syncedKeys = new Set<TKey>()\n    for (const transaction of this.pendingSyncedTransactions) {\n      for (const operation of transaction.operations) {\n        syncedKeys.add(operation.key as TKey)\n      }\n    }\n\n    // Mark keys as about to be synced to suppress intermediate events from recomputeOptimisticState\n    for (const key of syncedKeys) {\n      this.recentlySyncedKeys.add(key)\n    }\n\n    // Only capture current visible state for keys that will be affected by sync operations\n    // This is much more efficient than capturing the entire collection state\n    // Only capture keys that haven't been captured yet to preserve earlier captures\n    for (const key of syncedKeys) {\n      if (!this.preSyncVisibleState.has(key)) {\n        const currentValue = this.get(key)\n        if (currentValue !== undefined) {\n          this.preSyncVisibleState.set(key, currentValue)\n        }\n      }\n    }\n  }\n\n  /**\n   * Trigger a recomputation when transactions change\n   * This method should be called by the Transaction class when state changes\n   */\n  public onTransactionStateChange(): void {\n    // Check if commitPendingTransactions will be called after this\n    // by checking if there are pending sync transactions (same logic as in transactions.ts)\n    this.changes.shouldBatchEvents = this.pendingSyncedTransactions.length > 0\n\n    // CRITICAL: Capture visible state BEFORE clearing optimistic state\n    this.capturePreSyncVisibleState()\n\n    this.recomputeOptimisticState(false)\n  }\n\n  /**\n   * Clean up the collection by stopping sync and clearing data\n   * This can be called manually or automatically by garbage collection\n   */\n  public cleanup(): void {\n    this.syncedData.clear()\n    this.syncedMetadata.clear()\n    this.optimisticUpserts.clear()\n    this.optimisticDeletes.clear()\n    this.size = 0\n    this.pendingSyncedTransactions = []\n    this.syncedKeys.clear()\n    this.hasReceivedFirstCommit = false\n  }\n}\n", "/**\n * Generic type-safe event emitter\n * @template TEvents - Record of event names to event payload types\n */\nexport class EventEmitter<TEvents extends Record<string, any>> {\n  private listeners = new Map<\n    keyof TEvents,\n    Set<(event: TEvents[keyof TEvents]) => void>\n  >()\n\n  /**\n   * Subscribe to an event\n   * @param event - Event name to listen for\n   * @param callback - Function to call when event is emitted\n   * @returns Unsubscribe function\n   */\n  on<T extends keyof TEvents>(\n    event: T,\n    callback: (event: TEvents[T]) => void\n  ): () => void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set())\n    }\n    this.listeners.get(event)!.add(callback as (event: any) => void)\n\n    return () => {\n      this.listeners.get(event)?.delete(callback as (event: any) => void)\n    }\n  }\n\n  /**\n   * Subscribe to an event once (automatically unsubscribes after first emission)\n   * @param event - Event name to listen for\n   * @param callback - Function to call when event is emitted\n   * @returns Unsubscribe function\n   */\n  once<T extends keyof TEvents>(\n    event: T,\n    callback: (event: TEvents[T]) => void\n  ): () => void {\n    const unsubscribe = this.on(event, (eventPayload) => {\n      callback(eventPayload)\n      unsubscribe()\n    })\n    return unsubscribe\n  }\n\n  /**\n   * Unsubscribe from an event\n   * @param event - Event name to stop listening for\n   * @param callback - Function to remove\n   */\n  off<T extends keyof TEvents>(\n    event: T,\n    callback: (event: TEvents[T]) => void\n  ): void {\n    this.listeners.get(event)?.delete(callback as (event: any) => void)\n  }\n\n  /**\n   * Wait for an event to be emitted\n   * @param event - Event name to wait for\n   * @param timeout - Optional timeout in milliseconds\n   * @returns Promise that resolves with the event payload\n   */\n  waitFor<T extends keyof TEvents>(\n    event: T,\n    timeout?: number\n  ): Promise<TEvents[T]> {\n    return new Promise((resolve, reject) => {\n      let timeoutId: NodeJS.Timeout | undefined\n      const unsubscribe = this.on(event, (eventPayload) => {\n        if (timeoutId) {\n          clearTimeout(timeoutId)\n          timeoutId = undefined\n        }\n        resolve(eventPayload)\n        unsubscribe()\n      })\n      if (timeout) {\n        timeoutId = setTimeout(() => {\n          timeoutId = undefined\n          unsubscribe()\n          reject(new Error(`Timeout waiting for event ${String(event)}`))\n        }, timeout)\n      }\n    })\n  }\n\n  /**\n   * Emit an event to all listeners\n   * @param event - Event name to emit\n   * @param eventPayload - Event payload\n   * @internal For use by subclasses - subclasses should wrap this with a public emit if needed\n   */\n  protected emitInner<T extends keyof TEvents>(\n    event: T,\n    eventPayload: TEvents[T]\n  ): void {\n    this.listeners.get(event)?.forEach((listener) => {\n      try {\n        listener(eventPayload)\n      } catch (error) {\n        // Re-throw in a microtask to surface the error\n        queueMicrotask(() => {\n          throw error\n        })\n      }\n    })\n  }\n\n  /**\n   * Clear all listeners\n   */\n  protected clearListeners(): void {\n    this.listeners.clear()\n  }\n}\n", "import { ensureIndexForExpression } from \"../indexes/auto-index.js\"\nimport { and, eq, gt, lt } from \"../query/builder/functions.js\"\nimport { Value } from \"../query/ir.js\"\nimport { EventEmitter } from \"../event-emitter.js\"\nimport {\n  createFilterFunctionFromExpression,\n  createFilteredCallback,\n} from \"./change-events.js\"\nimport type { BasicExpression, OrderBy } from \"../query/ir.js\"\nimport type { IndexInterface } from \"../indexes/base-index.js\"\nimport type {\n  ChangeMessage,\n  LoadSubsetOptions,\n  Subscription,\n  SubscriptionEvents,\n  SubscriptionStatus,\n  SubscriptionUnsubscribedEvent,\n} from \"../types.js\"\nimport type { CollectionImpl } from \"./index.js\"\n\ntype RequestSnapshotOptions = {\n  where?: BasicExpression<boolean>\n  optimizedOnly?: boolean\n  trackLoadSubsetPromise?: boolean\n}\n\ntype RequestLimitedSnapshotOptions = {\n  orderBy: OrderBy\n  limit: number\n  minValue?: any\n}\n\ntype CollectionSubscriptionOptions = {\n  includeInitialState?: boolean\n  /** Pre-compiled expression for filtering changes */\n  whereExpression?: BasicExpression<boolean>\n  /** Callback to call when the subscription is unsubscribed */\n  onUnsubscribe?: (event: SubscriptionUnsubscribedEvent) => void\n}\n\nexport class CollectionSubscription\n  extends EventEmitter<SubscriptionEvents>\n  implements Subscription\n{\n  private loadedInitialState = false\n\n  // Flag to indicate that we have sent at least 1 snapshot.\n  // While `snapshotSent` is false we filter out all changes from subscription to the collection.\n  private snapshotSent = false\n\n  /**\n   * Track all loadSubset calls made by this subscription so we can unload them on cleanup.\n   * We store the exact LoadSubsetOptions we passed to loadSubset to ensure symmetric unload.\n   */\n  private loadedSubsets: Array<LoadSubsetOptions> = []\n\n  // Keep track of the keys we've sent (needed for join and orderBy optimizations)\n  private sentKeys = new Set<string | number>()\n\n  private filteredCallback: (changes: Array<ChangeMessage<any, any>>) => void\n\n  private orderByIndex: IndexInterface<string | number> | undefined\n\n  // Status tracking\n  private _status: SubscriptionStatus = `ready`\n  private pendingLoadSubsetPromises: Set<Promise<void>> = new Set()\n\n  public get status(): SubscriptionStatus {\n    return this._status\n  }\n\n  constructor(\n    private collection: CollectionImpl<any, any, any, any, any>,\n    private callback: (changes: Array<ChangeMessage<any, any>>) => void,\n    private options: CollectionSubscriptionOptions\n  ) {\n    super()\n    if (options.onUnsubscribe) {\n      this.on(`unsubscribed`, (event) => options.onUnsubscribe!(event))\n    }\n\n    // Auto-index for where expressions if enabled\n    if (options.whereExpression) {\n      ensureIndexForExpression(options.whereExpression, this.collection)\n    }\n\n    const callbackWithSentKeysTracking = (\n      changes: Array<ChangeMessage<any, any>>\n    ) => {\n      callback(changes)\n      this.trackSentKeys(changes)\n    }\n\n    this.callback = callbackWithSentKeysTracking\n\n    // Create a filtered callback if where clause is provided\n    this.filteredCallback = options.whereExpression\n      ? createFilteredCallback(this.callback, options)\n      : this.callback\n  }\n\n  setOrderByIndex(index: IndexInterface<any>) {\n    this.orderByIndex = index\n  }\n\n  /**\n   * Set subscription status and emit events if changed\n   */\n  private setStatus(newStatus: SubscriptionStatus) {\n    if (this._status === newStatus) {\n      return // No change\n    }\n\n    const previousStatus = this._status\n    this._status = newStatus\n\n    // Emit status:change event\n    this.emitInner(`status:change`, {\n      type: `status:change`,\n      subscription: this,\n      previousStatus,\n      status: newStatus,\n    })\n\n    // Emit specific status event\n    const eventKey: `status:${SubscriptionStatus}` = `status:${newStatus}`\n    this.emitInner(eventKey, {\n      type: eventKey,\n      subscription: this,\n      previousStatus,\n      status: newStatus,\n    } as SubscriptionEvents[typeof eventKey])\n  }\n\n  /**\n   * Track a loadSubset promise and manage loading status\n   */\n  private trackLoadSubsetPromise(syncResult: Promise<void> | true) {\n    // Track the promise if it's actually a promise (async work)\n    if (syncResult instanceof Promise) {\n      this.pendingLoadSubsetPromises.add(syncResult)\n      this.setStatus(`loadingSubset`)\n\n      syncResult.finally(() => {\n        this.pendingLoadSubsetPromises.delete(syncResult)\n        if (this.pendingLoadSubsetPromises.size === 0) {\n          this.setStatus(`ready`)\n        }\n      })\n    }\n  }\n\n  hasLoadedInitialState() {\n    return this.loadedInitialState\n  }\n\n  hasSentAtLeastOneSnapshot() {\n    return this.snapshotSent\n  }\n\n  emitEvents(changes: Array<ChangeMessage<any, any>>) {\n    const newChanges = this.filterAndFlipChanges(changes)\n    this.filteredCallback(newChanges)\n  }\n\n  /**\n   * Sends the snapshot to the callback.\n   * Returns a boolean indicating if it succeeded.\n   * It can only fail if there is no index to fulfill the request\n   * and the optimizedOnly option is set to true,\n   * or, the entire state was already loaded.\n   */\n  requestSnapshot(opts?: RequestSnapshotOptions): boolean {\n    if (this.loadedInitialState) {\n      // Subscription was deoptimized so we already sent the entire initial state\n      return false\n    }\n\n    const stateOpts: RequestSnapshotOptions = {\n      where: this.options.whereExpression,\n      optimizedOnly: opts?.optimizedOnly ?? false,\n    }\n\n    if (opts) {\n      if (`where` in opts) {\n        const snapshotWhereExp = opts.where\n        if (stateOpts.where) {\n          // Combine the two where expressions\n          const subWhereExp = stateOpts.where\n          const combinedWhereExp = and(subWhereExp, snapshotWhereExp)\n          stateOpts.where = combinedWhereExp\n        } else {\n          stateOpts.where = snapshotWhereExp\n        }\n      }\n    } else {\n      // No options provided so it's loading the entire initial state\n      this.loadedInitialState = true\n    }\n\n    // Request the sync layer to load more data\n    // don't await it, we will load the data into the collection when it comes in\n    const loadOptions: LoadSubsetOptions = {\n      where: stateOpts.where,\n      subscription: this,\n    }\n    const syncResult = this.collection._sync.loadSubset(loadOptions)\n\n    // Track this loadSubset call so we can unload it later\n    this.loadedSubsets.push(loadOptions)\n\n    const trackLoadSubsetPromise = opts?.trackLoadSubsetPromise ?? true\n    if (trackLoadSubsetPromise) {\n      this.trackLoadSubsetPromise(syncResult)\n    }\n\n    // Also load data immediately from the collection\n    const snapshot = this.collection.currentStateAsChanges(stateOpts)\n\n    if (snapshot === undefined) {\n      // Couldn't load from indexes\n      return false\n    }\n\n    // Only send changes that have not been sent yet\n    const filteredSnapshot = snapshot.filter(\n      (change) => !this.sentKeys.has(change.key)\n    )\n\n    this.snapshotSent = true\n    this.callback(filteredSnapshot)\n    return true\n  }\n\n  /**\n   * Sends a snapshot that fulfills the `where` clause and all rows are bigger or equal to `minValue`.\n   * Requires a range index to be set with `setOrderByIndex` prior to calling this method.\n   * It uses that range index to load the items in the order of the index.\n   * Note 1: it may load more rows than the provided LIMIT because it loads all values equal to `minValue` + limit values greater than `minValue`.\n   *         This is needed to ensure that it does not accidentally skip duplicate values when the limit falls in the middle of some duplicated values.\n   * Note 2: it does not send keys that have already been sent before.\n   */\n  requestLimitedSnapshot({\n    orderBy,\n    limit,\n    minValue,\n  }: RequestLimitedSnapshotOptions) {\n    if (!limit) throw new Error(`limit is required`)\n\n    if (!this.orderByIndex) {\n      throw new Error(\n        `Ordered snapshot was requested but no index was found. You have to call setOrderByIndex before requesting an ordered snapshot.`\n      )\n    }\n\n    const index = this.orderByIndex\n    const where = this.options.whereExpression\n    const whereFilterFn = where\n      ? createFilterFunctionFromExpression(where)\n      : undefined\n\n    const filterFn = (key: string | number): boolean => {\n      if (this.sentKeys.has(key)) {\n        return false\n      }\n\n      const value = this.collection.get(key)\n      if (value === undefined) {\n        return false\n      }\n\n      return whereFilterFn?.(value) ?? true\n    }\n\n    let biggestObservedValue = minValue\n    const changes: Array<ChangeMessage<any, string | number>> = []\n\n    // If we have a minValue we need to handle the case\n    // where there might be duplicate values equal to minValue that we need to include\n    // because we can have data like this: [1, 2, 3, 3, 3, 4, 5]\n    // so if minValue is 3 then the previous snapshot may not have included all 3s\n    // e.g. if it was offset 0 and limit 3 it would only have loaded the first 3\n    //      so we load all rows equal to minValue first, to be sure we don't skip any duplicate values\n    let keys: Array<string | number> = []\n    if (minValue !== undefined) {\n      // First, get all items with the same value as minValue\n      const { expression } = orderBy[0]!\n      const allRowsWithMinValue = this.collection.currentStateAsChanges({\n        where: eq(expression, new Value(minValue)),\n      })\n\n      if (allRowsWithMinValue) {\n        const keysWithMinValue = allRowsWithMinValue\n          .map((change) => change.key)\n          .filter((key) => !this.sentKeys.has(key) && filterFn(key))\n\n        // Add items with the minValue first\n        keys.push(...keysWithMinValue)\n\n        // Then get items greater than minValue\n        const keysGreaterThanMin = index.take(\n          limit - keys.length,\n          minValue,\n          filterFn\n        )\n        keys.push(...keysGreaterThanMin)\n      } else {\n        keys = index.take(limit, minValue, filterFn)\n      }\n    } else {\n      keys = index.take(limit, minValue, filterFn)\n    }\n\n    const valuesNeeded = () => Math.max(limit - changes.length, 0)\n    const collectionExhausted = () => keys.length === 0\n\n    while (valuesNeeded() > 0 && !collectionExhausted()) {\n      const insertedKeys = new Set<string | number>() // Track keys we add to `changes` in this iteration\n\n      for (const key of keys) {\n        const value = this.collection.get(key)!\n        changes.push({\n          type: `insert`,\n          key,\n          value,\n        })\n        biggestObservedValue = value\n        insertedKeys.add(key) // Track this key\n      }\n\n      keys = index.take(valuesNeeded(), biggestObservedValue, filterFn)\n    }\n\n    this.callback(changes)\n\n    let whereWithValueFilter = where\n    if (typeof minValue !== `undefined`) {\n      // Only request data that we haven't seen yet (i.e. is bigger than the minValue)\n      const { expression, compareOptions } = orderBy[0]!\n      const operator = compareOptions.direction === `asc` ? gt : lt\n      const valueFilter = operator(expression, new Value(minValue))\n      whereWithValueFilter = where ? and(where, valueFilter) : valueFilter\n    }\n\n    // Request the sync layer to load more data\n    // don't await it, we will load the data into the collection when it comes in\n    const loadOptions1: LoadSubsetOptions = {\n      where: whereWithValueFilter,\n      limit,\n      orderBy,\n      subscription: this,\n    }\n    const syncResult = this.collection._sync.loadSubset(loadOptions1)\n\n    // Track this loadSubset call\n    this.loadedSubsets.push(loadOptions1)\n\n    // Make parallel loadSubset calls for values equal to minValue and values greater than minValue\n    const promises: Array<Promise<void>> = []\n\n    // First promise: load all values equal to minValue\n    if (typeof minValue !== `undefined`) {\n      const { expression } = orderBy[0]!\n      const exactValueFilter = eq(expression, new Value(minValue))\n\n      const loadOptions2: LoadSubsetOptions = {\n        where: exactValueFilter,\n        subscription: this,\n      }\n      const equalValueResult = this.collection._sync.loadSubset(loadOptions2)\n\n      // Track this loadSubset call\n      this.loadedSubsets.push(loadOptions2)\n\n      if (equalValueResult instanceof Promise) {\n        promises.push(equalValueResult)\n      }\n    }\n\n    // Second promise: load values greater than minValue\n    if (syncResult instanceof Promise) {\n      promises.push(syncResult)\n    }\n\n    // Track the combined promise\n    if (promises.length > 0) {\n      const combinedPromise = Promise.all(promises).then(() => {})\n      this.trackLoadSubsetPromise(combinedPromise)\n    } else {\n      this.trackLoadSubsetPromise(syncResult)\n    }\n  }\n\n  // TODO: also add similar test but that checks that it can also load it from the collection's loadSubset function\n  //       and that that also works properly (i.e. does not skip duplicate values)\n\n  /**\n   * Filters and flips changes for keys that have not been sent yet.\n   * Deletes are filtered out for keys that have not been sent yet.\n   * Updates are flipped into inserts for keys that have not been sent yet.\n   */\n  private filterAndFlipChanges(changes: Array<ChangeMessage<any, any>>) {\n    if (this.loadedInitialState) {\n      // We loaded the entire initial state\n      // so no need to filter or flip changes\n      return changes\n    }\n\n    const newChanges = []\n    for (const change of changes) {\n      let newChange = change\n      if (!this.sentKeys.has(change.key)) {\n        if (change.type === `update`) {\n          newChange = { ...change, type: `insert`, previousValue: undefined }\n        } else if (change.type === `delete`) {\n          // filter out deletes for keys that have not been sent\n          continue\n        }\n        this.sentKeys.add(change.key)\n      }\n      newChanges.push(newChange)\n    }\n    return newChanges\n  }\n\n  private trackSentKeys(changes: Array<ChangeMessage<any, string | number>>) {\n    if (this.loadedInitialState) {\n      // No need to track sent keys if we loaded the entire state.\n      // Since we sent everything, all keys must have been observed.\n      return\n    }\n\n    for (const change of changes) {\n      this.sentKeys.add(change.key)\n    }\n  }\n\n  unsubscribe() {\n    // Unload all subsets that this subscription loaded\n    // We pass the exact same LoadSubsetOptions we used for loadSubset\n    for (const options of this.loadedSubsets) {\n      this.collection._sync.unloadSubset(options)\n    }\n    this.loadedSubsets = []\n\n    this.emitInner(`unsubscribed`, {\n      type: `unsubscribed`,\n      subscription: this,\n    })\n    // Clear all event listeners to prevent memory leaks\n    this.clearListeners()\n  }\n}\n", "import { NegativeActiveSubscribersError } from \"../errors\"\nimport { CollectionSubscription } from \"./subscription.js\"\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport type { ChangeMessage, SubscribeChangesOptions } from \"../types\"\nimport type { CollectionLifecycleManager } from \"./lifecycle.js\"\nimport type { CollectionSyncManager } from \"./sync.js\"\nimport type { CollectionEventsManager } from \"./events.js\"\nimport type { CollectionImpl } from \"./index.js\"\n\nexport class CollectionChangesManager<\n  TOutput extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n  TSchema extends StandardSchemaV1 = StandardSchemaV1,\n  TInput extends object = TOutput,\n> {\n  private lifecycle!: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n  private sync!: CollectionSyncManager<TOutput, TKey, TSchema, TInput>\n  private events!: CollectionEventsManager\n  private collection!: CollectionImpl<TOutput, TKey, any, TSchema, TInput>\n\n  public activeSubscribersCount = 0\n  public changeSubscriptions = new Set<CollectionSubscription>()\n  public batchedEvents: Array<ChangeMessage<TOutput, TKey>> = []\n  public shouldBatchEvents = false\n\n  /**\n   * Creates a new CollectionChangesManager instance\n   */\n  constructor() {}\n\n  public setDeps(deps: {\n    lifecycle: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n    sync: CollectionSyncManager<TOutput, TKey, TSchema, TInput>\n    events: CollectionEventsManager\n    collection: CollectionImpl<TOutput, TKey, any, TSchema, TInput>\n  }) {\n    this.lifecycle = deps.lifecycle\n    this.sync = deps.sync\n    this.events = deps.events\n    this.collection = deps.collection\n  }\n\n  /**\n   * Emit an empty ready event to notify subscribers that the collection is ready\n   * This bypasses the normal empty array check in emitEvents\n   */\n  public emitEmptyReadyEvent(): void {\n    // Emit empty array directly to all subscribers\n    for (const subscription of this.changeSubscriptions) {\n      subscription.emitEvents([])\n    }\n  }\n\n  /**\n   * Emit events either immediately or batch them for later emission\n   */\n  public emitEvents(\n    changes: Array<ChangeMessage<TOutput, TKey>>,\n    forceEmit = false\n  ): void {\n    // Skip batching for user actions (forceEmit=true) to keep UI responsive\n    if (this.shouldBatchEvents && !forceEmit) {\n      // Add events to the batch\n      this.batchedEvents.push(...changes)\n      return\n    }\n\n    // Either we're not batching, or we're forcing emission (user action or ending batch cycle)\n    let eventsToEmit = changes\n\n    if (forceEmit) {\n      // Force emit is used to end a batch (e.g. after a sync commit). Combine any\n      // buffered optimistic events with the final changes so subscribers see the\n      // whole picture, even if the sync diff is empty.\n      if (this.batchedEvents.length > 0) {\n        eventsToEmit = [...this.batchedEvents, ...changes]\n      }\n      this.batchedEvents = []\n      this.shouldBatchEvents = false\n    }\n\n    if (eventsToEmit.length === 0) {\n      return\n    }\n\n    // Emit to all listeners\n    for (const subscription of this.changeSubscriptions) {\n      subscription.emitEvents(eventsToEmit)\n    }\n  }\n\n  /**\n   * Subscribe to changes in the collection\n   */\n  public subscribeChanges(\n    callback: (changes: Array<ChangeMessage<TOutput>>) => void,\n    options: SubscribeChangesOptions = {}\n  ): CollectionSubscription {\n    // Start sync and track subscriber\n    this.addSubscriber()\n\n    const subscription = new CollectionSubscription(this.collection, callback, {\n      ...options,\n      onUnsubscribe: () => {\n        this.removeSubscriber()\n        this.changeSubscriptions.delete(subscription)\n      },\n    })\n\n    if (options.includeInitialState) {\n      subscription.requestSnapshot({ trackLoadSubsetPromise: false })\n    }\n\n    // Add to batched listeners\n    this.changeSubscriptions.add(subscription)\n\n    return subscription\n  }\n\n  /**\n   * Increment the active subscribers count and start sync if needed\n   */\n  private addSubscriber(): void {\n    const previousSubscriberCount = this.activeSubscribersCount\n    this.activeSubscribersCount++\n    this.lifecycle.cancelGCTimer()\n\n    // Start sync if collection was cleaned up\n    if (\n      this.lifecycle.status === `cleaned-up` ||\n      this.lifecycle.status === `idle`\n    ) {\n      this.sync.startSync()\n    }\n\n    this.events.emitSubscribersChange(\n      this.activeSubscribersCount,\n      previousSubscriberCount\n    )\n  }\n\n  /**\n   * Decrement the active subscribers count and start GC timer if needed\n   */\n  private removeSubscriber(): void {\n    const previousSubscriberCount = this.activeSubscribersCount\n    this.activeSubscribersCount--\n\n    if (this.activeSubscribersCount === 0) {\n      this.lifecycle.startGCTimer()\n    } else if (this.activeSubscribersCount < 0) {\n      throw new NegativeActiveSubscribersError()\n    }\n\n    this.events.emitSubscribersChange(\n      this.activeSubscribersCount,\n      previousSubscriberCount\n    )\n  }\n\n  /**\n   * Clean up the collection by stopping sync and clearing data\n   * This can be called manually or automatically by garbage collection\n   */\n  public cleanup(): void {\n    this.batchedEvents = []\n    this.shouldBatchEvents = false\n  }\n}\n", "// Type definitions for requestIdleCallback - compatible with existing browser types\nexport type IdleCallbackDeadline = {\n  didTimeout: boolean\n  timeRemaining: () => number\n}\n\nexport type IdleCallbackFunction = (deadline: IdleCallbackDeadline) => void\n\nconst requestIdleCallbackPolyfill = (\n  callback: IdleCallbackFunction\n): number => {\n  // Use a very small timeout for the polyfill to simulate idle time\n  const timeout = 0\n  const timeoutId = setTimeout(() => {\n    callback({\n      didTimeout: true, // Always indicate timeout for the polyfill\n      timeRemaining: () => 50, // Return some time remaining for polyfill\n    })\n  }, timeout)\n  return timeoutId as unknown as number\n}\n\nconst cancelIdleCallbackPolyfill = (id: number): void => {\n  clearTimeout(id as unknown as ReturnType<typeof setTimeout>)\n}\n\nexport const safeRequestIdleCallback: (\n  callback: IdleCallbackFunction,\n  options?: { timeout?: number }\n) => number =\n  typeof window !== `undefined` && `requestIdleCallback` in window\n    ? (callback, options) =>\n        (window as any).requestIdleCallback(callback, options)\n    : (callback, _options) => requestIdleCallbackPolyfill(callback)\n\nexport const safeCancelIdleCallback: (id: number) => void =\n  typeof window !== `undefined` && `cancelIdleCallback` in window\n    ? (id) => (window as any).cancelIdleCallback(id)\n    : cancelIdleCallbackPolyfill\n", "import {\n  CollectionInErrorStateError,\n  CollectionStateError,\n  InvalidCollectionStatusTransitionError,\n} from \"../errors\"\nimport {\n  safeCancelIdleCallback,\n  safeRequestIdleCallback,\n} from \"../utils/browser-polyfills\"\nimport type { IdleCallbackDeadline } from \"../utils/browser-polyfills\"\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport type { CollectionConfig, CollectionStatus } from \"../types\"\nimport type { CollectionEventsManager } from \"./events\"\nimport type { CollectionIndexesManager } from \"./indexes\"\nimport type { CollectionChangesManager } from \"./changes\"\nimport type { CollectionSyncManager } from \"./sync\"\nimport type { CollectionStateManager } from \"./state\"\n\nexport class CollectionLifecycleManager<\n  TOutput extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n  TSchema extends StandardSchemaV1 = StandardSchemaV1,\n  TInput extends object = TOutput,\n> {\n  private config: CollectionConfig<TOutput, TKey, TSchema>\n  private id: string\n  private indexes!: CollectionIndexesManager<TOutput, TKey, TSchema, TInput>\n  private events!: CollectionEventsManager\n  private changes!: CollectionChangesManager<TOutput, TKey, TSchema, TInput>\n  private sync!: CollectionSyncManager<TOutput, TKey, TSchema, TInput>\n  private state!: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n\n  public status: CollectionStatus = `idle`\n  public hasBeenReady = false\n  public hasReceivedFirstCommit = false\n  public onFirstReadyCallbacks: Array<() => void> = []\n  public gcTimeoutId: ReturnType<typeof setTimeout> | null = null\n  private idleCallbackId: number | null = null\n\n  /**\n   * Creates a new CollectionLifecycleManager instance\n   */\n  constructor(config: CollectionConfig<TOutput, TKey, TSchema>, id: string) {\n    this.config = config\n    this.id = id\n  }\n\n  setDeps(deps: {\n    indexes: CollectionIndexesManager<TOutput, TKey, TSchema, TInput>\n    events: CollectionEventsManager\n    changes: CollectionChangesManager<TOutput, TKey, TSchema, TInput>\n    sync: CollectionSyncManager<TOutput, TKey, TSchema, TInput>\n    state: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n  }) {\n    this.indexes = deps.indexes\n    this.events = deps.events\n    this.changes = deps.changes\n    this.sync = deps.sync\n    this.state = deps.state\n  }\n\n  /**\n   * Validates state transitions to prevent invalid status changes\n   */\n  public validateStatusTransition(\n    from: CollectionStatus,\n    to: CollectionStatus\n  ): void {\n    if (from === to) {\n      // Allow same state transitions\n      return\n    }\n    const validTransitions: Record<\n      CollectionStatus,\n      Array<CollectionStatus>\n    > = {\n      idle: [`loading`, `error`, `cleaned-up`],\n      loading: [`ready`, `error`, `cleaned-up`],\n      ready: [`cleaned-up`, `error`],\n      error: [`cleaned-up`, `idle`],\n      \"cleaned-up\": [`loading`, `error`],\n    }\n\n    if (!validTransitions[from].includes(to)) {\n      throw new InvalidCollectionStatusTransitionError(from, to, this.id)\n    }\n  }\n\n  /**\n   * Safely update the collection status with validation\n   * @private\n   */\n  public setStatus(\n    newStatus: CollectionStatus,\n    allowReady: boolean = false\n  ): void {\n    if (newStatus === `ready` && !allowReady) {\n      // setStatus('ready') is an internal method that should not be called directly\n      // Instead, use markReady to transition to ready triggering the necessary events\n      // and side effects.\n      throw new CollectionStateError(\n        `You can't directly call \"setStatus('ready'). You must use markReady instead.`\n      )\n    }\n    this.validateStatusTransition(this.status, newStatus)\n    const previousStatus = this.status\n    this.status = newStatus\n\n    // Resolve indexes when collection becomes ready\n    if (newStatus === `ready` && !this.indexes.isIndexesResolved) {\n      // Resolve indexes asynchronously without blocking\n      this.indexes.resolveAllIndexes().catch((error) => {\n        console.warn(\n          `${this.config.id ? `[${this.config.id}] ` : ``}Failed to resolve indexes:`,\n          error\n        )\n      })\n    }\n\n    // Emit event\n    this.events.emitStatusChange(newStatus, previousStatus)\n  }\n\n  /**\n   * Validates that the collection is in a usable state for data operations\n   * @private\n   */\n  public validateCollectionUsable(operation: string): void {\n    switch (this.status) {\n      case `error`:\n        throw new CollectionInErrorStateError(operation, this.id)\n      case `cleaned-up`:\n        // Automatically restart the collection when operations are called on cleaned-up collections\n        this.sync.startSync()\n        break\n    }\n  }\n\n  /**\n   * Mark the collection as ready for use\n   * This is called by sync implementations to explicitly signal that the collection is ready,\n   * providing a more intuitive alternative to using commits for readiness signaling\n   * @private - Should only be called by sync implementations\n   */\n  public markReady(): void {\n    this.validateStatusTransition(this.status, `ready`)\n    // Can transition to ready from loading state\n    if (this.status === `loading`) {\n      this.setStatus(`ready`, true)\n\n      // Call any registered first ready callbacks (only on first time becoming ready)\n      if (!this.hasBeenReady) {\n        this.hasBeenReady = true\n\n        // Also mark as having received first commit for backwards compatibility\n        if (!this.hasReceivedFirstCommit) {\n          this.hasReceivedFirstCommit = true\n        }\n\n        const callbacks = [...this.onFirstReadyCallbacks]\n        this.onFirstReadyCallbacks = []\n        callbacks.forEach((callback) => callback())\n      }\n      // Notify dependents when markReady is called, after status is set\n      // This ensures live queries get notified when their dependencies become ready\n      if (this.changes.changeSubscriptions.size > 0) {\n        this.changes.emitEmptyReadyEvent()\n      }\n    }\n  }\n\n  /**\n   * Start the garbage collection timer\n   * Called when the collection becomes inactive (no subscribers)\n   */\n  public startGCTimer(): void {\n    if (this.gcTimeoutId) {\n      clearTimeout(this.gcTimeoutId)\n    }\n\n    const gcTime = this.config.gcTime ?? 300000 // 5 minutes default\n\n    // If gcTime is 0, GC is disabled\n    if (gcTime === 0) {\n      return\n    }\n\n    this.gcTimeoutId = setTimeout(() => {\n      if (this.changes.activeSubscribersCount === 0) {\n        // Schedule cleanup during idle time to avoid blocking the UI thread\n        this.scheduleIdleCleanup()\n      }\n    }, gcTime)\n  }\n\n  /**\n   * Cancel the garbage collection timer\n   * Called when the collection becomes active again\n   */\n  public cancelGCTimer(): void {\n    if (this.gcTimeoutId) {\n      clearTimeout(this.gcTimeoutId)\n      this.gcTimeoutId = null\n    }\n    // Also cancel any pending idle cleanup\n    if (this.idleCallbackId !== null) {\n      safeCancelIdleCallback(this.idleCallbackId)\n      this.idleCallbackId = null\n    }\n  }\n\n  /**\n   * Schedule cleanup to run during browser idle time\n   * This prevents blocking the UI thread during cleanup operations\n   */\n  private scheduleIdleCleanup(): void {\n    // Cancel any existing idle callback\n    if (this.idleCallbackId !== null) {\n      safeCancelIdleCallback(this.idleCallbackId)\n    }\n\n    // Schedule cleanup with a timeout of 1 second\n    // This ensures cleanup happens even if the browser is busy\n    this.idleCallbackId = safeRequestIdleCallback(\n      (deadline) => {\n        // Perform cleanup if we still have no subscribers\n        if (this.changes.activeSubscribersCount === 0) {\n          const cleanupCompleted = this.performCleanup(deadline)\n          // Only clear the callback ID if cleanup actually completed\n          if (cleanupCompleted) {\n            this.idleCallbackId = null\n          }\n        } else {\n          // No need to cleanup, clear the callback ID\n          this.idleCallbackId = null\n        }\n      },\n      { timeout: 1000 }\n    )\n  }\n\n  /**\n   * Perform cleanup operations, optionally in chunks during idle time\n   * @returns true if cleanup was completed, false if it was rescheduled\n   */\n  private performCleanup(deadline?: IdleCallbackDeadline): boolean {\n    // If we have a deadline, we can potentially split cleanup into chunks\n    // For now, we'll do all cleanup at once but check if we have time\n    const hasTime =\n      !deadline || deadline.timeRemaining() > 0 || deadline.didTimeout\n\n    if (hasTime) {\n      // Perform all cleanup operations except events\n      this.sync.cleanup()\n      this.state.cleanup()\n      this.changes.cleanup()\n      this.indexes.cleanup()\n\n      if (this.gcTimeoutId) {\n        clearTimeout(this.gcTimeoutId)\n        this.gcTimeoutId = null\n      }\n\n      this.hasBeenReady = false\n      this.onFirstReadyCallbacks = []\n\n      // Set status to cleaned-up after everything is cleaned up\n      // This fires the status:change event to notify listeners\n      this.setStatus(`cleaned-up`)\n\n      // Finally, cleanup event handlers after the event has been fired\n      this.events.cleanup()\n\n      return true\n    } else {\n      // If we don't have time, reschedule for the next idle period\n      this.scheduleIdleCleanup()\n      return false\n    }\n  }\n\n  /**\n   * Register a callback to be executed when the collection first becomes ready\n   * Useful for preloading collections\n   * @param callback Function to call when the collection first becomes ready\n   */\n  public onFirstReady(callback: () => void): void {\n    // If already ready, call immediately\n    if (this.hasBeenReady) {\n      callback()\n      return\n    }\n\n    this.onFirstReadyCallbacks.push(callback)\n  }\n\n  public cleanup(): void {\n    // Cancel any pending idle cleanup\n    if (this.idleCallbackId !== null) {\n      safeCancelIdleCallback(this.idleCallbackId)\n      this.idleCallbackId = null\n    }\n\n    // Perform cleanup immediately (used when explicitly called)\n    this.performCleanup()\n  }\n}\n", "import type { CollectionConfigBuilder } from \"./collection-config-builder.js\"\n\n/**\n * Symbol for accessing internal utilities that should not be part of the public API\n */\nexport const LIVE_QUERY_INTERNAL = Symbol(`liveQueryInternal`)\n\n/**\n * Internal utilities for live queries, accessible via Symbol\n */\nexport type LiveQueryInternalUtils = {\n  getBuilder: () => CollectionConfigBuilder<any, any>\n  hasCustomGetKey: boolean\n  hasJoins: boolean\n}\n", "import {\n  CollectionConfigurationError,\n  CollectionIsInErrorStateError,\n  DuplicateKeySyncError,\n  NoPendingSyncTransactionCommitError,\n  NoPendingSyncTransactionWriteError,\n  SyncCleanupError,\n  SyncTransactionAlreadyCommittedError,\n  SyncTransactionAlreadyCommittedWriteError,\n} from \"../errors\"\nimport { deepEquals } from \"../utils\"\nimport { LIVE_QUERY_INTERNAL } from \"../query/live/internal.js\"\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport type {\n  ChangeMessage,\n  CleanupFn,\n  CollectionConfig,\n  LoadSubsetOptions,\n  SyncConfigRes,\n} from \"../types\"\nimport type { CollectionImpl } from \"./index.js\"\nimport type { CollectionStateManager } from \"./state\"\nimport type { CollectionLifecycleManager } from \"./lifecycle\"\nimport type { CollectionEventsManager } from \"./events.js\"\nimport type { LiveQueryCollectionUtils } from \"../query/live/collection-config-builder.js\"\n\nexport class CollectionSyncManager<\n  TOutput extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n  TSchema extends StandardSchemaV1 = StandardSchemaV1,\n  TInput extends object = TOutput,\n> {\n  private collection!: CollectionImpl<TOutput, TKey, any, TSchema, TInput>\n  private state!: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n  private lifecycle!: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n  private _events!: CollectionEventsManager\n  private config!: CollectionConfig<TOutput, TKey, TSchema>\n  private id: string\n  private syncMode: `eager` | `on-demand`\n\n  public preloadPromise: Promise<void> | null = null\n  public syncCleanupFn: (() => void) | null = null\n  public syncLoadSubsetFn:\n    | ((options: LoadSubsetOptions) => true | Promise<void>)\n    | null = null\n  public syncUnloadSubsetFn: ((options: LoadSubsetOptions) => void) | null =\n    null\n\n  private pendingLoadSubsetPromises: Set<Promise<void>> = new Set()\n\n  /**\n   * Creates a new CollectionSyncManager instance\n   */\n  constructor(config: CollectionConfig<TOutput, TKey, TSchema>, id: string) {\n    this.config = config\n    this.id = id\n    this.syncMode = config.syncMode ?? `eager`\n  }\n\n  setDeps(deps: {\n    collection: CollectionImpl<TOutput, TKey, any, TSchema, TInput>\n    state: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n    lifecycle: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n    events: CollectionEventsManager\n  }) {\n    this.collection = deps.collection\n    this.state = deps.state\n    this.lifecycle = deps.lifecycle\n    this._events = deps.events\n  }\n\n  /**\n   * Start the sync process for this collection\n   * This is called when the collection is first accessed or preloaded\n   */\n  public startSync(): void {\n    if (\n      this.lifecycle.status !== `idle` &&\n      this.lifecycle.status !== `cleaned-up`\n    ) {\n      return // Already started or in progress\n    }\n\n    this.lifecycle.setStatus(`loading`)\n\n    try {\n      const syncRes = normalizeSyncFnResult(\n        this.config.sync.sync({\n          collection: this.collection,\n          begin: () => {\n            this.state.pendingSyncedTransactions.push({\n              committed: false,\n              operations: [],\n              deletedKeys: new Set(),\n            })\n          },\n          write: (messageWithoutKey: Omit<ChangeMessage<TOutput>, `key`>) => {\n            const pendingTransaction =\n              this.state.pendingSyncedTransactions[\n                this.state.pendingSyncedTransactions.length - 1\n              ]\n            if (!pendingTransaction) {\n              throw new NoPendingSyncTransactionWriteError()\n            }\n            if (pendingTransaction.committed) {\n              throw new SyncTransactionAlreadyCommittedWriteError()\n            }\n            const key = this.config.getKey(messageWithoutKey.value)\n\n            let messageType = messageWithoutKey.type\n\n            // Check if an item with this key already exists when inserting\n            if (messageWithoutKey.type === `insert`) {\n              const insertingIntoExistingSynced = this.state.syncedData.has(key)\n              const hasPendingDeleteForKey =\n                pendingTransaction.deletedKeys.has(key)\n              const isTruncateTransaction = pendingTransaction.truncate === true\n              // Allow insert after truncate in the same transaction even if it existed in syncedData\n              if (\n                insertingIntoExistingSynced &&\n                !hasPendingDeleteForKey &&\n                !isTruncateTransaction\n              ) {\n                const existingValue = this.state.syncedData.get(key)\n                if (\n                  existingValue !== undefined &&\n                  deepEquals(existingValue, messageWithoutKey.value)\n                ) {\n                  // The \"insert\" is an echo of a value we already have locally.\n                  // Treat it as an update so we preserve optimistic intent without\n                  // throwing a duplicate-key error during reconciliation.\n                  messageType = `update`\n                } else {\n                  const utils = this.config\n                    .utils as Partial<LiveQueryCollectionUtils>\n                  const internal = utils[LIVE_QUERY_INTERNAL]\n                  throw new DuplicateKeySyncError(key, this.id, {\n                    hasCustomGetKey: internal?.hasCustomGetKey ?? false,\n                    hasJoins: internal?.hasJoins ?? false,\n                  })\n                }\n              }\n            }\n\n            const message: ChangeMessage<TOutput> = {\n              ...messageWithoutKey,\n              type: messageType,\n              key,\n            }\n            pendingTransaction.operations.push(message)\n\n            if (messageType === `delete`) {\n              pendingTransaction.deletedKeys.add(key)\n            }\n          },\n          commit: () => {\n            const pendingTransaction =\n              this.state.pendingSyncedTransactions[\n                this.state.pendingSyncedTransactions.length - 1\n              ]\n            if (!pendingTransaction) {\n              throw new NoPendingSyncTransactionCommitError()\n            }\n            if (pendingTransaction.committed) {\n              throw new SyncTransactionAlreadyCommittedError()\n            }\n\n            pendingTransaction.committed = true\n\n            this.state.commitPendingTransactions()\n          },\n          markReady: () => {\n            this.lifecycle.markReady()\n          },\n          truncate: () => {\n            const pendingTransaction =\n              this.state.pendingSyncedTransactions[\n                this.state.pendingSyncedTransactions.length - 1\n              ]\n            if (!pendingTransaction) {\n              throw new NoPendingSyncTransactionWriteError()\n            }\n            if (pendingTransaction.committed) {\n              throw new SyncTransactionAlreadyCommittedWriteError()\n            }\n\n            // Clear all operations from the current transaction\n            pendingTransaction.operations = []\n            pendingTransaction.deletedKeys.clear()\n\n            // Mark the transaction as a truncate operation. During commit, this triggers:\n            // - Delete events for all previously synced keys (excluding optimistic-deleted keys)\n            // - Clearing of syncedData/syncedMetadata\n            // - Subsequent synced ops applied on the fresh base\n            // - Finally, optimistic mutations re-applied on top (single batch)\n            pendingTransaction.truncate = true\n\n            // Capture optimistic state NOW to preserve it even if transactions complete\n            // before this truncate transaction is committed\n            pendingTransaction.optimisticSnapshot = {\n              upserts: new Map(this.state.optimisticUpserts),\n              deletes: new Set(this.state.optimisticDeletes),\n            }\n          },\n        })\n      )\n\n      // Store cleanup function if provided\n      this.syncCleanupFn = syncRes?.cleanup ?? null\n\n      // Store loadSubset function if provided\n      this.syncLoadSubsetFn = syncRes?.loadSubset ?? null\n\n      // Store unloadSubset function if provided\n      this.syncUnloadSubsetFn = syncRes?.unloadSubset ?? null\n\n      // Validate: on-demand mode requires a loadSubset function\n      if (this.syncMode === `on-demand` && !this.syncLoadSubsetFn) {\n        throw new CollectionConfigurationError(\n          `Collection \"${this.id}\" is configured with syncMode \"on-demand\" but the sync function did not return a loadSubset handler. ` +\n            `Either provide a loadSubset handler or use syncMode \"eager\".`\n        )\n      }\n    } catch (error) {\n      this.lifecycle.setStatus(`error`)\n      throw error\n    }\n  }\n\n  /**\n   * Preload the collection data by starting sync if not already started\n   * Multiple concurrent calls will share the same promise\n   */\n  public preload(): Promise<void> {\n    if (this.preloadPromise) {\n      return this.preloadPromise\n    }\n\n    // Warn when calling preload on an on-demand collection\n    if (this.syncMode === `on-demand`) {\n      console.warn(\n        `${this.id ? `[${this.id}] ` : ``}Calling .preload() on a collection with syncMode \"on-demand\" is a no-op. ` +\n          `In on-demand mode, data is only loaded when queries request it. ` +\n          `Instead, create a live query and call .preload() on that to load the specific data you need. ` +\n          `See https://tanstack.com/blog/tanstack-db-0.5-query-driven-sync for more details.`\n      )\n    }\n\n    this.preloadPromise = new Promise<void>((resolve, reject) => {\n      if (this.lifecycle.status === `ready`) {\n        resolve()\n        return\n      }\n\n      if (this.lifecycle.status === `error`) {\n        reject(new CollectionIsInErrorStateError())\n        return\n      }\n\n      // Register callback BEFORE starting sync to avoid race condition\n      this.lifecycle.onFirstReady(() => {\n        resolve()\n      })\n\n      // Start sync if collection hasn't started yet or was cleaned up\n      if (\n        this.lifecycle.status === `idle` ||\n        this.lifecycle.status === `cleaned-up`\n      ) {\n        try {\n          this.startSync()\n        } catch (error) {\n          reject(error)\n          return\n        }\n      }\n    })\n\n    return this.preloadPromise\n  }\n\n  /**\n   * Gets whether the collection is currently loading more data\n   */\n  public get isLoadingSubset(): boolean {\n    return this.pendingLoadSubsetPromises.size > 0\n  }\n\n  /**\n   * Tracks a load promise for isLoadingSubset state.\n   * @internal This is for internal coordination (e.g., live-query glue code), not for general use.\n   */\n  public trackLoadPromise(promise: Promise<void>): void {\n    const loadingStarting = !this.isLoadingSubset\n    this.pendingLoadSubsetPromises.add(promise)\n\n    if (loadingStarting) {\n      this._events.emit(`loadingSubset:change`, {\n        type: `loadingSubset:change`,\n        collection: this.collection,\n        isLoadingSubset: true,\n        previousIsLoadingSubset: false,\n        loadingSubsetTransition: `start`,\n      })\n    }\n\n    promise.finally(() => {\n      const loadingEnding =\n        this.pendingLoadSubsetPromises.size === 1 &&\n        this.pendingLoadSubsetPromises.has(promise)\n      this.pendingLoadSubsetPromises.delete(promise)\n\n      if (loadingEnding) {\n        this._events.emit(`loadingSubset:change`, {\n          type: `loadingSubset:change`,\n          collection: this.collection,\n          isLoadingSubset: false,\n          previousIsLoadingSubset: true,\n          loadingSubsetTransition: `end`,\n        })\n      }\n    })\n  }\n\n  /**\n   * Requests the sync layer to load more data.\n   * @param options Options to control what data is being loaded\n   * @returns If data loading is asynchronous, this method returns a promise that resolves when the data is loaded.\n   *          Returns true if no sync function is configured, if syncMode is 'eager', or if there is no work to do.\n   */\n  public loadSubset(options: LoadSubsetOptions): Promise<void> | true {\n    // Bypass loadSubset when syncMode is 'eager'\n    if (this.syncMode === `eager`) {\n      return true\n    }\n\n    if (this.syncLoadSubsetFn) {\n      const result = this.syncLoadSubsetFn(options)\n      // If the result is a promise, track it\n      if (result instanceof Promise) {\n        this.trackLoadPromise(result)\n        return result\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Notifies the sync layer that a subset is no longer needed.\n   * @param options Options that identify what data is being unloaded\n   */\n  public unloadSubset(options: LoadSubsetOptions): void {\n    if (this.syncUnloadSubsetFn) {\n      this.syncUnloadSubsetFn(options)\n    }\n  }\n\n  public cleanup(): void {\n    try {\n      if (this.syncCleanupFn) {\n        this.syncCleanupFn()\n        this.syncCleanupFn = null\n      }\n    } catch (error) {\n      // Re-throw in a microtask to surface the error after cleanup completes\n      queueMicrotask(() => {\n        if (error instanceof Error) {\n          // Preserve the original error and stack trace\n          const wrappedError = new SyncCleanupError(this.id, error)\n          wrappedError.cause = error\n          wrappedError.stack = error.stack\n          throw wrappedError\n        } else {\n          throw new SyncCleanupError(this.id, error as Error | string)\n        }\n      })\n    }\n    this.preloadPromise = null\n  }\n}\n\nfunction normalizeSyncFnResult(result: void | CleanupFn | SyncConfigRes) {\n  if (typeof result === `function`) {\n    return { cleanup: result }\n  }\n\n  if (typeof result === `object`) {\n    return result\n  }\n\n  return undefined\n}\n", "import { IndexProxy, LazyIndexWrapper } from \"../indexes/lazy-index\"\nimport {\n  createSingleRowRefProxy,\n  toExpression,\n} from \"../query/builder/ref-proxy\"\nimport { BTreeIndex } from \"../indexes/btree-index\"\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport type { BaseIndex, IndexResolver } from \"../indexes/base-index\"\nimport type { ChangeMessage } from \"../types\"\nimport type { IndexOptions } from \"../indexes/index-options\"\nimport type { SingleRowRefProxy } from \"../query/builder/ref-proxy\"\nimport type { CollectionLifecycleManager } from \"./lifecycle\"\nimport type { CollectionStateManager } from \"./state\"\n\nexport class CollectionIndexesManager<\n  TOutput extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n  TSchema extends StandardSchemaV1 = StandardSchemaV1,\n  TInput extends object = TOutput,\n> {\n  private lifecycle!: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n  private state!: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n\n  public lazyIndexes = new Map<number, LazyIndexWrapper<TKey>>()\n  public resolvedIndexes = new Map<number, BaseIndex<TKey>>()\n  public isIndexesResolved = false\n  public indexCounter = 0\n\n  constructor() {}\n\n  setDeps(deps: {\n    state: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n    lifecycle: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n  }) {\n    this.state = deps.state\n    this.lifecycle = deps.lifecycle\n  }\n\n  /**\n   * Creates an index on a collection for faster queries.\n   */\n  public createIndex<TResolver extends IndexResolver<TKey> = typeof BTreeIndex>(\n    indexCallback: (row: SingleRowRefProxy<TOutput>) => any,\n    config: IndexOptions<TResolver> = {}\n  ): IndexProxy<TKey> {\n    this.lifecycle.validateCollectionUsable(`createIndex`)\n\n    const indexId = ++this.indexCounter\n    const singleRowRefProxy = createSingleRowRefProxy<TOutput>()\n    const indexExpression = indexCallback(singleRowRefProxy)\n    const expression = toExpression(indexExpression)\n\n    // Default to BTreeIndex if no type specified\n    const resolver = config.indexType ?? (BTreeIndex as unknown as TResolver)\n\n    // Create lazy wrapper\n    const lazyIndex = new LazyIndexWrapper<TKey>(\n      indexId,\n      expression,\n      config.name,\n      resolver,\n      config.options,\n      this.state.entries()\n    )\n\n    this.lazyIndexes.set(indexId, lazyIndex)\n\n    // For BTreeIndex, resolve immediately and synchronously\n    if ((resolver as unknown) === BTreeIndex) {\n      try {\n        const resolvedIndex = lazyIndex.getResolved()\n        this.resolvedIndexes.set(indexId, resolvedIndex)\n      } catch (error) {\n        console.warn(`Failed to resolve BTreeIndex:`, error)\n      }\n    } else if (typeof resolver === `function` && resolver.prototype) {\n      // Other synchronous constructors - resolve immediately\n      try {\n        const resolvedIndex = lazyIndex.getResolved()\n        this.resolvedIndexes.set(indexId, resolvedIndex)\n      } catch {\n        // Fallback to async resolution\n        this.resolveSingleIndex(indexId, lazyIndex).catch((error) => {\n          console.warn(`Failed to resolve single index:`, error)\n        })\n      }\n    } else if (this.isIndexesResolved) {\n      // Async loader but indexes are already resolved - resolve this one\n      this.resolveSingleIndex(indexId, lazyIndex).catch((error) => {\n        console.warn(`Failed to resolve single index:`, error)\n      })\n    }\n\n    return new IndexProxy(indexId, lazyIndex)\n  }\n\n  /**\n   * Resolve all lazy indexes (called when collection first syncs)\n   */\n  public async resolveAllIndexes(): Promise<void> {\n    if (this.isIndexesResolved) return\n\n    const resolutionPromises = Array.from(this.lazyIndexes.entries()).map(\n      async ([indexId, lazyIndex]) => {\n        const resolvedIndex = await lazyIndex.resolve()\n\n        // Build index with current data\n        resolvedIndex.build(this.state.entries())\n\n        this.resolvedIndexes.set(indexId, resolvedIndex)\n        return { indexId, resolvedIndex }\n      }\n    )\n\n    await Promise.all(resolutionPromises)\n    this.isIndexesResolved = true\n  }\n\n  /**\n   * Resolve a single index immediately\n   */\n  private async resolveSingleIndex(\n    indexId: number,\n    lazyIndex: LazyIndexWrapper<TKey>\n  ): Promise<BaseIndex<TKey>> {\n    const resolvedIndex = await lazyIndex.resolve()\n    resolvedIndex.build(this.state.entries())\n    this.resolvedIndexes.set(indexId, resolvedIndex)\n    return resolvedIndex\n  }\n\n  /**\n   * Get resolved indexes for query optimization\n   */\n  get indexes(): Map<number, BaseIndex<TKey>> {\n    return this.resolvedIndexes\n  }\n\n  /**\n   * Updates all indexes when the collection changes\n   */\n  public updateIndexes(changes: Array<ChangeMessage<TOutput, TKey>>): void {\n    for (const index of this.resolvedIndexes.values()) {\n      for (const change of changes) {\n        switch (change.type) {\n          case `insert`:\n            index.add(change.key, change.value)\n            break\n          case `update`:\n            if (change.previousValue) {\n              index.update(change.key, change.previousValue, change.value)\n            } else {\n              index.add(change.key, change.value)\n            }\n            break\n          case `delete`:\n            index.remove(change.key, change.value)\n            break\n        }\n      }\n    }\n  }\n\n  /**\n   * Clean up the collection by stopping sync and clearing data\n   * This can be called manually or automatically by garbage collection\n   */\n  public cleanup(): void {\n    this.lazyIndexes.clear()\n    this.resolvedIndexes.clear()\n  }\n}\n", "import { withArrayChangeTracking, withChangeTracking } from \"../proxy\"\nimport { createTransaction, getActiveTransaction } from \"../transactions\"\nimport {\n  DeleteKeyNotFoundError,\n  DuplicateKeyError,\n  InvalidSchemaError,\n  KeyUpdateNotAllowedError,\n  MissingDeleteHandlerError,\n  MissingInsertHandlerError,\n  MissingUpdateArgumentError,\n  MissingUpdateHandlerError,\n  NoKeysPassedToDeleteError,\n  NoKeysPassedToUpdateError,\n  SchemaMustBeSynchronousError,\n  SchemaValidationError,\n  UndefinedKeyError,\n  UpdateKeyNotFoundError,\n} from \"../errors\"\nimport type { Collection, CollectionImpl } from \"./index.js\"\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport type {\n  CollectionConfig,\n  InsertConfig,\n  OperationConfig,\n  PendingMutation,\n  StandardSchema,\n  Transaction as TransactionType,\n  TransactionWithMutations,\n  UtilsRecord,\n  WritableDeep,\n} from \"../types\"\nimport type { CollectionLifecycleManager } from \"./lifecycle\"\nimport type { CollectionStateManager } from \"./state\"\n\nexport class CollectionMutationsManager<\n  TOutput extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n  TUtils extends UtilsRecord = {},\n  TSchema extends StandardSchemaV1 = StandardSchemaV1,\n  TInput extends object = TOutput,\n> {\n  private lifecycle!: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n  private state!: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n  private collection!: CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n  private config!: CollectionConfig<TOutput, TKey, TSchema>\n  private id: string\n\n  constructor(config: CollectionConfig<TOutput, TKey, TSchema>, id: string) {\n    this.id = id\n    this.config = config\n  }\n\n  setDeps(deps: {\n    lifecycle: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n    state: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n    collection: CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n  }) {\n    this.lifecycle = deps.lifecycle\n    this.state = deps.state\n    this.collection = deps.collection\n  }\n\n  private ensureStandardSchema(schema: unknown): StandardSchema<TOutput> {\n    // If the schema already implements the standard-schema interface, return it\n    if (schema && `~standard` in (schema as {})) {\n      return schema as StandardSchema<TOutput>\n    }\n\n    throw new InvalidSchemaError()\n  }\n\n  public validateData(\n    data: unknown,\n    type: `insert` | `update`,\n    key?: TKey\n  ): TOutput | never {\n    if (!this.config.schema) return data as TOutput\n\n    const standardSchema = this.ensureStandardSchema(this.config.schema)\n\n    // For updates, we need to merge with the existing data before validation\n    if (type === `update` && key) {\n      // Get the existing data for this key\n      const existingData = this.state.get(key)\n\n      if (\n        existingData &&\n        data &&\n        typeof data === `object` &&\n        typeof existingData === `object`\n      ) {\n        // Merge the update with the existing data\n        const mergedData = Object.assign({}, existingData, data)\n\n        // Validate the merged data\n        const result = standardSchema[`~standard`].validate(mergedData)\n\n        // Ensure validation is synchronous\n        if (result instanceof Promise) {\n          throw new SchemaMustBeSynchronousError()\n        }\n\n        // If validation fails, throw a SchemaValidationError with the issues\n        if (`issues` in result && result.issues) {\n          const typedIssues = result.issues.map((issue) => ({\n            message: issue.message,\n            path: issue.path?.map((p) => String(p)),\n          }))\n          throw new SchemaValidationError(type, typedIssues)\n        }\n\n        // Extract only the modified keys from the validated result\n        const validatedMergedData = result.value as TOutput\n        const modifiedKeys = Object.keys(data)\n        const extractedChanges = Object.fromEntries(\n          modifiedKeys.map((k) => [k, validatedMergedData[k as keyof TOutput]])\n        ) as TOutput\n\n        return extractedChanges\n      }\n    }\n\n    // For inserts or updates without existing data, validate the data directly\n    const result = standardSchema[`~standard`].validate(data)\n\n    // Ensure validation is synchronous\n    if (result instanceof Promise) {\n      throw new SchemaMustBeSynchronousError()\n    }\n\n    // If validation fails, throw a SchemaValidationError with the issues\n    if (`issues` in result && result.issues) {\n      const typedIssues = result.issues.map((issue) => ({\n        message: issue.message,\n        path: issue.path?.map((p) => String(p)),\n      }))\n      throw new SchemaValidationError(type, typedIssues)\n    }\n\n    return result.value as TOutput\n  }\n\n  public generateGlobalKey(key: any, item: any): string {\n    if (typeof key === `undefined`) {\n      throw new UndefinedKeyError(item)\n    }\n\n    return `KEY::${this.id}/${key}`\n  }\n\n  /**\n   * Inserts one or more items into the collection\n   */\n  insert = (data: TInput | Array<TInput>, config?: InsertConfig) => {\n    this.lifecycle.validateCollectionUsable(`insert`)\n    const state = this.state\n    const ambientTransaction = getActiveTransaction()\n\n    // If no ambient transaction exists, check for an onInsert handler early\n    if (!ambientTransaction && !this.config.onInsert) {\n      throw new MissingInsertHandlerError()\n    }\n\n    const items = Array.isArray(data) ? data : [data]\n    const mutations: Array<PendingMutation<TOutput>> = []\n\n    // Create mutations for each item\n    items.forEach((item) => {\n      // Validate the data against the schema if one exists\n      const validatedData = this.validateData(item, `insert`)\n\n      // Check if an item with this ID already exists in the collection\n      const key = this.config.getKey(validatedData)\n      if (this.state.has(key)) {\n        throw new DuplicateKeyError(key)\n      }\n      const globalKey = this.generateGlobalKey(key, item)\n\n      const mutation: PendingMutation<TOutput, `insert`> = {\n        mutationId: crypto.randomUUID(),\n        original: {},\n        modified: validatedData,\n        // Pick the values from validatedData based on what's passed in - this is for cases\n        // where a schema has default values. The validated data has the extra default\n        // values but for changes, we just want to show the data that was actually passed in.\n        changes: Object.fromEntries(\n          Object.keys(item).map((k) => [\n            k,\n            validatedData[k as keyof typeof validatedData],\n          ])\n        ) as TInput,\n        globalKey,\n        key,\n        metadata: config?.metadata as unknown,\n        syncMetadata: this.config.sync.getSyncMetadata?.() || {},\n        optimistic: config?.optimistic ?? true,\n        type: `insert`,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        collection: this.collection,\n      }\n\n      mutations.push(mutation)\n    })\n\n    // If an ambient transaction exists, use it\n    if (ambientTransaction) {\n      ambientTransaction.applyMutations(mutations)\n\n      state.transactions.set(ambientTransaction.id, ambientTransaction)\n      state.scheduleTransactionCleanup(ambientTransaction)\n      state.recomputeOptimisticState(true)\n\n      return ambientTransaction\n    } else {\n      // Create a new transaction with a mutation function that calls the onInsert handler\n      const directOpTransaction = createTransaction<TOutput>({\n        mutationFn: async (params) => {\n          // Call the onInsert handler with the transaction and collection\n          return await this.config.onInsert!({\n            transaction:\n              params.transaction as unknown as TransactionWithMutations<\n                TOutput,\n                `insert`\n              >,\n            collection: this.collection as unknown as Collection<TOutput, TKey>,\n          })\n        },\n      })\n\n      // Apply mutations to the new transaction\n      directOpTransaction.applyMutations(mutations)\n      // Errors still reject tx.isPersisted.promise; this catch only prevents global unhandled rejections\n      directOpTransaction.commit().catch(() => undefined)\n\n      // Add the transaction to the collection's transactions store\n      state.transactions.set(directOpTransaction.id, directOpTransaction)\n      state.scheduleTransactionCleanup(directOpTransaction)\n      state.recomputeOptimisticState(true)\n\n      return directOpTransaction\n    }\n  }\n\n  /**\n   * Updates one or more items in the collection using a callback function\n   */\n  update(\n    keys: (TKey | unknown) | Array<TKey | unknown>,\n    configOrCallback:\n      | ((draft: WritableDeep<TInput>) => void)\n      | ((drafts: Array<WritableDeep<TInput>>) => void)\n      | OperationConfig,\n    maybeCallback?:\n      | ((draft: WritableDeep<TInput>) => void)\n      | ((drafts: Array<WritableDeep<TInput>>) => void)\n  ) {\n    if (typeof keys === `undefined`) {\n      throw new MissingUpdateArgumentError()\n    }\n\n    const state = this.state\n    this.lifecycle.validateCollectionUsable(`update`)\n\n    const ambientTransaction = getActiveTransaction()\n\n    // If no ambient transaction exists, check for an onUpdate handler early\n    if (!ambientTransaction && !this.config.onUpdate) {\n      throw new MissingUpdateHandlerError()\n    }\n\n    const isArray = Array.isArray(keys)\n    const keysArray = isArray ? keys : [keys]\n\n    if (isArray && keysArray.length === 0) {\n      throw new NoKeysPassedToUpdateError()\n    }\n\n    const callback =\n      typeof configOrCallback === `function` ? configOrCallback : maybeCallback!\n    const config =\n      typeof configOrCallback === `function` ? {} : configOrCallback\n\n    // Get the current objects or empty objects if they don't exist\n    const currentObjects = keysArray.map((key) => {\n      const item = this.state.get(key)\n      if (!item) {\n        throw new UpdateKeyNotFoundError(key)\n      }\n\n      return item\n    }) as unknown as Array<TInput>\n\n    let changesArray\n    if (isArray) {\n      // Use the proxy to track changes for all objects\n      changesArray = withArrayChangeTracking(\n        currentObjects,\n        callback as (draft: Array<TInput>) => void\n      )\n    } else {\n      const result = withChangeTracking(\n        currentObjects[0]!,\n        callback as (draft: TInput) => void\n      )\n      changesArray = [result]\n    }\n\n    // Create mutations for each object that has changes\n    const mutations: Array<\n      PendingMutation<\n        TOutput,\n        `update`,\n        CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n      >\n    > = keysArray\n      .map((key, index) => {\n        const itemChanges = changesArray[index] // User-provided changes for this specific item\n\n        // Skip items with no changes\n        if (!itemChanges || Object.keys(itemChanges).length === 0) {\n          return null\n        }\n\n        const originalItem = currentObjects[index] as unknown as TOutput\n        // Validate the user-provided changes for this item\n        const validatedUpdatePayload = this.validateData(\n          itemChanges,\n          `update`,\n          key\n        )\n\n        // Construct the full modified item by applying the validated update payload to the original item\n        const modifiedItem = Object.assign(\n          {},\n          originalItem,\n          validatedUpdatePayload\n        )\n\n        // Check if the ID of the item is being changed\n        const originalItemId = this.config.getKey(originalItem)\n        const modifiedItemId = this.config.getKey(modifiedItem)\n\n        if (originalItemId !== modifiedItemId) {\n          throw new KeyUpdateNotAllowedError(originalItemId, modifiedItemId)\n        }\n\n        const globalKey = this.generateGlobalKey(modifiedItemId, modifiedItem)\n\n        return {\n          mutationId: crypto.randomUUID(),\n          original: originalItem,\n          modified: modifiedItem,\n          // Pick the values from modifiedItem based on what's passed in - this is for cases\n          // where a schema has default values or transforms. The modified data has the extra\n          // default or transformed values but for changes, we just want to show the data that\n          // was actually passed in.\n          changes: Object.fromEntries(\n            Object.keys(itemChanges).map((k) => [\n              k,\n              modifiedItem[k as keyof typeof modifiedItem],\n            ])\n          ) as TInput,\n          globalKey,\n          key,\n          metadata: config.metadata as unknown,\n          syncMetadata: (state.syncedMetadata.get(key) || {}) as Record<\n            string,\n            unknown\n          >,\n          optimistic: config.optimistic ?? true,\n          type: `update`,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          collection: this.collection,\n        }\n      })\n      .filter(Boolean) as Array<\n      PendingMutation<\n        TOutput,\n        `update`,\n        CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n      >\n    >\n\n    // If no changes were made, return an empty transaction early\n    if (mutations.length === 0) {\n      const emptyTransaction = createTransaction({\n        mutationFn: async () => {},\n      })\n      // Errors still propagate through tx.isPersisted.promise; suppress the background commit from warning\n      emptyTransaction.commit().catch(() => undefined)\n      // Schedule cleanup for empty transaction\n      state.scheduleTransactionCleanup(emptyTransaction)\n      return emptyTransaction\n    }\n\n    // If an ambient transaction exists, use it\n    if (ambientTransaction) {\n      ambientTransaction.applyMutations(mutations)\n\n      state.transactions.set(ambientTransaction.id, ambientTransaction)\n      state.scheduleTransactionCleanup(ambientTransaction)\n      state.recomputeOptimisticState(true)\n\n      return ambientTransaction\n    }\n\n    // No need to check for onUpdate handler here as we've already checked at the beginning\n\n    // Create a new transaction with a mutation function that calls the onUpdate handler\n    const directOpTransaction = createTransaction<TOutput>({\n      mutationFn: async (params) => {\n        // Call the onUpdate handler with the transaction and collection\n        return this.config.onUpdate!({\n          transaction:\n            params.transaction as unknown as TransactionWithMutations<\n              TOutput,\n              `update`\n            >,\n          collection: this.collection as unknown as Collection<TOutput, TKey>,\n        })\n      },\n    })\n\n    // Apply mutations to the new transaction\n    directOpTransaction.applyMutations(mutations)\n    // Errors still hit tx.isPersisted.promise; avoid leaking an unhandled rejection from the fire-and-forget commit\n    directOpTransaction.commit().catch(() => undefined)\n\n    // Add the transaction to the collection's transactions store\n\n    state.transactions.set(directOpTransaction.id, directOpTransaction)\n    state.scheduleTransactionCleanup(directOpTransaction)\n    state.recomputeOptimisticState(true)\n\n    return directOpTransaction\n  }\n\n  /**\n   * Deletes one or more items from the collection\n   */\n  delete = (\n    keys: Array<TKey> | TKey,\n    config?: OperationConfig\n  ): TransactionType<any> => {\n    const state = this.state\n    this.lifecycle.validateCollectionUsable(`delete`)\n\n    const ambientTransaction = getActiveTransaction()\n\n    // If no ambient transaction exists, check for an onDelete handler early\n    if (!ambientTransaction && !this.config.onDelete) {\n      throw new MissingDeleteHandlerError()\n    }\n\n    if (Array.isArray(keys) && keys.length === 0) {\n      throw new NoKeysPassedToDeleteError()\n    }\n\n    const keysArray = Array.isArray(keys) ? keys : [keys]\n    const mutations: Array<\n      PendingMutation<\n        TOutput,\n        `delete`,\n        CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n      >\n    > = []\n\n    for (const key of keysArray) {\n      if (!this.state.has(key)) {\n        throw new DeleteKeyNotFoundError(key)\n      }\n      const globalKey = this.generateGlobalKey(key, this.state.get(key)!)\n      const mutation: PendingMutation<\n        TOutput,\n        `delete`,\n        CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n      > = {\n        mutationId: crypto.randomUUID(),\n        original: this.state.get(key)!,\n        modified: this.state.get(key)!,\n        changes: this.state.get(key)!,\n        globalKey,\n        key,\n        metadata: config?.metadata as unknown,\n        syncMetadata: (state.syncedMetadata.get(key) || {}) as Record<\n          string,\n          unknown\n        >,\n        optimistic: config?.optimistic ?? true,\n        type: `delete`,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        collection: this.collection,\n      }\n\n      mutations.push(mutation)\n    }\n\n    // If an ambient transaction exists, use it\n    if (ambientTransaction) {\n      ambientTransaction.applyMutations(mutations)\n\n      state.transactions.set(ambientTransaction.id, ambientTransaction)\n      state.scheduleTransactionCleanup(ambientTransaction)\n      state.recomputeOptimisticState(true)\n\n      return ambientTransaction\n    }\n\n    // Create a new transaction with a mutation function that calls the onDelete handler\n    const directOpTransaction = createTransaction<TOutput>({\n      autoCommit: true,\n      mutationFn: async (params) => {\n        // Call the onDelete handler with the transaction and collection\n        return this.config.onDelete!({\n          transaction:\n            params.transaction as unknown as TransactionWithMutations<\n              TOutput,\n              `delete`\n            >,\n          collection: this.collection as unknown as Collection<TOutput, TKey>,\n        })\n      },\n    })\n\n    // Apply mutations to the new transaction\n    directOpTransaction.applyMutations(mutations)\n    // Errors still reject tx.isPersisted.promise; silence the internal commit promise to prevent test noise\n    directOpTransaction.commit().catch(() => undefined)\n\n    state.transactions.set(directOpTransaction.id, directOpTransaction)\n    state.scheduleTransactionCleanup(directOpTransaction)\n    state.recomputeOptimisticState(true)\n\n    return directOpTransaction\n  }\n}\n", "import { EventEmitter } from \"../event-emitter.js\"\nimport type { Collection } from \"./index.js\"\nimport type { CollectionStatus } from \"../types.js\"\n\n/**\n * Event emitted when the collection status changes\n */\nexport interface CollectionStatusChangeEvent {\n  type: `status:change`\n  collection: Collection\n  previousStatus: CollectionStatus\n  status: CollectionStatus\n}\n\n/**\n * Event emitted when the collection status changes to a specific status\n */\nexport interface CollectionStatusEvent<T extends CollectionStatus> {\n  type: `status:${T}`\n  collection: Collection\n  previousStatus: CollectionStatus\n  status: T\n}\n\n/**\n * Event emitted when the number of subscribers to the collection changes\n */\nexport interface CollectionSubscribersChangeEvent {\n  type: `subscribers:change`\n  collection: Collection\n  previousSubscriberCount: number\n  subscriberCount: number\n}\n\n/**\n * Event emitted when the collection's loading more state changes\n */\nexport interface CollectionLoadingSubsetChangeEvent {\n  type: `loadingSubset:change`\n  collection: Collection<any, any, any, any, any>\n  isLoadingSubset: boolean\n  previousIsLoadingSubset: boolean\n  loadingSubsetTransition: `start` | `end`\n}\n\nexport type AllCollectionEvents = {\n  \"status:change\": CollectionStatusChangeEvent\n  \"subscribers:change\": CollectionSubscribersChangeEvent\n  \"loadingSubset:change\": CollectionLoadingSubsetChangeEvent\n} & {\n  [K in CollectionStatus as `status:${K}`]: CollectionStatusEvent<K>\n}\n\nexport type CollectionEvent =\n  | AllCollectionEvents[keyof AllCollectionEvents]\n  | CollectionStatusChangeEvent\n  | CollectionSubscribersChangeEvent\n  | CollectionLoadingSubsetChangeEvent\n\nexport type CollectionEventHandler<T extends keyof AllCollectionEvents> = (\n  event: AllCollectionEvents[T]\n) => void\n\nexport class CollectionEventsManager extends EventEmitter<AllCollectionEvents> {\n  private collection!: Collection<any, any, any, any, any>\n\n  constructor() {\n    super()\n  }\n\n  setDeps(deps: { collection: Collection<any, any, any, any, any> }) {\n    this.collection = deps.collection\n  }\n\n  /**\n   * Emit an event to all listeners\n   * Public API for emitting collection events\n   */\n  emit<T extends keyof AllCollectionEvents>(\n    event: T,\n    eventPayload: AllCollectionEvents[T]\n  ): void {\n    this.emitInner(event, eventPayload)\n  }\n\n  emitStatusChange<T extends CollectionStatus>(\n    status: T,\n    previousStatus: CollectionStatus\n  ) {\n    this.emit(`status:change`, {\n      type: `status:change`,\n      collection: this.collection,\n      previousStatus,\n      status,\n    })\n\n    // Emit specific status event using type assertion\n    const eventKey: `status:${T}` = `status:${status}`\n    this.emit(eventKey, {\n      type: eventKey,\n      collection: this.collection,\n      previousStatus,\n      status,\n    } as AllCollectionEvents[`status:${T}`])\n  }\n\n  emitSubscribersChange(\n    subscriberCount: number,\n    previousSubscriberCount: number\n  ) {\n    this.emit(`subscribers:change`, {\n      type: `subscribers:change`,\n      collection: this.collection,\n      previousSubscriberCount,\n      subscriberCount,\n    })\n  }\n\n  cleanup() {\n    this.clearListeners()\n  }\n}\n", "import {\n  CollectionRequiresConfigError,\n  CollectionRequiresSyncConfigError,\n} from \"../errors\"\nimport { currentStateAsChanges } from \"./change-events\"\n\nimport { CollectionStateManager } from \"./state\"\nimport { CollectionChangesManager } from \"./changes\"\nimport { CollectionLifecycleManager } from \"./lifecycle.js\"\nimport { CollectionSyncManager } from \"./sync\"\nimport { CollectionIndexesManager } from \"./indexes\"\nimport { CollectionMutationsManager } from \"./mutations\"\nimport { CollectionEventsManager } from \"./events.js\"\nimport type { CollectionSubscription } from \"./subscription\"\nimport type { AllCollectionEvents, CollectionEventHandler } from \"./events.js\"\nimport type { BaseIndex, IndexResolver } from \"../indexes/base-index.js\"\nimport type { IndexOptions } from \"../indexes/index-options.js\"\nimport type {\n  ChangeMessage,\n  CollectionConfig,\n  CollectionStatus,\n  CurrentStateAsChangesOptions,\n  Fn,\n  InferSchemaInput,\n  InferSchemaOutput,\n  InsertConfig,\n  NonSingleResult,\n  OperationConfig,\n  SingleResult,\n  StringCollationConfig,\n  SubscribeChangesOptions,\n  Transaction as TransactionType,\n  UtilsRecord,\n  WritableDeep,\n} from \"../types\"\nimport type { SingleRowRefProxy } from \"../query/builder/ref-proxy\"\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport type { BTreeIndex } from \"../indexes/btree-index.js\"\nimport type { IndexProxy } from \"../indexes/lazy-index.js\"\n\n/**\n * Enhanced Collection interface that includes both data type T and utilities TUtils\n * @template T - The type of items in the collection\n * @template TKey - The type of the key for the collection\n * @template TUtils - The utilities record type\n * @template TInsertInput - The type for insert operations (can be different from T for schemas with defaults)\n */\nexport interface Collection<\n  T extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n  TUtils extends UtilsRecord = UtilsRecord,\n  TSchema extends StandardSchemaV1 = StandardSchemaV1,\n  TInsertInput extends object = T,\n> extends CollectionImpl<T, TKey, TUtils, TSchema, TInsertInput> {\n  readonly utils: TUtils\n  readonly singleResult?: true\n}\n\n/**\n * Creates a new Collection instance with the given configuration\n *\n * @template T - The schema type if a schema is provided, otherwise the type of items in the collection\n * @template TKey - The type of the key for the collection\n * @template TUtils - The utilities record type\n * @param options - Collection options with optional utilities\n * @returns A new Collection with utilities exposed both at top level and under .utils\n *\n * @example\n * // Pattern 1: With operation handlers (direct collection calls)\n * const todos = createCollection({\n *   id: \"todos\",\n *   getKey: (todo) => todo.id,\n *   schema,\n *   onInsert: async ({ transaction, collection }) => {\n *     // Send to API\n *     await api.createTodo(transaction.mutations[0].modified)\n *   },\n *   onUpdate: async ({ transaction, collection }) => {\n *     await api.updateTodo(transaction.mutations[0].modified)\n *   },\n *   onDelete: async ({ transaction, collection }) => {\n *     await api.deleteTodo(transaction.mutations[0].key)\n *   },\n *   sync: { sync: () => {} }\n * })\n *\n * // Direct usage (handlers manage transactions)\n * const tx = todos.insert({ id: \"1\", text: \"Buy milk\", completed: false })\n * await tx.isPersisted.promise\n *\n * @example\n * // Pattern 2: Manual transaction management\n * const todos = createCollection({\n *   getKey: (todo) => todo.id,\n *   schema: todoSchema,\n *   sync: { sync: () => {} }\n * })\n *\n * // Explicit transaction usage\n * const tx = createTransaction({\n *   mutationFn: async ({ transaction }) => {\n *     // Handle all mutations in transaction\n *     await api.saveChanges(transaction.mutations)\n *   }\n * })\n *\n * tx.mutate(() => {\n *   todos.insert({ id: \"1\", text: \"Buy milk\" })\n *   todos.update(\"2\", draft => { draft.completed = true })\n * })\n *\n * await tx.isPersisted.promise\n *\n * @example\n * // Using schema for type inference (preferred as it also gives you client side validation)\n * const todoSchema = z.object({\n *   id: z.string(),\n *   title: z.string(),\n *   completed: z.boolean()\n * })\n *\n * const todos = createCollection({\n *   schema: todoSchema,\n *   getKey: (todo) => todo.id,\n *   sync: { sync: () => {} }\n * })\n *\n */\n\n// Overload for when schema is provided\nexport function createCollection<\n  T extends StandardSchemaV1,\n  TKey extends string | number = string | number,\n  TUtils extends UtilsRecord = UtilsRecord,\n>(\n  options: CollectionConfig<InferSchemaOutput<T>, TKey, T, TUtils> & {\n    schema: T\n    utils?: TUtils\n  } & NonSingleResult\n): Collection<InferSchemaOutput<T>, TKey, TUtils, T, InferSchemaInput<T>> &\n  NonSingleResult\n\n// Overload for when schema is provided and singleResult is true\nexport function createCollection<\n  T extends StandardSchemaV1,\n  TKey extends string | number = string | number,\n  TUtils extends UtilsRecord = UtilsRecord,\n>(\n  options: CollectionConfig<InferSchemaOutput<T>, TKey, T, TUtils> & {\n    schema: T\n    utils?: TUtils\n  } & SingleResult\n): Collection<InferSchemaOutput<T>, TKey, TUtils, T, InferSchemaInput<T>> &\n  SingleResult\n\n// Overload for when no schema is provided\n// the type T needs to be passed explicitly unless it can be inferred from the getKey function in the config\nexport function createCollection<\n  T extends object,\n  TKey extends string | number = string | number,\n  TUtils extends UtilsRecord = UtilsRecord,\n>(\n  options: CollectionConfig<T, TKey, never, TUtils> & {\n    schema?: never // prohibit schema if an explicit type is provided\n    utils?: TUtils\n  } & NonSingleResult\n): Collection<T, TKey, TUtils, never, T> & NonSingleResult\n\n// Overload for when no schema is provided and singleResult is true\n// the type T needs to be passed explicitly unless it can be inferred from the getKey function in the config\nexport function createCollection<\n  T extends object,\n  TKey extends string | number = string | number,\n  TUtils extends UtilsRecord = UtilsRecord,\n>(\n  options: CollectionConfig<T, TKey, never, TUtils> & {\n    schema?: never // prohibit schema if an explicit type is provided\n    utils?: TUtils\n  } & SingleResult\n): Collection<T, TKey, TUtils, never, T> & SingleResult\n\n// Implementation\nexport function createCollection(\n  options: CollectionConfig<any, string | number, any> & {\n    schema?: StandardSchemaV1\n    utils?: UtilsRecord\n  }\n): Collection<any, string | number, UtilsRecord, any, any> {\n  const collection = new CollectionImpl<any, string | number, any, any, any>(\n    options\n  )\n\n  // Attach utils to collection\n  if (options.utils) {\n    collection.utils = options.utils\n  } else {\n    collection.utils = {}\n  }\n\n  return collection\n}\n\nexport class CollectionImpl<\n  TOutput extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n  TUtils extends UtilsRecord = {},\n  TSchema extends StandardSchemaV1 = StandardSchemaV1,\n  TInput extends object = TOutput,\n> {\n  public id: string\n  public config: CollectionConfig<TOutput, TKey, TSchema>\n\n  // Utilities namespace\n  // This is populated by createCollection\n  public utils: Record<string, Fn> = {}\n\n  // Managers\n  private _events: CollectionEventsManager\n  private _changes: CollectionChangesManager<TOutput, TKey, TSchema, TInput>\n  public _lifecycle: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n  public _sync: CollectionSyncManager<TOutput, TKey, TSchema, TInput>\n  private _indexes: CollectionIndexesManager<TOutput, TKey, TSchema, TInput>\n  private _mutations: CollectionMutationsManager<\n    TOutput,\n    TKey,\n    TUtils,\n    TSchema,\n    TInput\n  >\n  // The core state of the collection is \"public\" so that is accessible in tests\n  // and for debugging\n  public _state: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n\n  private comparisonOpts: StringCollationConfig\n\n  /**\n   * Creates a new Collection instance\n   *\n   * @param config - Configuration object for the collection\n   * @throws Error if sync config is missing\n   */\n  constructor(config: CollectionConfig<TOutput, TKey, TSchema>) {\n    // eslint-disable-next-line\n    if (!config) {\n      throw new CollectionRequiresConfigError()\n    }\n\n    // eslint-disable-next-line\n    if (!config.sync) {\n      throw new CollectionRequiresSyncConfigError()\n    }\n\n    if (config.id) {\n      this.id = config.id\n    } else {\n      this.id = crypto.randomUUID()\n    }\n\n    // Set default values for optional config properties\n    this.config = {\n      ...config,\n      autoIndex: config.autoIndex ?? `eager`,\n    }\n\n    this._changes = new CollectionChangesManager()\n    this._events = new CollectionEventsManager()\n    this._indexes = new CollectionIndexesManager()\n    this._lifecycle = new CollectionLifecycleManager(config, this.id)\n    this._mutations = new CollectionMutationsManager(config, this.id)\n    this._state = new CollectionStateManager(config)\n    this._sync = new CollectionSyncManager(config, this.id)\n\n    this.comparisonOpts = buildCompareOptionsFromConfig(config)\n\n    this._changes.setDeps({\n      collection: this, // Required for passing to CollectionSubscription\n      lifecycle: this._lifecycle,\n      sync: this._sync,\n      events: this._events,\n    })\n    this._events.setDeps({\n      collection: this, // Required for adding to emitted events\n    })\n    this._indexes.setDeps({\n      state: this._state,\n      lifecycle: this._lifecycle,\n    })\n    this._lifecycle.setDeps({\n      changes: this._changes,\n      events: this._events,\n      indexes: this._indexes,\n      state: this._state,\n      sync: this._sync,\n    })\n    this._mutations.setDeps({\n      collection: this, // Required for passing to config.onInsert/onUpdate/onDelete and annotating mutations\n      lifecycle: this._lifecycle,\n      state: this._state,\n    })\n    this._state.setDeps({\n      collection: this, // Required for filtering events to only include this collection\n      lifecycle: this._lifecycle,\n      changes: this._changes,\n      indexes: this._indexes,\n    })\n    this._sync.setDeps({\n      collection: this, // Required for passing to config.sync callback\n      state: this._state,\n      lifecycle: this._lifecycle,\n      events: this._events,\n    })\n\n    // Only start sync immediately if explicitly enabled\n    if (config.startSync === true) {\n      this._sync.startSync()\n    }\n  }\n\n  /**\n   * Gets the current status of the collection\n   */\n  public get status(): CollectionStatus {\n    return this._lifecycle.status\n  }\n\n  /**\n   * Get the number of subscribers to the collection\n   */\n  public get subscriberCount(): number {\n    return this._changes.activeSubscribersCount\n  }\n\n  /**\n   * Register a callback to be executed when the collection first becomes ready\n   * Useful for preloading collections\n   * @param callback Function to call when the collection first becomes ready\n   * @example\n   * collection.onFirstReady(() => {\n   *   console.log('Collection is ready for the first time')\n   *   // Safe to access collection.state now\n   * })\n   */\n  public onFirstReady(callback: () => void): void {\n    return this._lifecycle.onFirstReady(callback)\n  }\n\n  /**\n   * Check if the collection is ready for use\n   * Returns true if the collection has been marked as ready by its sync implementation\n   * @returns true if the collection is ready, false otherwise\n   * @example\n   * if (collection.isReady()) {\n   *   console.log('Collection is ready, data is available')\n   *   // Safe to access collection.state\n   * } else {\n   *   console.log('Collection is still loading')\n   * }\n   */\n  public isReady(): boolean {\n    return this._lifecycle.status === `ready`\n  }\n\n  /**\n   * Check if the collection is currently loading more data\n   * @returns true if the collection has pending load more operations, false otherwise\n   */\n  public get isLoadingSubset(): boolean {\n    return this._sync.isLoadingSubset\n  }\n\n  /**\n   * Start sync immediately - internal method for compiled queries\n   * This bypasses lazy loading for special cases like live query results\n   */\n  public startSyncImmediate(): void {\n    this._sync.startSync()\n  }\n\n  /**\n   * Preload the collection data by starting sync if not already started\n   * Multiple concurrent calls will share the same promise\n   */\n  public preload(): Promise<void> {\n    return this._sync.preload()\n  }\n\n  /**\n   * Get the current value for a key (virtual derived state)\n   */\n  public get(key: TKey): TOutput | undefined {\n    return this._state.get(key)\n  }\n\n  /**\n   * Check if a key exists in the collection (virtual derived state)\n   */\n  public has(key: TKey): boolean {\n    return this._state.has(key)\n  }\n\n  /**\n   * Get the current size of the collection (cached)\n   */\n  public get size(): number {\n    return this._state.size\n  }\n\n  /**\n   * Get all keys (virtual derived state)\n   */\n  public *keys(): IterableIterator<TKey> {\n    yield* this._state.keys()\n  }\n\n  /**\n   * Get all values (virtual derived state)\n   */\n  public *values(): IterableIterator<TOutput> {\n    yield* this._state.values()\n  }\n\n  /**\n   * Get all entries (virtual derived state)\n   */\n  public *entries(): IterableIterator<[TKey, TOutput]> {\n    yield* this._state.entries()\n  }\n\n  /**\n   * Get all entries (virtual derived state)\n   */\n  public *[Symbol.iterator](): IterableIterator<[TKey, TOutput]> {\n    yield* this._state[Symbol.iterator]()\n  }\n\n  /**\n   * Execute a callback for each entry in the collection\n   */\n  public forEach(\n    callbackfn: (value: TOutput, key: TKey, index: number) => void\n  ): void {\n    return this._state.forEach(callbackfn)\n  }\n\n  /**\n   * Create a new array with the results of calling a function for each entry in the collection\n   */\n  public map<U>(\n    callbackfn: (value: TOutput, key: TKey, index: number) => U\n  ): Array<U> {\n    return this._state.map(callbackfn)\n  }\n\n  public getKeyFromItem(item: TOutput): TKey {\n    return this.config.getKey(item)\n  }\n\n  /**\n   * Creates an index on a collection for faster queries.\n   * Indexes significantly improve query performance by allowing constant time lookups\n   * and logarithmic time range queries instead of full scans.\n   *\n   * @template TResolver - The type of the index resolver (constructor or async loader)\n   * @param indexCallback - Function that extracts the indexed value from each item\n   * @param config - Configuration including index type and type-specific options\n   * @returns An index proxy that provides access to the index when ready\n   *\n   * @example\n   * // Create a default B+ tree index\n   * const ageIndex = collection.createIndex((row) => row.age)\n   *\n   * // Create a ordered index with custom options\n   * const ageIndex = collection.createIndex((row) => row.age, {\n   *   indexType: BTreeIndex,\n   *   options: {\n   *     compareFn: customComparator,\n   *     compareOptions: { direction: 'asc', nulls: 'first', stringSort: 'lexical' }\n   *   },\n   *   name: 'age_btree'\n   * })\n   *\n   * // Create an async-loaded index\n   * const textIndex = collection.createIndex((row) => row.content, {\n   *   indexType: async () => {\n   *     const { FullTextIndex } = await import('./indexes/fulltext.js')\n   *     return FullTextIndex\n   *   },\n   *   options: { language: 'en' }\n   * })\n   */\n  public createIndex<TResolver extends IndexResolver<TKey> = typeof BTreeIndex>(\n    indexCallback: (row: SingleRowRefProxy<TOutput>) => any,\n    config: IndexOptions<TResolver> = {}\n  ): IndexProxy<TKey> {\n    return this._indexes.createIndex(indexCallback, config)\n  }\n\n  /**\n   * Get resolved indexes for query optimization\n   */\n  get indexes(): Map<number, BaseIndex<TKey>> {\n    return this._indexes.indexes\n  }\n\n  /**\n   * Validates the data against the schema\n   */\n  public validateData(\n    data: unknown,\n    type: `insert` | `update`,\n    key?: TKey\n  ): TOutput | never {\n    return this._mutations.validateData(data, type, key)\n  }\n\n  get compareOptions(): StringCollationConfig {\n    // return a copy such that no one can mutate the internal comparison object\n    return { ...this.comparisonOpts }\n  }\n\n  /**\n   * Inserts one or more items into the collection\n   * @param items - Single item or array of items to insert\n   * @param config - Optional configuration including metadata\n   * @returns A Transaction object representing the insert operation(s)\n   * @throws {SchemaValidationError} If the data fails schema validation\n   * @example\n   * // Insert a single todo (requires onInsert handler)\n   * const tx = collection.insert({ id: \"1\", text: \"Buy milk\", completed: false })\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Insert multiple todos at once\n   * const tx = collection.insert([\n   *   { id: \"1\", text: \"Buy milk\", completed: false },\n   *   { id: \"2\", text: \"Walk dog\", completed: true }\n   * ])\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Insert with metadata\n   * const tx = collection.insert({ id: \"1\", text: \"Buy groceries\" },\n   *   { metadata: { source: \"mobile-app\" } }\n   * )\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Handle errors\n   * try {\n   *   const tx = collection.insert({ id: \"1\", text: \"New item\" })\n   *   await tx.isPersisted.promise\n   *   console.log('Insert successful')\n   * } catch (error) {\n   *   console.log('Insert failed:', error)\n   * }\n   */\n  insert = (data: TInput | Array<TInput>, config?: InsertConfig) => {\n    return this._mutations.insert(data, config)\n  }\n\n  /**\n   * Updates one or more items in the collection using a callback function\n   * @param keys - Single key or array of keys to update\n   * @param configOrCallback - Either update configuration or update callback\n   * @param maybeCallback - Update callback if config was provided\n   * @returns A Transaction object representing the update operation(s)\n   * @throws {SchemaValidationError} If the updated data fails schema validation\n   * @example\n   * // Update single item by key\n   * const tx = collection.update(\"todo-1\", (draft) => {\n   *   draft.completed = true\n   * })\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Update multiple items\n   * const tx = collection.update([\"todo-1\", \"todo-2\"], (drafts) => {\n   *   drafts.forEach(draft => { draft.completed = true })\n   * })\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Update with metadata\n   * const tx = collection.update(\"todo-1\",\n   *   { metadata: { reason: \"user update\" } },\n   *   (draft) => { draft.text = \"Updated text\" }\n   * )\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Handle errors\n   * try {\n   *   const tx = collection.update(\"item-1\", draft => { draft.value = \"new\" })\n   *   await tx.isPersisted.promise\n   *   console.log('Update successful')\n   * } catch (error) {\n   *   console.log('Update failed:', error)\n   * }\n   */\n\n  // Overload 1: Update multiple items with a callback\n  update(\n    key: Array<TKey | unknown>,\n    callback: (drafts: Array<WritableDeep<TInput>>) => void\n  ): TransactionType\n\n  // Overload 2: Update multiple items with config and a callback\n  update(\n    keys: Array<TKey | unknown>,\n    config: OperationConfig,\n    callback: (drafts: Array<WritableDeep<TInput>>) => void\n  ): TransactionType\n\n  // Overload 3: Update a single item with a callback\n  update(\n    id: TKey | unknown,\n    callback: (draft: WritableDeep<TInput>) => void\n  ): TransactionType\n\n  // Overload 4: Update a single item with config and a callback\n  update(\n    id: TKey | unknown,\n    config: OperationConfig,\n    callback: (draft: WritableDeep<TInput>) => void\n  ): TransactionType\n\n  update(\n    keys: (TKey | unknown) | Array<TKey | unknown>,\n    configOrCallback:\n      | ((draft: WritableDeep<TInput>) => void)\n      | ((drafts: Array<WritableDeep<TInput>>) => void)\n      | OperationConfig,\n    maybeCallback?:\n      | ((draft: WritableDeep<TInput>) => void)\n      | ((drafts: Array<WritableDeep<TInput>>) => void)\n  ) {\n    return this._mutations.update(keys, configOrCallback, maybeCallback)\n  }\n\n  /**\n   * Deletes one or more items from the collection\n   * @param keys - Single key or array of keys to delete\n   * @param config - Optional configuration including metadata\n   * @returns A Transaction object representing the delete operation(s)\n   * @example\n   * // Delete a single item\n   * const tx = collection.delete(\"todo-1\")\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Delete multiple items\n   * const tx = collection.delete([\"todo-1\", \"todo-2\"])\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Delete with metadata\n   * const tx = collection.delete(\"todo-1\", { metadata: { reason: \"completed\" } })\n   * await tx.isPersisted.promise\n   *\n   * @example\n   * // Handle errors\n   * try {\n   *   const tx = collection.delete(\"item-1\")\n   *   await tx.isPersisted.promise\n   *   console.log('Delete successful')\n   * } catch (error) {\n   *   console.log('Delete failed:', error)\n   * }\n   */\n  delete = (\n    keys: Array<TKey> | TKey,\n    config?: OperationConfig\n  ): TransactionType<any> => {\n    return this._mutations.delete(keys, config)\n  }\n\n  /**\n   * Gets the current state of the collection as a Map\n   * @returns Map containing all items in the collection, with keys as identifiers\n   * @example\n   * const itemsMap = collection.state\n   * console.log(`Collection has ${itemsMap.size} items`)\n   *\n   * for (const [key, item] of itemsMap) {\n   *   console.log(`${key}: ${item.title}`)\n   * }\n   *\n   * // Check if specific item exists\n   * if (itemsMap.has(\"todo-1\")) {\n   *   console.log(\"Todo 1 exists:\", itemsMap.get(\"todo-1\"))\n   * }\n   */\n  get state() {\n    const result = new Map<TKey, TOutput>()\n    for (const [key, value] of this.entries()) {\n      result.set(key, value)\n    }\n    return result\n  }\n\n  /**\n   * Gets the current state of the collection as a Map, but only resolves when data is available\n   * Waits for the first sync commit to complete before resolving\n   *\n   * @returns Promise that resolves to a Map containing all items in the collection\n   */\n  stateWhenReady(): Promise<Map<TKey, TOutput>> {\n    // If we already have data or collection is ready, resolve immediately\n    if (this.size > 0 || this.isReady()) {\n      return Promise.resolve(this.state)\n    }\n\n    // Use preload to ensure the collection starts loading, then return the state\n    return this.preload().then(() => this.state)\n  }\n\n  /**\n   * Gets the current state of the collection as an Array\n   *\n   * @returns An Array containing all items in the collection\n   */\n  get toArray() {\n    return Array.from(this.values())\n  }\n\n  /**\n   * Gets the current state of the collection as an Array, but only resolves when data is available\n   * Waits for the first sync commit to complete before resolving\n   *\n   * @returns Promise that resolves to an Array containing all items in the collection\n   */\n  toArrayWhenReady(): Promise<Array<TOutput>> {\n    // If we already have data or collection is ready, resolve immediately\n    if (this.size > 0 || this.isReady()) {\n      return Promise.resolve(this.toArray)\n    }\n\n    // Use preload to ensure the collection starts loading, then return the array\n    return this.preload().then(() => this.toArray)\n  }\n\n  /**\n   * Returns the current state of the collection as an array of changes\n   * @param options - Options including optional where filter\n   * @returns An array of changes\n   * @example\n   * // Get all items as changes\n   * const allChanges = collection.currentStateAsChanges()\n   *\n   * // Get only items matching a condition\n   * const activeChanges = collection.currentStateAsChanges({\n   *   where: (row) => row.status === 'active'\n   * })\n   *\n   * // Get only items using a pre-compiled expression\n   * const activeChanges = collection.currentStateAsChanges({\n   *   whereExpression: eq(row.status, 'active')\n   * })\n   */\n  public currentStateAsChanges(\n    options: CurrentStateAsChangesOptions = {}\n  ): Array<ChangeMessage<TOutput>> | void {\n    return currentStateAsChanges(this, options)\n  }\n\n  /**\n   * Subscribe to changes in the collection\n   * @param callback - Function called when items change\n   * @param options - Subscription options including includeInitialState and where filter\n   * @returns Unsubscribe function - Call this to stop listening for changes\n   * @example\n   * // Basic subscription\n   * const subscription = collection.subscribeChanges((changes) => {\n   *   changes.forEach(change => {\n   *     console.log(`${change.type}: ${change.key}`, change.value)\n   *   })\n   * })\n   *\n   * // Later: subscription.unsubscribe()\n   *\n   * @example\n   * // Include current state immediately\n   * const subscription = collection.subscribeChanges((changes) => {\n   *   updateUI(changes)\n   * }, { includeInitialState: true })\n   *\n   * @example\n   * // Subscribe only to changes matching a condition\n   * const subscription = collection.subscribeChanges((changes) => {\n   *   updateUI(changes)\n   * }, {\n   *   includeInitialState: true,\n   *   where: (row) => row.status === 'active'\n   * })\n   *\n   * @example\n   * // Subscribe using a pre-compiled expression\n   * const subscription = collection.subscribeChanges((changes) => {\n   *   updateUI(changes)\n   * }, {\n   *   includeInitialState: true,\n   *   whereExpression: eq(row.status, 'active')\n   * })\n   */\n  public subscribeChanges(\n    callback: (changes: Array<ChangeMessage<TOutput>>) => void,\n    options: SubscribeChangesOptions = {}\n  ): CollectionSubscription {\n    return this._changes.subscribeChanges(callback, options)\n  }\n\n  /**\n   * Subscribe to a collection event\n   */\n  public on<T extends keyof AllCollectionEvents>(\n    event: T,\n    callback: CollectionEventHandler<T>\n  ) {\n    return this._events.on(event, callback)\n  }\n\n  /**\n   * Subscribe to a collection event once\n   */\n  public once<T extends keyof AllCollectionEvents>(\n    event: T,\n    callback: CollectionEventHandler<T>\n  ) {\n    return this._events.once(event, callback)\n  }\n\n  /**\n   * Unsubscribe from a collection event\n   */\n  public off<T extends keyof AllCollectionEvents>(\n    event: T,\n    callback: CollectionEventHandler<T>\n  ) {\n    this._events.off(event, callback)\n  }\n\n  /**\n   * Wait for a collection event\n   */\n  public waitFor<T extends keyof AllCollectionEvents>(\n    event: T,\n    timeout?: number\n  ) {\n    return this._events.waitFor(event, timeout)\n  }\n\n  /**\n   * Clean up the collection by stopping sync and clearing data\n   * This can be called manually or automatically by garbage collection\n   */\n  public async cleanup(): Promise<void> {\n    this._lifecycle.cleanup()\n    return Promise.resolve()\n  }\n}\n\nfunction buildCompareOptionsFromConfig(\n  config: CollectionConfig<any, any, any>\n): StringCollationConfig {\n  if (config.defaultStringCollation) {\n    const options = config.defaultStringCollation\n    return {\n      stringSort: options.stringSort ?? `locale`,\n      locale: options.stringSort === `locale` ? options.locale : undefined,\n      localeOptions:\n        options.stringSort === `locale` ? options.localeOptions : undefined,\n    }\n  } else {\n    return {\n      stringSort: `locale`,\n    }\n  }\n}\n", "/**\n * Type guard to check if a value is promise-like (has a `.then` method)\n * @param value - The value to check\n * @returns True if the value is promise-like, false otherwise\n */\nexport function isPromiseLike(value: unknown): value is PromiseLike<unknown> {\n  return (\n    !!value &&\n    (typeof value === `object` || typeof value === `function`) &&\n    typeof (value as { then?: unknown }).then === `function`\n  )\n}\n", "import { createTransaction } from \"./transactions\"\nimport { OnMutateMustBeSynchronousError } from \"./errors\"\nimport { isPromiseLike } from \"./utils/type-guards\"\nimport type { CreateOptimisticActionsOptions, Transaction } from \"./types\"\n\n/**\n * Creates an optimistic action function that applies local optimistic updates immediately\n * before executing the actual mutation on the server.\n *\n * This pattern allows for responsive UI updates while the actual mutation is in progress.\n * The optimistic update is applied via the `onMutate` callback, and the server mutation\n * is executed via the `mutationFn`.\n *\n * **Important:** Inside your `mutationFn`, you must ensure that your server writes have synced back\n * before you return, as the optimistic state is dropped when you return from the mutation function.\n * You generally use collection-specific helpers to do this, such as Query's `utils.refetch()`,\n * direct write APIs, or Electric's `utils.awaitTxId()`.\n *\n * @example\n * ```ts\n * const addTodo = createOptimisticAction<string>({\n *   onMutate: (text) => {\n *     // Instantly applies local optimistic state\n *     todoCollection.insert({\n *       id: uuid(),\n *       text,\n *       completed: false\n *     })\n *   },\n *   mutationFn: async (text, params) => {\n *     // Persist the todo to your backend\n *     const response = await fetch('/api/todos', {\n *       method: 'POST',\n *       body: JSON.stringify({ text, completed: false }),\n *     })\n *     const result = await response.json()\n *\n *     // IMPORTANT: Ensure server writes have synced back before returning\n *     // This ensures the optimistic state can be safely discarded\n *     await todoCollection.utils.refetch()\n *\n *     return result\n *   }\n * })\n *\n * // Usage\n * const transaction = addTodo('New Todo Item')\n * ```\n *\n * @template TVariables - The type of variables that will be passed to the action function\n * @param options - Configuration options for the optimistic action\n * @returns A function that accepts variables of type TVariables and returns a Transaction\n */\nexport function createOptimisticAction<TVariables = unknown>(\n  options: CreateOptimisticActionsOptions<TVariables>\n) {\n  const { mutationFn, onMutate, ...config } = options\n\n  return (variables: TVariables): Transaction => {\n    // Create transaction with the original config\n    const transaction = createTransaction({\n      ...config,\n      // Wire the mutationFn to use the provided variables\n      mutationFn: async (params) => {\n        return await mutationFn(variables, params)\n      },\n    })\n\n    // Execute the transaction. The mutationFn is called once mutate()\n    // is finished.\n    transaction.mutate(() => {\n      const maybePromise = onMutate(variables) as unknown\n\n      if (isPromiseLike(maybePromise)) {\n        throw new OnMutateMustBeSynchronousError()\n      }\n    })\n\n    return transaction\n  }\n}\n", "import type {\n  BaseCollectionConfig,\n  CollectionConfig,\n  DeleteMutationFnParams,\n  InferSchemaOutput,\n  InsertMutationFnParams,\n  OperationType,\n  PendingMutation,\n  SyncConfig,\n  UpdateMutationFnParams,\n  UtilsRecord,\n} from \"./types\"\nimport type { Collection } from \"./collection/index\"\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\n\n/**\n * Configuration interface for Local-only collection options\n * @template T - The type of items in the collection\n * @template TSchema - The schema type for validation\n * @template TKey - The type of the key returned by `getKey`\n */\nexport interface LocalOnlyCollectionConfig<\n  T extends object = object,\n  TSchema extends StandardSchemaV1 = never,\n  TKey extends string | number = string | number,\n> extends Omit<\n    BaseCollectionConfig<T, TKey, TSchema, LocalOnlyCollectionUtils>,\n    `gcTime` | `startSync`\n  > {\n  /**\n   * Optional initial data to populate the collection with on creation\n   * This data will be applied during the initial sync process\n   */\n  initialData?: Array<T>\n}\n\n/**\n * Local-only collection utilities type\n */\nexport interface LocalOnlyCollectionUtils extends UtilsRecord {\n  /**\n   * Accepts mutations from a transaction that belong to this collection and persists them.\n   * This should be called in your transaction's mutationFn to persist local-only data.\n   *\n   * @param transaction - The transaction containing mutations to accept\n   * @example\n   * const localData = createCollection(localOnlyCollectionOptions({...}))\n   *\n   * const tx = createTransaction({\n   *   mutationFn: async ({ transaction }) => {\n   *     // Make API call first\n   *     await api.save(...)\n   *     // Then persist local-only mutations after success\n   *     localData.utils.acceptMutations(transaction)\n   *   }\n   * })\n   */\n  acceptMutations: (transaction: {\n    mutations: Array<PendingMutation<Record<string, unknown>>>\n  }) => void\n}\n\ntype LocalOnlyCollectionOptionsResult<\n  T extends object,\n  TKey extends string | number,\n  TSchema extends StandardSchemaV1 | never = never,\n> = CollectionConfig<T, TKey, TSchema> & {\n  utils: LocalOnlyCollectionUtils\n}\n\n/**\n * Creates Local-only collection options for use with a standard Collection\n *\n * This is an in-memory collection that doesn't sync with external sources but uses a loopback sync config\n * that immediately \"syncs\" all optimistic changes to the collection, making them permanent.\n * Perfect for local-only data that doesn't need persistence or external synchronization.\n *\n * **Using with Manual Transactions:**\n *\n * For manual transactions, you must call `utils.acceptMutations()` in your transaction's `mutationFn`\n * to persist changes made during `tx.mutate()`. This is necessary because local-only collections\n * don't participate in the standard mutation handler flow for manual transactions.\n *\n * @template T - The schema type if a schema is provided, otherwise the type of items in the collection\n * @template TKey - The type of the key returned by getKey\n * @param config - Configuration options for the Local-only collection\n * @returns Collection options with utilities including acceptMutations\n *\n * @example\n * // Basic local-only collection\n * const collection = createCollection(\n *   localOnlyCollectionOptions({\n *     getKey: (item) => item.id,\n *   })\n * )\n *\n * @example\n * // Local-only collection with initial data\n * const collection = createCollection(\n *   localOnlyCollectionOptions({\n *     getKey: (item) => item.id,\n *     initialData: [\n *       { id: 1, name: 'Item 1' },\n *       { id: 2, name: 'Item 2' },\n *     ],\n *   })\n * )\n *\n * @example\n * // Local-only collection with mutation handlers\n * const collection = createCollection(\n *   localOnlyCollectionOptions({\n *     getKey: (item) => item.id,\n *     onInsert: async ({ transaction }) => {\n *       console.log('Item inserted:', transaction.mutations[0].modified)\n *       // Custom logic after insert\n *     },\n *   })\n * )\n *\n * @example\n * // Using with manual transactions\n * const localData = createCollection(\n *   localOnlyCollectionOptions({\n *     getKey: (item) => item.id,\n *   })\n * )\n *\n * const tx = createTransaction({\n *   mutationFn: async ({ transaction }) => {\n *     // Use local data in API call\n *     const localMutations = transaction.mutations.filter(m => m.collection === localData)\n *     await api.save({ metadata: localMutations[0]?.modified })\n *\n *     // Persist local-only mutations after API success\n *     localData.utils.acceptMutations(transaction)\n *   }\n * })\n *\n * tx.mutate(() => {\n *   localData.insert({ id: 1, data: 'metadata' })\n *   apiCollection.insert({ id: 2, data: 'main data' })\n * })\n *\n * await tx.commit()\n */\n\n// Overload for when schema is provided\nexport function localOnlyCollectionOptions<\n  T extends StandardSchemaV1,\n  TKey extends string | number = string | number,\n>(\n  config: LocalOnlyCollectionConfig<InferSchemaOutput<T>, T, TKey> & {\n    schema: T\n  }\n): LocalOnlyCollectionOptionsResult<InferSchemaOutput<T>, TKey, T> & {\n  schema: T\n}\n\n// Overload for when no schema is provided\n// the type T needs to be passed explicitly unless it can be inferred from the getKey function in the config\nexport function localOnlyCollectionOptions<\n  T extends object,\n  TKey extends string | number = string | number,\n>(\n  config: LocalOnlyCollectionConfig<T, never, TKey> & {\n    schema?: never // prohibit schema\n  }\n): LocalOnlyCollectionOptionsResult<T, TKey> & {\n  schema?: never // no schema in the result\n}\n\nexport function localOnlyCollectionOptions<\n  T extends object = object,\n  TSchema extends StandardSchemaV1 = never,\n  TKey extends string | number = string | number,\n>(\n  config: LocalOnlyCollectionConfig<T, TSchema, TKey>\n): LocalOnlyCollectionOptionsResult<T, TKey, TSchema> & {\n  schema?: StandardSchemaV1\n} {\n  const { initialData, onInsert, onUpdate, onDelete, ...restConfig } = config\n\n  // Create the sync configuration with transaction confirmation capability\n  const syncResult = createLocalOnlySync<T, TKey>(initialData)\n\n  /**\n   * Create wrapper handlers that call user handlers first, then confirm transactions\n   * Wraps the user's onInsert handler to also confirm the transaction immediately\n   */\n  const wrappedOnInsert = async (\n    params: InsertMutationFnParams<T, TKey, LocalOnlyCollectionUtils>\n  ) => {\n    // Call user handler first if provided\n    let handlerResult\n    if (onInsert) {\n      handlerResult = (await onInsert(params)) ?? {}\n    }\n\n    // Then synchronously confirm the transaction by looping through mutations\n    syncResult.confirmOperationsSync(params.transaction.mutations)\n\n    return handlerResult\n  }\n\n  /**\n   * Wrapper for onUpdate handler that also confirms the transaction immediately\n   */\n  const wrappedOnUpdate = async (\n    params: UpdateMutationFnParams<T, TKey, LocalOnlyCollectionUtils>\n  ) => {\n    // Call user handler first if provided\n    let handlerResult\n    if (onUpdate) {\n      handlerResult = (await onUpdate(params)) ?? {}\n    }\n\n    // Then synchronously confirm the transaction by looping through mutations\n    syncResult.confirmOperationsSync(params.transaction.mutations)\n\n    return handlerResult\n  }\n\n  /**\n   * Wrapper for onDelete handler that also confirms the transaction immediately\n   */\n  const wrappedOnDelete = async (\n    params: DeleteMutationFnParams<T, TKey, LocalOnlyCollectionUtils>\n  ) => {\n    // Call user handler first if provided\n    let handlerResult\n    if (onDelete) {\n      handlerResult = (await onDelete(params)) ?? {}\n    }\n\n    // Then synchronously confirm the transaction by looping through mutations\n    syncResult.confirmOperationsSync(params.transaction.mutations)\n\n    return handlerResult\n  }\n\n  /**\n   * Accepts mutations from a transaction that belong to this collection and persists them\n   */\n  const acceptMutations = (transaction: {\n    mutations: Array<PendingMutation<Record<string, unknown>>>\n  }) => {\n    // Filter mutations that belong to this collection\n    const collectionMutations = transaction.mutations.filter(\n      (m) =>\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        m.collection === syncResult.collection\n    )\n\n    if (collectionMutations.length === 0) {\n      return\n    }\n\n    // Persist the mutations through sync\n    syncResult.confirmOperationsSync(\n      collectionMutations as Array<PendingMutation<T>>\n    )\n  }\n\n  return {\n    ...restConfig,\n    sync: syncResult.sync,\n    onInsert: wrappedOnInsert,\n    onUpdate: wrappedOnUpdate,\n    onDelete: wrappedOnDelete,\n    utils: {\n      acceptMutations,\n    },\n    startSync: true,\n    gcTime: 0,\n  } as LocalOnlyCollectionOptionsResult<T, TKey, TSchema> & {\n    schema?: StandardSchemaV1\n  }\n}\n\n/**\n * Internal function to create Local-only sync configuration with transaction confirmation\n *\n * This captures the sync functions and provides synchronous confirmation of operations.\n * It creates a loopback sync that immediately confirms all optimistic operations,\n * making them permanent in the collection.\n *\n * @param initialData - Optional array of initial items to populate the collection\n * @returns Object with sync configuration and confirmOperationsSync function\n */\nfunction createLocalOnlySync<T extends object, TKey extends string | number>(\n  initialData?: Array<T>\n) {\n  // Capture sync functions and collection for transaction confirmation\n  let syncBegin: (() => void) | null = null\n  let syncWrite: ((message: { type: OperationType; value: T }) => void) | null =\n    null\n  let syncCommit: (() => void) | null = null\n  let collection: Collection<T, TKey, LocalOnlyCollectionUtils> | null = null\n\n  const sync: SyncConfig<T, TKey> = {\n    /**\n     * Sync function that captures sync parameters and applies initial data\n     * @param params - Sync parameters containing begin, write, and commit functions\n     * @returns Unsubscribe function (empty since no ongoing sync is needed)\n     */\n    sync: (params) => {\n      const { begin, write, commit, markReady } = params\n\n      // Capture sync functions and collection for later use\n      syncBegin = begin\n      syncWrite = write\n      syncCommit = commit\n      collection = params.collection\n\n      // Apply initial data if provided\n      if (initialData && initialData.length > 0) {\n        begin()\n        initialData.forEach((item) => {\n          write({\n            type: `insert`,\n            value: item,\n          })\n        })\n        commit()\n      }\n\n      // Mark collection as ready since local-only collections are immediately ready\n      markReady()\n\n      // Return empty unsubscribe function - no ongoing sync needed\n      return () => {}\n    },\n    /**\n     * Get sync metadata - returns empty object for local-only collections\n     * @returns Empty metadata object\n     */\n    getSyncMetadata: () => ({}),\n  }\n\n  /**\n   * Synchronously confirms optimistic operations by immediately writing through sync\n   *\n   * This loops through transaction mutations and applies them to move from optimistic to synced state.\n   * It's called after user handlers to make optimistic changes permanent.\n   *\n   * @param mutations - Array of mutation objects from the transaction\n   */\n  const confirmOperationsSync = (mutations: Array<PendingMutation<T>>) => {\n    if (!syncBegin || !syncWrite || !syncCommit) {\n      return // Sync not initialized yet, which is fine\n    }\n\n    // Immediately write back through sync interface\n    syncBegin()\n    mutations.forEach((mutation) => {\n      if (syncWrite) {\n        syncWrite({\n          type: mutation.type,\n          value: mutation.modified,\n        })\n      }\n    })\n    syncCommit()\n  }\n\n  return {\n    sync,\n    confirmOperationsSync,\n    collection,\n  }\n}\n", "import {\n  InvalidStorageDataFormatError,\n  InvalidStorageObjectFormatError,\n  SerializationError,\n  StorageKeyRequiredError,\n} from \"./errors\"\nimport type {\n  BaseCollectionConfig,\n  CollectionConfig,\n  DeleteMutationFnParams,\n  InferSchemaOutput,\n  InsertMutationFnParams,\n  PendingMutation,\n  SyncConfig,\n  UpdateMutationFnParams,\n  UtilsRecord,\n} from \"./types\"\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\"\n\n/**\n * Storage API interface - subset of DOM Storage that we need\n */\nexport type StorageApi = Pick<Storage, `getItem` | `setItem` | `removeItem`>\n\n/**\n * Storage event API - subset of Window for 'storage' events only\n */\nexport type StorageEventApi = {\n  addEventListener: (\n    type: `storage`,\n    listener: (event: StorageEvent) => void\n  ) => void\n  removeEventListener: (\n    type: `storage`,\n    listener: (event: StorageEvent) => void\n  ) => void\n}\n\n/**\n * Internal storage format that includes version tracking\n */\ninterface StoredItem<T> {\n  versionKey: string\n  data: T\n}\n\nexport interface Parser {\n  parse: (data: string) => unknown\n  stringify: (data: unknown) => string\n}\n\n/**\n * Configuration interface for localStorage collection options\n * @template T - The type of items in the collection\n * @template TSchema - The schema type for validation\n * @template TKey - The type of the key returned by `getKey`\n */\nexport interface LocalStorageCollectionConfig<\n  T extends object = object,\n  TSchema extends StandardSchemaV1 = never,\n  TKey extends string | number = string | number,\n> extends BaseCollectionConfig<T, TKey, TSchema> {\n  /**\n   * The key to use for storing the collection data in localStorage/sessionStorage\n   */\n  storageKey: string\n\n  /**\n   * Storage API to use (defaults to window.localStorage)\n   * Can be any object that implements the Storage interface (e.g., sessionStorage)\n   */\n  storage?: StorageApi\n\n  /**\n   * Storage event API to use for cross-tab synchronization (defaults to window)\n   * Can be any object that implements addEventListener/removeEventListener for storage events\n   */\n  storageEventApi?: StorageEventApi\n\n  /**\n   * Parser to use for serializing and deserializing data to and from storage\n   * Defaults to JSON\n   */\n  parser?: Parser\n}\n\n/**\n * Type for the clear utility function\n */\nexport type ClearStorageFn = () => void\n\n/**\n * Type for the getStorageSize utility function\n */\nexport type GetStorageSizeFn = () => number\n\n/**\n * LocalStorage collection utilities type\n */\nexport interface LocalStorageCollectionUtils extends UtilsRecord {\n  clearStorage: ClearStorageFn\n  getStorageSize: GetStorageSizeFn\n  /**\n   * Accepts mutations from a transaction that belong to this collection and persists them to localStorage.\n   * This should be called in your transaction's mutationFn to persist local-storage data.\n   *\n   * @param transaction - The transaction containing mutations to accept\n   * @example\n   * const localSettings = createCollection(localStorageCollectionOptions({...}))\n   *\n   * const tx = createTransaction({\n   *   mutationFn: async ({ transaction }) => {\n   *     // Make API call first\n   *     await api.save(...)\n   *     // Then persist local-storage mutations after success\n   *     localSettings.utils.acceptMutations(transaction)\n   *   }\n   * })\n   */\n  acceptMutations: (transaction: {\n    mutations: Array<PendingMutation<Record<string, unknown>>>\n  }) => void\n}\n\n/**\n * Validates that a value can be JSON serialized\n * @param parser - The parser to use for serialization\n * @param value - The value to validate for JSON serialization\n * @param operation - The operation type being performed (for error messages)\n * @throws Error if the value cannot be JSON serialized\n */\nfunction validateJsonSerializable(\n  parser: Parser,\n  value: any,\n  operation: string\n): void {\n  try {\n    parser.stringify(value)\n  } catch (error) {\n    throw new SerializationError(\n      operation,\n      error instanceof Error ? error.message : String(error)\n    )\n  }\n}\n\n/**\n * Generate a UUID for version tracking\n * @returns A unique identifier string for tracking data versions\n */\nfunction generateUuid(): string {\n  return crypto.randomUUID()\n}\n\n/**\n * Encodes a key (string or number) into a storage-safe string format.\n * This prevents collisions between numeric and string keys by prefixing with type information.\n *\n * Examples:\n *   - number 1 â†’ \"n:1\"\n *   - string \"1\" â†’ \"s:1\"\n *   - string \"n:1\" â†’ \"s:n:1\"\n *\n * @param key - The key to encode (string or number)\n * @returns Type-prefixed string that is safe for storage\n */\nfunction encodeStorageKey(key: string | number): string {\n  if (typeof key === `number`) {\n    return `n:${key}`\n  }\n  return `s:${key}`\n}\n\n/**\n * Decodes a storage key back to its original form.\n * This is the inverse of encodeStorageKey.\n *\n * @param encodedKey - The encoded key from storage\n * @returns The original key (string or number)\n */\nfunction decodeStorageKey(encodedKey: string): string | number {\n  if (encodedKey.startsWith(`n:`)) {\n    return Number(encodedKey.slice(2))\n  }\n  if (encodedKey.startsWith(`s:`)) {\n    return encodedKey.slice(2)\n  }\n  // Fallback for legacy data without encoding\n  return encodedKey\n}\n\n/**\n * Creates an in-memory storage implementation that mimics the StorageApi interface\n * Used as a fallback when localStorage is not available (e.g., server-side rendering)\n * @returns An object implementing the StorageApi interface using an in-memory Map\n */\nfunction createInMemoryStorage(): StorageApi {\n  const storage = new Map<string, string>()\n\n  return {\n    getItem(key: string): string | null {\n      return storage.get(key) ?? null\n    },\n    setItem(key: string, value: string): void {\n      storage.set(key, value)\n    },\n    removeItem(key: string): void {\n      storage.delete(key)\n    },\n  }\n}\n\n/**\n * Creates a no-op storage event API for environments without window (e.g., server-side)\n * This provides the required interface but doesn't actually listen to any events\n * since cross-tab synchronization is not possible in server environments\n * @returns An object implementing the StorageEventApi interface with no-op methods\n */\nfunction createNoOpStorageEventApi(): StorageEventApi {\n  return {\n    addEventListener: () => {\n      // No-op: cannot listen to storage events without window\n    },\n    removeEventListener: () => {\n      // No-op: cannot remove listeners without window\n    },\n  }\n}\n\n/**\n * Creates localStorage collection options for use with a standard Collection\n *\n * This function creates a collection that persists data to localStorage/sessionStorage\n * and synchronizes changes across browser tabs using storage events.\n *\n * **Fallback Behavior:**\n *\n * When localStorage is not available (e.g., in server-side rendering environments),\n * this function automatically falls back to an in-memory storage implementation.\n * This prevents errors during module initialization and allows the collection to\n * work in any environment, though data will not persist across page reloads or\n * be shared across tabs when using the in-memory fallback.\n *\n * **Using with Manual Transactions:**\n *\n * For manual transactions, you must call `utils.acceptMutations()` in your transaction's `mutationFn`\n * to persist changes made during `tx.mutate()`. This is necessary because local-storage collections\n * don't participate in the standard mutation handler flow for manual transactions.\n *\n * @template TExplicit - The explicit type of items in the collection (highest priority)\n * @template TSchema - The schema type for validation and type inference (second priority)\n * @template TFallback - The fallback type if no explicit or schema type is provided\n * @param config - Configuration options for the localStorage collection\n * @returns Collection options with utilities including clearStorage, getStorageSize, and acceptMutations\n *\n * @example\n * // Basic localStorage collection\n * const collection = createCollection(\n *   localStorageCollectionOptions({\n *     storageKey: 'todos',\n *     getKey: (item) => item.id,\n *   })\n * )\n *\n * @example\n * // localStorage collection with custom storage\n * const collection = createCollection(\n *   localStorageCollectionOptions({\n *     storageKey: 'todos',\n *     storage: window.sessionStorage, // Use sessionStorage instead\n *     getKey: (item) => item.id,\n *   })\n * )\n *\n * @example\n * // localStorage collection with mutation handlers\n * const collection = createCollection(\n *   localStorageCollectionOptions({\n *     storageKey: 'todos',\n *     getKey: (item) => item.id,\n *     onInsert: async ({ transaction }) => {\n *       console.log('Item inserted:', transaction.mutations[0].modified)\n *     },\n *   })\n * )\n *\n * @example\n * // Using with manual transactions\n * const localSettings = createCollection(\n *   localStorageCollectionOptions({\n *     storageKey: 'user-settings',\n *     getKey: (item) => item.id,\n *   })\n * )\n *\n * const tx = createTransaction({\n *   mutationFn: async ({ transaction }) => {\n *     // Use settings data in API call\n *     const settingsMutations = transaction.mutations.filter(m => m.collection === localSettings)\n *     await api.updateUserProfile({ settings: settingsMutations[0]?.modified })\n *\n *     // Persist local-storage mutations after API success\n *     localSettings.utils.acceptMutations(transaction)\n *   }\n * })\n *\n * tx.mutate(() => {\n *   localSettings.insert({ id: 'theme', value: 'dark' })\n *   apiCollection.insert({ id: 2, data: 'profile data' })\n * })\n *\n * await tx.commit()\n */\n\n// Overload for when schema is provided\nexport function localStorageCollectionOptions<\n  T extends StandardSchemaV1,\n  TKey extends string | number = string | number,\n>(\n  config: LocalStorageCollectionConfig<InferSchemaOutput<T>, T, TKey> & {\n    schema: T\n  }\n): CollectionConfig<\n  InferSchemaOutput<T>,\n  TKey,\n  T,\n  LocalStorageCollectionUtils\n> & {\n  id: string\n  utils: LocalStorageCollectionUtils\n  schema: T\n}\n\n// Overload for when no schema is provided\n// the type T needs to be passed explicitly unless it can be inferred from the getKey function in the config\nexport function localStorageCollectionOptions<\n  T extends object,\n  TKey extends string | number = string | number,\n>(\n  config: LocalStorageCollectionConfig<T, never, TKey> & {\n    schema?: never // prohibit schema\n  }\n): CollectionConfig<T, TKey, never, LocalStorageCollectionUtils> & {\n  id: string\n  utils: LocalStorageCollectionUtils\n  schema?: never // no schema in the result\n}\n\nexport function localStorageCollectionOptions(\n  config: LocalStorageCollectionConfig<any, any, string | number>\n): Omit<\n  CollectionConfig<any, string | number, any, LocalStorageCollectionUtils>,\n  `id`\n> & {\n  id: string\n  utils: LocalStorageCollectionUtils\n  schema?: StandardSchemaV1\n} {\n  // Validate required parameters\n  if (!config.storageKey) {\n    throw new StorageKeyRequiredError()\n  }\n\n  // Default to window.localStorage if no storage is provided\n  // Fall back to in-memory storage if localStorage is not available (e.g., server-side rendering)\n  const storage =\n    config.storage ||\n    (typeof window !== `undefined` ? window.localStorage : null) ||\n    createInMemoryStorage()\n\n  // Default to window for storage events if not provided\n  // Fall back to no-op storage event API if window is not available (e.g., server-side rendering)\n  const storageEventApi =\n    config.storageEventApi ||\n    (typeof window !== `undefined` ? window : null) ||\n    createNoOpStorageEventApi()\n\n  // Default to JSON parser if no parser is provided\n  const parser = config.parser || JSON\n\n  // Track the last known state to detect changes\n  const lastKnownData = new Map<string | number, StoredItem<any>>()\n\n  // Create the sync configuration\n  const sync = createLocalStorageSync<any>(\n    config.storageKey,\n    storage,\n    storageEventApi,\n    parser,\n    config.getKey,\n    lastKnownData\n  )\n\n  /**\n   * Save data to storage\n   * @param dataMap - Map of items with version tracking to save to storage\n   */\n  const saveToStorage = (\n    dataMap: Map<string | number, StoredItem<any>>\n  ): void => {\n    try {\n      // Convert Map to object format for storage\n      const objectData: Record<string, StoredItem<any>> = {}\n      dataMap.forEach((storedItem, key) => {\n        objectData[encodeStorageKey(key)] = storedItem\n      })\n      const serialized = parser.stringify(objectData)\n      storage.setItem(config.storageKey, serialized)\n    } catch (error) {\n      console.error(\n        `[LocalStorageCollection] Error saving data to storage key \"${config.storageKey}\":`,\n        error\n      )\n      throw error\n    }\n  }\n\n  /**\n   * Removes all collection data from the configured storage\n   */\n  const clearStorage: ClearStorageFn = (): void => {\n    storage.removeItem(config.storageKey)\n  }\n\n  /**\n   * Get the size of the stored data in bytes (approximate)\n   * @returns The approximate size in bytes of the stored collection data\n   */\n  const getStorageSize: GetStorageSizeFn = (): number => {\n    const data = storage.getItem(config.storageKey)\n    return data ? new Blob([data]).size : 0\n  }\n\n  /*\n   * Create wrapper handlers for direct persistence operations that perform actual storage operations\n   * Wraps the user's onInsert handler to also save changes to localStorage\n   */\n  const wrappedOnInsert = async (params: InsertMutationFnParams<any>) => {\n    // Validate that all values in the transaction can be JSON serialized\n    params.transaction.mutations.forEach((mutation) => {\n      validateJsonSerializable(parser, mutation.modified, `insert`)\n    })\n\n    // Call the user handler BEFORE persisting changes (if provided)\n    let handlerResult: any = {}\n    if (config.onInsert) {\n      handlerResult = (await config.onInsert(params)) ?? {}\n    }\n\n    // Always persist to storage\n    // Use lastKnownData (in-memory cache) instead of reading from storage\n    // Add new items with version keys\n    params.transaction.mutations.forEach((mutation) => {\n      // Use the engine's pre-computed key for consistency\n      const storedItem: StoredItem<any> = {\n        versionKey: generateUuid(),\n        data: mutation.modified,\n      }\n      lastKnownData.set(mutation.key, storedItem)\n    })\n\n    // Save to storage\n    saveToStorage(lastKnownData)\n\n    // Confirm mutations through sync interface (moves from optimistic to synced state)\n    // without reloading from storage\n    sync.confirmOperationsSync(params.transaction.mutations)\n\n    return handlerResult\n  }\n\n  const wrappedOnUpdate = async (params: UpdateMutationFnParams<any>) => {\n    // Validate that all values in the transaction can be JSON serialized\n    params.transaction.mutations.forEach((mutation) => {\n      validateJsonSerializable(parser, mutation.modified, `update`)\n    })\n\n    // Call the user handler BEFORE persisting changes (if provided)\n    let handlerResult: any = {}\n    if (config.onUpdate) {\n      handlerResult = (await config.onUpdate(params)) ?? {}\n    }\n\n    // Always persist to storage\n    // Use lastKnownData (in-memory cache) instead of reading from storage\n    // Update items with new version keys\n    params.transaction.mutations.forEach((mutation) => {\n      // Use the engine's pre-computed key for consistency\n      const storedItem: StoredItem<any> = {\n        versionKey: generateUuid(),\n        data: mutation.modified,\n      }\n      lastKnownData.set(mutation.key, storedItem)\n    })\n\n    // Save to storage\n    saveToStorage(lastKnownData)\n\n    // Confirm mutations through sync interface (moves from optimistic to synced state)\n    // without reloading from storage\n    sync.confirmOperationsSync(params.transaction.mutations)\n\n    return handlerResult\n  }\n\n  const wrappedOnDelete = async (params: DeleteMutationFnParams<any>) => {\n    // Call the user handler BEFORE persisting changes (if provided)\n    let handlerResult: any = {}\n    if (config.onDelete) {\n      handlerResult = (await config.onDelete(params)) ?? {}\n    }\n\n    // Always persist to storage\n    // Use lastKnownData (in-memory cache) instead of reading from storage\n    // Remove items\n    params.transaction.mutations.forEach((mutation) => {\n      // Use the engine's pre-computed key for consistency\n      lastKnownData.delete(mutation.key)\n    })\n\n    // Save to storage\n    saveToStorage(lastKnownData)\n\n    // Confirm mutations through sync interface (moves from optimistic to synced state)\n    // without reloading from storage\n    sync.confirmOperationsSync(params.transaction.mutations)\n\n    return handlerResult\n  }\n\n  // Extract standard Collection config properties\n  const {\n    storageKey: _storageKey,\n    storage: _storage,\n    storageEventApi: _storageEventApi,\n    onInsert: _onInsert,\n    onUpdate: _onUpdate,\n    onDelete: _onDelete,\n    id,\n    ...restConfig\n  } = config\n\n  // Default id to a pattern based on storage key if not provided\n  const collectionId = id ?? `local-collection:${config.storageKey}`\n\n  /**\n   * Accepts mutations from a transaction that belong to this collection and persists them to storage\n   */\n  const acceptMutations = (transaction: {\n    mutations: Array<PendingMutation<Record<string, unknown>>>\n  }) => {\n    // Filter mutations that belong to this collection\n    // Use collection ID for filtering if collection reference isn't available yet\n    const collectionMutations = transaction.mutations.filter((m) => {\n      // Try to match by collection reference first\n      if (sync.collection && m.collection === sync.collection) {\n        return true\n      }\n      // Fall back to matching by collection ID\n      return m.collection.id === collectionId\n    })\n\n    if (collectionMutations.length === 0) {\n      return\n    }\n\n    // Validate all mutations can be serialized before modifying storage\n    for (const mutation of collectionMutations) {\n      switch (mutation.type) {\n        case `insert`:\n        case `update`:\n          validateJsonSerializable(parser, mutation.modified, mutation.type)\n          break\n        case `delete`:\n          validateJsonSerializable(parser, mutation.original, mutation.type)\n          break\n      }\n    }\n\n    // Use lastKnownData (in-memory cache) instead of reading from storage\n    // Apply each mutation\n    for (const mutation of collectionMutations) {\n      // Use the engine's pre-computed key to avoid key derivation issues\n      switch (mutation.type) {\n        case `insert`:\n        case `update`: {\n          const storedItem: StoredItem<Record<string, unknown>> = {\n            versionKey: generateUuid(),\n            data: mutation.modified,\n          }\n          lastKnownData.set(mutation.key, storedItem)\n          break\n        }\n        case `delete`: {\n          lastKnownData.delete(mutation.key)\n          break\n        }\n      }\n    }\n\n    // Save to storage\n    saveToStorage(lastKnownData)\n\n    // Confirm the mutations in the collection to move them from optimistic to synced state\n    // This writes them through the sync interface to make them \"synced\" instead of \"optimistic\"\n    sync.confirmOperationsSync(collectionMutations)\n  }\n\n  return {\n    ...restConfig,\n    id: collectionId,\n    sync,\n    onInsert: wrappedOnInsert,\n    onUpdate: wrappedOnUpdate,\n    onDelete: wrappedOnDelete,\n    utils: {\n      clearStorage,\n      getStorageSize,\n      acceptMutations,\n    },\n  }\n}\n\n/**\n * Load data from storage and return as a Map\n * @param parser - The parser to use for deserializing the data\n * @param storageKey - The key used to store data in the storage API\n * @param storage - The storage API to load from (localStorage, sessionStorage, etc.)\n * @returns Map of stored items with version tracking, or empty Map if loading fails\n */\nfunction loadFromStorage<T extends object>(\n  storageKey: string,\n  storage: StorageApi,\n  parser: Parser\n): Map<string | number, StoredItem<T>> {\n  try {\n    const rawData = storage.getItem(storageKey)\n    if (!rawData) {\n      return new Map()\n    }\n\n    const parsed = parser.parse(rawData)\n    const dataMap = new Map<string | number, StoredItem<T>>()\n\n    // Handle object format where keys map to StoredItem values\n    if (\n      typeof parsed === `object` &&\n      parsed !== null &&\n      !Array.isArray(parsed)\n    ) {\n      Object.entries(parsed).forEach(([encodedKey, value]) => {\n        // Runtime check to ensure the value has the expected StoredItem structure\n        if (\n          value &&\n          typeof value === `object` &&\n          `versionKey` in value &&\n          `data` in value\n        ) {\n          const storedItem = value as StoredItem<T>\n          const decodedKey = decodeStorageKey(encodedKey)\n          dataMap.set(decodedKey, storedItem)\n        } else {\n          throw new InvalidStorageDataFormatError(storageKey, encodedKey)\n        }\n      })\n    } else {\n      throw new InvalidStorageObjectFormatError(storageKey)\n    }\n\n    return dataMap\n  } catch (error) {\n    console.warn(\n      `[LocalStorageCollection] Error loading data from storage key \"${storageKey}\":`,\n      error\n    )\n    return new Map()\n  }\n}\n\n/**\n * Internal function to create localStorage sync configuration\n * Creates a sync configuration that handles localStorage persistence and cross-tab synchronization\n * @param storageKey - The key used for storing data in localStorage\n * @param storage - The storage API to use (localStorage, sessionStorage, etc.)\n * @param storageEventApi - The event API for listening to storage changes\n * @param getKey - Function to extract the key from an item\n * @param lastKnownData - Map tracking the last known state for change detection\n * @returns Sync configuration with manual trigger capability\n */\nfunction createLocalStorageSync<T extends object>(\n  storageKey: string,\n  storage: StorageApi,\n  storageEventApi: StorageEventApi,\n  parser: Parser,\n  _getKey: (item: T) => string | number,\n  lastKnownData: Map<string | number, StoredItem<T>>\n): SyncConfig<T> & {\n  manualTrigger?: () => void\n  collection: any\n  confirmOperationsSync: (mutations: Array<any>) => void\n} {\n  let syncParams: Parameters<SyncConfig<T>[`sync`]>[0] | null = null\n  let collection: any = null\n\n  /**\n   * Compare two Maps to find differences using version keys\n   * @param oldData - The previous state of stored items\n   * @param newData - The current state of stored items\n   * @returns Array of changes with type, key, and value information\n   */\n  const findChanges = (\n    oldData: Map<string | number, StoredItem<T>>,\n    newData: Map<string | number, StoredItem<T>>\n  ): Array<{\n    type: `insert` | `update` | `delete`\n    key: string | number\n    value?: T\n  }> => {\n    const changes: Array<{\n      type: `insert` | `update` | `delete`\n      key: string | number\n      value?: T\n    }> = []\n\n    // Check for deletions and updates\n    oldData.forEach((oldStoredItem, key) => {\n      const newStoredItem = newData.get(key)\n      if (!newStoredItem) {\n        changes.push({ type: `delete`, key, value: oldStoredItem.data })\n      } else if (oldStoredItem.versionKey !== newStoredItem.versionKey) {\n        changes.push({ type: `update`, key, value: newStoredItem.data })\n      }\n    })\n\n    // Check for insertions\n    newData.forEach((newStoredItem, key) => {\n      if (!oldData.has(key)) {\n        changes.push({ type: `insert`, key, value: newStoredItem.data })\n      }\n    })\n\n    return changes\n  }\n\n  /**\n   * Process storage changes and update collection\n   * Loads new data from storage, compares with last known state, and applies changes\n   */\n  const processStorageChanges = () => {\n    if (!syncParams) return\n\n    const { begin, write, commit } = syncParams\n\n    // Load the new data\n    const newData = loadFromStorage<T>(storageKey, storage, parser)\n\n    // Find the specific changes\n    const changes = findChanges(lastKnownData, newData)\n\n    if (changes.length > 0) {\n      begin()\n      changes.forEach(({ type, value }) => {\n        if (value) {\n          validateJsonSerializable(parser, value, type)\n          write({ type, value })\n        }\n      })\n      commit()\n\n      // Update lastKnownData\n      lastKnownData.clear()\n      newData.forEach((storedItem, key) => {\n        lastKnownData.set(key, storedItem)\n      })\n    }\n  }\n\n  const syncConfig: SyncConfig<T> & {\n    manualTrigger?: () => void\n    collection: any\n  } = {\n    sync: (params: Parameters<SyncConfig<T>[`sync`]>[0]) => {\n      const { begin, write, commit, markReady } = params\n\n      // Store sync params and collection for later use\n      syncParams = params\n      collection = params.collection\n\n      // Initial load\n      const initialData = loadFromStorage<T>(storageKey, storage, parser)\n      if (initialData.size > 0) {\n        begin()\n        initialData.forEach((storedItem) => {\n          validateJsonSerializable(parser, storedItem.data, `load`)\n          write({ type: `insert`, value: storedItem.data })\n        })\n        commit()\n      }\n\n      // Update lastKnownData\n      lastKnownData.clear()\n      initialData.forEach((storedItem, key) => {\n        lastKnownData.set(key, storedItem)\n      })\n\n      // Mark collection as ready after initial load\n      markReady()\n\n      // Listen for storage events from other tabs\n      const handleStorageEvent = (event: StorageEvent) => {\n        // Only respond to changes to our specific key and from our storage\n        if (event.key !== storageKey || event.storageArea !== storage) {\n          return\n        }\n\n        processStorageChanges()\n      }\n\n      // Add storage event listener for cross-tab sync\n      storageEventApi.addEventListener(`storage`, handleStorageEvent)\n\n      // Note: Cleanup is handled automatically by the collection when it's disposed\n    },\n\n    /**\n     * Get sync metadata - returns storage key information\n     * @returns Object containing storage key and storage type metadata\n     */\n    getSyncMetadata: () => ({\n      storageKey,\n      storageType:\n        storage === (typeof window !== `undefined` ? window.localStorage : null)\n          ? `localStorage`\n          : `custom`,\n    }),\n\n    // Manual trigger function for local updates\n    manualTrigger: processStorageChanges,\n\n    // Collection instance reference\n    collection,\n  }\n\n  /**\n   * Confirms mutations by writing them through the sync interface\n   * This moves mutations from optimistic to synced state\n   * @param mutations - Array of mutation objects to confirm\n   */\n  const confirmOperationsSync = (mutations: Array<any>) => {\n    if (!syncParams) {\n      // Sync not initialized yet, mutations will be handled on next sync\n      return\n    }\n\n    const { begin, write, commit } = syncParams\n\n    // Write the mutations through sync to confirm them\n    begin()\n    mutations.forEach((mutation: any) => {\n      write({\n        type: mutation.type,\n        value:\n          mutation.type === `delete` ? mutation.original : mutation.modified,\n      })\n    })\n    commit()\n  }\n\n  return {\n    ...syncConfig,\n    confirmOperationsSync,\n  }\n}\n", "import { createTransaction } from \"./transactions\"\nimport type { MutationFn, Transaction } from \"./types\"\nimport type { Strategy } from \"./strategies/types\"\n\n/**\n * Configuration for creating a paced mutations manager\n */\nexport interface PacedMutationsConfig<\n  TVariables = unknown,\n  T extends object = Record<string, unknown>,\n> {\n  /**\n   * Callback to apply optimistic updates immediately.\n   * Receives the variables passed to the mutate function.\n   */\n  onMutate: (variables: TVariables) => void\n  /**\n   * Function to execute the mutation on the server.\n   * Receives the transaction parameters containing all merged mutations.\n   */\n  mutationFn: MutationFn<T>\n  /**\n   * Strategy for controlling mutation execution timing\n   * Examples: debounceStrategy, queueStrategy, throttleStrategy\n   */\n  strategy: Strategy\n  /**\n   * Custom metadata to associate with transactions\n   */\n  metadata?: Record<string, unknown>\n}\n\n/**\n * Creates a paced mutations manager with pluggable timing strategies.\n *\n * This function provides a way to control when and how optimistic mutations\n * are persisted to the backend, using strategies like debouncing, queuing,\n * or throttling. The optimistic updates are applied immediately via `onMutate`,\n * and the actual persistence is controlled by the strategy.\n *\n * The returned function accepts variables of type TVariables and returns a\n * Transaction object that can be awaited to know when persistence completes\n * or to handle errors.\n *\n * @param config - Configuration including onMutate, mutationFn and strategy\n * @returns A function that accepts variables and returns a Transaction\n *\n * @example\n * ```ts\n * // Debounced mutations for auto-save\n * const updateTodo = createPacedMutations<string>({\n *   onMutate: (text) => {\n *     // Apply optimistic update immediately\n *     collection.update(id, draft => { draft.text = text })\n *   },\n *   mutationFn: async ({ transaction }) => {\n *     await api.save(transaction.mutations)\n *   },\n *   strategy: debounceStrategy({ wait: 500 })\n * })\n *\n * // Call with variables, returns a transaction\n * const tx = updateTodo('New text')\n *\n * // Await persistence or handle errors\n * await tx.isPersisted.promise\n * ```\n *\n * @example\n * ```ts\n * // Queue strategy for sequential processing\n * const addTodo = createPacedMutations<{ text: string }>({\n *   onMutate: ({ text }) => {\n *     collection.insert({ id: uuid(), text, completed: false })\n *   },\n *   mutationFn: async ({ transaction }) => {\n *     await api.save(transaction.mutations)\n *   },\n *   strategy: queueStrategy({\n *     wait: 200,\n *     addItemsTo: 'back',\n *     getItemsFrom: 'front'\n *   })\n * })\n * ```\n */\nexport function createPacedMutations<\n  TVariables = unknown,\n  T extends object = Record<string, unknown>,\n>(\n  config: PacedMutationsConfig<TVariables, T>\n): (variables: TVariables) => Transaction<T> {\n  const { onMutate, mutationFn, strategy, ...transactionConfig } = config\n\n  // The currently active transaction (pending, not yet persisting)\n  let activeTransaction: Transaction<T> | null = null\n\n  // Commit callback that the strategy will call when it's time to persist\n  const commitCallback = () => {\n    if (!activeTransaction) {\n      throw new Error(\n        `Strategy callback called but no active transaction exists. This indicates a bug in the strategy implementation.`\n      )\n    }\n\n    if (activeTransaction.state !== `pending`) {\n      throw new Error(\n        `Strategy callback called but active transaction is in state \"${activeTransaction.state}\". Expected \"pending\".`\n      )\n    }\n\n    const txToCommit = activeTransaction\n\n    // Clear active transaction reference before committing\n    activeTransaction = null\n\n    // Commit the transaction\n    txToCommit.commit().catch(() => {\n      // Errors are handled via transaction.isPersisted.promise\n      // This catch prevents unhandled promise rejections\n    })\n\n    return txToCommit\n  }\n\n  /**\n   * Executes a mutation with the given variables. Creates a new transaction if none is active,\n   * or adds to the existing active transaction. The strategy controls when\n   * the transaction is actually committed.\n   */\n  function mutate(variables: TVariables): Transaction<T> {\n    // Create a new transaction if we don't have an active one\n    if (!activeTransaction || activeTransaction.state !== `pending`) {\n      activeTransaction = createTransaction<T>({\n        ...transactionConfig,\n        mutationFn,\n        autoCommit: false,\n      })\n    }\n\n    // Execute onMutate with variables to apply optimistic updates\n    activeTransaction.mutate(() => {\n      onMutate(variables)\n    })\n\n    // Save reference before calling strategy.execute\n    const txToReturn = activeTransaction\n\n    // For queue strategy, pass a function that commits the captured transaction\n    // This prevents the error when commitCallback tries to access the cleared activeTransaction\n    if (strategy._type === `queue`) {\n      const capturedTx = activeTransaction\n      activeTransaction = null // Clear so next mutation creates a new transaction\n      strategy.execute(() => {\n        capturedTx.commit().catch(() => {\n          // Errors are handled via transaction.isPersisted.promise\n        })\n        return capturedTx\n      })\n    } else {\n      // For debounce/throttle, use commitCallback which manages activeTransaction\n      strategy.execute(commitCallback)\n    }\n\n    return txToReturn\n  }\n\n  return mutate\n}\n", "/**\n * Expression Helpers for TanStack DB\n *\n * These utilities help parse LoadSubsetOptions (where, orderBy, limit) from TanStack DB\n * into formats suitable for your API backend. They provide a generic way to traverse\n * expression trees without having to implement your own parser.\n *\n * @example\n * ```typescript\n * import { parseWhereExpression, parseOrderByExpression } from '@tanstack/db'\n *\n * queryFn: async (ctx) => {\n *   const { limit, where, orderBy } = ctx.meta?.loadSubsetOptions ?? {}\n *\n *   // Convert expression tree to filters\n *   const filters = parseWhereExpression(where, {\n *     eq: (field, value) => ({ [field]: value }),\n *     lt: (field, value) => ({ [`${field}_lt`]: value }),\n *     and: (filters) => Object.assign({}, ...filters)\n *   })\n *\n *   // Extract sort information\n *   const sort = parseOrderByExpression(orderBy)\n *\n *   return api.getProducts({ ...filters, sort, limit })\n * }\n * ```\n */\n\nimport type { IR, OperatorName } from \"../index.js\"\n\ntype BasicExpression<T = any> = IR.BasicExpression<T>\ntype OrderBy = IR.OrderBy\n\n/**\n * Represents a simple field path extracted from an expression.\n * Can include string keys for object properties and numbers for array indices.\n */\nexport type FieldPath = Array<string | number>\n\n/**\n * Represents a simple comparison operation\n */\nexport interface SimpleComparison {\n  field: FieldPath\n  operator: string\n  value?: any // Optional for operators like isNull and isUndefined that don't have a value\n}\n\n/**\n * Options for customizing how WHERE expressions are parsed\n */\nexport interface ParseWhereOptions<T = any> {\n  /**\n   * Handler functions for different operators.\n   * Each handler receives the parsed field path(s) and value(s) and returns your custom format.\n   *\n   * Supported operators from TanStack DB:\n   * - Comparison: eq, gt, gte, lt, lte, in, like, ilike\n   * - Logical: and, or, not\n   * - Null checking: isNull, isUndefined\n   * - String functions: upper, lower, length, concat\n   * - Numeric: add\n   * - Utility: coalesce\n   * - Aggregates: count, avg, sum, min, max\n   */\n  handlers: {\n    [K in OperatorName]?: (...args: Array<any>) => T\n  } & {\n    [key: string]: (...args: Array<any>) => T\n  }\n  /**\n   * Optional handler for when an unknown operator is encountered.\n   * If not provided, unknown operators throw an error.\n   */\n  onUnknownOperator?: (operator: string, args: Array<any>) => T\n}\n\n/**\n * Result of parsing an ORDER BY expression\n */\nexport interface ParsedOrderBy {\n  field: FieldPath\n  direction: `asc` | `desc`\n  nulls: `first` | `last`\n  /** String sorting method: 'lexical' (default) or 'locale' (locale-aware) */\n  stringSort?: `lexical` | `locale`\n  /** Locale for locale-aware string sorting (e.g., 'en-US') */\n  locale?: string\n  /** Additional options for locale-aware sorting */\n  localeOptions?: object\n}\n\n/**\n * Extracts the field path from a PropRef expression.\n * Returns null for non-ref expressions.\n *\n * @param expr - The expression to extract from\n * @returns The field path array, or null\n *\n * @example\n * ```typescript\n * const field = extractFieldPath(someExpression)\n * // Returns: ['product', 'category']\n * ```\n */\nexport function extractFieldPath(expr: BasicExpression): FieldPath | null {\n  if (expr.type === `ref`) {\n    return expr.path\n  }\n  return null\n}\n\n/**\n * Extracts the value from a Value expression.\n * Returns undefined for non-value expressions.\n *\n * @param expr - The expression to extract from\n * @returns The extracted value\n *\n * @example\n * ```typescript\n * const val = extractValue(someExpression)\n * // Returns: 'electronics'\n * ```\n */\nexport function extractValue(expr: BasicExpression): any {\n  if (expr.type === `val`) {\n    return expr.value\n  }\n  return undefined\n}\n\n/**\n * Generic expression tree walker that visits each node in the expression.\n * Useful for implementing custom parsing logic.\n *\n * @param expr - The expression to walk\n * @param visitor - Visitor function called for each node\n *\n * @example\n * ```typescript\n * walkExpression(whereExpr, (node) => {\n *   if (node.type === 'func' && node.name === 'eq') {\n *     console.log('Found equality comparison')\n *   }\n * })\n * ```\n */\nexport function walkExpression(\n  expr: BasicExpression | undefined | null,\n  visitor: (node: BasicExpression) => void\n): void {\n  if (!expr) return\n\n  visitor(expr)\n\n  if (expr.type === `func`) {\n    expr.args.forEach((arg: BasicExpression) => walkExpression(arg, visitor))\n  }\n}\n\n/**\n * Parses a WHERE expression into a custom format using provided handlers.\n *\n * This is the main helper for converting TanStack DB where clauses into your API's filter format.\n * You provide handlers for each operator, and this function traverses the expression tree\n * and calls the appropriate handlers.\n *\n * @param expr - The WHERE expression to parse\n * @param options - Configuration with handler functions for each operator\n * @returns The parsed result in your custom format\n *\n * @example\n * ```typescript\n * // REST API with query parameters\n * const filters = parseWhereExpression(where, {\n *   handlers: {\n *     eq: (field, value) => ({ [field.join('.')]: value }),\n *     lt: (field, value) => ({ [`${field.join('.')}_lt`]: value }),\n *     gt: (field, value) => ({ [`${field.join('.')}_gt`]: value }),\n *     and: (...filters) => Object.assign({}, ...filters),\n *     or: (...filters) => ({ $or: filters })\n *   }\n * })\n * // Returns: { category: 'electronics', price_lt: 100 }\n * ```\n *\n * @example\n * ```typescript\n * // GraphQL where clause\n * const where = parseWhereExpression(whereExpr, {\n *   handlers: {\n *     eq: (field, value) => ({ [field.join('_')]: { _eq: value } }),\n *     lt: (field, value) => ({ [field.join('_')]: { _lt: value } }),\n *     and: (...filters) => ({ _and: filters })\n *   }\n * })\n * ```\n */\nexport function parseWhereExpression<T = any>(\n  expr: BasicExpression<boolean> | undefined | null,\n  options: ParseWhereOptions<T>\n): T | null {\n  if (!expr) return null\n\n  const { handlers, onUnknownOperator } = options\n\n  // Handle value expressions\n  if (expr.type === `val`) {\n    return expr.value as unknown as T\n  }\n\n  // Handle property references\n  if (expr.type === `ref`) {\n    return expr.path as unknown as T\n  }\n\n  // Handle function expressions\n  // After checking val and ref, expr must be func\n  const { name, args } = expr\n  const handler = handlers[name]\n\n  if (!handler) {\n    if (onUnknownOperator) {\n      return onUnknownOperator(name, args)\n    }\n    throw new Error(\n      `No handler provided for operator: ${name}. Available handlers: ${Object.keys(handlers).join(`, `)}`\n    )\n  }\n\n  // Parse arguments recursively\n  const parsedArgs = args.map((arg: BasicExpression) => {\n    // For refs, extract the field path\n    if (arg.type === `ref`) {\n      return arg.path\n    }\n    // For values, extract the value\n    if (arg.type === `val`) {\n      return arg.value\n    }\n    // For nested functions, recurse (after checking ref and val, must be func)\n    return parseWhereExpression(arg, options)\n  })\n\n  return handler(...parsedArgs)\n}\n\n/**\n * Parses an ORDER BY expression into a simple array of sort specifications.\n *\n * @param orderBy - The ORDER BY expression array\n * @returns Array of parsed order by specifications\n *\n * @example\n * ```typescript\n * const sorts = parseOrderByExpression(orderBy)\n * // Returns: [\n * //   { field: ['category'], direction: 'asc', nulls: 'last' },\n * //   { field: ['price'], direction: 'desc', nulls: 'last' }\n * // ]\n * ```\n */\nexport function parseOrderByExpression(\n  orderBy: OrderBy | undefined | null\n): Array<ParsedOrderBy> {\n  if (!orderBy || orderBy.length === 0) {\n    return []\n  }\n\n  return orderBy.map((clause: IR.OrderByClause) => {\n    const field = extractFieldPath(clause.expression)\n\n    if (!field) {\n      throw new Error(\n        `ORDER BY expression must be a field reference, got: ${clause.expression.type}`\n      )\n    }\n\n    const { direction, nulls } = clause.compareOptions\n    const result: ParsedOrderBy = {\n      field,\n      direction,\n      nulls,\n    }\n\n    // Add string collation options if present (discriminated union)\n    if (`stringSort` in clause.compareOptions) {\n      result.stringSort = clause.compareOptions.stringSort\n    }\n    if (`locale` in clause.compareOptions) {\n      result.locale = clause.compareOptions.locale\n    }\n    if (`localeOptions` in clause.compareOptions) {\n      result.localeOptions = clause.compareOptions.localeOptions\n    }\n\n    return result\n  })\n}\n\n/**\n * Extracts all simple comparisons from a WHERE expression.\n * This is useful for simple APIs that only support basic filters.\n *\n * Note: This only works for simple AND-ed conditions and NOT-wrapped comparisons.\n * Throws an error if it encounters unsupported operations like OR or complex nested expressions.\n *\n * NOT operators are flattened by prefixing the operator name (e.g., `not(eq(...))` becomes `not_eq`).\n *\n * @param expr - The WHERE expression to parse\n * @returns Array of simple comparisons\n * @throws Error if expression contains OR or other unsupported operations\n *\n * @example\n * ```typescript\n * const comparisons = extractSimpleComparisons(where)\n * // Returns: [\n * //   { field: ['category'], operator: 'eq', value: 'electronics' },\n * //   { field: ['price'], operator: 'lt', value: 100 },\n * //   { field: ['email'], operator: 'isNull' }, // No value for null checks\n * //   { field: ['status'], operator: 'not_eq', value: 'archived' }\n * // ]\n * ```\n */\nexport function extractSimpleComparisons(\n  expr: BasicExpression<boolean> | undefined | null\n): Array<SimpleComparison> {\n  if (!expr) return []\n\n  const comparisons: Array<SimpleComparison> = []\n\n  function extract(e: BasicExpression): void {\n    if (e.type === `func`) {\n      // Handle AND - recurse into both sides\n      if (e.name === `and`) {\n        e.args.forEach((arg: BasicExpression) => extract(arg))\n        return\n      }\n\n      // Handle NOT - recurse into argument and prefix operator with 'not_'\n      if (e.name === `not`) {\n        const [arg] = e.args\n        if (!arg || arg.type !== `func`) {\n          throw new Error(\n            `extractSimpleComparisons requires a comparison or null check inside 'not' operator.`\n          )\n        }\n\n        // Handle NOT with null/undefined checks\n        const nullCheckOps = [`isNull`, `isUndefined`]\n        if (nullCheckOps.includes(arg.name)) {\n          const [fieldArg] = arg.args\n          const field = fieldArg?.type === `ref` ? fieldArg.path : null\n\n          if (field) {\n            comparisons.push({\n              field,\n              operator: `not_${arg.name}`,\n              // No value for null/undefined checks\n            })\n          } else {\n            throw new Error(\n              `extractSimpleComparisons requires a field reference for '${arg.name}' operator.`\n            )\n          }\n          return\n        }\n\n        // Handle NOT with comparison operators\n        const comparisonOps = [`eq`, `gt`, `gte`, `lt`, `lte`, `in`]\n        if (comparisonOps.includes(arg.name)) {\n          const [leftArg, rightArg] = arg.args\n          const field = leftArg?.type === `ref` ? leftArg.path : null\n          const value = rightArg?.type === `val` ? rightArg.value : null\n\n          if (field && value !== undefined) {\n            comparisons.push({\n              field,\n              operator: `not_${arg.name}`,\n              value,\n            })\n          } else {\n            throw new Error(\n              `extractSimpleComparisons requires simple field-value comparisons. Found complex expression for 'not(${arg.name})' operator.`\n            )\n          }\n          return\n        }\n\n        // NOT can only wrap simple comparisons or null checks\n        throw new Error(\n          `extractSimpleComparisons does not support 'not(${arg.name})'. NOT can only wrap comparison operators (eq, gt, gte, lt, lte, in) or null checks (isNull, isUndefined).`\n        )\n      }\n\n      // Throw on unsupported operations\n      const unsupportedOps = [\n        `or`,\n        `like`,\n        `ilike`,\n        `upper`,\n        `lower`,\n        `length`,\n        `concat`,\n        `add`,\n        `coalesce`,\n        `count`,\n        `avg`,\n        `sum`,\n        `min`,\n        `max`,\n      ]\n      if (unsupportedOps.includes(e.name)) {\n        throw new Error(\n          `extractSimpleComparisons does not support '${e.name}' operator. Use parseWhereExpression with custom handlers for complex expressions.`\n        )\n      }\n\n      // Handle null/undefined check operators (single argument, no value)\n      const nullCheckOps = [`isNull`, `isUndefined`]\n      if (nullCheckOps.includes(e.name)) {\n        const [fieldArg] = e.args\n\n        // Extract field (must be a ref)\n        const field = fieldArg?.type === `ref` ? fieldArg.path : null\n\n        if (field) {\n          comparisons.push({\n            field,\n            operator: e.name,\n            // No value for null/undefined checks\n          })\n        } else {\n          throw new Error(\n            `extractSimpleComparisons requires a field reference for '${e.name}' operator.`\n          )\n        }\n        return\n      }\n\n      // Handle comparison operators\n      const comparisonOps = [`eq`, `gt`, `gte`, `lt`, `lte`, `in`]\n      if (comparisonOps.includes(e.name)) {\n        const [leftArg, rightArg] = e.args\n\n        // Extract field and value\n        const field = leftArg?.type === `ref` ? leftArg.path : null\n        const value = rightArg?.type === `val` ? rightArg.value : null\n\n        if (field && value !== undefined) {\n          comparisons.push({\n            field,\n            operator: e.name,\n            value,\n          })\n        } else {\n          throw new Error(\n            `extractSimpleComparisons requires simple field-value comparisons. Found complex expression for '${e.name}' operator.`\n          )\n        }\n      } else {\n        // Unknown operator\n        throw new Error(\n          `extractSimpleComparisons encountered unknown operator: '${e.name}'`\n        )\n      }\n    }\n  }\n\n  extract(expr)\n  return comparisons\n}\n\n/**\n * Convenience function to get all LoadSubsetOptions in a pre-parsed format.\n * Good starting point for simple use cases.\n *\n * @param options - The LoadSubsetOptions from ctx.meta\n * @returns Pre-parsed filters, sorts, and limit\n *\n * @example\n * ```typescript\n * queryFn: async (ctx) => {\n *   const parsed = parseLoadSubsetOptions(ctx.meta?.loadSubsetOptions)\n *\n *   // Convert to your API format\n *   return api.getProducts({\n *     ...Object.fromEntries(\n *       parsed.filters.map(f => [`${f.field.join('.')}_${f.operator}`, f.value])\n *     ),\n *     sort: parsed.sorts.map(s => `${s.field.join('.')}:${s.direction}`).join(','),\n *     limit: parsed.limit\n *   })\n * }\n * ```\n */\nexport function parseLoadSubsetOptions(\n  options:\n    | {\n        where?: BasicExpression<boolean>\n        orderBy?: OrderBy\n        limit?: number\n      }\n    | undefined\n    | null\n): {\n  filters: Array<SimpleComparison>\n  sorts: Array<ParsedOrderBy>\n  limit?: number\n} {\n  if (!options) {\n    return { filters: [], sorts: [] }\n  }\n\n  return {\n    filters: extractSimpleComparisons(options.where),\n    sorts: parseOrderByExpression(options.orderBy),\n    limit: options.limit,\n  }\n}\n", "import { CollectionImpl } from \"../../collection/index.js\"\nimport {\n  Aggregate as AggregateExpr,\n  CollectionRef,\n  Func as FuncExpr,\n  PropRef,\n  QueryRef,\n  Value as ValueExpr,\n  isExpressionLike,\n} from \"../ir.js\"\nimport {\n  InvalidSourceError,\n  InvalidSourceTypeError,\n  JoinConditionMustBeEqualityError,\n  OnlyOneSourceAllowedError,\n  QueryMustHaveFromClauseError,\n  SubQueryMustHaveFromClauseError,\n} from \"../../errors.js\"\nimport { createRefProxy, toExpression } from \"./ref-proxy.js\"\nimport type { NamespacedRow, SingleResult } from \"../../types.js\"\nimport type {\n  Aggregate,\n  BasicExpression,\n  JoinClause,\n  OrderBy,\n  OrderByDirection,\n  QueryIR,\n} from \"../ir.js\"\nimport type {\n  CompareOptions,\n  Context,\n  GroupByCallback,\n  JoinOnCallback,\n  MergeContextForJoinCallback,\n  MergeContextWithJoinType,\n  OrderByCallback,\n  OrderByOptions,\n  RefsForContext,\n  ResultTypeFromSelect,\n  SchemaFromSource,\n  SelectObject,\n  Source,\n  WhereCallback,\n  WithResult,\n} from \"./types.js\"\n\nexport class BaseQueryBuilder<TContext extends Context = Context> {\n  private readonly query: Partial<QueryIR> = {}\n\n  constructor(query: Partial<QueryIR> = {}) {\n    this.query = { ...query }\n  }\n\n  /**\n   * Creates a CollectionRef or QueryRef from a source object\n   * @param source - An object with a single key-value pair\n   * @param context - Context string for error messages (e.g., \"from clause\", \"join clause\")\n   * @returns A tuple of [alias, ref] where alias is the source key and ref is the created reference\n   */\n  private _createRefForSource<TSource extends Source>(\n    source: TSource,\n    context: string\n  ): [string, CollectionRef | QueryRef] {\n    // Validate source is a plain object (not null, array, string, etc.)\n    // We use try-catch to handle null/undefined gracefully\n    let keys: Array<string>\n    try {\n      keys = Object.keys(source)\n    } catch {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      const type = source === null ? `null` : `undefined`\n      throw new InvalidSourceTypeError(context, type)\n    }\n\n    // Check if it's an array (arrays pass Object.keys but aren't valid sources)\n    if (Array.isArray(source)) {\n      throw new InvalidSourceTypeError(context, `array`)\n    }\n\n    // Validate exactly one key\n    if (keys.length !== 1) {\n      if (keys.length === 0) {\n        throw new InvalidSourceTypeError(context, `empty object`)\n      }\n      // Check if it looks like a string was passed (has numeric keys)\n      if (keys.every((k) => !isNaN(Number(k)))) {\n        throw new InvalidSourceTypeError(context, `string`)\n      }\n      throw new OnlyOneSourceAllowedError(context)\n    }\n\n    const alias = keys[0]!\n    const sourceValue = source[alias]\n\n    // Validate the value is a Collection or QueryBuilder\n    let ref: CollectionRef | QueryRef\n\n    if (sourceValue instanceof CollectionImpl) {\n      ref = new CollectionRef(sourceValue, alias)\n    } else if (sourceValue instanceof BaseQueryBuilder) {\n      const subQuery = sourceValue._getQuery()\n      if (!(subQuery as Partial<QueryIR>).from) {\n        throw new SubQueryMustHaveFromClauseError(context)\n      }\n      ref = new QueryRef(subQuery, alias)\n    } else {\n      throw new InvalidSourceError(alias)\n    }\n\n    return [alias, ref]\n  }\n\n  /**\n   * Specify the source table or subquery for the query\n   *\n   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery\n   * @returns A QueryBuilder with the specified source\n   *\n   * @example\n   * ```ts\n   * // Query from a collection\n   * query.from({ users: usersCollection })\n   *\n   * // Query from a subquery\n   * const activeUsers = query.from({ u: usersCollection }).where(({u}) => u.active)\n   * query.from({ activeUsers })\n   * ```\n   */\n  from<TSource extends Source>(\n    source: TSource\n  ): QueryBuilder<{\n    baseSchema: SchemaFromSource<TSource>\n    schema: SchemaFromSource<TSource>\n    fromSourceName: keyof TSource & string\n    hasJoins: false\n  }> {\n    const [, from] = this._createRefForSource(source, `from clause`)\n\n    return new BaseQueryBuilder({\n      ...this.query,\n      from,\n    }) as any\n  }\n\n  /**\n   * Join another table or subquery to the current query\n   *\n   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery\n   * @param onCallback - A function that receives table references and returns the join condition\n   * @param type - The type of join: 'inner', 'left', 'right', or 'full' (defaults to 'left')\n   * @returns A QueryBuilder with the joined table available\n   *\n   * @example\n   * ```ts\n   * // Left join users with posts\n   * query\n   *   .from({ users: usersCollection })\n   *   .join({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))\n   *\n   * // Inner join with explicit type\n   * query\n   *   .from({ u: usersCollection })\n   *   .join({ p: postsCollection }, ({u, p}) => eq(u.id, p.userId), 'inner')\n   * ```\n   *\n   * // Join with a subquery\n   * const activeUsers = query.from({ u: usersCollection }).where(({u}) => u.active)\n   * query\n   *   .from({ activeUsers })\n   *   .join({ p: postsCollection }, ({u, p}) => eq(u.id, p.userId))\n   */\n  join<\n    TSource extends Source,\n    TJoinType extends `inner` | `left` | `right` | `full` = `left`,\n  >(\n    source: TSource,\n    onCallback: JoinOnCallback<\n      MergeContextForJoinCallback<TContext, SchemaFromSource<TSource>>\n    >,\n    type: TJoinType = `left` as TJoinType\n  ): QueryBuilder<\n    MergeContextWithJoinType<TContext, SchemaFromSource<TSource>, TJoinType>\n  > {\n    const [alias, from] = this._createRefForSource(source, `join clause`)\n\n    // Create a temporary context for the callback\n    const currentAliases = this._getCurrentAliases()\n    const newAliases = [...currentAliases, alias]\n    const refProxy = createRefProxy(newAliases) as RefsForContext<\n      MergeContextForJoinCallback<TContext, SchemaFromSource<TSource>>\n    >\n\n    // Get the join condition expression\n    const onExpression = onCallback(refProxy)\n\n    // Extract left and right from the expression\n    // For now, we'll assume it's an eq function with two arguments\n    let left: BasicExpression\n    let right: BasicExpression\n\n    if (\n      onExpression.type === `func` &&\n      onExpression.name === `eq` &&\n      onExpression.args.length === 2\n    ) {\n      left = onExpression.args[0]!\n      right = onExpression.args[1]!\n    } else {\n      throw new JoinConditionMustBeEqualityError()\n    }\n\n    const joinClause: JoinClause = {\n      from,\n      type,\n      left,\n      right,\n    }\n\n    const existingJoins = this.query.join || []\n\n    return new BaseQueryBuilder({\n      ...this.query,\n      join: [...existingJoins, joinClause],\n    }) as any\n  }\n\n  /**\n   * Perform a LEFT JOIN with another table or subquery\n   *\n   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery\n   * @param onCallback - A function that receives table references and returns the join condition\n   * @returns A QueryBuilder with the left joined table available\n   *\n   * @example\n   * ```ts\n   * // Left join users with posts\n   * query\n   *   .from({ users: usersCollection })\n   *   .leftJoin({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))\n   * ```\n   */\n  leftJoin<TSource extends Source>(\n    source: TSource,\n    onCallback: JoinOnCallback<\n      MergeContextForJoinCallback<TContext, SchemaFromSource<TSource>>\n    >\n  ): QueryBuilder<\n    MergeContextWithJoinType<TContext, SchemaFromSource<TSource>, `left`>\n  > {\n    return this.join(source, onCallback, `left`)\n  }\n\n  /**\n   * Perform a RIGHT JOIN with another table or subquery\n   *\n   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery\n   * @param onCallback - A function that receives table references and returns the join condition\n   * @returns A QueryBuilder with the right joined table available\n   *\n   * @example\n   * ```ts\n   * // Right join users with posts\n   * query\n   *   .from({ users: usersCollection })\n   *   .rightJoin({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))\n   * ```\n   */\n  rightJoin<TSource extends Source>(\n    source: TSource,\n    onCallback: JoinOnCallback<\n      MergeContextForJoinCallback<TContext, SchemaFromSource<TSource>>\n    >\n  ): QueryBuilder<\n    MergeContextWithJoinType<TContext, SchemaFromSource<TSource>, `right`>\n  > {\n    return this.join(source, onCallback, `right`)\n  }\n\n  /**\n   * Perform an INNER JOIN with another table or subquery\n   *\n   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery\n   * @param onCallback - A function that receives table references and returns the join condition\n   * @returns A QueryBuilder with the inner joined table available\n   *\n   * @example\n   * ```ts\n   * // Inner join users with posts\n   * query\n   *   .from({ users: usersCollection })\n   *   .innerJoin({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))\n   * ```\n   */\n  innerJoin<TSource extends Source>(\n    source: TSource,\n    onCallback: JoinOnCallback<\n      MergeContextForJoinCallback<TContext, SchemaFromSource<TSource>>\n    >\n  ): QueryBuilder<\n    MergeContextWithJoinType<TContext, SchemaFromSource<TSource>, `inner`>\n  > {\n    return this.join(source, onCallback, `inner`)\n  }\n\n  /**\n   * Perform a FULL JOIN with another table or subquery\n   *\n   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery\n   * @param onCallback - A function that receives table references and returns the join condition\n   * @returns A QueryBuilder with the full joined table available\n   *\n   * @example\n   * ```ts\n   * // Full join users with posts\n   * query\n   *   .from({ users: usersCollection })\n   *   .fullJoin({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))\n   * ```\n   */\n  fullJoin<TSource extends Source>(\n    source: TSource,\n    onCallback: JoinOnCallback<\n      MergeContextForJoinCallback<TContext, SchemaFromSource<TSource>>\n    >\n  ): QueryBuilder<\n    MergeContextWithJoinType<TContext, SchemaFromSource<TSource>, `full`>\n  > {\n    return this.join(source, onCallback, `full`)\n  }\n\n  /**\n   * Filter rows based on a condition\n   *\n   * @param callback - A function that receives table references and returns an expression\n   * @returns A QueryBuilder with the where condition applied\n   *\n   * @example\n   * ```ts\n   * // Simple condition\n   * query\n   *   .from({ users: usersCollection })\n   *   .where(({users}) => gt(users.age, 18))\n   *\n   * // Multiple conditions\n   * query\n   *   .from({ users: usersCollection })\n   *   .where(({users}) => and(\n   *     gt(users.age, 18),\n   *     eq(users.active, true)\n   *   ))\n   *\n   * // Multiple where calls are ANDed together\n   * query\n   *   .from({ users: usersCollection })\n   *   .where(({users}) => gt(users.age, 18))\n   *   .where(({users}) => eq(users.active, true))\n   * ```\n   */\n  where(callback: WhereCallback<TContext>): QueryBuilder<TContext> {\n    const aliases = this._getCurrentAliases()\n    const refProxy = createRefProxy(aliases) as RefsForContext<TContext>\n    const expression = callback(refProxy)\n\n    const existingWhere = this.query.where || []\n\n    return new BaseQueryBuilder({\n      ...this.query,\n      where: [...existingWhere, expression],\n    }) as any\n  }\n\n  /**\n   * Filter grouped rows based on aggregate conditions\n   *\n   * @param callback - A function that receives table references and returns an expression\n   * @returns A QueryBuilder with the having condition applied\n   *\n   * @example\n   * ```ts\n   * // Filter groups by count\n   * query\n   *   .from({ posts: postsCollection })\n   *   .groupBy(({posts}) => posts.userId)\n   *   .having(({posts}) => gt(count(posts.id), 5))\n   *\n   * // Filter by average\n   * query\n   *   .from({ orders: ordersCollection })\n   *   .groupBy(({orders}) => orders.customerId)\n   *   .having(({orders}) => gt(avg(orders.total), 100))\n   *\n   * // Multiple having calls are ANDed together\n   * query\n   *   .from({ orders: ordersCollection })\n   *   .groupBy(({orders}) => orders.customerId)\n   *   .having(({orders}) => gt(count(orders.id), 5))\n   *   .having(({orders}) => gt(avg(orders.total), 100))\n   * ```\n   */\n  having(callback: WhereCallback<TContext>): QueryBuilder<TContext> {\n    const aliases = this._getCurrentAliases()\n    const refProxy = createRefProxy(aliases) as RefsForContext<TContext>\n    const expression = callback(refProxy)\n\n    const existingHaving = this.query.having || []\n\n    return new BaseQueryBuilder({\n      ...this.query,\n      having: [...existingHaving, expression],\n    }) as any\n  }\n\n  /**\n   * Select specific columns or computed values from the query\n   *\n   * @param callback - A function that receives table references and returns an object with selected fields or expressions\n   * @returns A QueryBuilder that returns only the selected fields\n   *\n   * @example\n   * ```ts\n   * // Select specific columns\n   * query\n   *   .from({ users: usersCollection })\n   *   .select(({users}) => ({\n   *     name: users.name,\n   *     email: users.email\n   *   }))\n   *\n   * // Select with computed values\n   * query\n   *   .from({ users: usersCollection })\n   *   .select(({users}) => ({\n   *     fullName: concat(users.firstName, ' ', users.lastName),\n   *     ageInMonths: mul(users.age, 12)\n   *   }))\n   *\n   * // Select with aggregates (requires GROUP BY)\n   * query\n   *   .from({ posts: postsCollection })\n   *   .groupBy(({posts}) => posts.userId)\n   *   .select(({posts, count}) => ({\n   *     userId: posts.userId,\n   *     postCount: count(posts.id)\n   *   }))\n   * ```\n   */\n  select<TSelectObject extends SelectObject>(\n    callback: (refs: RefsForContext<TContext>) => TSelectObject\n  ): QueryBuilder<WithResult<TContext, ResultTypeFromSelect<TSelectObject>>> {\n    const aliases = this._getCurrentAliases()\n    const refProxy = createRefProxy(aliases) as RefsForContext<TContext>\n    const selectObject = callback(refProxy)\n    const select = buildNestedSelect(selectObject)\n\n    return new BaseQueryBuilder({\n      ...this.query,\n      select: select,\n      fnSelect: undefined, // remove the fnSelect clause if it exists\n    }) as any\n  }\n\n  /**\n   * Sort the query results by one or more columns\n   *\n   * @param callback - A function that receives table references and returns the field to sort by\n   * @param direction - Sort direction: 'asc' for ascending, 'desc' for descending (defaults to 'asc')\n   * @returns A QueryBuilder with the ordering applied\n   *\n   * @example\n   * ```ts\n   * // Sort by a single column\n   * query\n   *   .from({ users: usersCollection })\n   *   .orderBy(({users}) => users.name)\n   *\n   * // Sort descending\n   * query\n   *   .from({ users: usersCollection })\n   *   .orderBy(({users}) => users.createdAt, 'desc')\n   *\n   * // Multiple sorts (chain orderBy calls)\n   * query\n   *   .from({ users: usersCollection })\n   *   .orderBy(({users}) => users.lastName)\n   *   .orderBy(({users}) => users.firstName)\n   * ```\n   */\n  orderBy(\n    callback: OrderByCallback<TContext>,\n    options: OrderByDirection | OrderByOptions = `asc`\n  ): QueryBuilder<TContext> {\n    const aliases = this._getCurrentAliases()\n    const refProxy = createRefProxy(aliases) as RefsForContext<TContext>\n    const result = callback(refProxy)\n\n    const opts: CompareOptions =\n      typeof options === `string`\n        ? { direction: options, nulls: `first` }\n        : {\n            direction: options.direction ?? `asc`,\n            nulls: options.nulls ?? `first`,\n            stringSort: options.stringSort,\n            locale:\n              options.stringSort === `locale` ? options.locale : undefined,\n            localeOptions:\n              options.stringSort === `locale`\n                ? options.localeOptions\n                : undefined,\n          }\n\n    const makeOrderByClause = (res: any) => {\n      return {\n        expression: toExpression(res),\n        compareOptions: opts,\n      }\n    }\n\n    // Create the new OrderBy structure with expression and direction\n    const orderByClauses = Array.isArray(result)\n      ? result.map((r) => makeOrderByClause(r))\n      : [makeOrderByClause(result)]\n\n    const existingOrderBy: OrderBy = this.query.orderBy || []\n\n    return new BaseQueryBuilder({\n      ...this.query,\n      orderBy: [...existingOrderBy, ...orderByClauses],\n    }) as any\n  }\n\n  /**\n   * Group rows by one or more columns for aggregation\n   *\n   * @param callback - A function that receives table references and returns the field(s) to group by\n   * @returns A QueryBuilder with grouping applied (enables aggregate functions in SELECT and HAVING)\n   *\n   * @example\n   * ```ts\n   * // Group by a single column\n   * query\n   *   .from({ posts: postsCollection })\n   *   .groupBy(({posts}) => posts.userId)\n   *   .select(({posts, count}) => ({\n   *     userId: posts.userId,\n   *     postCount: count()\n   *   }))\n   *\n   * // Group by multiple columns\n   * query\n   *   .from({ sales: salesCollection })\n   *   .groupBy(({sales}) => [sales.region, sales.category])\n   *   .select(({sales, sum}) => ({\n   *     region: sales.region,\n   *     category: sales.category,\n   *     totalSales: sum(sales.amount)\n   *   }))\n   * ```\n   */\n  groupBy(callback: GroupByCallback<TContext>): QueryBuilder<TContext> {\n    const aliases = this._getCurrentAliases()\n    const refProxy = createRefProxy(aliases) as RefsForContext<TContext>\n    const result = callback(refProxy)\n\n    const newExpressions = Array.isArray(result)\n      ? result.map((r) => toExpression(r))\n      : [toExpression(result)]\n\n    // Extend existing groupBy expressions (multiple groupBy calls should accumulate)\n    const existingGroupBy = this.query.groupBy || []\n    return new BaseQueryBuilder({\n      ...this.query,\n      groupBy: [...existingGroupBy, ...newExpressions],\n    }) as any\n  }\n\n  /**\n   * Limit the number of rows returned by the query\n   * `orderBy` is required for `limit`\n   *\n   * @param count - Maximum number of rows to return\n   * @returns A QueryBuilder with the limit applied\n   *\n   * @example\n   * ```ts\n   * // Get top 5 posts by likes\n   * query\n   *   .from({ posts: postsCollection })\n   *   .orderBy(({posts}) => posts.likes, 'desc')\n   *   .limit(5)\n   * ```\n   */\n  limit(count: number): QueryBuilder<TContext> {\n    return new BaseQueryBuilder({\n      ...this.query,\n      limit: count,\n    }) as any\n  }\n\n  /**\n   * Skip a number of rows before returning results\n   * `orderBy` is required for `offset`\n   *\n   * @param count - Number of rows to skip\n   * @returns A QueryBuilder with the offset applied\n   *\n   * @example\n   * ```ts\n   * // Get second page of results\n   * query\n   *   .from({ posts: postsCollection })\n   *   .orderBy(({posts}) => posts.createdAt, 'desc')\n   *   .offset(page * pageSize)\n   *   .limit(pageSize)\n   * ```\n   */\n  offset(count: number): QueryBuilder<TContext> {\n    return new BaseQueryBuilder({\n      ...this.query,\n      offset: count,\n    }) as any\n  }\n\n  /**\n   * Specify that the query should return distinct rows.\n   * Deduplicates rows based on the selected columns.\n   * @returns A QueryBuilder with distinct enabled\n   *\n   * @example\n   * ```ts\n   * // Get countries our users are from\n   * query\n   *   .from({ users: usersCollection })\n   *   .select(({users}) => users.country)\n   *   .distinct()\n   * ```\n   */\n  distinct(): QueryBuilder<TContext> {\n    return new BaseQueryBuilder({\n      ...this.query,\n      distinct: true,\n    }) as any\n  }\n\n  /**\n   * Specify that the query should return a single result\n   * @returns A QueryBuilder that returns the first result\n   *\n   * @example\n   * ```ts\n   * // Get the user matching the query\n   * query\n   *   .from({ users: usersCollection })\n   *   .where(({users}) => eq(users.id, 1))\n   *   .findOne()\n   *```\n   */\n  findOne(): QueryBuilder<TContext & SingleResult> {\n    return new BaseQueryBuilder({\n      ...this.query,\n      // TODO: enforcing return only one result with also a default orderBy if none is specified\n      // limit: 1,\n      singleResult: true,\n    })\n  }\n\n  // Helper methods\n  private _getCurrentAliases(): Array<string> {\n    const aliases: Array<string> = []\n\n    // Add the from alias\n    if (this.query.from) {\n      aliases.push(this.query.from.alias)\n    }\n\n    // Add join aliases\n    if (this.query.join) {\n      for (const join of this.query.join) {\n        aliases.push(join.from.alias)\n      }\n    }\n\n    return aliases\n  }\n\n  /**\n   * Functional variants of the query builder\n   * These are imperative function that are called for ery row.\n   * Warning: that these cannot be optimized by the query compiler, and may prevent\n   * some type of optimizations being possible.\n   * @example\n   * ```ts\n   * q.fn.select((row) => ({\n   *   name: row.user.name.toUpperCase(),\n   *   age: row.user.age + 1,\n   * }))\n   * ```\n   */\n  get fn() {\n    const builder = this\n    return {\n      /**\n       * Select fields using a function that operates on each row\n       * Warning: This cannot be optimized by the query compiler\n       *\n       * @param callback - A function that receives a row and returns the selected value\n       * @returns A QueryBuilder with functional selection applied\n       *\n       * @example\n       * ```ts\n       * // Functional select (not optimized)\n       * query\n       *   .from({ users: usersCollection })\n       *   .fn.select(row => ({\n       *     name: row.users.name.toUpperCase(),\n       *     age: row.users.age + 1,\n       *   }))\n       * ```\n       */\n      select<TFuncSelectResult>(\n        callback: (row: TContext[`schema`]) => TFuncSelectResult\n      ): QueryBuilder<WithResult<TContext, TFuncSelectResult>> {\n        return new BaseQueryBuilder({\n          ...builder.query,\n          select: undefined, // remove the select clause if it exists\n          fnSelect: callback,\n        })\n      },\n      /**\n       * Filter rows using a function that operates on each row\n       * Warning: This cannot be optimized by the query compiler\n       *\n       * @param callback - A function that receives a row and returns a boolean\n       * @returns A QueryBuilder with functional filtering applied\n       *\n       * @example\n       * ```ts\n       * // Functional where (not optimized)\n       * query\n       *   .from({ users: usersCollection })\n       *   .fn.where(row => row.users.name.startsWith('A'))\n       * ```\n       */\n      where(\n        callback: (row: TContext[`schema`]) => any\n      ): QueryBuilder<TContext> {\n        return new BaseQueryBuilder({\n          ...builder.query,\n          fnWhere: [\n            ...(builder.query.fnWhere || []),\n            callback as (row: NamespacedRow) => any,\n          ],\n        })\n      },\n      /**\n       * Filter grouped rows using a function that operates on each aggregated row\n       * Warning: This cannot be optimized by the query compiler\n       *\n       * @param callback - A function that receives an aggregated row and returns a boolean\n       * @returns A QueryBuilder with functional having filter applied\n       *\n       * @example\n       * ```ts\n       * // Functional having (not optimized)\n       * query\n       *   .from({ posts: postsCollection })\n       *   .groupBy(({posts}) => posts.userId)\n       *   .fn.having(row => row.count > 5)\n       * ```\n       */\n      having(\n        callback: (row: TContext[`schema`]) => any\n      ): QueryBuilder<TContext> {\n        return new BaseQueryBuilder({\n          ...builder.query,\n          fnHaving: [\n            ...(builder.query.fnHaving || []),\n            callback as (row: NamespacedRow) => any,\n          ],\n        })\n      },\n    }\n  }\n\n  _getQuery(): QueryIR {\n    if (!this.query.from) {\n      throw new QueryMustHaveFromClauseError()\n    }\n    return this.query as QueryIR\n  }\n}\n\n// Helper to ensure we have a BasicExpression/Aggregate for a value\nfunction toExpr(value: any): BasicExpression | Aggregate {\n  if (value === undefined) return toExpression(null)\n  if (\n    value instanceof AggregateExpr ||\n    value instanceof FuncExpr ||\n    value instanceof PropRef ||\n    value instanceof ValueExpr\n  ) {\n    return value as BasicExpression | Aggregate\n  }\n  return toExpression(value)\n}\n\nfunction isPlainObject(value: any): value is Record<string, any> {\n  return (\n    value !== null &&\n    typeof value === `object` &&\n    !isExpressionLike(value) &&\n    !value.__refProxy\n  )\n}\n\nfunction buildNestedSelect(obj: any): any {\n  if (!isPlainObject(obj)) return toExpr(obj)\n  const out: Record<string, any> = {}\n  for (const [k, v] of Object.entries(obj)) {\n    if (typeof k === `string` && k.startsWith(`__SPREAD_SENTINEL__`)) {\n      // Preserve sentinel key and its value (value is unimportant at compile time)\n      out[k] = v\n      continue\n    }\n    out[k] = buildNestedSelect(v)\n  }\n  return out\n}\n\n// Internal function to build a query from a callback\n// used by liveQueryCollectionOptions.query\nexport function buildQuery<TContext extends Context>(\n  fn: (builder: InitialQueryBuilder) => QueryBuilder<TContext>\n): QueryIR {\n  const result = fn(new BaseQueryBuilder())\n  return getQueryIR(result)\n}\n\n// Internal function to get the QueryIR from a builder\nexport function getQueryIR(\n  builder: BaseQueryBuilder | QueryBuilder<any> | InitialQueryBuilder\n): QueryIR {\n  return (builder as unknown as BaseQueryBuilder)._getQuery()\n}\n\n// Type-only exports for the query builder\nexport type InitialQueryBuilder = Pick<BaseQueryBuilder<Context>, `from`>\n\nexport type InitialQueryBuilderConstructor = new () => InitialQueryBuilder\n\nexport type QueryBuilder<TContext extends Context> = Omit<\n  BaseQueryBuilder<TContext>,\n  `from` | `_getQuery`\n>\n\n// Main query builder class alias with the constructor type modified to hide all\n// but the from method on the initial instance\nexport const Query: InitialQueryBuilderConstructor = BaseQueryBuilder\n\n// Helper type to extract context from a QueryBuilder\nexport type ExtractContext<T> =\n  T extends BaseQueryBuilder<infer TContext>\n    ? TContext\n    : T extends QueryBuilder<infer TContext>\n      ? TContext\n      : never\n\n// Export the types from types.ts for convenience\nexport type {\n  Context,\n  Source,\n  GetResult,\n  RefLeaf as Ref,\n  InferResultType,\n} from \"./types.js\"\n", "/**\n * # Query Optimizer\n *\n * The query optimizer improves query performance by implementing predicate pushdown optimization.\n * It rewrites the intermediate representation (IR) to push WHERE clauses as close to the data\n * source as possible, reducing the amount of data processed during joins.\n *\n * ## How It Works\n *\n * The optimizer follows a 4-step process:\n *\n * ### 1. AND Clause Splitting\n * Splits AND clauses at the root level into separate WHERE clauses for granular optimization.\n * ```javascript\n * // Before: WHERE and(eq(users.department_id, 1), gt(users.age, 25))\n * // After:  WHERE eq(users.department_id, 1) + WHERE gt(users.age, 25)\n * ```\n *\n * ### 2. Source Analysis\n * Analyzes each WHERE clause to determine which table sources it references:\n * - Single-source clauses: Touch only one table (e.g., `users.department_id = 1`)\n * - Multi-source clauses: Touch multiple tables (e.g., `users.id = posts.user_id`)\n *\n * ### 3. Clause Grouping\n * Groups WHERE clauses by the sources they touch:\n * - Single-source clauses are grouped by their respective table\n * - Multi-source clauses are combined for the main query\n *\n * ### 4. Subquery Creation\n * Lifts single-source WHERE clauses into subqueries that wrap the original table references.\n *\n * ## Safety & Edge Cases\n *\n * The optimizer includes targeted safety checks to prevent predicate pushdown when it could\n * break query semantics:\n *\n * ### Always Safe Operations\n * - **Creating new subqueries**: Wrapping collection references in subqueries with WHERE clauses\n * - **Main query optimizations**: Moving single-source WHERE clauses from main query to subqueries\n * - **Queries with aggregates/ORDER BY/HAVING**: Can still create new filtered subqueries\n *\n * ### Unsafe Operations (blocked by safety checks)\n * Pushing WHERE clauses **into existing subqueries** that have:\n * - **Aggregates**: GROUP BY, HAVING, or aggregate functions in SELECT (would change aggregation)\n * - **Ordering + Limits**: ORDER BY combined with LIMIT/OFFSET (would change result set)\n * - **Functional Operations**: fnSelect, fnWhere, fnHaving (potential side effects)\n *\n * ### Residual WHERE Clauses\n * For outer joins (LEFT, RIGHT, FULL), WHERE clauses are copied to subqueries for optimization\n * but also kept as \"residual\" clauses in the main query to preserve semantics. This ensures\n * that NULL values from outer joins are properly filtered according to SQL standards.\n *\n * The optimizer tracks which clauses were actually optimized and only removes those from the\n * main query. Subquery reuse is handled safely through immutable query copies.\n *\n * ## Example Optimizations\n *\n * ### Basic Query with Joins\n * **Original Query:**\n * ```javascript\n * query\n *   .from({ users: usersCollection })\n *   .join({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.user_id))\n *   .where(({users}) => eq(users.department_id, 1))\n *   .where(({posts}) => gt(posts.views, 100))\n *   .where(({users, posts}) => eq(users.id, posts.author_id))\n * ```\n *\n * **Optimized Query:**\n * ```javascript\n * query\n *   .from({\n *     users: subquery\n *       .from({ users: usersCollection })\n *       .where(({users}) => eq(users.department_id, 1))\n *   })\n *   .join({\n *     posts: subquery\n *       .from({ posts: postsCollection })\n *       .where(({posts}) => gt(posts.views, 100))\n *   }, ({users, posts}) => eq(users.id, posts.user_id))\n *   .where(({users, posts}) => eq(users.id, posts.author_id))\n * ```\n *\n * ### Query with Aggregates (Now Optimizable!)\n * **Original Query:**\n * ```javascript\n * query\n *   .from({ users: usersCollection })\n *   .join({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.user_id))\n *   .where(({users}) => eq(users.department_id, 1))\n *   .groupBy(['users.department_id'])\n *   .select({ count: agg('count', '*') })\n * ```\n *\n * **Optimized Query:**\n * ```javascript\n * query\n *   .from({\n *     users: subquery\n *       .from({ users: usersCollection })\n *       .where(({users}) => eq(users.department_id, 1))\n *   })\n *   .join({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.user_id))\n *   .groupBy(['users.department_id'])\n *   .select({ count: agg('count', '*') })\n * ```\n *\n * ## Benefits\n *\n * - **Reduced Data Processing**: Filters applied before joins reduce intermediate result size\n * - **Better Performance**: Smaller datasets lead to faster query execution\n * - **Automatic Optimization**: No manual query rewriting required\n * - **Preserves Semantics**: Optimized queries return identical results\n * - **Safe by Design**: Comprehensive checks prevent semantic-breaking optimizations\n *\n * ## Integration\n *\n * The optimizer is automatically called during query compilation before the IR is\n * transformed into a D2Mini pipeline.\n */\n\nimport { deepEquals } from \"../utils.js\"\nimport { CannotCombineEmptyExpressionListError } from \"../errors.js\"\nimport {\n  CollectionRef as CollectionRefClass,\n  Func,\n  PropRef,\n  QueryRef as QueryRefClass,\n  createResidualWhere,\n  getWhereExpression,\n  isResidualWhere,\n} from \"./ir.js\"\nimport type { BasicExpression, From, QueryIR, Select, Where } from \"./ir.js\"\n\n/**\n * Represents a WHERE clause after source analysis\n */\nexport interface AnalyzedWhereClause {\n  /** The WHERE expression */\n  expression: BasicExpression<boolean>\n  /** Set of table/source aliases that this WHERE clause touches */\n  touchedSources: Set<string>\n  /** Whether this clause contains namespace-only references that prevent pushdown */\n  hasNamespaceOnlyRef: boolean\n}\n\n/**\n * Represents WHERE clauses grouped by the sources they touch\n */\nexport interface GroupedWhereClauses {\n  /** WHERE clauses that touch only a single source, grouped by source alias */\n  singleSource: Map<string, BasicExpression<boolean>>\n  /** WHERE clauses that touch multiple sources, combined into one expression */\n  multiSource?: BasicExpression<boolean>\n}\n\n/**\n * Result of query optimization including both the optimized query and collection-specific WHERE clauses\n */\nexport interface OptimizationResult {\n  /** The optimized query with WHERE clauses potentially moved to subqueries */\n  optimizedQuery: QueryIR\n  /** Map of source aliases to their extracted WHERE clauses for index optimization */\n  sourceWhereClauses: Map<string, BasicExpression<boolean>>\n}\n\n/**\n * Main query optimizer entry point that lifts WHERE clauses into subqueries.\n *\n * This function implements multi-level predicate pushdown optimization by recursively\n * moving WHERE clauses through nested subqueries to get them as close to the data\n * sources as possible, then removing redundant subqueries.\n *\n * @param query - The QueryIR to optimize\n * @returns An OptimizationResult with the optimized query and collection WHERE clause mapping\n *\n * @example\n * ```typescript\n * const originalQuery = {\n *   from: new CollectionRef(users, 'u'),\n *   join: [{ from: new CollectionRef(posts, 'p'), ... }],\n *   where: [eq(u.dept_id, 1), gt(p.views, 100)]\n * }\n *\n * const { optimizedQuery, sourceWhereClauses } = optimizeQuery(originalQuery)\n * // Result: Single-source clauses moved to deepest possible subqueries\n * // sourceWhereClauses: Map { 'u' => eq(u.dept_id, 1), 'p' => gt(p.views, 100) }\n * ```\n */\nexport function optimizeQuery(query: QueryIR): OptimizationResult {\n  // First, extract source WHERE clauses before optimization\n  const sourceWhereClauses = extractSourceWhereClauses(query)\n\n  // Apply multi-level predicate pushdown with iterative convergence\n  let optimized = query\n  let previousOptimized: QueryIR | undefined\n  let iterations = 0\n  const maxIterations = 10 // Prevent infinite loops\n\n  // Keep optimizing until no more changes occur or max iterations reached\n  while (\n    iterations < maxIterations &&\n    !deepEquals(optimized, previousOptimized)\n  ) {\n    previousOptimized = optimized\n    optimized = applyRecursiveOptimization(optimized)\n    iterations++\n  }\n\n  // Remove redundant subqueries\n  const cleaned = removeRedundantSubqueries(optimized)\n\n  return {\n    optimizedQuery: cleaned,\n    sourceWhereClauses,\n  }\n}\n\n/**\n * Extracts collection-specific WHERE clauses from a query for index optimization.\n * This analyzes the original query to identify WHERE clauses that can be pushed down\n * to specific collections, but only for simple queries without joins.\n *\n * @param query - The original QueryIR to analyze\n * @returns Map of source aliases to their WHERE clauses\n */\nfunction extractSourceWhereClauses(\n  query: QueryIR\n): Map<string, BasicExpression<boolean>> {\n  const sourceWhereClauses = new Map<string, BasicExpression<boolean>>()\n\n  // Only analyze queries that have WHERE clauses\n  if (!query.where || query.where.length === 0) {\n    return sourceWhereClauses\n  }\n\n  // Split all AND clauses at the root level for granular analysis\n  const splitWhereClauses = splitAndClauses(query.where)\n\n  // Analyze each WHERE clause to determine which sources it touches\n  const analyzedClauses = splitWhereClauses.map((clause) =>\n    analyzeWhereClause(clause)\n  )\n\n  // Group clauses by single-source vs multi-source\n  const groupedClauses = groupWhereClauses(analyzedClauses)\n\n  // Only include single-source clauses that reference collections directly\n  for (const [sourceAlias, whereClause] of groupedClauses.singleSource) {\n    // Check if this source alias corresponds to a collection reference\n    if (isCollectionReference(query, sourceAlias)) {\n      sourceWhereClauses.set(sourceAlias, whereClause)\n    }\n  }\n\n  return sourceWhereClauses\n}\n\n/**\n * Determines if a source alias refers to a collection reference (not a subquery).\n * This is used to identify WHERE clauses that can be pushed down to collection subscriptions.\n *\n * @param query - The query to analyze\n * @param sourceAlias - The source alias to check\n * @returns True if the alias refers to a collection reference\n */\nfunction isCollectionReference(query: QueryIR, sourceAlias: string): boolean {\n  // Check the FROM clause\n  if (query.from.alias === sourceAlias) {\n    return query.from.type === `collectionRef`\n  }\n\n  // Check JOIN clauses\n  if (query.join) {\n    for (const joinClause of query.join) {\n      if (joinClause.from.alias === sourceAlias) {\n        return joinClause.from.type === `collectionRef`\n      }\n    }\n  }\n\n  return false\n}\n\n/**\n * Applies recursive predicate pushdown optimization.\n *\n * @param query - The QueryIR to optimize\n * @returns A new QueryIR with optimizations applied\n */\nfunction applyRecursiveOptimization(query: QueryIR): QueryIR {\n  // First, recursively optimize any existing subqueries\n  const subqueriesOptimized = {\n    ...query,\n    from:\n      query.from.type === `queryRef`\n        ? new QueryRefClass(\n            applyRecursiveOptimization(query.from.query),\n            query.from.alias\n          )\n        : query.from,\n    join: query.join?.map((joinClause) => ({\n      ...joinClause,\n      from:\n        joinClause.from.type === `queryRef`\n          ? new QueryRefClass(\n              applyRecursiveOptimization(joinClause.from.query),\n              joinClause.from.alias\n            )\n          : joinClause.from,\n    })),\n  }\n\n  // Then apply single-level optimization to this query\n  return applySingleLevelOptimization(subqueriesOptimized)\n}\n\n/**\n * Applies single-level predicate pushdown optimization (existing logic)\n */\nfunction applySingleLevelOptimization(query: QueryIR): QueryIR {\n  // Skip optimization if no WHERE clauses exist\n  if (!query.where || query.where.length === 0) {\n    return query\n  }\n\n  // For queries without joins, combine multiple WHERE clauses into a single clause\n  // to avoid creating multiple filter operators in the pipeline\n  if (!query.join || query.join.length === 0) {\n    // Only optimize if there are multiple WHERE clauses to combine\n    if (query.where.length > 1) {\n      // Combine multiple WHERE clauses into a single AND expression\n      const splitWhereClauses = splitAndClauses(query.where)\n      const combinedWhere = combineWithAnd(splitWhereClauses)\n\n      return {\n        ...query,\n        where: [combinedWhere],\n      }\n    }\n\n    // For single WHERE clauses, no optimization needed\n    return query\n  }\n\n  // Filter out residual WHERE clauses to prevent them from being optimized again\n  const nonResidualWhereClauses = query.where.filter(\n    (where) => !isResidualWhere(where)\n  )\n\n  // Step 1: Split all AND clauses at the root level for granular optimization\n  const splitWhereClauses = splitAndClauses(nonResidualWhereClauses)\n\n  // Step 2: Analyze each WHERE clause to determine which sources it touches\n  const analyzedClauses = splitWhereClauses.map((clause) =>\n    analyzeWhereClause(clause)\n  )\n\n  // Step 3: Group clauses by single-source vs multi-source\n  const groupedClauses = groupWhereClauses(analyzedClauses)\n\n  // Step 4: Apply optimizations by lifting single-source clauses into subqueries\n  const optimizedQuery = applyOptimizations(query, groupedClauses)\n\n  // Add back any residual WHERE clauses that were filtered out\n  const residualWhereClauses = query.where.filter((where) =>\n    isResidualWhere(where)\n  )\n  if (residualWhereClauses.length > 0) {\n    optimizedQuery.where = [\n      ...(optimizedQuery.where || []),\n      ...residualWhereClauses,\n    ]\n  }\n\n  return optimizedQuery\n}\n\n/**\n * Removes redundant subqueries that don't add value.\n * A subquery is redundant if it only wraps another query without adding\n * WHERE, SELECT, GROUP BY, HAVING, ORDER BY, or LIMIT/OFFSET clauses.\n *\n * @param query - The QueryIR to process\n * @returns A new QueryIR with redundant subqueries removed\n */\nfunction removeRedundantSubqueries(query: QueryIR): QueryIR {\n  return {\n    ...query,\n    from: removeRedundantFromClause(query.from),\n    join: query.join?.map((joinClause) => ({\n      ...joinClause,\n      from: removeRedundantFromClause(joinClause.from),\n    })),\n  }\n}\n\n/**\n * Removes redundant subqueries from a FROM clause.\n *\n * @param from - The FROM clause to process\n * @returns A FROM clause with redundant subqueries removed\n */\nfunction removeRedundantFromClause(from: From): From {\n  if (from.type === `collectionRef`) {\n    return from\n  }\n\n  const processedQuery = removeRedundantSubqueries(from.query)\n\n  // Check if this subquery is redundant\n  if (isRedundantSubquery(processedQuery)) {\n    // Return the inner query's FROM clause with this alias\n    const innerFrom = removeRedundantFromClause(processedQuery.from)\n    if (innerFrom.type === `collectionRef`) {\n      return new CollectionRefClass(innerFrom.collection, from.alias)\n    } else {\n      return new QueryRefClass(innerFrom.query, from.alias)\n    }\n  }\n\n  return new QueryRefClass(processedQuery, from.alias)\n}\n\n/**\n * Determines if a subquery is redundant (adds no value).\n *\n * @param query - The query to check\n * @returns True if the query is redundant and can be removed\n */\nfunction isRedundantSubquery(query: QueryIR): boolean {\n  return (\n    (!query.where || query.where.length === 0) &&\n    !query.select &&\n    (!query.groupBy || query.groupBy.length === 0) &&\n    (!query.having || query.having.length === 0) &&\n    (!query.orderBy || query.orderBy.length === 0) &&\n    (!query.join || query.join.length === 0) &&\n    query.limit === undefined &&\n    query.offset === undefined &&\n    !query.fnSelect &&\n    (!query.fnWhere || query.fnWhere.length === 0) &&\n    (!query.fnHaving || query.fnHaving.length === 0)\n  )\n}\n\n/**\n * Step 1: Split all AND clauses recursively into separate WHERE clauses.\n *\n * This enables more granular optimization by treating each condition independently.\n * OR clauses are preserved as they cannot be split without changing query semantics.\n *\n * @param whereClauses - Array of WHERE expressions to split\n * @returns Flattened array with AND clauses split into separate expressions\n *\n * @example\n * ```typescript\n * // Input: [and(eq(a, 1), gt(b, 2)), eq(c, 3)]\n * // Output: [eq(a, 1), gt(b, 2), eq(c, 3)]\n * ```\n */\nfunction splitAndClauses(\n  whereClauses: Array<Where>\n): Array<BasicExpression<boolean>> {\n  const result: Array<BasicExpression<boolean>> = []\n\n  for (const whereClause of whereClauses) {\n    const clause = getWhereExpression(whereClause)\n    result.push(...splitAndClausesRecursive(clause))\n  }\n\n  return result\n}\n\n// Helper function for recursive splitting of BasicExpression arrays\nfunction splitAndClausesRecursive(\n  clause: BasicExpression<boolean>\n): Array<BasicExpression<boolean>> {\n  if (clause.type === `func` && clause.name === `and`) {\n    // Recursively split nested AND clauses to handle complex expressions\n    const result: Array<BasicExpression<boolean>> = []\n    for (const arg of clause.args as Array<BasicExpression<boolean>>) {\n      result.push(...splitAndClausesRecursive(arg))\n    }\n    return result\n  } else {\n    // Preserve non-AND clauses as-is (including OR clauses)\n    return [clause]\n  }\n}\n\n/**\n * Step 2: Analyze which table sources a WHERE clause touches.\n *\n * This determines whether a clause can be pushed down to a specific table\n * or must remain in the main query (for multi-source clauses like join conditions).\n *\n * Special handling for namespace-only references in outer joins:\n * WHERE clauses that reference only a table namespace (e.g., isUndefined(special), eq(special, value))\n * rather than specific properties (e.g., isUndefined(special.id), eq(special.id, value)) are treated as\n * multi-source to prevent incorrect predicate pushdown that would change join semantics.\n *\n * @param clause - The WHERE expression to analyze\n * @returns Analysis result with the expression and touched source aliases\n *\n * @example\n * ```typescript\n * // eq(users.department_id, 1) -> touches ['users'], hasNamespaceOnlyRef: false\n * // eq(users.id, posts.user_id) -> touches ['users', 'posts'], hasNamespaceOnlyRef: false\n * // isUndefined(special) -> touches ['special'], hasNamespaceOnlyRef: true (prevents pushdown)\n * // eq(special, someValue) -> touches ['special'], hasNamespaceOnlyRef: true (prevents pushdown)\n * // isUndefined(special.id) -> touches ['special'], hasNamespaceOnlyRef: false (allows pushdown)\n * // eq(special.id, 5) -> touches ['special'], hasNamespaceOnlyRef: false (allows pushdown)\n * ```\n */\nfunction analyzeWhereClause(\n  clause: BasicExpression<boolean>\n): AnalyzedWhereClause {\n  // Track which table aliases this WHERE clause touches\n  const touchedSources = new Set<string>()\n  // Track whether this clause contains namespace-only references that prevent pushdown\n  let hasNamespaceOnlyRef = false\n\n  /**\n   * Recursively collect all table aliases referenced in an expression\n   */\n  function collectSources(expr: BasicExpression | any): void {\n    switch (expr.type) {\n      case `ref`:\n        // PropRef path has the table alias as the first element\n        if (expr.path && expr.path.length > 0) {\n          const firstElement = expr.path[0]\n          if (firstElement) {\n            touchedSources.add(firstElement)\n\n            // If the path has only one element (just the namespace),\n            // this is a namespace-only reference that should not be pushed down\n            // This applies to ANY function, not just existence-checking functions\n            if (expr.path.length === 1) {\n              hasNamespaceOnlyRef = true\n            }\n          }\n        }\n        break\n      case `func`:\n        // Recursively analyze function arguments (e.g., eq, gt, and, or)\n        if (expr.args) {\n          expr.args.forEach(collectSources)\n        }\n        break\n      case `val`:\n        // Values don't reference any sources\n        break\n      case `agg`:\n        // Aggregates can reference sources in their arguments\n        if (expr.args) {\n          expr.args.forEach(collectSources)\n        }\n        break\n    }\n  }\n\n  collectSources(clause)\n\n  return {\n    expression: clause,\n    touchedSources,\n    hasNamespaceOnlyRef,\n  }\n}\n\n/**\n * Step 3: Group WHERE clauses by the sources they touch.\n *\n * Single-source clauses can be pushed down to subqueries for optimization.\n * Multi-source clauses must remain in the main query to preserve join semantics.\n *\n * @param analyzedClauses - Array of analyzed WHERE clauses\n * @returns Grouped clauses ready for optimization\n */\nfunction groupWhereClauses(\n  analyzedClauses: Array<AnalyzedWhereClause>\n): GroupedWhereClauses {\n  const singleSource = new Map<string, Array<BasicExpression<boolean>>>()\n  const multiSource: Array<BasicExpression<boolean>> = []\n\n  // Categorize each clause based on how many sources it touches\n  for (const clause of analyzedClauses) {\n    if (clause.touchedSources.size === 1 && !clause.hasNamespaceOnlyRef) {\n      // Single source clause without namespace-only references - can be optimized\n      const source = Array.from(clause.touchedSources)[0]!\n      if (!singleSource.has(source)) {\n        singleSource.set(source, [])\n      }\n      singleSource.get(source)!.push(clause.expression)\n    } else if (clause.touchedSources.size > 1 || clause.hasNamespaceOnlyRef) {\n      // Multi-source clause or namespace-only reference - must stay in main query\n      multiSource.push(clause.expression)\n    }\n    // Skip clauses that touch no sources (constants) - they don't need optimization\n  }\n\n  // Combine multiple clauses for each source with AND\n  const combinedSingleSource = new Map<string, BasicExpression<boolean>>()\n  for (const [source, clauses] of singleSource) {\n    combinedSingleSource.set(source, combineWithAnd(clauses))\n  }\n\n  // Combine multi-source clauses with AND\n  const combinedMultiSource =\n    multiSource.length > 0 ? combineWithAnd(multiSource) : undefined\n\n  return {\n    singleSource: combinedSingleSource,\n    multiSource: combinedMultiSource,\n  }\n}\n\n/**\n * Step 4: Apply optimizations by lifting single-source clauses into subqueries.\n *\n * Creates a new QueryIR with single-source WHERE clauses moved to subqueries\n * that wrap the original table references. This ensures immutability and prevents\n * infinite recursion issues.\n *\n * @param query - Original QueryIR to optimize\n * @param groupedClauses - WHERE clauses grouped by optimization strategy\n * @returns New QueryIR with optimizations applied\n */\nfunction applyOptimizations(\n  query: QueryIR,\n  groupedClauses: GroupedWhereClauses\n): QueryIR {\n  // Track which single-source clauses were actually optimized\n  const actuallyOptimized = new Set<string>()\n\n  // Optimize the main FROM clause and track what was optimized\n  const optimizedFrom = optimizeFromWithTracking(\n    query.from,\n    groupedClauses.singleSource,\n    actuallyOptimized\n  )\n\n  // Optimize JOIN clauses and track what was optimized\n  const optimizedJoins = query.join\n    ? query.join.map((joinClause) => ({\n        ...joinClause,\n        from: optimizeFromWithTracking(\n          joinClause.from,\n          groupedClauses.singleSource,\n          actuallyOptimized\n        ),\n      }))\n    : undefined\n\n  // Build the remaining WHERE clauses: multi-source + residual single-source clauses\n  const remainingWhereClauses: Array<Where> = []\n\n  // Add multi-source clauses\n  if (groupedClauses.multiSource) {\n    remainingWhereClauses.push(groupedClauses.multiSource)\n  }\n\n  // Determine if we need residual clauses (when query has outer JOINs)\n  const hasOuterJoins =\n    query.join &&\n    query.join.some(\n      (join) =>\n        join.type === `left` || join.type === `right` || join.type === `full`\n    )\n\n  // Add single-source clauses\n  for (const [source, clause] of groupedClauses.singleSource) {\n    if (!actuallyOptimized.has(source)) {\n      // Wasn't optimized at all - keep as regular WHERE clause\n      remainingWhereClauses.push(clause)\n    } else if (hasOuterJoins) {\n      // Was optimized AND query has outer JOINs - keep as residual WHERE clause\n      remainingWhereClauses.push(createResidualWhere(clause))\n    }\n    // If optimized and no outer JOINs - don't keep (original behavior)\n  }\n\n  // Combine multiple remaining WHERE clauses into a single clause to avoid\n  // multiple filter operations in the pipeline (performance optimization)\n  // First flatten any nested AND expressions to avoid and(and(...), ...)\n  const finalWhere: Array<Where> =\n    remainingWhereClauses.length > 1\n      ? [\n          combineWithAnd(\n            remainingWhereClauses.flatMap((clause) =>\n              splitAndClausesRecursive(getWhereExpression(clause))\n            )\n          ),\n        ]\n      : remainingWhereClauses\n\n  // Create a completely new query object to ensure immutability\n  const optimizedQuery: QueryIR = {\n    // Copy all non-optimized fields as-is\n    select: query.select,\n    groupBy: query.groupBy ? [...query.groupBy] : undefined,\n    having: query.having ? [...query.having] : undefined,\n    orderBy: query.orderBy ? [...query.orderBy] : undefined,\n    limit: query.limit,\n    offset: query.offset,\n    distinct: query.distinct,\n    fnSelect: query.fnSelect,\n    fnWhere: query.fnWhere ? [...query.fnWhere] : undefined,\n    fnHaving: query.fnHaving ? [...query.fnHaving] : undefined,\n\n    // Use the optimized FROM and JOIN clauses\n    from: optimizedFrom,\n    join: optimizedJoins,\n\n    // Include combined WHERE clauses\n    where: finalWhere.length > 0 ? finalWhere : [],\n  }\n\n  return optimizedQuery\n}\n\n/**\n * Helper function to create a deep copy of a QueryIR object for immutability.\n *\n * This ensures that all optimizations create new objects rather than modifying\n * existing ones, preventing infinite recursion and shared reference issues.\n *\n * @param query - QueryIR to deep copy\n * @returns New QueryIR object with all nested objects copied\n */\nfunction deepCopyQuery(query: QueryIR): QueryIR {\n  return {\n    // Recursively copy the FROM clause\n    from:\n      query.from.type === `collectionRef`\n        ? new CollectionRefClass(query.from.collection, query.from.alias)\n        : new QueryRefClass(deepCopyQuery(query.from.query), query.from.alias),\n\n    // Copy all other fields, creating new arrays where necessary\n    select: query.select,\n    join: query.join\n      ? query.join.map((joinClause) => ({\n          type: joinClause.type,\n          left: joinClause.left,\n          right: joinClause.right,\n          from:\n            joinClause.from.type === `collectionRef`\n              ? new CollectionRefClass(\n                  joinClause.from.collection,\n                  joinClause.from.alias\n                )\n              : new QueryRefClass(\n                  deepCopyQuery(joinClause.from.query),\n                  joinClause.from.alias\n                ),\n        }))\n      : undefined,\n    where: query.where ? [...query.where] : undefined,\n    groupBy: query.groupBy ? [...query.groupBy] : undefined,\n    having: query.having ? [...query.having] : undefined,\n    orderBy: query.orderBy ? [...query.orderBy] : undefined,\n    limit: query.limit,\n    offset: query.offset,\n    fnSelect: query.fnSelect,\n    fnWhere: query.fnWhere ? [...query.fnWhere] : undefined,\n    fnHaving: query.fnHaving ? [...query.fnHaving] : undefined,\n  }\n}\n\n/**\n * Helper function to optimize a FROM clause while tracking what was actually optimized.\n *\n * @param from - FROM clause to optimize\n * @param singleSourceClauses - Map of source aliases to their WHERE clauses\n * @param actuallyOptimized - Set to track which sources were actually optimized\n * @returns New FROM clause, potentially wrapped in a subquery\n */\nfunction optimizeFromWithTracking(\n  from: From,\n  singleSourceClauses: Map<string, BasicExpression<boolean>>,\n  actuallyOptimized: Set<string>\n): From {\n  const whereClause = singleSourceClauses.get(from.alias)\n\n  if (!whereClause) {\n    // No optimization needed, but return a copy to maintain immutability\n    if (from.type === `collectionRef`) {\n      return new CollectionRefClass(from.collection, from.alias)\n    }\n    // Must be queryRef due to type system\n    return new QueryRefClass(deepCopyQuery(from.query), from.alias)\n  }\n\n  if (from.type === `collectionRef`) {\n    // Create a new subquery with the WHERE clause for the collection\n    // This is always safe since we're creating a new subquery\n    const subQuery: QueryIR = {\n      from: new CollectionRefClass(from.collection, from.alias),\n      where: [whereClause],\n    }\n    actuallyOptimized.add(from.alias) // Mark as successfully optimized\n    return new QueryRefClass(subQuery, from.alias)\n  }\n\n  // SAFETY CHECK: Only check safety when pushing WHERE clauses into existing subqueries\n  // We need to be careful about pushing WHERE clauses into subqueries that already have\n  // aggregates, HAVING, or ORDER BY + LIMIT since that could change their semantics\n  if (!isSafeToPushIntoExistingSubquery(from.query, whereClause, from.alias)) {\n    // Return a copy without optimization to maintain immutability\n    // Do NOT mark as optimized since we didn't actually optimize it\n    return new QueryRefClass(deepCopyQuery(from.query), from.alias)\n  }\n\n  // Skip pushdown when a clause references a field that only exists via a renamed\n  // projection inside the subquery; leaving it outside preserves the alias mapping.\n  if (referencesAliasWithRemappedSelect(from.query, whereClause, from.alias)) {\n    return new QueryRefClass(deepCopyQuery(from.query), from.alias)\n  }\n\n  // Add the WHERE clause to the existing subquery\n  // Create a deep copy to ensure immutability\n  const existingWhere = from.query.where || []\n  const optimizedSubQuery: QueryIR = {\n    ...deepCopyQuery(from.query),\n    where: [...existingWhere, whereClause],\n  }\n  actuallyOptimized.add(from.alias) // Mark as successfully optimized\n  return new QueryRefClass(optimizedSubQuery, from.alias)\n}\n\nfunction unsafeSelect(\n  query: QueryIR,\n  whereClause: BasicExpression<boolean>,\n  outerAlias: string\n): boolean {\n  if (!query.select) return false\n\n  return (\n    selectHasAggregates(query.select) ||\n    whereReferencesComputedSelectFields(query.select, whereClause, outerAlias)\n  )\n}\n\nfunction unsafeGroupBy(query: QueryIR) {\n  return query.groupBy && query.groupBy.length > 0\n}\n\nfunction unsafeHaving(query: QueryIR) {\n  return query.having && query.having.length > 0\n}\n\nfunction unsafeOrderBy(query: QueryIR) {\n  return (\n    query.orderBy &&\n    query.orderBy.length > 0 &&\n    (query.limit !== undefined || query.offset !== undefined)\n  )\n}\n\nfunction unsafeFnSelect(query: QueryIR) {\n  return (\n    query.fnSelect ||\n    (query.fnWhere && query.fnWhere.length > 0) ||\n    (query.fnHaving && query.fnHaving.length > 0)\n  )\n}\n\nfunction isSafeToPushIntoExistingSubquery(\n  query: QueryIR,\n  whereClause: BasicExpression<boolean>,\n  outerAlias: string\n): boolean {\n  return !(\n    unsafeSelect(query, whereClause, outerAlias) ||\n    unsafeGroupBy(query) ||\n    unsafeHaving(query) ||\n    unsafeOrderBy(query) ||\n    unsafeFnSelect(query)\n  )\n}\n\n/**\n * Detects whether a SELECT projection contains any aggregate expressions.\n * Recursively traverses nested select objects.\n *\n * @param select - The SELECT object from the IR\n * @returns True if any field is an aggregate, false otherwise\n */\nfunction selectHasAggregates(select: Select): boolean {\n  for (const value of Object.values(select)) {\n    if (typeof value === `object`) {\n      const v: any = value\n      if (v.type === `agg`) return true\n      if (!(`type` in v)) {\n        if (selectHasAggregates(v as unknown as Select)) return true\n      }\n    }\n  }\n  return false\n}\n\n/**\n * Recursively collects all PropRef references from an expression.\n *\n * @param expr - The expression to traverse\n * @returns Array of PropRef references found in the expression\n */\nfunction collectRefs(expr: any): Array<PropRef> {\n  const refs: Array<PropRef> = []\n\n  if (expr == null || typeof expr !== `object`) return refs\n\n  switch (expr.type) {\n    case `ref`:\n      refs.push(expr as PropRef)\n      break\n    case `func`:\n    case `agg`:\n      for (const arg of expr.args ?? []) {\n        refs.push(...collectRefs(arg))\n      }\n      break\n    default:\n      break\n  }\n\n  return refs\n}\n\n/**\n * Determines whether the provided WHERE clause references fields that are\n * computed by a subquery SELECT rather than pass-through properties.\n *\n * If true, pushing the WHERE clause into the subquery could change semantics\n * (since computed fields do not necessarily exist at the subquery input level),\n * so predicate pushdown must be avoided.\n *\n * @param select - The subquery SELECT map\n * @param whereClause - The WHERE expression to analyze\n * @param outerAlias - The alias of the subquery in the outer query\n * @returns True if WHERE references computed fields, otherwise false\n */\nfunction whereReferencesComputedSelectFields(\n  select: Select,\n  whereClause: BasicExpression<boolean>,\n  outerAlias: string\n): boolean {\n  // Build a set of computed field names at the top-level of the subquery output\n  const computed = new Set<string>()\n  for (const [key, value] of Object.entries(select)) {\n    if (key.startsWith(`__SPREAD_SENTINEL__`)) continue\n    if (value instanceof PropRef) continue\n    // Nested object or non-PropRef expression counts as computed\n    computed.add(key)\n  }\n\n  const refs = collectRefs(whereClause)\n\n  for (const ref of refs) {\n    const path = (ref as any).path as Array<string>\n    if (!Array.isArray(path) || path.length < 2) continue\n    const alias = path[0]\n    const field = path[1] as string\n    if (alias !== outerAlias) continue\n    if (computed.has(field)) return true\n  }\n  return false\n}\n\n/**\n * Detects whether a WHERE clause references the subquery alias through fields that\n * are re-exposed under different names (renamed SELECT projections or fnSelect output).\n * In those cases we keep the clause at the outer level to avoid alias remapping bugs.\n * TODO: in future we should handle this by rewriting the clause to use the subquery's\n * internal field references, but it likely needs a wider refactor to do cleanly.\n */\nfunction referencesAliasWithRemappedSelect(\n  subquery: QueryIR,\n  whereClause: BasicExpression<boolean>,\n  outerAlias: string\n): boolean {\n  const refs = collectRefs(whereClause)\n  // Only care about clauses that actually reference the outer alias.\n  if (refs.every((ref) => ref.path[0] !== outerAlias)) {\n    return false\n  }\n\n  // fnSelect always rewrites the row shape, so alias-safe pushdown is impossible.\n  if (subquery.fnSelect) {\n    return true\n  }\n\n  const select = subquery.select\n  // Without an explicit SELECT the clause still refers to the original collection.\n  if (!select) {\n    return false\n  }\n\n  for (const ref of refs) {\n    const path = ref.path\n    // Need at least alias + field to matter.\n    if (path.length < 2) continue\n    if (path[0] !== outerAlias) continue\n\n    const projected = select[path[1]!]\n    // Unselected fields can't be remapped, so skip - only care about fields in the SELECT.\n    if (!projected) continue\n\n    // Non-PropRef projections are computed values; cannot push down.\n    if (!(projected instanceof PropRef)) {\n      return true\n    }\n\n    // If the projection is just the alias (whole row) without a specific field,\n    // we can't verify whether the field we're referencing is being preserved or remapped.\n    if (projected.path.length < 2) {\n      return true\n    }\n\n    const [innerAlias, innerField] = projected.path\n\n    // Safe only when the projection points straight back to the same alias or the\n    // underlying source alias and preserves the field name.\n    if (innerAlias !== outerAlias && innerAlias !== subquery.from.alias) {\n      return true\n    }\n\n    if (innerField !== path[1]) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Helper function to combine multiple expressions with AND.\n *\n * If there's only one expression, it's returned as-is.\n * If there are multiple expressions, they're combined with an AND function.\n *\n * @param expressions - Array of expressions to combine\n * @returns Single expression representing the AND combination\n * @throws Error if the expressions array is empty\n */\nfunction combineWithAnd(\n  expressions: Array<BasicExpression<boolean>>\n): BasicExpression<boolean> {\n  if (expressions.length === 0) {\n    throw new CannotCombineEmptyExpressionListError()\n  }\n\n  if (expressions.length === 1) {\n    return expressions[0]!\n  }\n\n  // Create an AND function with all expressions as arguments\n  return new Func(`and`, expressions)\n}\n", "import { filter, join as joinOperator, map, tap } from \"@tanstack/db-ivm\"\nimport {\n  CollectionInputNotFoundError,\n  InvalidJoinCondition,\n  InvalidJoinConditionLeftSourceError,\n  InvalidJoinConditionRightSourceError,\n  InvalidJoinConditionSameSourceError,\n  InvalidJoinConditionSourceMismatchError,\n  JoinCollectionNotFoundError,\n  SubscriptionNotFoundError,\n  UnsupportedJoinSourceTypeError,\n  UnsupportedJoinTypeError,\n} from \"../../errors.js\"\nimport { ensureIndexForField } from \"../../indexes/auto-index.js\"\nimport { PropRef, followRef } from \"../ir.js\"\nimport { inArray } from \"../builder/functions.js\"\nimport { compileExpression } from \"./evaluators.js\"\nimport type { CompileQueryFn } from \"./index.js\"\nimport type { OrderByOptimizationInfo } from \"./order-by.js\"\nimport type {\n  BasicExpression,\n  CollectionRef,\n  JoinClause,\n  QueryIR,\n  QueryRef,\n} from \"../ir.js\"\nimport type { IStreamBuilder, JoinType } from \"@tanstack/db-ivm\"\nimport type { Collection } from \"../../collection/index.js\"\nimport type {\n  KeyedStream,\n  NamespacedAndKeyedStream,\n  NamespacedRow,\n} from \"../../types.js\"\nimport type { QueryCache, QueryMapping, WindowOptions } from \"./types.js\"\nimport type { CollectionSubscription } from \"../../collection/subscription.js\"\n\n/** Function type for loading specific keys into a lazy collection */\nexport type LoadKeysFn = (key: Set<string | number>) => void\n\n/** Callbacks for managing lazy-loaded collections in optimized joins */\nexport type LazyCollectionCallbacks = {\n  loadKeys: LoadKeysFn\n  loadInitialState: () => void\n}\n\n/**\n * Processes all join clauses, applying lazy loading optimizations and maintaining\n * alias tracking for per-alias subscriptions (enables self-joins).\n */\nexport function processJoins(\n  pipeline: NamespacedAndKeyedStream,\n  joinClauses: Array<JoinClause>,\n  sources: Record<string, KeyedStream>,\n  mainCollectionId: string,\n  mainSource: string,\n  allInputs: Record<string, KeyedStream>,\n  cache: QueryCache,\n  queryMapping: QueryMapping,\n  collections: Record<string, Collection>,\n  subscriptions: Record<string, CollectionSubscription>,\n  callbacks: Record<string, LazyCollectionCallbacks>,\n  lazySources: Set<string>,\n  optimizableOrderByCollections: Record<string, OrderByOptimizationInfo>,\n  setWindowFn: (windowFn: (options: WindowOptions) => void) => void,\n  rawQuery: QueryIR,\n  onCompileSubquery: CompileQueryFn,\n  aliasToCollectionId: Record<string, string>,\n  aliasRemapping: Record<string, string>\n): NamespacedAndKeyedStream {\n  let resultPipeline = pipeline\n\n  for (const joinClause of joinClauses) {\n    resultPipeline = processJoin(\n      resultPipeline,\n      joinClause,\n      sources,\n      mainCollectionId,\n      mainSource,\n      allInputs,\n      cache,\n      queryMapping,\n      collections,\n      subscriptions,\n      callbacks,\n      lazySources,\n      optimizableOrderByCollections,\n      setWindowFn,\n      rawQuery,\n      onCompileSubquery,\n      aliasToCollectionId,\n      aliasRemapping\n    )\n  }\n\n  return resultPipeline\n}\n\n/**\n * Processes a single join clause with lazy loading optimization.\n * For LEFT/RIGHT/INNER joins, marks one side as \"lazy\" (loads on-demand based on join keys).\n */\nfunction processJoin(\n  pipeline: NamespacedAndKeyedStream,\n  joinClause: JoinClause,\n  sources: Record<string, KeyedStream>,\n  mainCollectionId: string,\n  mainSource: string,\n  allInputs: Record<string, KeyedStream>,\n  cache: QueryCache,\n  queryMapping: QueryMapping,\n  collections: Record<string, Collection>,\n  subscriptions: Record<string, CollectionSubscription>,\n  callbacks: Record<string, LazyCollectionCallbacks>,\n  lazySources: Set<string>,\n  optimizableOrderByCollections: Record<string, OrderByOptimizationInfo>,\n  setWindowFn: (windowFn: (options: WindowOptions) => void) => void,\n  rawQuery: QueryIR,\n  onCompileSubquery: CompileQueryFn,\n  aliasToCollectionId: Record<string, string>,\n  aliasRemapping: Record<string, string>\n): NamespacedAndKeyedStream {\n  const isCollectionRef = joinClause.from.type === `collectionRef`\n\n  // Get the joined source alias and input stream\n  const {\n    alias: joinedSource,\n    input: joinedInput,\n    collectionId: joinedCollectionId,\n  } = processJoinSource(\n    joinClause.from,\n    allInputs,\n    collections,\n    subscriptions,\n    callbacks,\n    lazySources,\n    optimizableOrderByCollections,\n    setWindowFn,\n    cache,\n    queryMapping,\n    onCompileSubquery,\n    aliasToCollectionId,\n    aliasRemapping\n  )\n\n  // Add the joined source to the sources map\n  sources[joinedSource] = joinedInput\n  if (isCollectionRef) {\n    // Only direct collection references form new alias bindings. Subquery\n    // aliases reuse the mapping returned from the recursive compilation above.\n    aliasToCollectionId[joinedSource] = joinedCollectionId\n  }\n\n  const mainCollection = collections[mainCollectionId]\n  const joinedCollection = collections[joinedCollectionId]\n\n  if (!mainCollection) {\n    throw new JoinCollectionNotFoundError(mainCollectionId)\n  }\n\n  if (!joinedCollection) {\n    throw new JoinCollectionNotFoundError(joinedCollectionId)\n  }\n\n  const { activeSource, lazySource } = getActiveAndLazySources(\n    joinClause.type,\n    mainCollection,\n    joinedCollection\n  )\n\n  // Analyze which source each expression refers to and swap if necessary\n  const availableSources = Object.keys(sources)\n  const { mainExpr, joinedExpr } = analyzeJoinExpressions(\n    joinClause.left,\n    joinClause.right,\n    availableSources,\n    joinedSource\n  )\n\n  // Pre-compile the join expressions\n  const compiledMainExpr = compileExpression(mainExpr)\n  const compiledJoinedExpr = compileExpression(joinedExpr)\n\n  // Prepare the main pipeline for joining\n  let mainPipeline = pipeline.pipe(\n    map(([currentKey, namespacedRow]) => {\n      // Extract the join key from the main source expression\n      const mainKey = compiledMainExpr(namespacedRow)\n\n      // Return [joinKey, [originalKey, namespacedRow]]\n      return [mainKey, [currentKey, namespacedRow]] as [\n        unknown,\n        [string, typeof namespacedRow],\n      ]\n    })\n  )\n\n  // Prepare the joined pipeline\n  let joinedPipeline = joinedInput.pipe(\n    map(([currentKey, row]) => {\n      // Wrap the row in a namespaced structure\n      const namespacedRow: NamespacedRow = { [joinedSource]: row }\n\n      // Extract the join key from the joined source expression\n      const joinedKey = compiledJoinedExpr(namespacedRow)\n\n      // Return [joinKey, [originalKey, namespacedRow]]\n      return [joinedKey, [currentKey, namespacedRow]] as [\n        unknown,\n        [string, typeof namespacedRow],\n      ]\n    })\n  )\n\n  // Apply the join operation\n  if (![`inner`, `left`, `right`, `full`].includes(joinClause.type)) {\n    throw new UnsupportedJoinTypeError(joinClause.type)\n  }\n\n  if (activeSource) {\n    // If the lazy collection comes from a subquery that has a limit and/or an offset clause\n    // then we need to deoptimize the join because we don't know which rows are in the result set\n    // since we simply lookup matching keys in the index but the index contains all rows\n    // (not just the ones that pass the limit and offset clauses)\n    const lazyFrom = activeSource === `main` ? joinClause.from : rawQuery.from\n    const limitedSubquery =\n      lazyFrom.type === `queryRef` &&\n      (lazyFrom.query.limit || lazyFrom.query.offset)\n\n    // If join expressions contain computed values (like concat functions)\n    // we don't optimize the join because we don't have an index over the computed values\n    const hasComputedJoinExpr =\n      mainExpr.type === `func` || joinedExpr.type === `func`\n\n    if (!limitedSubquery && !hasComputedJoinExpr) {\n      // This join can be optimized by having the active collection\n      // dynamically load keys into the lazy collection\n      // based on the value of the joinKey and by looking up\n      // matching rows in the index of the lazy collection\n\n      // Mark the lazy source alias as lazy\n      // this Set is passed by the liveQueryCollection to the compiler\n      // such that the liveQueryCollection can check it after compilation\n      // to know which source aliases should load data lazily (not initially)\n      const lazyAlias = activeSource === `main` ? joinedSource : mainSource\n      lazySources.add(lazyAlias)\n\n      const activePipeline =\n        activeSource === `main` ? mainPipeline : joinedPipeline\n\n      const lazySourceJoinExpr =\n        activeSource === `main`\n          ? (joinedExpr as PropRef)\n          : (mainExpr as PropRef)\n\n      const followRefResult = followRef(\n        rawQuery,\n        lazySourceJoinExpr,\n        lazySource\n      )!\n      const followRefCollection = followRefResult.collection\n\n      const fieldName = followRefResult.path[0]\n      if (fieldName) {\n        ensureIndexForField(\n          fieldName,\n          followRefResult.path,\n          followRefCollection\n        )\n      }\n\n      // Set up lazy loading: intercept active side's stream and dynamically load\n      // matching rows from lazy side based on join keys.\n      const activePipelineWithLoading: IStreamBuilder<\n        [key: unknown, [originalKey: string, namespacedRow: NamespacedRow]]\n      > = activePipeline.pipe(\n        tap((data) => {\n          // Find the subscription for lazy loading.\n          // Subscriptions are keyed by the innermost alias (where the collection subscription\n          // was actually created). For subqueries, the join alias may differ from the inner alias.\n          // aliasRemapping provides a flattened one-hop lookup from outer â†’ innermost alias.\n          // Example: .join({ activeUser: subquery }) where subquery uses .from({ user: collection })\n          // â†’ aliasRemapping['activeUser'] = 'user' (always maps directly to innermost, never recursive)\n          const resolvedAlias = aliasRemapping[lazyAlias] || lazyAlias\n          const lazySourceSubscription = subscriptions[resolvedAlias]\n\n          if (!lazySourceSubscription) {\n            throw new SubscriptionNotFoundError(\n              resolvedAlias,\n              lazyAlias,\n              lazySource.id,\n              Object.keys(subscriptions)\n            )\n          }\n\n          if (lazySourceSubscription.hasLoadedInitialState()) {\n            // Entire state was already loaded because we deoptimized the join\n            return\n          }\n\n          // Request filtered snapshot from lazy collection for matching join keys\n          const joinKeys = data.getInner().map(([[joinKey]]) => joinKey)\n          const lazyJoinRef = new PropRef(followRefResult.path)\n          const loaded = lazySourceSubscription.requestSnapshot({\n            where: inArray(lazyJoinRef, joinKeys),\n            optimizedOnly: true,\n          })\n\n          if (!loaded) {\n            // Snapshot wasn't sent because it could not be loaded from the indexes\n            lazySourceSubscription.requestSnapshot()\n          }\n        })\n      )\n\n      if (activeSource === `main`) {\n        mainPipeline = activePipelineWithLoading\n      } else {\n        joinedPipeline = activePipelineWithLoading\n      }\n    }\n  }\n\n  return mainPipeline.pipe(\n    joinOperator(joinedPipeline, joinClause.type as JoinType),\n    processJoinResults(joinClause.type)\n  )\n}\n\n/**\n * Analyzes join expressions to determine which refers to which source\n * and returns them in the correct order (available source expression first, joined source expression second)\n */\nfunction analyzeJoinExpressions(\n  left: BasicExpression,\n  right: BasicExpression,\n  allAvailableSourceAliases: Array<string>,\n  joinedSource: string\n): { mainExpr: BasicExpression; joinedExpr: BasicExpression } {\n  // Filter out the joined source alias from the available source aliases\n  const availableSources = allAvailableSourceAliases.filter(\n    (alias) => alias !== joinedSource\n  )\n\n  const leftSourceAlias = getSourceAliasFromExpression(left)\n  const rightSourceAlias = getSourceAliasFromExpression(right)\n\n  // If left expression refers to an available source and right refers to joined source, keep as is\n  if (\n    leftSourceAlias &&\n    availableSources.includes(leftSourceAlias) &&\n    rightSourceAlias === joinedSource\n  ) {\n    return { mainExpr: left, joinedExpr: right }\n  }\n\n  // If left expression refers to joined source and right refers to an available source, swap them\n  if (\n    leftSourceAlias === joinedSource &&\n    rightSourceAlias &&\n    availableSources.includes(rightSourceAlias)\n  ) {\n    return { mainExpr: right, joinedExpr: left }\n  }\n\n  // If one expression doesn't refer to any source, this is an invalid join\n  if (!leftSourceAlias || !rightSourceAlias) {\n    throw new InvalidJoinConditionSourceMismatchError()\n  }\n\n  // If both expressions refer to the same alias, this is an invalid join\n  if (leftSourceAlias === rightSourceAlias) {\n    throw new InvalidJoinConditionSameSourceError(leftSourceAlias)\n  }\n\n  // Left side must refer to an available source\n  // This cannot happen with the query builder as there is no way to build a ref\n  // to an unavailable source, but just in case, but could happen with the IR\n  if (!availableSources.includes(leftSourceAlias)) {\n    throw new InvalidJoinConditionLeftSourceError(leftSourceAlias)\n  }\n\n  // Right side must refer to the joined source\n  if (rightSourceAlias !== joinedSource) {\n    throw new InvalidJoinConditionRightSourceError(joinedSource)\n  }\n\n  // This should not be reachable given the logic above, but just in case\n  throw new InvalidJoinCondition()\n}\n\n/**\n * Extracts the source alias from a join expression\n */\nfunction getSourceAliasFromExpression(expr: BasicExpression): string | null {\n  switch (expr.type) {\n    case `ref`:\n      // PropRef path has the source alias as the first element\n      return expr.path[0] || null\n    case `func`: {\n      // For function expressions, we need to check if all arguments refer to the same source\n      const sourceAliases = new Set<string>()\n      for (const arg of expr.args) {\n        const alias = getSourceAliasFromExpression(arg)\n        if (alias) {\n          sourceAliases.add(alias)\n        }\n      }\n      // If all arguments refer to the same source, return that source alias\n      return sourceAliases.size === 1 ? Array.from(sourceAliases)[0]! : null\n    }\n    default:\n      // Values (type='val') don't reference any source\n      return null\n  }\n}\n\n/**\n * Processes the join source (collection or sub-query)\n */\nfunction processJoinSource(\n  from: CollectionRef | QueryRef,\n  allInputs: Record<string, KeyedStream>,\n  collections: Record<string, Collection>,\n  subscriptions: Record<string, CollectionSubscription>,\n  callbacks: Record<string, LazyCollectionCallbacks>,\n  lazySources: Set<string>,\n  optimizableOrderByCollections: Record<string, OrderByOptimizationInfo>,\n  setWindowFn: (windowFn: (options: WindowOptions) => void) => void,\n  cache: QueryCache,\n  queryMapping: QueryMapping,\n  onCompileSubquery: CompileQueryFn,\n  aliasToCollectionId: Record<string, string>,\n  aliasRemapping: Record<string, string>\n): { alias: string; input: KeyedStream; collectionId: string } {\n  switch (from.type) {\n    case `collectionRef`: {\n      const input = allInputs[from.alias]\n      if (!input) {\n        throw new CollectionInputNotFoundError(\n          from.alias,\n          from.collection.id,\n          Object.keys(allInputs)\n        )\n      }\n      aliasToCollectionId[from.alias] = from.collection.id\n      return { alias: from.alias, input, collectionId: from.collection.id }\n    }\n    case `queryRef`: {\n      // Find the original query for caching purposes\n      const originalQuery = queryMapping.get(from.query) || from.query\n\n      // Recursively compile the sub-query with cache\n      const subQueryResult = onCompileSubquery(\n        originalQuery,\n        allInputs,\n        collections,\n        subscriptions,\n        callbacks,\n        lazySources,\n        optimizableOrderByCollections,\n        setWindowFn,\n        cache,\n        queryMapping\n      )\n\n      // Pull up alias mappings from subquery to parent scope.\n      // This includes both the innermost alias-to-collection mappings AND\n      // any existing remappings from nested subquery levels.\n      Object.assign(aliasToCollectionId, subQueryResult.aliasToCollectionId)\n      Object.assign(aliasRemapping, subQueryResult.aliasRemapping)\n\n      // Create a flattened remapping from outer alias to innermost alias.\n      // For nested subqueries, this ensures one-hop lookups (not recursive chains).\n      //\n      // Example with 3-level nesting:\n      //   Inner:  .from({ user: usersCollection })\n      //   Middle: .from({ activeUser: innerSubquery })     â†’ creates: activeUser â†’ user\n      //   Outer:  .join({ author: middleSubquery }, ...)   â†’ creates: author â†’ user (not author â†’ activeUser)\n      //\n      // We search through the PULLED-UP aliasToCollectionId (which contains the\n      // innermost 'user' alias), so we always map directly to the deepest level.\n      // This means aliasRemapping[lazyAlias] is always a single lookup, never recursive.\n      const innerAlias = Object.keys(subQueryResult.aliasToCollectionId).find(\n        (alias) =>\n          subQueryResult.aliasToCollectionId[alias] ===\n          subQueryResult.collectionId\n      )\n      if (innerAlias && innerAlias !== from.alias) {\n        aliasRemapping[from.alias] = innerAlias\n      }\n\n      // Extract the pipeline from the compilation result\n      const subQueryInput = subQueryResult.pipeline\n\n      // Subqueries may return [key, [value, orderByIndex]] (with ORDER BY) or [key, value] (without ORDER BY)\n      // We need to extract just the value for use in parent queries\n      const extractedInput = subQueryInput.pipe(\n        map((data: any) => {\n          const [key, [value, _orderByIndex]] = data\n          return [key, value] as [unknown, any]\n        })\n      )\n\n      return {\n        alias: from.alias,\n        input: extractedInput as KeyedStream,\n        collectionId: subQueryResult.collectionId,\n      }\n    }\n    default:\n      throw new UnsupportedJoinSourceTypeError((from as any).type)\n  }\n}\n\n/**\n * Processes the results of a join operation\n */\nfunction processJoinResults(joinType: string) {\n  return function (\n    pipeline: IStreamBuilder<\n      [\n        key: string,\n        [\n          [string, NamespacedRow] | undefined,\n          [string, NamespacedRow] | undefined,\n        ],\n      ]\n    >\n  ): NamespacedAndKeyedStream {\n    return pipeline.pipe(\n      // Process the join result and handle nulls\n      filter((result) => {\n        const [_key, [main, joined]] = result\n        const mainNamespacedRow = main?.[1]\n        const joinedNamespacedRow = joined?.[1]\n\n        // Handle different join types\n        if (joinType === `inner`) {\n          return !!(mainNamespacedRow && joinedNamespacedRow)\n        }\n\n        if (joinType === `left`) {\n          return !!mainNamespacedRow\n        }\n\n        if (joinType === `right`) {\n          return !!joinedNamespacedRow\n        }\n\n        // For full joins, always include\n        return true\n      }),\n      map((result) => {\n        const [_key, [main, joined]] = result\n        const mainKey = main?.[0]\n        const mainNamespacedRow = main?.[1]\n        const joinedKey = joined?.[0]\n        const joinedNamespacedRow = joined?.[1]\n\n        // Merge the namespaced rows\n        const mergedNamespacedRow: NamespacedRow = {}\n\n        // Add main row data if it exists\n        if (mainNamespacedRow) {\n          Object.assign(mergedNamespacedRow, mainNamespacedRow)\n        }\n\n        // Add joined row data if it exists\n        if (joinedNamespacedRow) {\n          Object.assign(mergedNamespacedRow, joinedNamespacedRow)\n        }\n\n        // We create a composite key that combines the main and joined keys\n        const resultKey = `[${mainKey},${joinedKey}]`\n\n        return [resultKey, mergedNamespacedRow] as [string, NamespacedRow]\n      })\n    )\n  }\n}\n\n/**\n * Returns the active and lazy collections for a join clause.\n * The active collection is the one that we need to fully iterate over\n * and it can be the main source (i.e. left collection) or the joined source (i.e. right collection).\n * The lazy collection is the one that we should join-in lazily based on matches in the active collection.\n * @param joinClause - The join clause to analyze\n * @param leftCollection - The left collection\n * @param rightCollection - The right collection\n * @returns The active and lazy collections. They are undefined if we need to loop over both collections (i.e. both are active)\n */\nfunction getActiveAndLazySources(\n  joinType: JoinClause[`type`],\n  leftCollection: Collection,\n  rightCollection: Collection\n):\n  | { activeSource: `main` | `joined`; lazySource: Collection }\n  | { activeSource: undefined; lazySource: undefined } {\n  // Self-joins can now be optimized since we track lazy loading by source alias\n  // rather than collection ID. Each alias has its own subscription and lazy state.\n\n  switch (joinType) {\n    case `left`:\n      return { activeSource: `main`, lazySource: rightCollection }\n    case `right`:\n      return { activeSource: `joined`, lazySource: leftCollection }\n    case `inner`:\n      // The smallest collection should be the active collection\n      // and the biggest collection should be lazy\n      return leftCollection.size < rightCollection.size\n        ? { activeSource: `main`, lazySource: rightCollection }\n        : { activeSource: `joined`, lazySource: leftCollection }\n    default:\n      return { activeSource: undefined, lazySource: undefined }\n  }\n}\n", "import { map } from \"@tanstack/db-ivm\"\nimport { PropRef, Value as ValClass, isExpressionLike } from \"../ir.js\"\nimport { AggregateNotSupportedError } from \"../../errors.js\"\nimport { compileExpression } from \"./evaluators.js\"\nimport type { Aggregate, BasicExpression, Select } from \"../ir.js\"\nimport type {\n  KeyedStream,\n  NamespacedAndKeyedStream,\n  NamespacedRow,\n} from \"../../types.js\"\n\n/**\n * Type for operations array used in select processing\n */\ntype SelectOp =\n  | {\n      kind: `merge`\n      targetPath: Array<string>\n      source: (row: NamespacedRow) => any\n    }\n  | { kind: `field`; alias: string; compiled: (row: NamespacedRow) => any }\n\n/**\n * Unwraps any Value expressions\n */\nfunction unwrapVal(input: any): any {\n  if (input instanceof ValClass) return input.value\n  return input\n}\n\n/**\n * Processes a merge operation by merging source values into the target path\n */\nfunction processMerge(\n  op: Extract<SelectOp, { kind: `merge` }>,\n  namespacedRow: NamespacedRow,\n  selectResults: Record<string, any>\n): void {\n  const value = op.source(namespacedRow)\n  if (value && typeof value === `object`) {\n    // Ensure target object exists\n    let cursor: any = selectResults\n    const path = op.targetPath\n    if (path.length === 0) {\n      // Top-level merge\n      for (const [k, v] of Object.entries(value)) {\n        selectResults[k] = unwrapVal(v)\n      }\n    } else {\n      for (let i = 0; i < path.length; i++) {\n        const seg = path[i]!\n        if (i === path.length - 1) {\n          const dest = (cursor[seg] ??= {})\n          if (typeof dest === `object`) {\n            for (const [k, v] of Object.entries(value)) {\n              dest[k] = unwrapVal(v)\n            }\n          }\n        } else {\n          const next = cursor[seg]\n          if (next == null || typeof next !== `object`) {\n            cursor[seg] = {}\n          }\n          cursor = cursor[seg]\n        }\n      }\n    }\n  }\n}\n\n/**\n * Processes a non-merge operation by setting the field value at the specified alias path\n */\nfunction processNonMergeOp(\n  op: Extract<SelectOp, { kind: `field` }>,\n  namespacedRow: NamespacedRow,\n  selectResults: Record<string, any>\n): void {\n  // Support nested alias paths like \"meta.author.name\"\n  const path = op.alias.split(`.`)\n  if (path.length === 1) {\n    selectResults[op.alias] = op.compiled(namespacedRow)\n  } else {\n    let cursor: any = selectResults\n    for (let i = 0; i < path.length - 1; i++) {\n      const seg = path[i]!\n      const next = cursor[seg]\n      if (next == null || typeof next !== `object`) {\n        cursor[seg] = {}\n      }\n      cursor = cursor[seg]\n    }\n    cursor[path[path.length - 1]!] = unwrapVal(op.compiled(namespacedRow))\n  }\n}\n\n/**\n * Processes a single row to generate select results\n */\nfunction processRow(\n  [key, namespacedRow]: [unknown, NamespacedRow],\n  ops: Array<SelectOp>\n): [unknown, typeof namespacedRow & { __select_results: any }] {\n  const selectResults: Record<string, any> = {}\n\n  for (const op of ops) {\n    if (op.kind === `merge`) {\n      processMerge(op, namespacedRow, selectResults)\n    } else {\n      processNonMergeOp(op, namespacedRow, selectResults)\n    }\n  }\n\n  // Return the namespaced row with __select_results added\n  return [\n    key,\n    {\n      ...namespacedRow,\n      __select_results: selectResults,\n    },\n  ] as [\n    unknown,\n    typeof namespacedRow & { __select_results: typeof selectResults },\n  ]\n}\n\n/**\n * Processes the SELECT clause and places results in __select_results\n * while preserving the original namespaced row for ORDER BY access\n */\nexport function processSelect(\n  pipeline: NamespacedAndKeyedStream,\n  select: Select,\n  _allInputs: Record<string, KeyedStream>\n): NamespacedAndKeyedStream {\n  // Build ordered operations to preserve authoring order (spreads and fields)\n  const ops: Array<SelectOp> = []\n\n  addFromObject([], select, ops)\n\n  return pipeline.pipe(map((row) => processRow(row, ops)))\n}\n\n/**\n * Helper function to check if an expression is an aggregate\n */\nfunction isAggregateExpression(\n  expr: BasicExpression | Aggregate\n): expr is Aggregate {\n  return expr.type === `agg`\n}\n\n/**\n * Processes a single argument in a function context\n */\nexport function processArgument(\n  arg: BasicExpression | Aggregate,\n  namespacedRow: NamespacedRow\n): any {\n  if (isAggregateExpression(arg)) {\n    throw new AggregateNotSupportedError()\n  }\n\n  // Pre-compile the expression and evaluate immediately\n  const compiledExpression = compileExpression(arg)\n  const value = compiledExpression(namespacedRow)\n\n  return value\n}\n\n/**\n * Helper function to check if an object is a nested select object\n *\n * .select({\n *   id: users.id,\n *   profile: { // <-- this is a nested select object\n *     name: users.name,\n *     email: users.email\n *   }\n * })\n */\nfunction isNestedSelectObject(obj: any): boolean {\n  return obj && typeof obj === `object` && !isExpressionLike(obj)\n}\n\n/**\n * Helper function to process select objects and build operations array\n */\nfunction addFromObject(\n  prefixPath: Array<string>,\n  obj: any,\n  ops: Array<SelectOp>\n) {\n  for (const [key, value] of Object.entries(obj)) {\n    if (key.startsWith(`__SPREAD_SENTINEL__`)) {\n      const rest = key.slice(`__SPREAD_SENTINEL__`.length)\n      const splitIndex = rest.lastIndexOf(`__`)\n      const pathStr = splitIndex >= 0 ? rest.slice(0, splitIndex) : rest\n      const isRefExpr =\n        value &&\n        typeof value === `object` &&\n        `type` in (value as any) &&\n        (value as any).type === `ref`\n      if (pathStr.includes(`.`) || isRefExpr) {\n        // Merge into the current destination (prefixPath) from the referenced source path\n        const targetPath = [...prefixPath]\n        const expr = isRefExpr\n          ? (value as BasicExpression)\n          : (new PropRef(pathStr.split(`.`)) as BasicExpression)\n        const compiled = compileExpression(expr)\n        ops.push({ kind: `merge`, targetPath, source: compiled })\n      } else {\n        // Table-level: pathStr is the alias; merge from namespaced row at the current prefix\n        const tableAlias = pathStr\n        const targetPath = [...prefixPath]\n        ops.push({\n          kind: `merge`,\n          targetPath,\n          source: (row) => (row as any)[tableAlias],\n        })\n      }\n      continue\n    }\n\n    const expression = value as any\n    if (isNestedSelectObject(expression)) {\n      // Nested selection object\n      addFromObject([...prefixPath, key], expression, ops)\n      continue\n    }\n\n    if (isAggregateExpression(expression)) {\n      // Placeholder for group-by processing later\n      ops.push({\n        kind: `field`,\n        alias: [...prefixPath, key].join(`.`),\n        compiled: () => null,\n      })\n    } else {\n      if (expression === undefined || !isExpressionLike(expression)) {\n        ops.push({\n          kind: `field`,\n          alias: [...prefixPath, key].join(`.`),\n          compiled: () => expression,\n        })\n        continue\n      }\n      // If the expression is a Value wrapper, embed the literal to avoid re-compilation mishaps\n      if (expression instanceof ValClass) {\n        const val = expression.value\n        ops.push({\n          kind: `field`,\n          alias: [...prefixPath, key].join(`.`),\n          compiled: () => val,\n        })\n      } else {\n        ops.push({\n          kind: `field`,\n          alias: [...prefixPath, key].join(`.`),\n          compiled: compileExpression(expression as BasicExpression),\n        })\n      }\n    }\n  }\n}\n", "import { distinct, filter, map } from \"@tanstack/db-ivm\"\nimport { optimizeQuery } from \"../optimizer.js\"\nimport {\n  CollectionInputNotFoundError,\n  DistinctRequiresSelectError,\n  DuplicateAliasInSubqueryError,\n  HavingRequiresGroupByError,\n  LimitOffsetRequireOrderByError,\n  UnsupportedFromTypeError,\n} from \"../../errors.js\"\nimport { PropRef, Value as ValClass, getWhereExpression } from \"../ir.js\"\nimport { compileExpression, toBooleanPredicate } from \"./evaluators.js\"\nimport { processJoins } from \"./joins.js\"\nimport { processGroupBy } from \"./group-by.js\"\nimport { processOrderBy } from \"./order-by.js\"\nimport { processSelect } from \"./select.js\"\nimport type { CollectionSubscription } from \"../../collection/subscription.js\"\nimport type { OrderByOptimizationInfo } from \"./order-by.js\"\nimport type {\n  BasicExpression,\n  CollectionRef,\n  QueryIR,\n  QueryRef,\n} from \"../ir.js\"\nimport type { LazyCollectionCallbacks } from \"./joins.js\"\nimport type { Collection } from \"../../collection/index.js\"\nimport type {\n  KeyedStream,\n  NamespacedAndKeyedStream,\n  ResultStream,\n} from \"../../types.js\"\nimport type { QueryCache, QueryMapping, WindowOptions } from \"./types.js\"\n\nexport type { WindowOptions } from \"./types.js\"\n\n/**\n * Result of query compilation including both the pipeline and source-specific WHERE clauses\n */\nexport interface CompilationResult {\n  /** The ID of the main collection */\n  collectionId: string\n\n  /** The compiled query pipeline (D2 stream) */\n  pipeline: ResultStream\n\n  /** Map of source aliases to their WHERE clauses for index optimization */\n  sourceWhereClauses: Map<string, BasicExpression<boolean>>\n\n  /**\n   * Maps each source alias to its collection ID. Enables per-alias subscriptions for self-joins.\n   * Example: `{ employee: 'employees-col-id', manager: 'employees-col-id' }`\n   */\n  aliasToCollectionId: Record<string, string>\n\n  /**\n   * Flattened mapping from outer alias to innermost alias for subqueries.\n   * Always provides one-hop lookups, never recursive chains.\n   *\n   * Example: `{ activeUser: 'user' }` when `.from({ activeUser: subquery })`\n   * where the subquery uses `.from({ user: collection })`.\n   *\n   * For deeply nested subqueries, the mapping goes directly to the innermost alias:\n   * `{ author: 'user' }` (not `{ author: 'activeUser' }`), so `aliasRemapping[alias]`\n   * always resolves in a single lookup.\n   *\n   * Used to resolve subscriptions during lazy loading when join aliases differ from\n   * the inner aliases where collection subscriptions were created.\n   */\n  aliasRemapping: Record<string, string>\n}\n\n/**\n * Compiles a query IR into a D2 pipeline\n * @param rawQuery The query IR to compile\n * @param inputs Mapping of source aliases to input streams (e.g., `{ employee: input1, manager: input2 }`)\n * @param collections Mapping of collection IDs to Collection instances\n * @param subscriptions Mapping of source aliases to CollectionSubscription instances\n * @param callbacks Mapping of source aliases to lazy loading callbacks\n * @param lazySources Set of source aliases that should load data lazily\n * @param optimizableOrderByCollections Map of collection IDs to order-by optimization info\n * @param cache Optional cache for compiled subqueries (used internally for recursion)\n * @param queryMapping Optional mapping from optimized queries to original queries\n * @returns A CompilationResult with the pipeline, source WHERE clauses, and alias metadata\n */\nexport function compileQuery(\n  rawQuery: QueryIR,\n  inputs: Record<string, KeyedStream>,\n  collections: Record<string, Collection<any, any, any, any, any>>,\n  subscriptions: Record<string, CollectionSubscription>,\n  callbacks: Record<string, LazyCollectionCallbacks>,\n  lazySources: Set<string>,\n  optimizableOrderByCollections: Record<string, OrderByOptimizationInfo>,\n  setWindowFn: (windowFn: (options: WindowOptions) => void) => void,\n  cache: QueryCache = new WeakMap(),\n  queryMapping: QueryMapping = new WeakMap()\n): CompilationResult {\n  // Check if the original raw query has already been compiled\n  const cachedResult = cache.get(rawQuery)\n  if (cachedResult) {\n    return cachedResult\n  }\n\n  // Validate the raw query BEFORE optimization to check user's original structure.\n  // This must happen before optimization because the optimizer may create internal\n  // subqueries (e.g., for predicate pushdown) that reuse aliases, which is fine.\n  validateQueryStructure(rawQuery)\n\n  // Optimize the query before compilation\n  const { optimizedQuery: query, sourceWhereClauses } = optimizeQuery(rawQuery)\n\n  // Create mapping from optimized query to original for caching\n  queryMapping.set(query, rawQuery)\n  mapNestedQueries(query, rawQuery, queryMapping)\n\n  // Create a copy of the inputs map to avoid modifying the original\n  const allInputs = { ...inputs }\n\n  // Track alias to collection id relationships discovered during compilation.\n  // This includes all user-declared aliases plus inner aliases from subqueries.\n  const aliasToCollectionId: Record<string, string> = {}\n\n  // Track alias remapping for subqueries (outer alias â†’ inner alias)\n  // e.g., when .join({ activeUser: subquery }) where subquery uses .from({ user: collection })\n  // we store: aliasRemapping['activeUser'] = 'user'\n  const aliasRemapping: Record<string, string> = {}\n\n  // Create a map of source aliases to input streams.\n  // Inputs MUST be keyed by alias (e.g., `{ employee: input1, manager: input2 }`),\n  // not by collection ID. This enables per-alias subscriptions where different aliases\n  // of the same collection (e.g., self-joins) maintain independent filtered streams.\n  const sources: Record<string, KeyedStream> = {}\n\n  // Process the FROM clause to get the main source\n  const {\n    alias: mainSource,\n    input: mainInput,\n    collectionId: mainCollectionId,\n  } = processFrom(\n    query.from,\n    allInputs,\n    collections,\n    subscriptions,\n    callbacks,\n    lazySources,\n    optimizableOrderByCollections,\n    setWindowFn,\n    cache,\n    queryMapping,\n    aliasToCollectionId,\n    aliasRemapping\n  )\n  sources[mainSource] = mainInput\n\n  // Prepare the initial pipeline with the main source wrapped in its alias\n  let pipeline: NamespacedAndKeyedStream = mainInput.pipe(\n    map(([key, row]) => {\n      // Initialize the record with a nested structure\n      const ret = [key, { [mainSource]: row }] as [\n        string,\n        Record<string, typeof row>,\n      ]\n      return ret\n    })\n  )\n\n  // Process JOIN clauses if they exist\n  if (query.join && query.join.length > 0) {\n    pipeline = processJoins(\n      pipeline,\n      query.join,\n      sources,\n      mainCollectionId,\n      mainSource,\n      allInputs,\n      cache,\n      queryMapping,\n      collections,\n      subscriptions,\n      callbacks,\n      lazySources,\n      optimizableOrderByCollections,\n      setWindowFn,\n      rawQuery,\n      compileQuery,\n      aliasToCollectionId,\n      aliasRemapping\n    )\n  }\n\n  // Process the WHERE clause if it exists\n  if (query.where && query.where.length > 0) {\n    // Apply each WHERE condition as a filter (they are ANDed together)\n    for (const where of query.where) {\n      const whereExpression = getWhereExpression(where)\n      const compiledWhere = compileExpression(whereExpression)\n      pipeline = pipeline.pipe(\n        filter(([_key, namespacedRow]) => {\n          return toBooleanPredicate(compiledWhere(namespacedRow))\n        })\n      )\n    }\n  }\n\n  // Process functional WHERE clauses if they exist\n  if (query.fnWhere && query.fnWhere.length > 0) {\n    for (const fnWhere of query.fnWhere) {\n      pipeline = pipeline.pipe(\n        filter(([_key, namespacedRow]) => {\n          return toBooleanPredicate(fnWhere(namespacedRow))\n        })\n      )\n    }\n  }\n\n  if (query.distinct && !query.fnSelect && !query.select) {\n    throw new DistinctRequiresSelectError()\n  }\n\n  // Process the SELECT clause early - always create __select_results\n  // This eliminates duplication and allows for DISTINCT implementation\n  if (query.fnSelect) {\n    // Handle functional select - apply the function to transform the row\n    pipeline = pipeline.pipe(\n      map(([key, namespacedRow]) => {\n        const selectResults = query.fnSelect!(namespacedRow)\n        return [\n          key,\n          {\n            ...namespacedRow,\n            __select_results: selectResults,\n          },\n        ] as [string, typeof namespacedRow & { __select_results: any }]\n      })\n    )\n  } else if (query.select) {\n    pipeline = processSelect(pipeline, query.select, allInputs)\n  } else {\n    // If no SELECT clause, create __select_results with the main table data\n    pipeline = pipeline.pipe(\n      map(([key, namespacedRow]) => {\n        const selectResults =\n          !query.join && !query.groupBy\n            ? namespacedRow[mainSource]\n            : namespacedRow\n\n        return [\n          key,\n          {\n            ...namespacedRow,\n            __select_results: selectResults,\n          },\n        ] as [string, typeof namespacedRow & { __select_results: any }]\n      })\n    )\n  }\n\n  // Process the GROUP BY clause if it exists\n  if (query.groupBy && query.groupBy.length > 0) {\n    pipeline = processGroupBy(\n      pipeline,\n      query.groupBy,\n      query.having,\n      query.select,\n      query.fnHaving\n    )\n  } else if (query.select) {\n    // Check if SELECT contains aggregates but no GROUP BY (implicit single-group aggregation)\n    const hasAggregates = Object.values(query.select).some(\n      (expr) => expr.type === `agg`\n    )\n    if (hasAggregates) {\n      // Handle implicit single-group aggregation\n      pipeline = processGroupBy(\n        pipeline,\n        [], // Empty group by means single group\n        query.having,\n        query.select,\n        query.fnHaving\n      )\n    }\n  }\n\n  // Process the HAVING clause if it exists (only applies after GROUP BY)\n  if (query.having && (!query.groupBy || query.groupBy.length === 0)) {\n    // Check if we have aggregates in SELECT that would trigger implicit grouping\n    const hasAggregates = query.select\n      ? Object.values(query.select).some((expr) => expr.type === `agg`)\n      : false\n\n    if (!hasAggregates) {\n      throw new HavingRequiresGroupByError()\n    }\n  }\n\n  // Process functional HAVING clauses outside of GROUP BY (treat as additional WHERE filters)\n  if (\n    query.fnHaving &&\n    query.fnHaving.length > 0 &&\n    (!query.groupBy || query.groupBy.length === 0)\n  ) {\n    // If there's no GROUP BY but there are fnHaving clauses, apply them as filters\n    for (const fnHaving of query.fnHaving) {\n      pipeline = pipeline.pipe(\n        filter(([_key, namespacedRow]) => {\n          return fnHaving(namespacedRow)\n        })\n      )\n    }\n  }\n\n  // Process the DISTINCT clause if it exists\n  if (query.distinct) {\n    pipeline = pipeline.pipe(distinct(([_key, row]) => row.__select_results))\n  }\n\n  // Process orderBy parameter if it exists\n  if (query.orderBy && query.orderBy.length > 0) {\n    const orderedPipeline = processOrderBy(\n      rawQuery,\n      pipeline,\n      query.orderBy,\n      query.select || {},\n      collections[mainCollectionId]!,\n      optimizableOrderByCollections,\n      setWindowFn,\n      query.limit,\n      query.offset\n    )\n\n    // Final step: extract the __select_results and include orderBy index\n    const resultPipeline = orderedPipeline.pipe(\n      map(([key, [row, orderByIndex]]) => {\n        // Extract the final results from __select_results and include orderBy index\n        const raw = (row as any).__select_results\n        const finalResults = unwrapValue(raw)\n        return [key, [finalResults, orderByIndex]] as [unknown, [any, string]]\n      })\n    )\n\n    const result = resultPipeline\n    // Cache the result before returning (use original query as key)\n    const compilationResult = {\n      collectionId: mainCollectionId,\n      pipeline: result,\n      sourceWhereClauses,\n      aliasToCollectionId,\n      aliasRemapping,\n    }\n    cache.set(rawQuery, compilationResult)\n\n    return compilationResult\n  } else if (query.limit !== undefined || query.offset !== undefined) {\n    // If there's a limit or offset without orderBy, throw an error\n    throw new LimitOffsetRequireOrderByError()\n  }\n\n  // Final step: extract the __select_results and return tuple format (no orderBy)\n  const resultPipeline: ResultStream = pipeline.pipe(\n    map(([key, row]) => {\n      // Extract the final results from __select_results and return [key, [results, undefined]]\n      const raw = (row as any).__select_results\n      const finalResults = unwrapValue(raw)\n      return [key, [finalResults, undefined]] as [\n        unknown,\n        [any, string | undefined],\n      ]\n    })\n  )\n\n  const result = resultPipeline\n  // Cache the result before returning (use original query as key)\n  const compilationResult = {\n    collectionId: mainCollectionId,\n    pipeline: result,\n    sourceWhereClauses,\n    aliasToCollectionId,\n    aliasRemapping,\n  }\n  cache.set(rawQuery, compilationResult)\n\n  return compilationResult\n}\n\n/**\n * Collects aliases used for DIRECT collection references (not subqueries).\n * Used to validate that subqueries don't reuse parent query collection aliases.\n * Only direct CollectionRef aliases matter - QueryRef aliases don't cause conflicts.\n */\nfunction collectDirectCollectionAliases(query: QueryIR): Set<string> {\n  const aliases = new Set<string>()\n\n  // Collect FROM alias only if it's a direct collection reference\n  if (query.from.type === `collectionRef`) {\n    aliases.add(query.from.alias)\n  }\n\n  // Collect JOIN aliases only for direct collection references\n  if (query.join) {\n    for (const joinClause of query.join) {\n      if (joinClause.from.type === `collectionRef`) {\n        aliases.add(joinClause.from.alias)\n      }\n    }\n  }\n\n  return aliases\n}\n\n/**\n * Validates the structure of a query and its subqueries.\n * Checks that subqueries don't reuse collection aliases from parent queries.\n * This must be called on the RAW query before optimization.\n */\nfunction validateQueryStructure(\n  query: QueryIR,\n  parentCollectionAliases: Set<string> = new Set()\n): void {\n  // Collect direct collection aliases from this query level\n  const currentLevelAliases = collectDirectCollectionAliases(query)\n\n  // Check if any current alias conflicts with parent aliases\n  for (const alias of currentLevelAliases) {\n    if (parentCollectionAliases.has(alias)) {\n      throw new DuplicateAliasInSubqueryError(\n        alias,\n        Array.from(parentCollectionAliases)\n      )\n    }\n  }\n\n  // Combine parent and current aliases for checking nested subqueries\n  const combinedAliases = new Set([\n    ...parentCollectionAliases,\n    ...currentLevelAliases,\n  ])\n\n  // Recursively validate FROM subquery\n  if (query.from.type === `queryRef`) {\n    validateQueryStructure(query.from.query, combinedAliases)\n  }\n\n  // Recursively validate JOIN subqueries\n  if (query.join) {\n    for (const joinClause of query.join) {\n      if (joinClause.from.type === `queryRef`) {\n        validateQueryStructure(joinClause.from.query, combinedAliases)\n      }\n    }\n  }\n}\n\n/**\n * Processes the FROM clause, handling direct collection references and subqueries.\n * Populates `aliasToCollectionId` and `aliasRemapping` for per-alias subscription tracking.\n */\nfunction processFrom(\n  from: CollectionRef | QueryRef,\n  allInputs: Record<string, KeyedStream>,\n  collections: Record<string, Collection>,\n  subscriptions: Record<string, CollectionSubscription>,\n  callbacks: Record<string, LazyCollectionCallbacks>,\n  lazySources: Set<string>,\n  optimizableOrderByCollections: Record<string, OrderByOptimizationInfo>,\n  setWindowFn: (windowFn: (options: WindowOptions) => void) => void,\n  cache: QueryCache,\n  queryMapping: QueryMapping,\n  aliasToCollectionId: Record<string, string>,\n  aliasRemapping: Record<string, string>\n): { alias: string; input: KeyedStream; collectionId: string } {\n  switch (from.type) {\n    case `collectionRef`: {\n      const input = allInputs[from.alias]\n      if (!input) {\n        throw new CollectionInputNotFoundError(\n          from.alias,\n          from.collection.id,\n          Object.keys(allInputs)\n        )\n      }\n      aliasToCollectionId[from.alias] = from.collection.id\n      return { alias: from.alias, input, collectionId: from.collection.id }\n    }\n    case `queryRef`: {\n      // Find the original query for caching purposes\n      const originalQuery = queryMapping.get(from.query) || from.query\n\n      // Recursively compile the sub-query with cache\n      const subQueryResult = compileQuery(\n        originalQuery,\n        allInputs,\n        collections,\n        subscriptions,\n        callbacks,\n        lazySources,\n        optimizableOrderByCollections,\n        setWindowFn,\n        cache,\n        queryMapping\n      )\n\n      // Pull up alias mappings from subquery to parent scope.\n      // This includes both the innermost alias-to-collection mappings AND\n      // any existing remappings from nested subquery levels.\n      Object.assign(aliasToCollectionId, subQueryResult.aliasToCollectionId)\n      Object.assign(aliasRemapping, subQueryResult.aliasRemapping)\n\n      // Create a FLATTENED remapping from outer alias to innermost alias.\n      // For nested subqueries, this ensures one-hop lookups (not recursive chains).\n      //\n      // Example with 3-level nesting:\n      //   Inner:  .from({ user: usersCollection })\n      //   Middle: .from({ activeUser: innerSubquery })     â†’ creates: activeUser â†’ user\n      //   Outer:  .from({ author: middleSubquery })        â†’ creates: author â†’ user (not author â†’ activeUser)\n      //\n      // The key insight: We search through the PULLED-UP aliasToCollectionId (which contains\n      // the innermost 'user' alias), so we always map directly to the deepest level.\n      // This means aliasRemapping[alias] is always a single lookup, never recursive.\n      // Needed for subscription resolution during lazy loading.\n      const innerAlias = Object.keys(subQueryResult.aliasToCollectionId).find(\n        (alias) =>\n          subQueryResult.aliasToCollectionId[alias] ===\n          subQueryResult.collectionId\n      )\n      if (innerAlias && innerAlias !== from.alias) {\n        aliasRemapping[from.alias] = innerAlias\n      }\n\n      // Extract the pipeline from the compilation result\n      const subQueryInput = subQueryResult.pipeline\n\n      // Subqueries may return [key, [value, orderByIndex]] (with ORDER BY) or [key, value] (without ORDER BY)\n      // We need to extract just the value for use in parent queries\n      const extractedInput = subQueryInput.pipe(\n        map((data: any) => {\n          const [key, [value, _orderByIndex]] = data\n          // Unwrap Value expressions that might have leaked through as the entire row\n          const unwrapped = unwrapValue(value)\n          return [key, unwrapped] as [unknown, any]\n        })\n      )\n\n      return {\n        alias: from.alias,\n        input: extractedInput,\n        collectionId: subQueryResult.collectionId,\n      }\n    }\n    default:\n      throw new UnsupportedFromTypeError((from as any).type)\n  }\n}\n\n// Helper to check if a value is a Value expression\nfunction isValue(raw: any): boolean {\n  return (\n    raw instanceof ValClass ||\n    (raw && typeof raw === `object` && `type` in raw && raw.type === `val`)\n  )\n}\n\n// Helper to unwrap a Value expression or return the value itself\nfunction unwrapValue(value: any): any {\n  return isValue(value) ? value.value : value\n}\n\n/**\n * Recursively maps optimized subqueries to their original queries for proper caching.\n * This ensures that when we encounter the same QueryRef object in different contexts,\n * we can find the original query to check the cache.\n */\nfunction mapNestedQueries(\n  optimizedQuery: QueryIR,\n  originalQuery: QueryIR,\n  queryMapping: QueryMapping\n): void {\n  // Map the FROM clause if it's a QueryRef\n  if (\n    optimizedQuery.from.type === `queryRef` &&\n    originalQuery.from.type === `queryRef`\n  ) {\n    queryMapping.set(optimizedQuery.from.query, originalQuery.from.query)\n    // Recursively map nested queries\n    mapNestedQueries(\n      optimizedQuery.from.query,\n      originalQuery.from.query,\n      queryMapping\n    )\n  }\n\n  // Map JOIN clauses if they exist\n  if (optimizedQuery.join && originalQuery.join) {\n    for (\n      let i = 0;\n      i < optimizedQuery.join.length && i < originalQuery.join.length;\n      i++\n    ) {\n      const optimizedJoin = optimizedQuery.join[i]!\n      const originalJoin = originalQuery.join[i]!\n\n      if (\n        optimizedJoin.from.type === `queryRef` &&\n        originalJoin.from.type === `queryRef`\n      ) {\n        queryMapping.set(optimizedJoin.from.query, originalJoin.from.query)\n        // Recursively map nested queries in joins\n        mapNestedQueries(\n          optimizedJoin.from.query,\n          originalJoin.from.query,\n          queryMapping\n        )\n      }\n    }\n  }\n}\n\nfunction getRefFromAlias(\n  query: QueryIR,\n  alias: string\n): CollectionRef | QueryRef | void {\n  if (query.from.alias === alias) {\n    return query.from\n  }\n\n  for (const join of query.join || []) {\n    if (join.from.alias === alias) {\n      return join.from\n    }\n  }\n}\n\n/**\n * Follows the given reference in a query\n * until its finds the root field the reference points to.\n * @returns The collection, its alias, and the path to the root field in this collection\n */\nexport function followRef(\n  query: QueryIR,\n  ref: PropRef<any>,\n  collection: Collection\n): { collection: Collection; path: Array<string> } | void {\n  if (ref.path.length === 0) {\n    return\n  }\n\n  if (ref.path.length === 1) {\n    // This field should be part of this collection\n    const field = ref.path[0]!\n    // is it part of the select clause?\n    if (query.select) {\n      const selectedField = query.select[field]\n      if (selectedField && selectedField.type === `ref`) {\n        return followRef(query, selectedField, collection)\n      }\n    }\n\n    // Either this field is not part of the select clause\n    // and thus it must be part of the collection itself\n    // or it is part of the select but is not a reference\n    // so we can stop here and don't have to follow it\n    return { collection, path: [field] }\n  }\n\n  if (ref.path.length > 1) {\n    // This is a nested field\n    const [alias, ...rest] = ref.path\n    const aliasRef = getRefFromAlias(query, alias!)\n    if (!aliasRef) {\n      return\n    }\n\n    if (aliasRef.type === `queryRef`) {\n      return followRef(aliasRef.query, new PropRef(rest), collection)\n    } else {\n      // This is a reference to a collection\n      // we can't follow it further\n      // so the field must be on the collection itself\n      return { collection: aliasRef.collection, path: rest }\n    }\n  }\n}\n\nexport type CompileQueryFn = typeof compileQuery\n", "import { Func, PropRef, Value } from \"../ir.js\"\nimport type { BasicExpression, OrderBy } from \"../ir.js\"\n\n/**\n * Normalizes a WHERE clause expression by removing table aliases from property references.\n *\n * This function recursively traverses an expression tree and creates new BasicExpression\n * instances with normalized paths. The main transformation is removing the collection alias\n * from property reference paths (e.g., `['user', 'id']` becomes `['id']` when `collectionAlias`\n * is `'user'`), which is needed when converting query-level expressions to collection-level\n * expressions for subscriptions.\n *\n * @param whereClause - The WHERE clause expression to normalize\n * @param collectionAlias - The alias of the collection being filtered (to strip from paths)\n * @returns A new BasicExpression with normalized paths\n *\n * @example\n * // Input: ref with path ['user', 'id'] where collectionAlias is 'user'\n * // Output: ref with path ['id']\n */\nexport function normalizeExpressionPaths(\n  whereClause: BasicExpression<boolean>,\n  collectionAlias: string\n): BasicExpression<boolean> {\n  const tpe = whereClause.type\n  if (tpe === `val`) {\n    return new Value(whereClause.value)\n  } else if (tpe === `ref`) {\n    const path = whereClause.path\n    if (Array.isArray(path)) {\n      if (path[0] === collectionAlias && path.length > 1) {\n        // Remove the table alias from the path for single-collection queries\n        return new PropRef(path.slice(1))\n      } else if (path.length === 1 && path[0] !== undefined) {\n        // Single field reference\n        return new PropRef([path[0]])\n      }\n    }\n    // Fallback for non-array paths\n    return new PropRef(Array.isArray(path) ? path : [String(path)])\n  } else {\n    // Recursively convert all arguments\n    const args: Array<BasicExpression> = []\n    for (const arg of whereClause.args) {\n      const convertedArg = normalizeExpressionPaths(\n        arg as BasicExpression<boolean>,\n        collectionAlias\n      )\n      args.push(convertedArg)\n    }\n    return new Func(whereClause.name, args)\n  }\n}\n\nexport function normalizeOrderByPaths(\n  orderBy: OrderBy,\n  collectionAlias: string\n): OrderBy {\n  const normalizedOrderBy = orderBy.map((clause) => {\n    const basicExp = normalizeExpressionPaths(\n      clause.expression,\n      collectionAlias\n    )\n\n    return {\n      ...clause,\n      expression: basicExp,\n    }\n  })\n\n  return normalizedOrderBy\n}\n", "import { MultiSet } from \"@tanstack/db-ivm\"\nimport {\n  normalizeExpressionPaths,\n  normalizeOrderByPaths,\n} from \"../compiler/expressions.js\"\nimport type { MultiSetArray, RootStreamBuilder } from \"@tanstack/db-ivm\"\nimport type { Collection } from \"../../collection/index.js\"\nimport type { ChangeMessage } from \"../../types.js\"\nimport type { Context, GetResult } from \"../builder/types.js\"\nimport type { BasicExpression } from \"../ir.js\"\nimport type { OrderByOptimizationInfo } from \"../compiler/order-by.js\"\nimport type { CollectionConfigBuilder } from \"./collection-config-builder.js\"\nimport type { CollectionSubscription } from \"../../collection/subscription.js\"\n\nconst loadMoreCallbackSymbol = Symbol.for(\n  `@tanstack/db.collection-config-builder`\n)\n\nexport class CollectionSubscriber<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n> {\n  // Keep track of the biggest value we've sent so far (needed for orderBy optimization)\n  private biggest: any = undefined\n\n  // Track deferred promises for subscription loading states\n  private subscriptionLoadingPromises = new Map<\n    CollectionSubscription,\n    { resolve: () => void }\n  >()\n\n  constructor(\n    private alias: string,\n    private collectionId: string,\n    private collection: Collection,\n    private collectionConfigBuilder: CollectionConfigBuilder<TContext, TResult>\n  ) {}\n\n  subscribe(): CollectionSubscription {\n    const whereClause = this.getWhereClauseForAlias()\n\n    if (whereClause) {\n      const whereExpression = normalizeExpressionPaths(whereClause, this.alias)\n      return this.subscribeToChanges(whereExpression)\n    }\n\n    return this.subscribeToChanges()\n  }\n\n  private subscribeToChanges(whereExpression?: BasicExpression<boolean>) {\n    let subscription: CollectionSubscription\n    const orderByInfo = this.getOrderByInfo()\n    if (orderByInfo) {\n      subscription = this.subscribeToOrderedChanges(\n        whereExpression,\n        orderByInfo\n      )\n    } else {\n      // If the source alias is lazy then we should not include the initial state\n      const includeInitialState = !this.collectionConfigBuilder.isLazyAlias(\n        this.alias\n      )\n\n      subscription = this.subscribeToMatchingChanges(\n        whereExpression,\n        includeInitialState\n      )\n    }\n\n    const trackLoadPromise = () => {\n      // Guard against duplicate transitions\n      if (!this.subscriptionLoadingPromises.has(subscription)) {\n        let resolve: () => void\n        const promise = new Promise<void>((res) => {\n          resolve = res\n        })\n\n        this.subscriptionLoadingPromises.set(subscription, {\n          resolve: resolve!,\n        })\n        this.collectionConfigBuilder.liveQueryCollection!._sync.trackLoadPromise(\n          promise\n        )\n      }\n    }\n\n    // It can be that we are not yet subscribed when the first `loadSubset` call happens (i.e. the initial query).\n    // So we also check the status here and if it's `loadingSubset` then we track the load promise\n    if (subscription.status === `loadingSubset`) {\n      trackLoadPromise()\n    }\n\n    // Subscribe to subscription status changes to propagate loading state\n    const statusUnsubscribe = subscription.on(`status:change`, (event) => {\n      if (event.status === `loadingSubset`) {\n        trackLoadPromise()\n      } else {\n        // status is 'ready'\n        const deferred = this.subscriptionLoadingPromises.get(subscription)\n        if (deferred) {\n          // Clear the map entry FIRST (before resolving)\n          this.subscriptionLoadingPromises.delete(subscription)\n          deferred.resolve()\n        }\n      }\n    })\n\n    const unsubscribe = () => {\n      // If subscription has a pending promise, resolve it before unsubscribing\n      const deferred = this.subscriptionLoadingPromises.get(subscription)\n      if (deferred) {\n        // Clear the map entry FIRST (before resolving)\n        this.subscriptionLoadingPromises.delete(subscription)\n        deferred.resolve()\n      }\n\n      statusUnsubscribe()\n      subscription.unsubscribe()\n    }\n    // currentSyncState is always defined when subscribe() is called\n    // (called during sync session setup)\n    this.collectionConfigBuilder.currentSyncState!.unsubscribeCallbacks.add(\n      unsubscribe\n    )\n    return subscription\n  }\n\n  private sendChangesToPipeline(\n    changes: Iterable<ChangeMessage<any, string | number>>,\n    callback?: () => boolean\n  ) {\n    // currentSyncState and input are always defined when this method is called\n    // (only called from active subscriptions during a sync session)\n    const input =\n      this.collectionConfigBuilder.currentSyncState!.inputs[this.alias]!\n    const sentChanges = sendChangesToInput(\n      input,\n      changes,\n      this.collection.config.getKey\n    )\n\n    // Do not provide the callback that loads more data\n    // if there's no more data to load\n    // otherwise we end up in an infinite loop trying to load more data\n    const dataLoader = sentChanges > 0 ? callback : undefined\n\n    // We need to schedule a graph run even if there's no data to load\n    // because we need to mark the collection as ready if it's not already\n    // and that's only done in `scheduleGraphRun`\n    this.collectionConfigBuilder.scheduleGraphRun(dataLoader, {\n      alias: this.alias,\n    })\n  }\n\n  private subscribeToMatchingChanges(\n    whereExpression: BasicExpression<boolean> | undefined,\n    includeInitialState: boolean = false\n  ) {\n    const sendChanges = (\n      changes: Array<ChangeMessage<any, string | number>>\n    ) => {\n      this.sendChangesToPipeline(changes)\n    }\n\n    const subscription = this.collection.subscribeChanges(sendChanges, {\n      includeInitialState,\n      whereExpression,\n    })\n\n    return subscription\n  }\n\n  private subscribeToOrderedChanges(\n    whereExpression: BasicExpression<boolean> | undefined,\n    orderByInfo: OrderByOptimizationInfo\n  ) {\n    const { orderBy, offset, limit, index } = orderByInfo\n\n    const sendChangesInRange = (\n      changes: Iterable<ChangeMessage<any, string | number>>\n    ) => {\n      // Split live updates into a delete of the old value and an insert of the new value\n      const splittedChanges = splitUpdates(changes)\n      this.sendChangesToPipelineWithTracking(splittedChanges, subscription)\n    }\n\n    // Subscribe to changes and only send changes that are smaller than the biggest value we've sent so far\n    // values that are bigger don't need to be sent because they can't affect the topK\n    const subscription = this.collection.subscribeChanges(sendChangesInRange, {\n      whereExpression,\n    })\n\n    subscription.setOrderByIndex(index)\n\n    // Normalize the orderBy clauses such that the references are relative to the collection\n    const normalizedOrderBy = normalizeOrderByPaths(orderBy, this.alias)\n\n    // Load the first `offset + limit` values from the index\n    // i.e. the K items from the collection that fall into the requested range: [offset, offset + limit[\n    subscription.requestLimitedSnapshot({\n      limit: offset + limit,\n      orderBy: normalizedOrderBy,\n    })\n\n    return subscription\n  }\n\n  // This function is called by maybeRunGraph\n  // after each iteration of the query pipeline\n  // to ensure that the orderBy operator has enough data to work with\n  loadMoreIfNeeded(subscription: CollectionSubscription) {\n    const orderByInfo = this.getOrderByInfo()\n\n    if (!orderByInfo) {\n      // This query has no orderBy operator\n      // so there's no data to load\n      return true\n    }\n\n    const { dataNeeded } = orderByInfo\n\n    if (!dataNeeded) {\n      // This should never happen because the topK operator should always set the size callback\n      // which in turn should lead to the orderBy operator setting the dataNeeded callback\n      throw new Error(\n        `Missing dataNeeded callback for collection ${this.collectionId}`\n      )\n    }\n\n    // `dataNeeded` probes the orderBy operator to see if it needs more data\n    // if it needs more data, it returns the number of items it needs\n    const n = dataNeeded()\n    if (n > 0) {\n      this.loadNextItems(n, subscription)\n    }\n    return true\n  }\n\n  private sendChangesToPipelineWithTracking(\n    changes: Iterable<ChangeMessage<any, string | number>>,\n    subscription: CollectionSubscription\n  ) {\n    const orderByInfo = this.getOrderByInfo()\n    if (!orderByInfo) {\n      this.sendChangesToPipeline(changes)\n      return\n    }\n\n    const trackedChanges = this.trackSentValues(changes, orderByInfo.comparator)\n\n    // Cache the loadMoreIfNeeded callback on the subscription using a symbol property.\n    // This ensures we pass the same function instance to the scheduler each time,\n    // allowing it to deduplicate callbacks when multiple changes arrive during a transaction.\n    type SubscriptionWithLoader = CollectionSubscription & {\n      [loadMoreCallbackSymbol]?: () => boolean\n    }\n\n    const subscriptionWithLoader = subscription as SubscriptionWithLoader\n\n    subscriptionWithLoader[loadMoreCallbackSymbol] ??=\n      this.loadMoreIfNeeded.bind(this, subscription)\n\n    this.sendChangesToPipeline(\n      trackedChanges,\n      subscriptionWithLoader[loadMoreCallbackSymbol]\n    )\n  }\n\n  // Loads the next `n` items from the collection\n  // starting from the biggest item it has sent\n  private loadNextItems(n: number, subscription: CollectionSubscription) {\n    const orderByInfo = this.getOrderByInfo()\n    if (!orderByInfo) {\n      return\n    }\n    const { orderBy, valueExtractorForRawRow } = orderByInfo\n    const biggestSentRow = this.biggest\n    const biggestSentValue = biggestSentRow\n      ? valueExtractorForRawRow(biggestSentRow)\n      : biggestSentRow\n\n    // Normalize the orderBy clauses such that the references are relative to the collection\n    const normalizedOrderBy = normalizeOrderByPaths(orderBy, this.alias)\n\n    // Take the `n` items after the biggest sent value\n    subscription.requestLimitedSnapshot({\n      orderBy: normalizedOrderBy,\n      limit: n,\n      minValue: biggestSentValue,\n    })\n  }\n\n  private getWhereClauseForAlias(): BasicExpression<boolean> | undefined {\n    const sourceWhereClausesCache =\n      this.collectionConfigBuilder.sourceWhereClausesCache\n    if (!sourceWhereClausesCache) {\n      return undefined\n    }\n    return sourceWhereClausesCache.get(this.alias)\n  }\n\n  private getOrderByInfo(): OrderByOptimizationInfo | undefined {\n    const info =\n      this.collectionConfigBuilder.optimizableOrderByCollections[\n        this.collectionId\n      ]\n    if (info && info.alias === this.alias) {\n      return info\n    }\n    return undefined\n  }\n\n  private *trackSentValues(\n    changes: Iterable<ChangeMessage<any, string | number>>,\n    comparator: (a: any, b: any) => number\n  ) {\n    for (const change of changes) {\n      if (!this.biggest) {\n        this.biggest = change.value\n      } else if (comparator(this.biggest, change.value) < 0) {\n        this.biggest = change.value\n      }\n\n      yield change\n    }\n  }\n}\n\n/**\n * Helper function to send changes to a D2 input stream\n */\nfunction sendChangesToInput(\n  input: RootStreamBuilder<unknown>,\n  changes: Iterable<ChangeMessage>,\n  getKey: (item: ChangeMessage[`value`]) => any\n): number {\n  const multiSetArray: MultiSetArray<unknown> = []\n  for (const change of changes) {\n    const key = getKey(change.value)\n    if (change.type === `insert`) {\n      multiSetArray.push([[key, change.value], 1])\n    } else if (change.type === `update`) {\n      multiSetArray.push([[key, change.previousValue], -1])\n      multiSetArray.push([[key, change.value], 1])\n    } else {\n      // change.type === `delete`\n      multiSetArray.push([[key, change.value], -1])\n    }\n  }\n\n  if (multiSetArray.length !== 0) {\n    input.sendData(new MultiSet(multiSetArray))\n  }\n\n  return multiSetArray.length\n}\n\n/** Splits updates into a delete of the old value and an insert of the new value */\nfunction* splitUpdates<\n  T extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n>(\n  changes: Iterable<ChangeMessage<T, TKey>>\n): Generator<ChangeMessage<T, TKey>> {\n  for (const change of changes) {\n    if (change.type === `update`) {\n      yield { type: `delete`, key: change.key, value: change.previousValue! }\n      yield { type: `insert`, key: change.key, value: change.value }\n    } else {\n      yield change\n    }\n  }\n}\n", "import { LIVE_QUERY_INTERNAL } from \"./internal.js\"\nimport type { Collection } from \"../../collection/index.js\"\nimport type { CollectionConfigBuilder } from \"./collection-config-builder.js\"\n\nconst collectionBuilderRegistry = new WeakMap<\n  Collection<any, any, any>,\n  CollectionConfigBuilder<any, any>\n>()\n\n/**\n * Retrieves the builder attached to a config object via its internal utils.\n *\n * @param config - The collection config object\n * @returns The attached builder, or `undefined` if none exists\n */\nexport function getBuilderFromConfig(\n  config: object\n): CollectionConfigBuilder<any, any> | undefined {\n  return (config as any).utils?.[LIVE_QUERY_INTERNAL]?.getBuilder?.()\n}\n\n/**\n * Registers a builder for a collection in the global registry.\n * Used to detect when a live query depends on another live query,\n * enabling the scheduler to ensure parent queries run first.\n *\n * @param collection - The collection to register the builder for\n * @param builder - The builder that produces this collection\n */\nexport function registerCollectionBuilder(\n  collection: Collection<any, any, any>,\n  builder: CollectionConfigBuilder<any, any>\n): void {\n  collectionBuilderRegistry.set(collection, builder)\n}\n\n/**\n * Retrieves the builder registered for a collection.\n * Used to discover dependencies when a live query subscribes to another live query.\n *\n * @param collection - The collection to look up\n * @returns The registered builder, or `undefined` if none exists\n */\nexport function getCollectionBuilder(\n  collection: Collection<any, any, any>\n): CollectionConfigBuilder<any, any> | undefined {\n  return collectionBuilderRegistry.get(collection)\n}\n", "import { D2, output } from \"@tanstack/db-ivm\"\nimport { compileQuery } from \"../compiler/index.js\"\nimport { buildQuery, getQueryIR } from \"../builder/index.js\"\nimport {\n  MissingAliasInputsError,\n  SetWindowRequiresOrderByError,\n} from \"../../errors.js\"\nimport { transactionScopedScheduler } from \"../../scheduler.js\"\nimport { getActiveTransaction } from \"../../transactions.js\"\nimport { CollectionSubscriber } from \"./collection-subscriber.js\"\nimport { getCollectionBuilder } from \"./collection-registry.js\"\nimport { LIVE_QUERY_INTERNAL } from \"./internal.js\"\nimport type { LiveQueryInternalUtils } from \"./internal.js\"\nimport type { WindowOptions } from \"../compiler/index.js\"\nimport type { SchedulerContextId } from \"../../scheduler.js\"\nimport type { CollectionSubscription } from \"../../collection/subscription.js\"\nimport type { RootStreamBuilder } from \"@tanstack/db-ivm\"\nimport type { OrderByOptimizationInfo } from \"../compiler/order-by.js\"\nimport type { Collection } from \"../../collection/index.js\"\nimport type {\n  CollectionConfigSingleRowOption,\n  KeyedStream,\n  ResultStream,\n  StringCollationConfig,\n  SyncConfig,\n  UtilsRecord,\n} from \"../../types.js\"\nimport type { Context, GetResult } from \"../builder/types.js\"\nimport type { BasicExpression, QueryIR } from \"../ir.js\"\nimport type { LazyCollectionCallbacks } from \"../compiler/joins.js\"\nimport type {\n  Changes,\n  FullSyncState,\n  LiveQueryCollectionConfig,\n  SyncState,\n} from \"./types.js\"\nimport type { AllCollectionEvents } from \"../../collection/events.js\"\n\nexport type LiveQueryCollectionUtils = UtilsRecord & {\n  getRunCount: () => number\n  /**\n   * Sets the offset and limit of an ordered query.\n   * Is a no-op if the query is not ordered.\n   *\n   * @returns `true` if no subset loading was triggered, or `Promise<void>` that resolves when the subset has been loaded\n   */\n  setWindow: (options: WindowOptions) => true | Promise<void>\n  /**\n   * Gets the current window (offset and limit) for an ordered query.\n   *\n   * @returns The current window settings, or `undefined` if the query is not windowed\n   */\n  getWindow: () => { offset: number; limit: number } | undefined\n  [LIVE_QUERY_INTERNAL]: LiveQueryInternalUtils\n}\n\ntype PendingGraphRun = {\n  loadCallbacks: Set<() => boolean>\n}\n\n// Global counter for auto-generated collection IDs\nlet liveQueryCollectionCounter = 0\n\ntype SyncMethods<TResult extends object> = Parameters<\n  SyncConfig<TResult>[`sync`]\n>[0]\n\nexport class CollectionConfigBuilder<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n> {\n  private readonly id: string\n  readonly query: QueryIR\n  private readonly collections: Record<string, Collection<any, any, any>>\n  private readonly collectionByAlias: Record<string, Collection<any, any, any>>\n  // Populated during compilation with all aliases (including subquery inner aliases)\n  private compiledAliasToCollectionId: Record<string, string> = {}\n\n  // WeakMap to store the keys of the results\n  // so that we can retrieve them in the getKey function\n  private readonly resultKeys = new WeakMap<object, unknown>()\n\n  // WeakMap to store the orderBy index for each result\n  private readonly orderByIndices = new WeakMap<object, string>()\n\n  private readonly compare?: (val1: TResult, val2: TResult) => number\n  private readonly compareOptions?: StringCollationConfig\n\n  private isGraphRunning = false\n  private runCount = 0\n\n  // Current sync session state (set when sync starts, cleared when it stops)\n  // Public for testing purposes (CollectionConfigBuilder is internal, not public API)\n  public currentSyncConfig:\n    | Parameters<SyncConfig<TResult>[`sync`]>[0]\n    | undefined\n  public currentSyncState: FullSyncState | undefined\n\n  // Error state tracking\n  private isInErrorState = false\n\n  // Reference to the live query collection for error state transitions\n  public liveQueryCollection?: Collection<TResult, any, any>\n\n  private windowFn: ((options: WindowOptions) => void) | undefined\n  private currentWindow: WindowOptions | undefined\n\n  private maybeRunGraphFn: (() => void) | undefined\n\n  private readonly aliasDependencies: Record<\n    string,\n    Array<CollectionConfigBuilder<any, any>>\n  > = {}\n\n  private readonly builderDependencies = new Set<\n    CollectionConfigBuilder<any, any>\n  >()\n\n  // Pending graph runs per scheduler context (e.g., per transaction)\n  // The builder manages its own state; the scheduler just orchestrates execution order\n  // Only stores callbacks - if sync ends, pending jobs gracefully no-op\n  private readonly pendingGraphRuns = new Map<\n    SchedulerContextId,\n    PendingGraphRun\n  >()\n\n  // Unsubscribe function for scheduler's onClear listener\n  // Registered when sync starts, unregistered when sync stops\n  // Prevents memory leaks by releasing the scheduler's reference to this builder\n  private unsubscribeFromSchedulerClears?: () => void\n\n  private graphCache: D2 | undefined\n  private inputsCache: Record<string, RootStreamBuilder<unknown>> | undefined\n  private pipelineCache: ResultStream | undefined\n  public sourceWhereClausesCache:\n    | Map<string, BasicExpression<boolean>>\n    | undefined\n\n  // Map of source alias to subscription\n  readonly subscriptions: Record<string, CollectionSubscription> = {}\n  // Map of source aliases to functions that load keys for that lazy source\n  lazySourcesCallbacks: Record<string, LazyCollectionCallbacks> = {}\n  // Set of source aliases that are lazy (don't load initial state)\n  readonly lazySources = new Set<string>()\n  // Set of collection IDs that include an optimizable ORDER BY clause\n  optimizableOrderByCollections: Record<string, OrderByOptimizationInfo> = {}\n\n  constructor(\n    private readonly config: LiveQueryCollectionConfig<TContext, TResult>\n  ) {\n    // Generate a unique ID if not provided\n    this.id = config.id || `live-query-${++liveQueryCollectionCounter}`\n\n    this.query = buildQueryFromConfig(config)\n    this.collections = extractCollectionsFromQuery(this.query)\n    const collectionAliasesById = extractCollectionAliases(this.query)\n\n    // Build a reverse lookup map from alias to collection instance.\n    // This enables self-join support where the same collection can be referenced\n    // multiple times with different aliases (e.g., { employee: col, manager: col })\n    this.collectionByAlias = {}\n    for (const [collectionId, aliases] of collectionAliasesById.entries()) {\n      const collection = this.collections[collectionId]\n      if (!collection) continue\n      for (const alias of aliases) {\n        this.collectionByAlias[alias] = collection\n      }\n    }\n\n    // Create compare function for ordering if the query has orderBy\n    if (this.query.orderBy && this.query.orderBy.length > 0) {\n      this.compare = createOrderByComparator<TResult>(this.orderByIndices)\n    }\n\n    // Use explicitly provided compareOptions if available, otherwise inherit from FROM collection\n    this.compareOptions =\n      this.config.defaultStringCollation ??\n      extractCollectionFromSource(this.query).compareOptions\n\n    // Compile the base pipeline once initially\n    // This is done to ensure that any errors are thrown immediately and synchronously\n    this.compileBasePipeline()\n  }\n\n  /**\n   * Recursively checks if a query or any of its subqueries contains joins\n   */\n  private hasJoins(query: QueryIR): boolean {\n    // Check if this query has joins\n    if (query.join && query.join.length > 0) {\n      return true\n    }\n\n    // Recursively check subqueries in the from clause\n    if (query.from.type === `queryRef`) {\n      if (this.hasJoins(query.from.query)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  getConfig(): CollectionConfigSingleRowOption<TResult> & {\n    utils: LiveQueryCollectionUtils\n  } {\n    return {\n      id: this.id,\n      getKey:\n        this.config.getKey ||\n        ((item) => this.resultKeys.get(item) as string | number),\n      sync: this.getSyncConfig(),\n      compare: this.compare,\n      defaultStringCollation: this.compareOptions,\n      gcTime: this.config.gcTime || 5000, // 5 seconds by default for live queries\n      schema: this.config.schema,\n      onInsert: this.config.onInsert,\n      onUpdate: this.config.onUpdate,\n      onDelete: this.config.onDelete,\n      startSync: this.config.startSync,\n      singleResult: this.query.singleResult,\n      utils: {\n        getRunCount: this.getRunCount.bind(this),\n        setWindow: this.setWindow.bind(this),\n        getWindow: this.getWindow.bind(this),\n        [LIVE_QUERY_INTERNAL]: {\n          getBuilder: () => this,\n          hasCustomGetKey: !!this.config.getKey,\n          hasJoins: this.hasJoins(this.query),\n        },\n      },\n    }\n  }\n\n  setWindow(options: WindowOptions): true | Promise<void> {\n    if (!this.windowFn) {\n      throw new SetWindowRequiresOrderByError()\n    }\n\n    this.currentWindow = options\n    this.windowFn(options)\n    this.maybeRunGraphFn?.()\n\n    // Check if loading a subset was triggered\n    if (this.liveQueryCollection?.isLoadingSubset) {\n      // Loading was triggered, return a promise that resolves when it completes\n      return new Promise<void>((resolve) => {\n        const unsubscribe = this.liveQueryCollection!.on(\n          `loadingSubset:change`,\n          (event) => {\n            if (!event.isLoadingSubset) {\n              unsubscribe()\n              resolve()\n            }\n          }\n        )\n      })\n    }\n\n    // No loading was triggered\n    return true\n  }\n\n  getWindow(): { offset: number; limit: number } | undefined {\n    // Only return window if this is a windowed query (has orderBy and windowFn)\n    if (!this.windowFn || !this.currentWindow) {\n      return undefined\n    }\n    return {\n      offset: this.currentWindow.offset ?? 0,\n      limit: this.currentWindow.limit ?? 0,\n    }\n  }\n\n  /**\n   * Resolves a collection alias to its collection ID.\n   *\n   * Uses a two-tier lookup strategy:\n   * 1. First checks compiled aliases (includes subquery inner aliases)\n   * 2. Falls back to declared aliases from the query's from/join clauses\n   *\n   * @param alias - The alias to resolve (e.g., \"employee\", \"manager\")\n   * @returns The collection ID that the alias references\n   * @throws {Error} If the alias is not found in either lookup\n   */\n  getCollectionIdForAlias(alias: string): string {\n    const compiled = this.compiledAliasToCollectionId[alias]\n    if (compiled) {\n      return compiled\n    }\n    const collection = this.collectionByAlias[alias]\n    if (collection) {\n      return collection.id\n    }\n    throw new Error(`Unknown source alias \"${alias}\"`)\n  }\n\n  isLazyAlias(alias: string): boolean {\n    return this.lazySources.has(alias)\n  }\n\n  // The callback function is called after the graph has run.\n  // This gives the callback a chance to load more data if needed,\n  // that's used to optimize orderBy operators that set a limit,\n  // in order to load some more data if we still don't have enough rows after the pipeline has run.\n  // That can happen because even though we load N rows, the pipeline might filter some of these rows out\n  // causing the orderBy operator to receive less than N rows or even no rows at all.\n  // So this callback would notice that it doesn't have enough rows and load some more.\n  // The callback returns a boolean, when it's true it's done loading data and we can mark the collection as ready.\n  maybeRunGraph(callback?: () => boolean) {\n    if (this.isGraphRunning) {\n      // no nested runs of the graph\n      // which is possible if the `callback`\n      // would call `maybeRunGraph` e.g. after it has loaded some more data\n      return\n    }\n\n    // Should only be called when sync is active\n    if (!this.currentSyncConfig || !this.currentSyncState) {\n      throw new Error(\n        `maybeRunGraph called without active sync session. This should not happen.`\n      )\n    }\n\n    this.isGraphRunning = true\n\n    try {\n      const { begin, commit } = this.currentSyncConfig\n      const syncState = this.currentSyncState\n\n      // Don't run if the live query is in an error state\n      if (this.isInErrorState) {\n        return\n      }\n\n      // Always run the graph if subscribed (eager execution)\n      if (syncState.subscribedToAllCollections) {\n        while (syncState.graph.pendingWork()) {\n          syncState.graph.run()\n          callback?.()\n        }\n\n        // On the initial run, we may need to do an empty commit to ensure that\n        // the collection is initialized\n        if (syncState.messagesCount === 0) {\n          begin()\n          commit()\n          // After initial commit, check if we should mark ready\n          // (in case all sources were already ready before we subscribed)\n          this.updateLiveQueryStatus(this.currentSyncConfig)\n        }\n      }\n    } finally {\n      this.isGraphRunning = false\n    }\n  }\n\n  /**\n   * Schedules a graph run with the transaction-scoped scheduler.\n   * Ensures each builder runs at most once per transaction, with automatic dependency tracking\n   * to run parent queries before child queries. Outside a transaction, runs immediately.\n   *\n   * Multiple calls during a transaction are coalesced into a single execution.\n   * Dependencies are auto-discovered from subscribed live queries, or can be overridden.\n   * Load callbacks are combined when entries merge.\n   *\n   * Uses the current sync session's config and syncState from instance properties.\n   *\n   * @param callback - Optional callback to load more data if needed (returns true when done)\n   * @param options - Optional scheduling configuration\n   * @param options.contextId - Transaction ID to group work; defaults to active transaction\n   * @param options.jobId - Unique identifier for this job; defaults to this builder instance\n   * @param options.alias - Source alias that triggered this schedule; adds alias-specific dependencies\n   * @param options.dependencies - Explicit dependency list; overrides auto-discovered dependencies\n   */\n  scheduleGraphRun(\n    callback?: () => boolean,\n    options?: {\n      contextId?: SchedulerContextId\n      jobId?: unknown\n      alias?: string\n      dependencies?: Array<CollectionConfigBuilder<any, any>>\n    }\n  ) {\n    const contextId = options?.contextId ?? getActiveTransaction()?.id\n    // Use the builder instance as the job ID for deduplication. This is memory-safe\n    // because the scheduler's context Map is deleted after flushing (no long-term retention).\n    const jobId = options?.jobId ?? this\n    const dependentBuilders = (() => {\n      if (options?.dependencies) {\n        return options.dependencies\n      }\n\n      const deps = new Set(this.builderDependencies)\n      if (options?.alias) {\n        const aliasDeps = this.aliasDependencies[options.alias]\n        if (aliasDeps) {\n          for (const dep of aliasDeps) {\n            deps.add(dep)\n          }\n        }\n      }\n\n      deps.delete(this)\n\n      return Array.from(deps)\n    })()\n\n    // Ensure dependent builders are actually scheduled in this context so that\n    // dependency edges always point to a real job (or a deduped no-op if already scheduled).\n    if (contextId) {\n      for (const dep of dependentBuilders) {\n        if (typeof dep.scheduleGraphRun === `function`) {\n          dep.scheduleGraphRun(undefined, { contextId })\n        }\n      }\n    }\n\n    // We intentionally scope deduplication to the builder instance. Each instance\n    // owns caches and compiled pipelines, so sharing work across instances that\n    // merely reuse the same string id would execute the wrong builder's graph.\n\n    if (!this.currentSyncConfig || !this.currentSyncState) {\n      throw new Error(\n        `scheduleGraphRun called without active sync session. This should not happen.`\n      )\n    }\n\n    // Manage our own state - get or create pending callbacks for this context\n    let pending = contextId ? this.pendingGraphRuns.get(contextId) : undefined\n    if (!pending) {\n      pending = {\n        loadCallbacks: new Set(),\n      }\n      if (contextId) {\n        this.pendingGraphRuns.set(contextId, pending)\n      }\n    }\n\n    // Add callback if provided (this is what accumulates between schedules)\n    if (callback) {\n      pending.loadCallbacks.add(callback)\n    }\n\n    // Schedule execution (scheduler just orchestrates order, we manage state)\n    // For immediate execution (no contextId), pass pending directly since it won't be in the map\n    const pendingToPass = contextId ? undefined : pending\n    transactionScopedScheduler.schedule({\n      contextId,\n      jobId,\n      dependencies: dependentBuilders,\n      run: () => this.executeGraphRun(contextId, pendingToPass),\n    })\n  }\n\n  /**\n   * Clears pending graph run state for a specific context.\n   * Called when the scheduler clears a context (e.g., transaction rollback/abort).\n   */\n  clearPendingGraphRun(contextId: SchedulerContextId): void {\n    this.pendingGraphRuns.delete(contextId)\n  }\n\n  /**\n   * Returns true if this builder has a pending graph run for the given context.\n   */\n  hasPendingGraphRun(contextId: SchedulerContextId): boolean {\n    return this.pendingGraphRuns.has(contextId)\n  }\n\n  /**\n   * Executes a pending graph run. Called by the scheduler when dependencies are satisfied.\n   * Clears the pending state BEFORE execution so that any re-schedules during the run\n   * create fresh state and don't interfere with the current execution.\n   * Uses instance sync state - if sync has ended, gracefully returns without executing.\n   *\n   * @param contextId - Optional context ID to look up pending state\n   * @param pendingParam - For immediate execution (no context), pending state is passed directly\n   */\n  private executeGraphRun(\n    contextId?: SchedulerContextId,\n    pendingParam?: PendingGraphRun\n  ): void {\n    // Get pending state: either from parameter (no context) or from map (with context)\n    // Remove from map BEFORE checking sync state to prevent leaking entries when sync ends\n    // before the transaction flushes (e.g., unsubscribe during in-flight transaction)\n    const pending =\n      pendingParam ??\n      (contextId ? this.pendingGraphRuns.get(contextId) : undefined)\n    if (contextId) {\n      this.pendingGraphRuns.delete(contextId)\n    }\n\n    // If no pending state, nothing to execute (context was cleared)\n    if (!pending) {\n      return\n    }\n\n    // If sync session has ended, don't execute (graph is finalized, subscriptions cleared)\n    if (!this.currentSyncConfig || !this.currentSyncState) {\n      return\n    }\n\n    this.incrementRunCount()\n\n    const combinedLoader = () => {\n      let allDone = true\n      let firstError: unknown\n      pending.loadCallbacks.forEach((loader) => {\n        try {\n          allDone = loader() && allDone\n        } catch (error) {\n          allDone = false\n          firstError ??= error\n        }\n      })\n      if (firstError) {\n        throw firstError\n      }\n      // Returning false signals that callers should schedule another pass.\n      return allDone\n    }\n\n    this.maybeRunGraph(combinedLoader)\n  }\n\n  private getSyncConfig(): SyncConfig<TResult> {\n    return {\n      rowUpdateMode: `full`,\n      sync: this.syncFn.bind(this),\n    }\n  }\n\n  incrementRunCount() {\n    this.runCount++\n  }\n\n  getRunCount() {\n    return this.runCount\n  }\n\n  private syncFn(config: SyncMethods<TResult>) {\n    // Store reference to the live query collection for error state transitions\n    this.liveQueryCollection = config.collection\n    // Store config and syncState as instance properties for the duration of this sync session\n    this.currentSyncConfig = config\n\n    const syncState: SyncState = {\n      messagesCount: 0,\n      subscribedToAllCollections: false,\n      unsubscribeCallbacks: new Set<() => void>(),\n    }\n\n    // Extend the pipeline such that it applies the incoming changes to the collection\n    const fullSyncState = this.extendPipelineWithChangeProcessing(\n      config,\n      syncState\n    )\n    this.currentSyncState = fullSyncState\n\n    // Listen for scheduler context clears to clean up our pending state\n    // Re-register on each sync start so the listener is active for the sync session's lifetime\n    this.unsubscribeFromSchedulerClears = transactionScopedScheduler.onClear(\n      (contextId) => {\n        this.clearPendingGraphRun(contextId)\n      }\n    )\n\n    const loadSubsetDataCallbacks = this.subscribeToAllCollections(\n      config,\n      fullSyncState\n    )\n\n    this.maybeRunGraphFn = () => this.scheduleGraphRun(loadSubsetDataCallbacks)\n\n    // Initial run with callback to load more data if needed\n    this.scheduleGraphRun(loadSubsetDataCallbacks)\n\n    // Return the unsubscribe function\n    return () => {\n      syncState.unsubscribeCallbacks.forEach((unsubscribe) => unsubscribe())\n\n      // Clear current sync session state\n      this.currentSyncConfig = undefined\n      this.currentSyncState = undefined\n\n      // Clear all pending graph runs to prevent memory leaks from in-flight transactions\n      // that may flush after the sync session ends\n      this.pendingGraphRuns.clear()\n\n      // Reset caches so a fresh graph/pipeline is compiled on next start\n      // This avoids reusing a finalized D2 graph across GC restarts\n      this.graphCache = undefined\n      this.inputsCache = undefined\n      this.pipelineCache = undefined\n      this.sourceWhereClausesCache = undefined\n\n      // Reset lazy source alias state\n      this.lazySources.clear()\n      this.optimizableOrderByCollections = {}\n      this.lazySourcesCallbacks = {}\n\n      // Clear subscription references to prevent memory leaks\n      // Note: Individual subscriptions are already unsubscribed via unsubscribeCallbacks\n      Object.keys(this.subscriptions).forEach(\n        (key) => delete this.subscriptions[key]\n      )\n      this.compiledAliasToCollectionId = {}\n\n      // Unregister from scheduler's onClear listener to prevent memory leaks\n      // The scheduler's listener Set would otherwise keep a strong reference to this builder\n      this.unsubscribeFromSchedulerClears?.()\n      this.unsubscribeFromSchedulerClears = undefined\n    }\n  }\n\n  /**\n   * Compiles the query pipeline with all declared aliases.\n   */\n  private compileBasePipeline() {\n    this.graphCache = new D2()\n    this.inputsCache = Object.fromEntries(\n      Object.keys(this.collectionByAlias).map((alias) => [\n        alias,\n        this.graphCache!.newInput<any>(),\n      ])\n    )\n\n    const compilation = compileQuery(\n      this.query,\n      this.inputsCache as Record<string, KeyedStream>,\n      this.collections,\n      this.subscriptions,\n      this.lazySourcesCallbacks,\n      this.lazySources,\n      this.optimizableOrderByCollections,\n      (windowFn: (options: WindowOptions) => void) => {\n        this.windowFn = windowFn\n      }\n    )\n\n    this.pipelineCache = compilation.pipeline\n    this.sourceWhereClausesCache = compilation.sourceWhereClauses\n    this.compiledAliasToCollectionId = compilation.aliasToCollectionId\n\n    // Defensive check: verify all compiled aliases have corresponding inputs\n    // This should never happen since all aliases come from user declarations,\n    // but catch it early if the assumption is violated in the future.\n    const missingAliases = Object.keys(this.compiledAliasToCollectionId).filter(\n      (alias) => !Object.hasOwn(this.inputsCache!, alias)\n    )\n    if (missingAliases.length > 0) {\n      throw new MissingAliasInputsError(missingAliases)\n    }\n  }\n\n  private maybeCompileBasePipeline() {\n    if (!this.graphCache || !this.inputsCache || !this.pipelineCache) {\n      this.compileBasePipeline()\n    }\n    return {\n      graph: this.graphCache!,\n      inputs: this.inputsCache!,\n      pipeline: this.pipelineCache!,\n    }\n  }\n\n  private extendPipelineWithChangeProcessing(\n    config: SyncMethods<TResult>,\n    syncState: SyncState\n  ): FullSyncState {\n    const { begin, commit } = config\n    const { graph, inputs, pipeline } = this.maybeCompileBasePipeline()\n\n    pipeline.pipe(\n      output((data) => {\n        const messages = data.getInner()\n        syncState.messagesCount += messages.length\n\n        begin()\n        messages\n          .reduce(\n            accumulateChanges<TResult>,\n            new Map<unknown, Changes<TResult>>()\n          )\n          .forEach(this.applyChanges.bind(this, config))\n        commit()\n      })\n    )\n\n    graph.finalize()\n\n    // Extend the sync state with the graph, inputs, and pipeline\n    syncState.graph = graph\n    syncState.inputs = inputs\n    syncState.pipeline = pipeline\n\n    return syncState as FullSyncState\n  }\n\n  private applyChanges(\n    config: SyncMethods<TResult>,\n    changes: {\n      deletes: number\n      inserts: number\n      value: TResult\n      orderByIndex: string | undefined\n    },\n    key: unknown\n  ) {\n    const { write, collection } = config\n    const { deletes, inserts, value, orderByIndex } = changes\n\n    // Store the key of the result so that we can retrieve it in the\n    // getKey function\n    this.resultKeys.set(value, key)\n\n    // Store the orderBy index if it exists\n    if (orderByIndex !== undefined) {\n      this.orderByIndices.set(value, orderByIndex)\n    }\n\n    // Simple singular insert.\n    if (inserts && deletes === 0) {\n      write({\n        value,\n        type: `insert`,\n      })\n    } else if (\n      // Insert & update(s) (updates are a delete & insert)\n      inserts > deletes ||\n      // Just update(s) but the item is already in the collection (so\n      // was inserted previously).\n      (inserts === deletes && collection.has(collection.getKeyFromItem(value)))\n    ) {\n      write({\n        value,\n        type: `update`,\n      })\n      // Only delete is left as an option\n    } else if (deletes > 0) {\n      write({\n        value,\n        type: `delete`,\n      })\n    } else {\n      throw new Error(\n        `Could not apply changes: ${JSON.stringify(changes)}. This should never happen.`\n      )\n    }\n  }\n\n  /**\n   * Handle status changes from source collections\n   */\n  private handleSourceStatusChange(\n    config: SyncMethods<TResult>,\n    collectionId: string,\n    event: AllCollectionEvents[`status:change`]\n  ) {\n    const { status } = event\n\n    // Handle error state - any source collection in error puts live query in error\n    if (status === `error`) {\n      this.transitionToError(\n        `Source collection '${collectionId}' entered error state`\n      )\n      return\n    }\n\n    // Handle manual cleanup - this should not happen due to GC prevention,\n    // but could happen if user manually calls cleanup()\n    if (status === `cleaned-up`) {\n      this.transitionToError(\n        `Source collection '${collectionId}' was manually cleaned up while live query '${this.id}' depends on it. ` +\n          `Live queries prevent automatic GC, so this was likely a manual cleanup() call.`\n      )\n      return\n    }\n\n    // Update ready status based on all source collections\n    this.updateLiveQueryStatus(config)\n  }\n\n  /**\n   * Update the live query status based on source collection statuses\n   */\n  private updateLiveQueryStatus(config: SyncMethods<TResult>) {\n    const { markReady } = config\n\n    // Don't update status if already in error\n    if (this.isInErrorState) {\n      return\n    }\n\n    // Mark ready when all source collections are ready\n    if (this.allCollectionsReady()) {\n      markReady()\n    }\n  }\n\n  /**\n   * Transition the live query to error state\n   */\n  private transitionToError(message: string) {\n    this.isInErrorState = true\n\n    // Log error to console for debugging\n    console.error(`[Live Query Error] ${message}`)\n\n    // Transition live query collection to error state\n    this.liveQueryCollection?._lifecycle.setStatus(`error`)\n  }\n\n  private allCollectionsReady() {\n    return Object.values(this.collections).every((collection) =>\n      collection.isReady()\n    )\n  }\n\n  /**\n   * Creates per-alias subscriptions enabling self-join support.\n   * Each alias gets its own subscription with independent filters, even for the same collection.\n   * Example: `{ employee: col, manager: col }` creates two separate subscriptions.\n   */\n  private subscribeToAllCollections(\n    config: SyncMethods<TResult>,\n    syncState: FullSyncState\n  ) {\n    // Use compiled aliases as the source of truth - these include all aliases from the query\n    // including those from subqueries, which may not be in collectionByAlias\n    const compiledAliases = Object.entries(this.compiledAliasToCollectionId)\n    if (compiledAliases.length === 0) {\n      throw new Error(\n        `Compiler returned no alias metadata for query '${this.id}'. This should not happen; please report.`\n      )\n    }\n\n    // Create a separate subscription for each alias, enabling self-joins where the same\n    // collection can be used multiple times with different filters and subscriptions\n    const loaders = compiledAliases.map(([alias, collectionId]) => {\n      // Try collectionByAlias first (for declared aliases), fall back to collections (for subquery aliases)\n      const collection =\n        this.collectionByAlias[alias] ?? this.collections[collectionId]!\n\n      const dependencyBuilder = getCollectionBuilder(collection)\n      if (dependencyBuilder && dependencyBuilder !== this) {\n        this.aliasDependencies[alias] = [dependencyBuilder]\n        this.builderDependencies.add(dependencyBuilder)\n      } else {\n        this.aliasDependencies[alias] = []\n      }\n\n      // CollectionSubscriber handles the actual subscription to the source collection\n      // and feeds data into the D2 graph inputs for this specific alias\n      const collectionSubscriber = new CollectionSubscriber(\n        alias,\n        collectionId,\n        collection,\n        this\n      )\n\n      // Subscribe to status changes for status flow\n      const statusUnsubscribe = collection.on(`status:change`, (event) => {\n        this.handleSourceStatusChange(config, collectionId, event)\n      })\n      syncState.unsubscribeCallbacks.add(statusUnsubscribe)\n\n      const subscription = collectionSubscriber.subscribe()\n      // Store subscription by alias (not collection ID) to support lazy loading\n      // which needs to look up subscriptions by their query alias\n      this.subscriptions[alias] = subscription\n\n      // Create a callback for loading more data if needed (used by OrderBy optimization)\n      const loadMore = collectionSubscriber.loadMoreIfNeeded.bind(\n        collectionSubscriber,\n        subscription\n      )\n\n      return loadMore\n    })\n\n    // Combine all loaders into a single callback that initiates loading more data\n    // from any source that needs it. Returns true once all loaders have been called,\n    // but the actual async loading may still be in progress.\n    const loadSubsetDataCallbacks = () => {\n      loaders.map((loader) => loader())\n      return true\n    }\n\n    // Mark as subscribed so the graph can start running\n    // (graph only runs when all collections are subscribed)\n    syncState.subscribedToAllCollections = true\n\n    // Initial status check after all subscriptions are set up\n    this.updateLiveQueryStatus(config)\n\n    return loadSubsetDataCallbacks\n  }\n}\n\nfunction buildQueryFromConfig<TContext extends Context>(\n  config: LiveQueryCollectionConfig<any, any>\n) {\n  // Build the query using the provided query builder function or instance\n  if (typeof config.query === `function`) {\n    return buildQuery<TContext>(config.query)\n  }\n  return getQueryIR(config.query)\n}\n\nfunction createOrderByComparator<T extends object>(\n  orderByIndices: WeakMap<object, string>\n) {\n  return (val1: T, val2: T): number => {\n    // Use the orderBy index stored in the WeakMap\n    const index1 = orderByIndices.get(val1)\n    const index2 = orderByIndices.get(val2)\n\n    // Compare fractional indices lexicographically\n    if (index1 && index2) {\n      if (index1 < index2) {\n        return -1\n      } else if (index1 > index2) {\n        return 1\n      } else {\n        return 0\n      }\n    }\n\n    // Fallback to no ordering if indices are missing\n    return 0\n  }\n}\n\n/**\n * Helper function to extract collections from a compiled query\n * Traverses the query IR to find all collection references\n * Maps collections by their ID (not alias) as expected by the compiler\n */\nfunction extractCollectionsFromQuery(\n  query: any\n): Record<string, Collection<any, any, any>> {\n  const collections: Record<string, any> = {}\n\n  // Helper function to recursively extract collections from a query or source\n  function extractFromSource(source: any) {\n    if (source.type === `collectionRef`) {\n      collections[source.collection.id] = source.collection\n    } else if (source.type === `queryRef`) {\n      // Recursively extract from subquery\n      extractFromQuery(source.query)\n    }\n  }\n\n  // Helper function to recursively extract collections from a query\n  function extractFromQuery(q: any) {\n    // Extract from FROM clause\n    if (q.from) {\n      extractFromSource(q.from)\n    }\n\n    // Extract from JOIN clauses\n    if (q.join && Array.isArray(q.join)) {\n      for (const joinClause of q.join) {\n        if (joinClause.from) {\n          extractFromSource(joinClause.from)\n        }\n      }\n    }\n  }\n\n  // Start extraction from the root query\n  extractFromQuery(query)\n\n  return collections\n}\n\n/**\n * Helper function to extract the collection that is referenced in the query's FROM clause.\n * The FROM clause may refer directly to a collection or indirectly to a subquery.\n */\nfunction extractCollectionFromSource(query: any): Collection<any, any, any> {\n  const from = query.from\n\n  if (from.type === `collectionRef`) {\n    return from.collection\n  } else if (from.type === `queryRef`) {\n    // Recursively extract from subquery\n    return extractCollectionFromSource(from.query)\n  }\n\n  throw new Error(\n    `Failed to extract collection. Invalid FROM clause: ${JSON.stringify(query)}`\n  )\n}\n\n/**\n * Extracts all aliases used for each collection across the entire query tree.\n *\n * Traverses the QueryIR recursively to build a map from collection ID to all aliases\n * that reference that collection. This is essential for self-join support, where the\n * same collection may be referenced multiple times with different aliases.\n *\n * For example, given a query like:\n * ```ts\n * q.from({ employee: employeesCollection })\n *   .join({ manager: employeesCollection }, ({ employee, manager }) =>\n *     eq(employee.managerId, manager.id)\n *   )\n * ```\n *\n * This function would return:\n * ```\n * Map { \"employees\" => Set { \"employee\", \"manager\" } }\n * ```\n *\n * @param query - The query IR to extract aliases from\n * @returns A map from collection ID to the set of all aliases referencing that collection\n */\nfunction extractCollectionAliases(query: QueryIR): Map<string, Set<string>> {\n  const aliasesById = new Map<string, Set<string>>()\n\n  function recordAlias(source: any) {\n    if (!source) return\n\n    if (source.type === `collectionRef`) {\n      const { id } = source.collection\n      const existing = aliasesById.get(id)\n      if (existing) {\n        existing.add(source.alias)\n      } else {\n        aliasesById.set(id, new Set([source.alias]))\n      }\n    } else if (source.type === `queryRef`) {\n      traverse(source.query)\n    }\n  }\n\n  function traverse(q?: QueryIR) {\n    if (!q) return\n\n    recordAlias(q.from)\n\n    if (q.join) {\n      for (const joinClause of q.join) {\n        recordAlias(joinClause.from)\n      }\n    }\n  }\n\n  traverse(query)\n\n  return aliasesById\n}\n\nfunction accumulateChanges<T>(\n  acc: Map<unknown, Changes<T>>,\n  [[key, tupleData], multiplicity]: [\n    [unknown, [any, string | undefined]],\n    number,\n  ]\n) {\n  // All queries now consistently return [value, orderByIndex] format\n  // where orderByIndex is undefined for queries without ORDER BY\n  const [value, orderByIndex] = tupleData as [T, string | undefined]\n\n  const changes = acc.get(key) || {\n    deletes: 0,\n    inserts: 0,\n    value,\n    orderByIndex,\n  }\n  if (multiplicity < 0) {\n    changes.deletes += Math.abs(multiplicity)\n  } else if (multiplicity > 0) {\n    changes.inserts += multiplicity\n    changes.value = value\n    changes.orderByIndex = orderByIndex\n  }\n  acc.set(key, changes)\n  return acc\n}\n", "import { createCollection } from \"../collection/index.js\"\nimport { CollectionConfigBuilder } from \"./live/collection-config-builder.js\"\nimport {\n  getBuilderFromConfig,\n  registerCollectionBuilder,\n} from \"./live/collection-registry.js\"\nimport type { LiveQueryCollectionUtils } from \"./live/collection-config-builder.js\"\nimport type { LiveQueryCollectionConfig } from \"./live/types.js\"\nimport type { InitialQueryBuilder, QueryBuilder } from \"./builder/index.js\"\nimport type { Collection } from \"../collection/index.js\"\nimport type {\n  CollectionConfig,\n  CollectionConfigSingleRowOption,\n  NonSingleResult,\n  SingleResult,\n  UtilsRecord,\n} from \"../types.js\"\nimport type { Context, GetResult } from \"./builder/types.js\"\n\ntype CollectionConfigForContext<\n  TContext extends Context,\n  TResult extends object,\n  TUtils extends UtilsRecord = {},\n> = TContext extends SingleResult\n  ? CollectionConfigSingleRowOption<TResult, string | number, never, TUtils> &\n      SingleResult\n  : CollectionConfigSingleRowOption<TResult, string | number, never, TUtils> &\n      NonSingleResult\n\ntype CollectionForContext<\n  TContext extends Context,\n  TResult extends object,\n  TUtils extends UtilsRecord = {},\n> = TContext extends SingleResult\n  ? Collection<TResult, string | number, TUtils> & SingleResult\n  : Collection<TResult, string | number, TUtils> & NonSingleResult\n\n/**\n * Creates live query collection options for use with createCollection\n *\n * @example\n * ```typescript\n * const options = liveQueryCollectionOptions({\n *   // id is optional - will auto-generate if not provided\n *   query: (q) => q\n *     .from({ post: postsCollection })\n *     .where(({ post }) => eq(post.published, true))\n *     .select(({ post }) => ({\n *       id: post.id,\n *       title: post.title,\n *       content: post.content,\n *     })),\n *   // getKey is optional - will use stream key if not provided\n * })\n *\n * const collection = createCollection(options)\n * ```\n *\n * @param config - Configuration options for the live query collection\n * @returns Collection options that can be passed to createCollection\n */\nexport function liveQueryCollectionOptions<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n>(\n  config: LiveQueryCollectionConfig<TContext, TResult>\n): CollectionConfigForContext<TContext, TResult> & {\n  utils: LiveQueryCollectionUtils\n} {\n  const collectionConfigBuilder = new CollectionConfigBuilder<\n    TContext,\n    TResult\n  >(config)\n  return collectionConfigBuilder.getConfig() as CollectionConfigForContext<\n    TContext,\n    TResult\n  > & { utils: LiveQueryCollectionUtils }\n}\n\n/**\n * Creates a live query collection directly\n *\n * @example\n * ```typescript\n * // Minimal usage - just pass a query function\n * const activeUsers = createLiveQueryCollection(\n *   (q) => q\n *     .from({ user: usersCollection })\n *     .where(({ user }) => eq(user.active, true))\n *     .select(({ user }) => ({ id: user.id, name: user.name }))\n * )\n *\n * // Full configuration with custom options\n * const searchResults = createLiveQueryCollection({\n *   id: \"search-results\", // Custom ID (auto-generated if omitted)\n *   query: (q) => q\n *     .from({ post: postsCollection })\n *     .where(({ post }) => like(post.title, `%${searchTerm}%`))\n *     .select(({ post }) => ({\n *       id: post.id,\n *       title: post.title,\n *       excerpt: post.excerpt,\n *     })),\n *   getKey: (item) => item.id, // Custom key function (uses stream key if omitted)\n *   utils: {\n *     updateSearchTerm: (newTerm: string) => {\n *       // Custom utility functions\n *     }\n *   }\n * })\n * ```\n */\n\n// Overload 1: Accept just the query function\nexport function createLiveQueryCollection<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n>(\n  query: (q: InitialQueryBuilder) => QueryBuilder<TContext>\n): CollectionForContext<TContext, TResult> & {\n  utils: LiveQueryCollectionUtils\n}\n\n// Overload 2: Accept full config object with optional utilities\nexport function createLiveQueryCollection<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n  TUtils extends UtilsRecord = {},\n>(\n  config: LiveQueryCollectionConfig<TContext, TResult> & { utils?: TUtils }\n): CollectionForContext<TContext, TResult> & {\n  utils: LiveQueryCollectionUtils & TUtils\n}\n\n// Implementation\nexport function createLiveQueryCollection<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n  TUtils extends UtilsRecord = {},\n>(\n  configOrQuery:\n    | (LiveQueryCollectionConfig<TContext, TResult> & { utils?: TUtils })\n    | ((q: InitialQueryBuilder) => QueryBuilder<TContext>)\n): CollectionForContext<TContext, TResult> & {\n  utils: LiveQueryCollectionUtils & TUtils\n} {\n  // Determine if the argument is a function (query) or a config object\n  if (typeof configOrQuery === `function`) {\n    // Simple query function case\n    const config: LiveQueryCollectionConfig<TContext, TResult> = {\n      query: configOrQuery as (\n        q: InitialQueryBuilder\n      ) => QueryBuilder<TContext>,\n    }\n    const options = liveQueryCollectionOptions<TContext, TResult>(config)\n    return bridgeToCreateCollection(options) as CollectionForContext<\n      TContext,\n      TResult\n    > & { utils: LiveQueryCollectionUtils & TUtils }\n  } else {\n    // Config object case\n    const config = configOrQuery as LiveQueryCollectionConfig<\n      TContext,\n      TResult\n    > & { utils?: TUtils }\n    const options = liveQueryCollectionOptions<TContext, TResult>(config)\n\n    // Merge custom utils if provided, preserving the getBuilder() method for dependency tracking\n    if (config.utils) {\n      options.utils = { ...options.utils, ...config.utils }\n    }\n\n    return bridgeToCreateCollection(options) as CollectionForContext<\n      TContext,\n      TResult\n    > & { utils: LiveQueryCollectionUtils & TUtils }\n  }\n}\n\n/**\n * Bridge function that handles the type compatibility between query2's TResult\n * and core collection's output type without exposing ugly type assertions to users\n */\nfunction bridgeToCreateCollection<\n  TResult extends object,\n  TUtils extends UtilsRecord = {},\n>(\n  options: CollectionConfig<TResult> & { utils: TUtils }\n): Collection<TResult, string | number, TUtils> {\n  const collection = createCollection(options as any) as unknown as Collection<\n    TResult,\n    string | number,\n    LiveQueryCollectionUtils\n  >\n\n  const builder = getBuilderFromConfig(options)\n  if (builder) {\n    registerCollectionBuilder(collection, builder)\n  }\n\n  return collection as unknown as Collection<TResult, string | number, TUtils>\n}\n", "import { Func, Value } from \"./ir.js\"\nimport type { BasicExpression, OrderBy, PropRef } from \"./ir.js\"\nimport type { LoadSubsetOptions } from \"../types.js\"\n\n/**\n * Check if one where clause is a logical subset of another.\n * Returns true if the subset predicate is more restrictive than (or equal to) the superset predicate.\n *\n * @example\n * // age > 20 is subset of age > 10 (more restrictive)\n * isWhereSubset(gt(ref('age'), val(20)), gt(ref('age'), val(10))) // true\n *\n * @example\n * // age > 10 AND name = 'X' is subset of age > 10 (more conditions)\n * isWhereSubset(and(gt(ref('age'), val(10)), eq(ref('name'), val('X'))), gt(ref('age'), val(10))) // true\n *\n * @param subset - The potentially more restrictive predicate\n * @param superset - The potentially less restrictive predicate\n * @returns true if subset logically implies superset\n */\nexport function isWhereSubset(\n  subset: BasicExpression<boolean> | undefined,\n  superset: BasicExpression<boolean> | undefined\n): boolean {\n  // undefined/missing where clause means \"no filter\" (all data)\n  // Both undefined means subset relationship holds (all data âŠ† all data)\n  if (subset === undefined && superset === undefined) {\n    return true\n  }\n\n  // If subset is undefined but superset is not, we're requesting ALL data\n  // but have only loaded SOME data - subset relationship does NOT hold\n  if (subset === undefined && superset !== undefined) {\n    return false\n  }\n\n  // If superset is undefined (no filter = all data loaded),\n  // then any constrained subset is contained\n  if (superset === undefined && subset !== undefined) {\n    return true\n  }\n\n  return isWhereSubsetInternal(subset!, superset!)\n}\n\nfunction makeDisjunction(\n  preds: Array<BasicExpression<boolean>>\n): BasicExpression<boolean> {\n  if (preds.length === 0) {\n    return new Value(false)\n  }\n  if (preds.length === 1) {\n    return preds[0]!\n  }\n  return new Func(`or`, preds)\n}\n\nfunction convertInToOr(inField: InField) {\n  const equalities = inField.values.map(\n    (value) => new Func(`eq`, [inField.ref, new Value(value)])\n  )\n  return makeDisjunction(equalities)\n}\n\nfunction isWhereSubsetInternal(\n  subset: BasicExpression<boolean>,\n  superset: BasicExpression<boolean>\n): boolean {\n  // If subset is false it is requesting no data,\n  // thus the result set is empty\n  // and the empty set is a subset of any set\n  if (subset.type === `val` && subset.value === false) {\n    return true\n  }\n\n  // If expressions are structurally equal, subset relationship holds\n  if (areExpressionsEqual(subset, superset)) {\n    return true\n  }\n\n  // Handle superset being an AND: subset must imply ALL conjuncts\n  // If superset is (A AND B), then subset âŠ† (A AND B) only if subset âŠ† A AND subset âŠ† B\n  // Example: (age > 20) âŠ† (age > 10 AND status = 'active') is false (doesn't imply status condition)\n  if (superset.type === `func` && superset.name === `and`) {\n    return superset.args.every((arg) =>\n      isWhereSubsetInternal(subset, arg as BasicExpression<boolean>)\n    )\n  }\n\n  // Handle subset being an AND: (A AND B) implies both A and B\n  if (subset.type === `func` && subset.name === `and`) {\n    // For (A AND B) âŠ† C, since (A AND B) implies A, we check if any conjunct implies C\n    return subset.args.some((arg) =>\n      isWhereSubsetInternal(arg as BasicExpression<boolean>, superset)\n    )\n  }\n\n  // Turn x IN [A, B, C] into x = A OR x = B OR x = C\n  // for unified handling of IN and OR\n  if (subset.type === `func` && subset.name === `in`) {\n    const inField = extractInField(subset)\n    if (inField) {\n      return isWhereSubsetInternal(convertInToOr(inField), superset)\n    }\n  }\n\n  if (superset.type === `func` && superset.name === `in`) {\n    const inField = extractInField(superset)\n    if (inField) {\n      return isWhereSubsetInternal(subset, convertInToOr(inField))\n    }\n  }\n\n  // Handle OR in subset: (A OR B) is subset of C only if both A and B are subsets of C\n  if (subset.type === `func` && subset.name === `or`) {\n    return subset.args.every((arg) =>\n      isWhereSubsetInternal(arg as BasicExpression<boolean>, superset)\n    )\n  }\n\n  // Handle OR in superset: subset âŠ† (A OR B) if subset âŠ† A or subset âŠ† B\n  // (A OR B) as superset means data can satisfy A or B\n  // If subset is contained in any disjunct, it's contained in the union\n  if (superset.type === `func` && superset.name === `or`) {\n    return superset.args.some((arg) =>\n      isWhereSubsetInternal(subset, arg as BasicExpression<boolean>)\n    )\n  }\n\n  // Handle comparison operators on the same field\n  if (subset.type === `func` && superset.type === `func`) {\n    const subsetFunc = subset as Func\n    const supersetFunc = superset as Func\n\n    // Check if both are comparisons on the same field\n    const subsetField = extractComparisonField(subsetFunc)\n    const supersetField = extractComparisonField(supersetFunc)\n\n    if (\n      subsetField &&\n      supersetField &&\n      areRefsEqual(subsetField.ref, supersetField.ref)\n    ) {\n      return isComparisonSubset(\n        subsetFunc,\n        subsetField.value,\n        supersetFunc,\n        supersetField.value\n      )\n    }\n\n    /*\n    // Handle eq vs in\n    if (subsetFunc.name === `eq` && supersetFunc.name === `in`) {\n      const subsetFieldEq = extractEqualityField(subsetFunc)\n      const supersetFieldIn = extractInField(supersetFunc)\n      if (\n        subsetFieldEq &&\n        supersetFieldIn &&\n        areRefsEqual(subsetFieldEq.ref, supersetFieldIn.ref)\n      ) {\n        // field = X is subset of field IN [X, Y, Z] if X is in the array\n        // Use cached primitive set and metadata from extraction\n        return arrayIncludesWithSet(\n          supersetFieldIn.values,\n          subsetFieldEq.value,\n          supersetFieldIn.primitiveSet ?? null,\n          supersetFieldIn.areAllPrimitives\n        )\n      }\n    }\n\n    // Handle in vs in\n    if (subsetFunc.name === `in` && supersetFunc.name === `in`) {\n      const subsetFieldIn = extractInField(subsetFunc)\n      const supersetFieldIn = extractInField(supersetFunc)\n      if (\n        subsetFieldIn &&\n        supersetFieldIn &&\n        areRefsEqual(subsetFieldIn.ref, supersetFieldIn.ref)\n      ) {\n        // field IN [A, B] is subset of field IN [A, B, C] if all values in subset are in superset\n        // Use cached primitive set and metadata from extraction\n        return subsetFieldIn.values.every((subVal) =>\n          arrayIncludesWithSet(\n            supersetFieldIn.values,\n            subVal,\n            supersetFieldIn.primitiveSet ?? null,\n            supersetFieldIn.areAllPrimitives\n          )\n        )\n      }\n    }\n    */\n  }\n\n  // Conservative: if we can't determine, return false\n  return false\n}\n\n/**\n * Helper to combine where predicates with common logic for AND/OR operations\n */\nfunction combineWherePredicates(\n  predicates: Array<BasicExpression<boolean>>,\n  operation: `and` | `or`,\n  simplifyFn: (\n    preds: Array<BasicExpression<boolean>>\n  ) => BasicExpression<boolean> | null\n): BasicExpression<boolean> {\n  const emptyValue = operation === `and` ? true : false\n  const identityValue = operation === `and` ? true : false\n\n  if (predicates.length === 0) {\n    return { type: `val`, value: emptyValue } as BasicExpression<boolean>\n  }\n\n  if (predicates.length === 1) {\n    return predicates[0]!\n  }\n\n  // Flatten nested expressions of the same operation\n  const flatPredicates: Array<BasicExpression<boolean>> = []\n  for (const pred of predicates) {\n    if (pred.type === `func` && pred.name === operation) {\n      flatPredicates.push(...pred.args)\n    } else {\n      flatPredicates.push(pred)\n    }\n  }\n\n  // Group predicates by field for simplification\n  const grouped = groupPredicatesByField(flatPredicates)\n\n  // Simplify each group\n  const simplified: Array<BasicExpression<boolean>> = []\n  for (const [field, preds] of grouped.entries()) {\n    if (field === null) {\n      // Complex predicates that we can't group by field\n      simplified.push(...preds)\n    } else {\n      // Try to simplify same-field predicates\n      const result = simplifyFn(preds)\n\n      // For intersection: check for empty set (contradiction)\n      if (\n        operation === `and` &&\n        result &&\n        result.type === `val` &&\n        result.value === false\n      ) {\n        // Intersection is empty (conflicting constraints) - entire AND is false\n        return { type: `val`, value: false } as BasicExpression<boolean>\n      }\n\n      // For union: result may be null if simplification failed\n      if (result) {\n        simplified.push(result)\n      }\n    }\n  }\n\n  if (simplified.length === 0) {\n    return { type: `val`, value: identityValue } as BasicExpression<boolean>\n  }\n\n  if (simplified.length === 1) {\n    return simplified[0]!\n  }\n\n  // Return combined predicate\n  return {\n    type: `func`,\n    name: operation,\n    args: simplified,\n  } as BasicExpression<boolean>\n}\n\n/**\n * Combine multiple where predicates with OR logic (union).\n * Returns a predicate that is satisfied when any input predicate is satisfied.\n * Simplifies when possible (e.g., age > 10 OR age > 20 â†’ age > 10).\n *\n * @example\n * // Take least restrictive\n * unionWherePredicates([gt(ref('age'), val(10)), gt(ref('age'), val(20))]) // age > 10\n *\n * @example\n * // Combine equals into IN\n * unionWherePredicates([eq(ref('age'), val(5)), eq(ref('age'), val(10))]) // age IN [5, 10]\n *\n * @param predicates - Array of where predicates to union\n * @returns Combined predicate representing the union\n */\nexport function unionWherePredicates(\n  predicates: Array<BasicExpression<boolean>>\n): BasicExpression<boolean> {\n  return combineWherePredicates(predicates, `or`, unionSameFieldPredicates)\n}\n\n/**\n * Compute the difference between two where predicates: `fromPredicate AND NOT(subtractPredicate)`.\n * Returns the simplified predicate, or null if the difference cannot be simplified\n * (in which case the caller should fetch the full fromPredicate).\n *\n * @example\n * // Range difference\n * minusWherePredicates(\n *   gt(ref('age'), val(10)),      // age > 10\n *   gt(ref('age'), val(20))       // age > 20\n * ) // â†’ age > 10 AND age <= 20\n *\n * @example\n * // Set difference\n * minusWherePredicates(\n *   inOp(ref('status'), ['A', 'B', 'C', 'D']),  // status IN ['A','B','C','D']\n *   inOp(ref('status'), ['B', 'C'])             // status IN ['B','C']\n * ) // â†’ status IN ['A', 'D']\n *\n * @example\n * // Common conditions\n * minusWherePredicates(\n *   and(gt(ref('age'), val(10)), eq(ref('status'), val('active'))),  // age > 10 AND status = 'active'\n *   and(gt(ref('age'), val(20)), eq(ref('status'), val('active')))   // age > 20 AND status = 'active'\n * ) // â†’ age > 10 AND age <= 20 AND status = 'active'\n *\n * @example\n * // Complete overlap - empty result\n * minusWherePredicates(\n *   gt(ref('age'), val(20)),     // age > 20\n *   gt(ref('age'), val(10))      // age > 10\n * ) // â†’ {type: 'val', value: false} (empty set)\n *\n * @param fromPredicate - The predicate to subtract from\n * @param subtractPredicate - The predicate to subtract\n * @returns The simplified difference, or null if cannot be simplified\n */\nexport function minusWherePredicates(\n  fromPredicate: BasicExpression<boolean> | undefined,\n  subtractPredicate: BasicExpression<boolean> | undefined\n): BasicExpression<boolean> | null {\n  // If nothing to subtract, return the original\n  if (subtractPredicate === undefined) {\n    return (\n      fromPredicate ??\n      ({ type: `val`, value: true } as BasicExpression<boolean>)\n    )\n  }\n\n  // If from is undefined then we are asking for all data\n  // so we need to load all data minus what we already loaded\n  // i.e. we need to load NOT(subtractPredicate)\n  if (fromPredicate === undefined) {\n    return {\n      type: `func`,\n      name: `not`,\n      args: [subtractPredicate],\n    } as BasicExpression<boolean>\n  }\n\n  // Check if fromPredicate is entirely contained in subtractPredicate\n  // In that case, fromPredicate AND NOT(subtractPredicate) = empty set\n  if (isWhereSubset(fromPredicate, subtractPredicate)) {\n    return { type: `val`, value: false } as BasicExpression<boolean>\n  }\n\n  // Try to detect and handle common conditions\n  const commonConditions = findCommonConditions(\n    fromPredicate,\n    subtractPredicate\n  )\n  if (commonConditions.length > 0) {\n    // Extract predicates without common conditions\n    const fromWithoutCommon = removeConditions(fromPredicate, commonConditions)\n    const subtractWithoutCommon = removeConditions(\n      subtractPredicate,\n      commonConditions\n    )\n\n    // Recursively compute difference on simplified predicates\n    const simplifiedDifference = minusWherePredicates(\n      fromWithoutCommon,\n      subtractWithoutCommon\n    )\n\n    if (simplifiedDifference !== null) {\n      // Combine the simplified difference with common conditions\n      return combineConditions([...commonConditions, simplifiedDifference])\n    }\n  }\n\n  // Check if they are on the same field - if so, we can try to simplify\n  if (fromPredicate.type === `func` && subtractPredicate.type === `func`) {\n    const result = minusSameFieldPredicates(fromPredicate, subtractPredicate)\n    if (result !== null) {\n      return result\n    }\n  }\n\n  // Can't simplify - return null to indicate caller should fetch full fromPredicate\n  return null\n}\n\n/**\n * Helper function to compute difference for same-field predicates\n */\nfunction minusSameFieldPredicates(\n  fromPred: Func,\n  subtractPred: Func\n): BasicExpression<boolean> | null {\n  // Extract field information\n  const fromField =\n    extractComparisonField(fromPred) ||\n    extractEqualityField(fromPred) ||\n    extractInField(fromPred)\n  const subtractField =\n    extractComparisonField(subtractPred) ||\n    extractEqualityField(subtractPred) ||\n    extractInField(subtractPred)\n\n  // Must be on the same field\n  if (\n    !fromField ||\n    !subtractField ||\n    !areRefsEqual(fromField.ref, subtractField.ref)\n  ) {\n    return null\n  }\n\n  // Handle IN minus IN: status IN [A,B,C,D] - status IN [B,C] = status IN [A,D]\n  if (fromPred.name === `in` && subtractPred.name === `in`) {\n    const fromInField = fromField as InField\n    const subtractInField = subtractField as InField\n\n    // Filter out values that are in the subtract set\n    const remainingValues = fromInField.values.filter(\n      (v) =>\n        !arrayIncludesWithSet(\n          subtractInField.values,\n          v,\n          subtractInField.primitiveSet ?? null,\n          subtractInField.areAllPrimitives\n        )\n    )\n\n    if (remainingValues.length === 0) {\n      return { type: `val`, value: false } as BasicExpression<boolean>\n    }\n\n    if (remainingValues.length === 1) {\n      return {\n        type: `func`,\n        name: `eq`,\n        args: [fromField.ref, { type: `val`, value: remainingValues[0] }],\n      } as BasicExpression<boolean>\n    }\n\n    return {\n      type: `func`,\n      name: `in`,\n      args: [fromField.ref, { type: `val`, value: remainingValues }],\n    } as BasicExpression<boolean>\n  }\n\n  // Handle IN minus equality: status IN [A,B,C] - status = B = status IN [A,C]\n  if (fromPred.name === `in` && subtractPred.name === `eq`) {\n    const fromInField = fromField as InField\n    const subtractValue = (subtractField as { ref: PropRef; value: any }).value\n\n    const remainingValues = fromInField.values.filter(\n      (v) => !areValuesEqual(v, subtractValue)\n    )\n\n    if (remainingValues.length === 0) {\n      return { type: `val`, value: false } as BasicExpression<boolean>\n    }\n\n    if (remainingValues.length === 1) {\n      return {\n        type: `func`,\n        name: `eq`,\n        args: [fromField.ref, { type: `val`, value: remainingValues[0] }],\n      } as BasicExpression<boolean>\n    }\n\n    return {\n      type: `func`,\n      name: `in`,\n      args: [fromField.ref, { type: `val`, value: remainingValues }],\n    } as BasicExpression<boolean>\n  }\n\n  // Handle equality minus equality: age = 15 - age = 15 = empty, age = 15 - age = 20 = age = 15\n  if (fromPred.name === `eq` && subtractPred.name === `eq`) {\n    const fromValue = (fromField as { ref: PropRef; value: any }).value\n    const subtractValue = (subtractField as { ref: PropRef; value: any }).value\n\n    if (areValuesEqual(fromValue, subtractValue)) {\n      return { type: `val`, value: false } as BasicExpression<boolean>\n    }\n\n    // No overlap - return original\n    return fromPred as BasicExpression<boolean>\n  }\n\n  // Handle range minus range: age > 10 - age > 20 = age > 10 AND age <= 20\n  const fromComp = extractComparisonField(fromPred)\n  const subtractComp = extractComparisonField(subtractPred)\n\n  if (\n    fromComp &&\n    subtractComp &&\n    areRefsEqual(fromComp.ref, subtractComp.ref)\n  ) {\n    // Try to compute the difference using range logic\n    const result = minusRangePredicates(\n      fromPred,\n      fromComp.value,\n      subtractPred,\n      subtractComp.value\n    )\n    return result\n  }\n\n  // Can't simplify\n  return null\n}\n\n/**\n * Helper to compute difference between range predicates\n */\nfunction minusRangePredicates(\n  fromFunc: Func,\n  fromValue: any,\n  subtractFunc: Func,\n  subtractValue: any\n): BasicExpression<boolean> | null {\n  const fromOp = fromFunc.name as `gt` | `gte` | `lt` | `lte` | `eq`\n  const subtractOp = subtractFunc.name as `gt` | `gte` | `lt` | `lte` | `eq`\n  const ref = (extractComparisonField(fromFunc) ||\n    extractEqualityField(fromFunc))!.ref\n\n  // age > 10 - age > 20 = (age > 10 AND age <= 20)\n  if (fromOp === `gt` && subtractOp === `gt`) {\n    if (fromValue < subtractValue) {\n      // Result is: fromValue < field <= subtractValue\n      return {\n        type: `func`,\n        name: `and`,\n        args: [\n          fromFunc as BasicExpression<boolean>,\n          {\n            type: `func`,\n            name: `lte`,\n            args: [ref, { type: `val`, value: subtractValue }],\n          } as BasicExpression<boolean>,\n        ],\n      } as BasicExpression<boolean>\n    }\n    // fromValue >= subtractValue means no overlap\n    return fromFunc as BasicExpression<boolean>\n  }\n\n  // age >= 10 - age >= 20 = (age >= 10 AND age < 20)\n  if (fromOp === `gte` && subtractOp === `gte`) {\n    if (fromValue < subtractValue) {\n      return {\n        type: `func`,\n        name: `and`,\n        args: [\n          fromFunc as BasicExpression<boolean>,\n          {\n            type: `func`,\n            name: `lt`,\n            args: [ref, { type: `val`, value: subtractValue }],\n          } as BasicExpression<boolean>,\n        ],\n      } as BasicExpression<boolean>\n    }\n    return fromFunc as BasicExpression<boolean>\n  }\n\n  // age > 10 - age >= 20 = (age > 10 AND age < 20)\n  if (fromOp === `gt` && subtractOp === `gte`) {\n    if (fromValue < subtractValue) {\n      return {\n        type: `func`,\n        name: `and`,\n        args: [\n          fromFunc as BasicExpression<boolean>,\n          {\n            type: `func`,\n            name: `lt`,\n            args: [ref, { type: `val`, value: subtractValue }],\n          } as BasicExpression<boolean>,\n        ],\n      } as BasicExpression<boolean>\n    }\n    return fromFunc as BasicExpression<boolean>\n  }\n\n  // age >= 10 - age > 20 = (age >= 10 AND age <= 20)\n  if (fromOp === `gte` && subtractOp === `gt`) {\n    if (fromValue <= subtractValue) {\n      return {\n        type: `func`,\n        name: `and`,\n        args: [\n          fromFunc as BasicExpression<boolean>,\n          {\n            type: `func`,\n            name: `lte`,\n            args: [ref, { type: `val`, value: subtractValue }],\n          } as BasicExpression<boolean>,\n        ],\n      } as BasicExpression<boolean>\n    }\n    return fromFunc as BasicExpression<boolean>\n  }\n\n  // age < 30 - age < 20 = (age >= 20 AND age < 30)\n  if (fromOp === `lt` && subtractOp === `lt`) {\n    if (fromValue > subtractValue) {\n      return {\n        type: `func`,\n        name: `and`,\n        args: [\n          {\n            type: `func`,\n            name: `gte`,\n            args: [ref, { type: `val`, value: subtractValue }],\n          } as BasicExpression<boolean>,\n          fromFunc as BasicExpression<boolean>,\n        ],\n      } as BasicExpression<boolean>\n    }\n    return fromFunc as BasicExpression<boolean>\n  }\n\n  // age <= 30 - age <= 20 = (age > 20 AND age <= 30)\n  if (fromOp === `lte` && subtractOp === `lte`) {\n    if (fromValue > subtractValue) {\n      return {\n        type: `func`,\n        name: `and`,\n        args: [\n          {\n            type: `func`,\n            name: `gt`,\n            args: [ref, { type: `val`, value: subtractValue }],\n          } as BasicExpression<boolean>,\n          fromFunc as BasicExpression<boolean>,\n        ],\n      } as BasicExpression<boolean>\n    }\n    return fromFunc as BasicExpression<boolean>\n  }\n\n  // age < 30 - age <= 20 = (age > 20 AND age < 30)\n  if (fromOp === `lt` && subtractOp === `lte`) {\n    if (fromValue > subtractValue) {\n      return {\n        type: `func`,\n        name: `and`,\n        args: [\n          {\n            type: `func`,\n            name: `gt`,\n            args: [ref, { type: `val`, value: subtractValue }],\n          } as BasicExpression<boolean>,\n          fromFunc as BasicExpression<boolean>,\n        ],\n      } as BasicExpression<boolean>\n    }\n    return fromFunc as BasicExpression<boolean>\n  }\n\n  // age <= 30 - age < 20 = (age >= 20 AND age <= 30)\n  if (fromOp === `lte` && subtractOp === `lt`) {\n    if (fromValue >= subtractValue) {\n      return {\n        type: `func`,\n        name: `and`,\n        args: [\n          {\n            type: `func`,\n            name: `gte`,\n            args: [ref, { type: `val`, value: subtractValue }],\n          } as BasicExpression<boolean>,\n          fromFunc as BasicExpression<boolean>,\n        ],\n      } as BasicExpression<boolean>\n    }\n    return fromFunc as BasicExpression<boolean>\n  }\n\n  // Can't simplify other combinations\n  return null\n}\n\n/**\n * Check if one orderBy clause is a subset of another.\n * Returns true if the subset ordering requirements are satisfied by the superset ordering.\n *\n * @example\n * // Subset is prefix of superset\n * isOrderBySubset([{expr: age, asc}], [{expr: age, asc}, {expr: name, desc}]) // true\n *\n * @param subset - The ordering requirements to check\n * @param superset - The ordering that might satisfy the requirements\n * @returns true if subset is satisfied by superset\n */\nexport function isOrderBySubset(\n  subset: OrderBy | undefined,\n  superset: OrderBy | undefined\n): boolean {\n  // No ordering requirement is always satisfied\n  if (!subset || subset.length === 0) {\n    return true\n  }\n\n  // If there's no superset ordering but subset requires ordering, not satisfied\n  if (!superset || superset.length === 0) {\n    return false\n  }\n\n  // Check if subset is a prefix of superset with matching expressions and compare options\n  if (subset.length > superset.length) {\n    return false\n  }\n\n  for (let i = 0; i < subset.length; i++) {\n    const subClause = subset[i]!\n    const superClause = superset[i]!\n\n    // Check if expressions match\n    if (!areExpressionsEqual(subClause.expression, superClause.expression)) {\n      return false\n    }\n\n    // Check if compare options match\n    if (\n      !areCompareOptionsEqual(\n        subClause.compareOptions,\n        superClause.compareOptions\n      )\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Check if one limit is a subset of another.\n * Returns true if the subset limit requirements are satisfied by the superset limit.\n *\n * @example\n * isLimitSubset(10, 20) // true (requesting 10 items when 20 are available)\n * isLimitSubset(20, 10) // false (requesting 20 items when only 10 are available)\n * isLimitSubset(10, undefined) // true (requesting 10 items when unlimited are available)\n *\n * @param subset - The limit requirement to check\n * @param superset - The limit that might satisfy the requirement\n * @returns true if subset is satisfied by superset\n */\nexport function isLimitSubset(\n  subset: number | undefined,\n  superset: number | undefined\n): boolean {\n  // Unlimited superset satisfies any limit requirement\n  if (superset === undefined) {\n    return true\n  }\n\n  // If requesting all data (no limit), we need unlimited data to satisfy it\n  // But we know superset is not unlimited so we return false\n  if (subset === undefined) {\n    return false\n  }\n\n  // Otherwise, subset must be less than or equal to superset\n  return subset <= superset\n}\n\n/**\n * Check if one predicate (where + orderBy + limit) is a subset of another.\n * Returns true if all aspects of the subset predicate are satisfied by the superset.\n *\n * @example\n * isPredicateSubset(\n *   { where: gt(ref('age'), val(20)), limit: 10 },\n *   { where: gt(ref('age'), val(10)), limit: 20 }\n * ) // true\n *\n * @param subset - The predicate requirements to check\n * @param superset - The predicate that might satisfy the requirements\n * @returns true if subset is satisfied by superset\n */\nexport function isPredicateSubset(\n  subset: LoadSubsetOptions,\n  superset: LoadSubsetOptions\n): boolean {\n  return (\n    isWhereSubset(subset.where, superset.where) &&\n    isOrderBySubset(subset.orderBy, superset.orderBy) &&\n    isLimitSubset(subset.limit, superset.limit)\n  )\n}\n\n// ============================================================================\n// Helper functions\n// ============================================================================\n\n/**\n * Find common conditions between two predicates.\n * Returns an array of conditions that appear in both predicates.\n */\nfunction findCommonConditions(\n  predicate1: BasicExpression<boolean>,\n  predicate2: BasicExpression<boolean>\n): Array<BasicExpression<boolean>> {\n  const conditions1 = extractAllConditions(predicate1)\n  const conditions2 = extractAllConditions(predicate2)\n\n  const common: Array<BasicExpression<boolean>> = []\n\n  for (const cond1 of conditions1) {\n    for (const cond2 of conditions2) {\n      if (areExpressionsEqual(cond1, cond2)) {\n        // Avoid duplicates\n        if (!common.some((c) => areExpressionsEqual(c, cond1))) {\n          common.push(cond1)\n        }\n        break\n      }\n    }\n  }\n\n  return common\n}\n\n/**\n * Extract all individual conditions from a predicate, flattening AND operations.\n */\nfunction extractAllConditions(\n  predicate: BasicExpression<boolean>\n): Array<BasicExpression<boolean>> {\n  if (predicate.type === `func` && predicate.name === `and`) {\n    const conditions: Array<BasicExpression<boolean>> = []\n    for (const arg of predicate.args) {\n      conditions.push(...extractAllConditions(arg as BasicExpression<boolean>))\n    }\n    return conditions\n  }\n\n  return [predicate]\n}\n\n/**\n * Remove specified conditions from a predicate.\n * Returns the predicate with the specified conditions removed, or undefined if all conditions are removed.\n */\nfunction removeConditions(\n  predicate: BasicExpression<boolean>,\n  conditionsToRemove: Array<BasicExpression<boolean>>\n): BasicExpression<boolean> | undefined {\n  if (predicate.type === `func` && predicate.name === `and`) {\n    const remainingArgs = predicate.args.filter(\n      (arg) =>\n        !conditionsToRemove.some((cond) =>\n          areExpressionsEqual(arg as BasicExpression<boolean>, cond)\n        )\n    )\n\n    if (remainingArgs.length === 0) {\n      return undefined\n    } else if (remainingArgs.length === 1) {\n      return remainingArgs[0]!\n    } else {\n      return {\n        type: `func`,\n        name: `and`,\n        args: remainingArgs,\n      } as BasicExpression<boolean>\n    }\n  }\n\n  // For non-AND predicates, don't remove anything\n  return predicate\n}\n\n/**\n * Combine multiple conditions into a single predicate using AND logic.\n * Flattens nested AND operations to avoid unnecessary nesting.\n */\nfunction combineConditions(\n  conditions: Array<BasicExpression<boolean>>\n): BasicExpression<boolean> {\n  if (conditions.length === 0) {\n    return { type: `val`, value: true } as BasicExpression<boolean>\n  } else if (conditions.length === 1) {\n    return conditions[0]!\n  } else {\n    // Flatten all conditions, including those that are already AND operations\n    const flattenedConditions: Array<BasicExpression<boolean>> = []\n\n    for (const condition of conditions) {\n      if (condition.type === `func` && condition.name === `and`) {\n        // Flatten nested AND operations\n        flattenedConditions.push(...condition.args)\n      } else {\n        flattenedConditions.push(condition)\n      }\n    }\n\n    if (flattenedConditions.length === 1) {\n      return flattenedConditions[0]!\n    } else {\n      return {\n        type: `func`,\n        name: `and`,\n        args: flattenedConditions,\n      } as BasicExpression<boolean>\n    }\n  }\n}\n\n/**\n * Find a predicate with a specific operator and value\n */\nfunction findPredicateWithOperator(\n  predicates: Array<BasicExpression<boolean>>,\n  operator: string,\n  value: any\n): BasicExpression<boolean> | undefined {\n  return predicates.find((p) => {\n    if (p.type === `func`) {\n      const f = p as Func\n      const field = extractComparisonField(f)\n      return f.name === operator && field && areValuesEqual(field.value, value)\n    }\n    return false\n  })\n}\n\nfunction areExpressionsEqual(a: BasicExpression, b: BasicExpression): boolean {\n  if (a.type !== b.type) {\n    return false\n  }\n\n  if (a.type === `val` && b.type === `val`) {\n    return areValuesEqual(a.value, b.value)\n  }\n\n  if (a.type === `ref` && b.type === `ref`) {\n    return areRefsEqual(a, b)\n  }\n\n  if (a.type === `func` && b.type === `func`) {\n    const aFunc = a\n    const bFunc = b\n    if (aFunc.name !== bFunc.name) {\n      return false\n    }\n    if (aFunc.args.length !== bFunc.args.length) {\n      return false\n    }\n    return aFunc.args.every((arg, i) =>\n      areExpressionsEqual(arg, bFunc.args[i]!)\n    )\n  }\n\n  return false\n}\n\nfunction areValuesEqual(a: any, b: any): boolean {\n  // Simple equality check - could be enhanced for deep object comparison\n  if (a === b) {\n    return true\n  }\n\n  // Handle NaN\n  if (typeof a === `number` && typeof b === `number` && isNaN(a) && isNaN(b)) {\n    return true\n  }\n\n  // Handle Date objects\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime()\n  }\n\n  // For arrays and objects, use reference equality\n  // (In practice, we don't need deep equality for these cases -\n  // same object reference means same value for our use case)\n  if (\n    typeof a === `object` &&\n    typeof b === `object` &&\n    a !== null &&\n    b !== null\n  ) {\n    return a === b\n  }\n\n  return false\n}\n\nfunction areRefsEqual(a: PropRef, b: PropRef): boolean {\n  if (a.path.length !== b.path.length) {\n    return false\n  }\n  return a.path.every((segment, i) => segment === b.path[i])\n}\n\n/**\n * Check if a value is a primitive (string, number, boolean, null, undefined)\n * Primitives can use Set for fast lookups\n */\nfunction isPrimitive(value: any): boolean {\n  return (\n    value === null ||\n    value === undefined ||\n    typeof value === `string` ||\n    typeof value === `number` ||\n    typeof value === `boolean`\n  )\n}\n\n/**\n * Check if all values in an array are primitives\n */\nfunction areAllPrimitives(values: Array<any>): boolean {\n  return values.every(isPrimitive)\n}\n\n/**\n * Check if a value is in an array, with optional pre-built Set for optimization.\n * The primitiveSet is cached in InField during extraction and reused for all lookups.\n */\nfunction arrayIncludesWithSet(\n  array: Array<any>,\n  value: any,\n  primitiveSet: Set<any> | null,\n  arrayIsAllPrimitives?: boolean\n): boolean {\n  // Fast path: use pre-built Set for O(1) lookup\n  if (primitiveSet) {\n    // Skip isPrimitive check if we know the value must be primitive for a match\n    // (if array is all primitives, only primitives can match)\n    if (arrayIsAllPrimitives || isPrimitive(value)) {\n      return primitiveSet.has(value)\n    }\n    return false // Non-primitive can't be in primitive-only set\n  }\n\n  // Fallback: use areValuesEqual for Dates and objects\n  return array.some((v) => areValuesEqual(v, value))\n}\n\n/**\n * Get the maximum of two values, handling both numbers and Dates\n */\nfunction maxValue(a: any, b: any): any {\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() > b.getTime() ? a : b\n  }\n  return Math.max(a, b)\n}\n\n/**\n * Get the minimum of two values, handling both numbers and Dates\n */\nfunction minValue(a: any, b: any): any {\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() < b.getTime() ? a : b\n  }\n  return Math.min(a, b)\n}\n\nfunction areCompareOptionsEqual(\n  a: { direction?: `asc` | `desc`; [key: string]: any },\n  b: { direction?: `asc` | `desc`; [key: string]: any }\n): boolean {\n  // For now, just compare direction - could be enhanced for other options\n  return a.direction === b.direction\n}\n\ninterface ComparisonField {\n  ref: PropRef\n  value: any\n}\n\nfunction extractComparisonField(func: Func): ComparisonField | null {\n  // Handle comparison operators: eq, gt, gte, lt, lte\n  if ([`eq`, `gt`, `gte`, `lt`, `lte`].includes(func.name)) {\n    // Assume first arg is ref, second is value\n    const firstArg = func.args[0]\n    const secondArg = func.args[1]\n\n    if (firstArg?.type === `ref` && secondArg?.type === `val`) {\n      return {\n        ref: firstArg,\n        value: secondArg.value,\n      }\n    }\n  }\n\n  return null\n}\n\nfunction extractEqualityField(func: Func): ComparisonField | null {\n  if (func.name === `eq`) {\n    const firstArg = func.args[0]\n    const secondArg = func.args[1]\n\n    if (firstArg?.type === `ref` && secondArg?.type === `val`) {\n      return {\n        ref: firstArg,\n        value: secondArg.value,\n      }\n    }\n  }\n  return null\n}\n\ninterface InField {\n  ref: PropRef\n  values: Array<any>\n  // Cached optimization data (computed once, reused many times)\n  areAllPrimitives?: boolean\n  primitiveSet?: Set<any> | null\n}\n\nfunction extractInField(func: Func): InField | null {\n  if (func.name === `in`) {\n    const firstArg = func.args[0]\n    const secondArg = func.args[1]\n\n    if (\n      firstArg?.type === `ref` &&\n      secondArg?.type === `val` &&\n      Array.isArray(secondArg.value)\n    ) {\n      let values = secondArg.value\n      // Precompute optimization metadata once\n      const allPrimitives = areAllPrimitives(values)\n      let primitiveSet: Set<any> | null = null\n\n      if (allPrimitives && values.length > 10) {\n        // Build Set and dedupe values at the same time\n        primitiveSet = new Set(values)\n        // If we found duplicates, use the deduped array going forward\n        if (primitiveSet.size < values.length) {\n          values = Array.from(primitiveSet)\n        }\n      }\n\n      return {\n        ref: firstArg,\n        values,\n        areAllPrimitives: allPrimitives,\n        primitiveSet,\n      }\n    }\n  }\n  return null\n}\n\nfunction isComparisonSubset(\n  subsetFunc: Func,\n  subsetValue: any,\n  supersetFunc: Func,\n  supersetValue: any\n): boolean {\n  const subOp = subsetFunc.name\n  const superOp = supersetFunc.name\n\n  // Handle same operator\n  if (subOp === superOp) {\n    if (subOp === `eq`) {\n      // field = X is subset of field = X only\n      // Fast path: primitives can use strict equality\n      if (isPrimitive(subsetValue) && isPrimitive(supersetValue)) {\n        return subsetValue === supersetValue\n      }\n      return areValuesEqual(subsetValue, supersetValue)\n    } else if (subOp === `gt`) {\n      // field > 20 is subset of field > 10 if 20 > 10\n      return subsetValue >= supersetValue\n    } else if (subOp === `gte`) {\n      // field >= 20 is subset of field >= 10 if 20 >= 10\n      return subsetValue >= supersetValue\n    } else if (subOp === `lt`) {\n      // field < 10 is subset of field < 20 if 10 <= 20\n      return subsetValue <= supersetValue\n    } else if (subOp === `lte`) {\n      // field <= 10 is subset of field <= 20 if 10 <= 20\n      return subsetValue <= supersetValue\n    }\n  }\n\n  // Handle different operators on same field\n  // eq vs gt/gte: field = 15 is subset of field > 10 if 15 > 10\n  if (subOp === `eq` && superOp === `gt`) {\n    return subsetValue > supersetValue\n  }\n  if (subOp === `eq` && superOp === `gte`) {\n    return subsetValue >= supersetValue\n  }\n  if (subOp === `eq` && superOp === `lt`) {\n    return subsetValue < supersetValue\n  }\n  if (subOp === `eq` && superOp === `lte`) {\n    return subsetValue <= supersetValue\n  }\n\n  // gt/gte vs gte/gt\n  if (subOp === `gt` && superOp === `gte`) {\n    // field > 10 is subset of field >= 10 if 10 >= 10 (always true for same value)\n    return subsetValue >= supersetValue\n  }\n  if (subOp === `gte` && superOp === `gt`) {\n    // field >= 11 is subset of field > 10 if 11 > 10\n    return subsetValue > supersetValue\n  }\n\n  // lt/lte vs lte/lt\n  if (subOp === `lt` && superOp === `lte`) {\n    // field < 10 is subset of field <= 10 if 10 <= 10\n    return subsetValue <= supersetValue\n  }\n  if (subOp === `lte` && superOp === `lt`) {\n    // field <= 9 is subset of field < 10 if 9 < 10\n    return subsetValue < supersetValue\n  }\n\n  return false\n}\n\nfunction groupPredicatesByField(\n  predicates: Array<BasicExpression<boolean>>\n): Map<string | null, Array<BasicExpression<boolean>>> {\n  const groups = new Map<string | null, Array<BasicExpression<boolean>>>()\n\n  for (const pred of predicates) {\n    let fieldKey: string | null = null\n\n    if (pred.type === `func`) {\n      const func = pred as Func\n      const field =\n        extractComparisonField(func) ||\n        extractEqualityField(func) ||\n        extractInField(func)\n      if (field) {\n        fieldKey = field.ref.path.join(`.`)\n      }\n    }\n\n    const group = groups.get(fieldKey) || []\n    group.push(pred)\n    groups.set(fieldKey, group)\n  }\n\n  return groups\n}\n\nfunction unionSameFieldPredicates(\n  predicates: Array<BasicExpression<boolean>>\n): BasicExpression<boolean> | null {\n  if (predicates.length === 1) {\n    return predicates[0]!\n  }\n\n  // Try to extract range constraints\n  let maxGt: number | null = null\n  let maxGte: number | null = null\n  let minLt: number | null = null\n  let minLte: number | null = null\n  const eqValues: Set<any> = new Set()\n  const inValues: Set<any> = new Set()\n  const otherPredicates: Array<BasicExpression<boolean>> = []\n\n  for (const pred of predicates) {\n    if (pred.type === `func`) {\n      const func = pred as Func\n      const field = extractComparisonField(func)\n\n      if (field) {\n        const value = field.value\n        if (func.name === `gt`) {\n          maxGt = maxGt === null ? value : minValue(maxGt, value)\n        } else if (func.name === `gte`) {\n          maxGte = maxGte === null ? value : minValue(maxGte, value)\n        } else if (func.name === `lt`) {\n          minLt = minLt === null ? value : maxValue(minLt, value)\n        } else if (func.name === `lte`) {\n          minLte = minLte === null ? value : maxValue(minLte, value)\n        } else if (func.name === `eq`) {\n          eqValues.add(value)\n        } else {\n          otherPredicates.push(pred)\n        }\n      } else {\n        const inField = extractInField(func)\n        if (inField) {\n          for (const val of inField.values) {\n            inValues.add(val)\n          }\n        } else {\n          otherPredicates.push(pred)\n        }\n      }\n    } else {\n      otherPredicates.push(pred)\n    }\n  }\n\n  // If we have multiple equality values, combine into IN\n  if (eqValues.size > 1 || (eqValues.size > 0 && inValues.size > 0)) {\n    const allValues = [...eqValues, ...inValues]\n    const ref = predicates.find((p) => {\n      if (p.type === `func`) {\n        const field =\n          extractComparisonField(p as Func) || extractInField(p as Func)\n        return field !== null\n      }\n      return false\n    })\n\n    if (ref && ref.type === `func`) {\n      const field =\n        extractComparisonField(ref as Func) || extractInField(ref as Func)\n      if (field) {\n        return {\n          type: `func`,\n          name: `in`,\n          args: [\n            field.ref,\n            { type: `val`, value: allValues } as BasicExpression,\n          ],\n        } as BasicExpression<boolean>\n      }\n    }\n  }\n\n  // Build the least restrictive range\n  const result: Array<BasicExpression<boolean>> = []\n\n  // Choose the least restrictive lower bound\n  if (maxGt !== null && maxGte !== null) {\n    // Take the smaller one (less restrictive)\n    const pred =\n      maxGte <= maxGt\n        ? findPredicateWithOperator(predicates, `gte`, maxGte)\n        : findPredicateWithOperator(predicates, `gt`, maxGt)\n    if (pred) result.push(pred)\n  } else if (maxGt !== null) {\n    const pred = findPredicateWithOperator(predicates, `gt`, maxGt)\n    if (pred) result.push(pred)\n  } else if (maxGte !== null) {\n    const pred = findPredicateWithOperator(predicates, `gte`, maxGte)\n    if (pred) result.push(pred)\n  }\n\n  // Choose the least restrictive upper bound\n  if (minLt !== null && minLte !== null) {\n    const pred =\n      minLte >= minLt\n        ? findPredicateWithOperator(predicates, `lte`, minLte)\n        : findPredicateWithOperator(predicates, `lt`, minLt)\n    if (pred) result.push(pred)\n  } else if (minLt !== null) {\n    const pred = findPredicateWithOperator(predicates, `lt`, minLt)\n    if (pred) result.push(pred)\n  } else if (minLte !== null) {\n    const pred = findPredicateWithOperator(predicates, `lte`, minLte)\n    if (pred) result.push(pred)\n  }\n\n  // Add single eq value\n  if (eqValues.size === 1 && inValues.size === 0) {\n    const pred = findPredicateWithOperator(predicates, `eq`, [...eqValues][0])\n    if (pred) result.push(pred)\n  }\n\n  // Add IN if only IN values\n  if (eqValues.size === 0 && inValues.size > 0) {\n    result.push(\n      predicates.find((p) => {\n        if (p.type === `func`) {\n          return (p as Func).name === `in`\n        }\n        return false\n      })!\n    )\n  }\n\n  // Add other predicates\n  result.push(...otherPredicates)\n\n  if (result.length === 0) {\n    return { type: `val`, value: true } as BasicExpression<boolean>\n  }\n\n  if (result.length === 1) {\n    return result[0]!\n  }\n\n  return {\n    type: `func`,\n    name: `or`,\n    args: result,\n  } as BasicExpression<boolean>\n}\n", "import {\n  isPredicateSubset,\n  isWhereSubset,\n  minusWherePredicates,\n  unionWherePredicates,\n} from \"./predicate-utils.js\"\nimport type { BasicExpression } from \"./ir.js\"\nimport type { LoadSubsetOptions } from \"../types.js\"\n\n/**\n * Deduplicated wrapper for a loadSubset function.\n * Tracks what data has been loaded and avoids redundant calls by applying\n * subset logic to predicates.\n *\n * @param opts - The options for the DeduplicatedLoadSubset\n * @param opts.loadSubset - The underlying loadSubset function to wrap\n * @param opts.onDeduplicate - An optional callback function that is invoked when a loadSubset call is deduplicated.\n *                              If the call is deduplicated because the requested data is being loaded by an inflight request,\n *                              then this callback is invoked when the inflight request completes successfully and the data is fully loaded.\n *                              This callback is useful if you need to track rows per query, in which case you can't ignore deduplicated calls\n *                              because you need to know which rows were loaded for each query.\n * @example\n * const dedupe = new DeduplicatedLoadSubset({ loadSubset: myLoadSubset, onDeduplicate: (opts) => console.log(`Call was deduplicated:`, opts) })\n *\n * // First call - fetches data\n * await dedupe.loadSubset({ where: gt(ref('age'), val(10)) })\n *\n * // Second call - subset of first, returns true immediately\n * await dedupe.loadSubset({ where: gt(ref('age'), val(20)) })\n *\n * // Clear state to start fresh\n * dedupe.reset()\n */\nexport class DeduplicatedLoadSubset {\n  // The underlying loadSubset function to wrap\n  private readonly _loadSubset: (\n    options: LoadSubsetOptions\n  ) => true | Promise<void>\n\n  // An optional callback function that is invoked when a loadSubset call is deduplicated.\n  private readonly onDeduplicate:\n    | ((options: LoadSubsetOptions) => void)\n    | undefined\n\n  // Combined where predicate for all unlimited calls (no limit)\n  private unlimitedWhere: BasicExpression<boolean> | undefined = undefined\n\n  // Flag to track if we've loaded all data (unlimited call with no where clause)\n  private hasLoadedAllData = false\n\n  // List of all limited calls (with limit, possibly with orderBy)\n  // We clone options before storing to prevent mutation of stored predicates\n  private limitedCalls: Array<LoadSubsetOptions> = []\n\n  // Track in-flight calls to prevent concurrent duplicate requests\n  // We store both the options and the promise so we can apply subset logic\n  private inflightCalls: Array<{\n    options: LoadSubsetOptions\n    promise: Promise<void>\n  }> = []\n\n  // Generation counter to invalidate in-flight requests after reset()\n  // When reset() is called, this increments, and any in-flight completion handlers\n  // check if their captured generation matches before updating tracking state\n  private generation = 0\n\n  constructor(opts: {\n    loadSubset: (options: LoadSubsetOptions) => true | Promise<void>\n    onDeduplicate?: (options: LoadSubsetOptions) => void\n  }) {\n    this._loadSubset = opts.loadSubset\n    this.onDeduplicate = opts.onDeduplicate\n  }\n\n  /**\n   * Load a subset of data, with automatic deduplication based on previously\n   * loaded predicates and in-flight requests.\n   *\n   * This method is auto-bound, so it can be safely passed as a callback without\n   * losing its `this` context (e.g., `loadSubset: dedupe.loadSubset` in a sync config).\n   *\n   * @param options - The predicate options (where, orderBy, limit)\n   * @returns true if data is already loaded, or a Promise that resolves when data is loaded\n   */\n  loadSubset = (options: LoadSubsetOptions): true | Promise<void> => {\n    // If we've loaded all data, everything is covered\n    if (this.hasLoadedAllData) {\n      this.onDeduplicate?.(options)\n      return true\n    }\n\n    // Check against unlimited combined predicate\n    // If we've loaded all data matching a where clause, we don't need to refetch subsets\n    if (this.unlimitedWhere !== undefined && options.where !== undefined) {\n      if (isWhereSubset(options.where, this.unlimitedWhere)) {\n        this.onDeduplicate?.(options)\n        return true // Data already loaded via unlimited call\n      }\n    }\n\n    // Check against limited calls\n    if (options.limit !== undefined) {\n      const alreadyLoaded = this.limitedCalls.some((loaded) =>\n        isPredicateSubset(options, loaded)\n      )\n\n      if (alreadyLoaded) {\n        this.onDeduplicate?.(options)\n        return true // Already loaded\n      }\n    }\n\n    // Check against in-flight calls using the same subset logic as resolved calls\n    // This prevents duplicate requests when concurrent calls have subset relationships\n    const matchingInflight = this.inflightCalls.find((inflight) =>\n      isPredicateSubset(options, inflight.options)\n    )\n\n    if (matchingInflight !== undefined) {\n      // An in-flight call will load data that covers this request\n      // Return the same promise so this caller waits for the data to load\n      // The in-flight promise already handles tracking updates when it completes\n      const prom = matchingInflight.promise\n      // Call `onDeduplicate` when the inflight request has loaded the data\n      prom.then(() => this.onDeduplicate?.(options)).catch() // ignore errors\n      return prom\n    }\n\n    // Not fully covered by existing data\n    // Compute the subset of data that is not covered by the existing data\n    // such that we only have to load that subset of missing data\n    const clonedOptions = cloneOptions(options)\n    if (this.unlimitedWhere !== undefined && options.limit === undefined) {\n      // Compute difference to get only the missing data\n      // We can only do this for unlimited queries\n      // and we can only remove data that was loaded from unlimited queries\n      // because with limited queries we have no way to express that we already loaded part of the matching data\n      clonedOptions.where =\n        minusWherePredicates(clonedOptions.where, this.unlimitedWhere) ??\n        clonedOptions.where\n    }\n\n    // Call underlying loadSubset to load the missing data\n    const resultPromise = this._loadSubset(clonedOptions)\n\n    // Handle both sync (true) and async (Promise<void>) return values\n    if (resultPromise === true) {\n      // Sync return - update tracking synchronously\n      // Clone options before storing to protect against caller mutation\n      this.updateTracking(clonedOptions)\n      return true\n    } else {\n      // Async return - track the promise and update tracking after it resolves\n\n      // Capture the current generation - this lets us detect if reset() was called\n      // while this request was in-flight, so we can skip updating tracking state\n      const capturedGeneration = this.generation\n\n      // We need to create a reference to the in-flight entry so we can remove it later\n      const inflightEntry = {\n        options: clonedOptions, // Store cloned options for subset matching\n        promise: resultPromise\n          .then((result) => {\n            // Only update tracking if this request is still from the current generation\n            // If reset() was called, the generation will have incremented and we should\n            // not repopulate the state that was just cleared\n            if (capturedGeneration === this.generation) {\n              // Use the cloned options that we captured before any caller mutations\n              // This ensures we track exactly what was loaded, not what the caller changed\n              this.updateTracking(clonedOptions)\n            }\n            return result\n          })\n          .finally(() => {\n            // Always remove from in-flight array on completion OR rejection\n            // This ensures failed requests can be retried instead of being cached forever\n            const index = this.inflightCalls.indexOf(inflightEntry)\n            if (index !== -1) {\n              this.inflightCalls.splice(index, 1)\n            }\n          }),\n      }\n\n      // Store the in-flight entry so concurrent subset calls can wait for it\n      this.inflightCalls.push(inflightEntry)\n      return inflightEntry.promise\n    }\n  }\n\n  /**\n   * Reset all tracking state.\n   * Clears the history of loaded predicates and in-flight calls.\n   * Use this when you want to start fresh, for example after clearing the underlying data store.\n   *\n   * Note: Any in-flight requests will still complete, but they will not update the tracking\n   * state after the reset. This prevents old requests from repopulating cleared state.\n   */\n  reset(): void {\n    this.unlimitedWhere = undefined\n    this.hasLoadedAllData = false\n    this.limitedCalls = []\n    this.inflightCalls = []\n    // Increment generation to invalidate any in-flight completion handlers\n    // This ensures requests that were started before reset() don't repopulate the state\n    this.generation++\n  }\n\n  private updateTracking(options: LoadSubsetOptions): void {\n    // Update tracking based on whether this was a limited or unlimited call\n    if (options.limit === undefined) {\n      // Unlimited call - update combined where predicate\n      // We ignore orderBy for unlimited calls as mentioned in requirements\n      if (options.where === undefined) {\n        // No where clause = all data loaded\n        this.hasLoadedAllData = true\n        this.unlimitedWhere = undefined\n        this.limitedCalls = []\n        this.inflightCalls = []\n      } else if (this.unlimitedWhere === undefined) {\n        this.unlimitedWhere = options.where\n      } else {\n        this.unlimitedWhere = unionWherePredicates([\n          this.unlimitedWhere,\n          options.where,\n        ])\n      }\n    } else {\n      // Limited call - add to list for future subset checks\n      // Options are already cloned by caller to prevent mutation issues\n      this.limitedCalls.push(options)\n    }\n  }\n}\n\n/**\n * Clones a LoadSubsetOptions object to prevent mutation of stored predicates.\n * This is crucial because callers often reuse the same options object and mutate\n * properties like limit or where between calls. Without cloning, our stored history\n * would reflect the mutated values rather than what was actually loaded.\n */\nexport function cloneOptions(options: LoadSubsetOptions): LoadSubsetOptions {\n  return { ...options }\n}\n", "import type { AnyFunction } from '@tanstack/pacer/types'\n\n/**\n * Options for configuring a lite debounced function\n */\nexport interface LiteDebouncerOptions<TFn extends AnyFunction = AnyFunction> {\n  /**\n   * Whether to execute on the leading edge of the timeout.\n   * The first call will execute immediately and the rest will wait the delay.\n   * Defaults to false.\n   */\n  leading?: boolean\n  /**\n   * Callback function that is called after the function is executed\n   */\n  onExecute?: (args: Parameters<TFn>, debouncer: LiteDebouncer<TFn>) => void\n  /**\n   * Whether to execute on the trailing edge of the timeout.\n   * Defaults to true.\n   */\n  trailing?: boolean\n  /**\n   * Delay in milliseconds before executing the function.\n   */\n  wait: number\n}\n\n/**\n * A lightweight class that creates a debounced function.\n *\n * This is an alternative to the Debouncer in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core Debouncer,\n * this version does not use TanStack Store for state management, has no devtools integration,\n * and provides only essential debouncing functionality.\n *\n * Debouncing ensures that a function is only executed after a certain amount of time has passed\n * since its last invocation. This is useful for handling frequent events like window resizing,\n * scroll events, or input changes where you want to limit the rate of execution.\n *\n * The debounced function can be configured to execute either at the start of the delay period\n * (leading edge) or at the end (trailing edge, default). Each new call during the wait period\n * will reset the timer.\n *\n * Features:\n * - Zero dependencies - no external libraries required\n * - Minimal API surface - only essential methods (maybeExecute, flush, cancel)\n * - Simple state management - uses basic private properties instead of reactive stores\n * - Callback support for monitoring execution events\n * - Lightweight - designed for use in npm packages where bundle size matters\n *\n * @example\n * ```ts\n * const debouncer = new LiteDebouncer((value: string) => {\n *   saveToDatabase(value);\n * }, {\n *   wait: 500,\n *   onExecute: (args, debouncer) => {\n *     console.log('Saved value:', args[0]);\n *   }\n * });\n *\n * // Will only save after 500ms of no new input\n * inputElement.addEventListener('input', () => {\n *   debouncer.maybeExecute(inputElement.value);\n * });\n * ```\n */\nexport class LiteDebouncer<TFn extends AnyFunction> {\n  private timeoutId: NodeJS.Timeout | undefined\n  private lastArgs: Parameters<TFn> | undefined\n  private canLeadingExecute = true\n\n  constructor(\n    public fn: TFn,\n    public options: LiteDebouncerOptions<TFn>,\n  ) {\n    // Default trailing to true if neither leading nor trailing is specified\n    if (\n      this.options.leading === undefined &&\n      this.options.trailing === undefined\n    ) {\n      this.options.trailing = true\n    }\n  }\n\n  /**\n   * Attempts to execute the debounced function.\n   * If leading is true and this is the first call, executes immediately.\n   * Otherwise, queues the execution for after the wait time.\n   * Each new call resets the timer.\n   */\n  maybeExecute = (...args: Parameters<TFn>): void => {\n    let didLeadingExecute = false\n\n    if (this.options.leading && this.canLeadingExecute) {\n      this.canLeadingExecute = false\n      didLeadingExecute = true\n      this.fn(...args)\n      this.options.onExecute?.(args, this)\n    }\n\n    this.lastArgs = args\n\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n    }\n\n    this.timeoutId = setTimeout(() => {\n      this.canLeadingExecute = true\n      if (this.options.trailing && !didLeadingExecute && this.lastArgs) {\n        this.fn(...this.lastArgs)\n        this.options.onExecute?.(this.lastArgs, this)\n      }\n      this.lastArgs = undefined\n    }, this.options.wait)\n  }\n\n  /**\n   * Processes the current pending execution immediately.\n   * If there's a pending execution, it will be executed right away\n   * and the timeout will be cleared.\n   */\n  flush = (): void => {\n    if (this.timeoutId && this.lastArgs) {\n      clearTimeout(this.timeoutId)\n      this.timeoutId = undefined\n      const args = this.lastArgs\n      this.fn(...args)\n      this.options.onExecute?.(args, this)\n      this.lastArgs = undefined\n      this.canLeadingExecute = true\n    }\n  }\n\n  /**\n   * Cancels any pending execution.\n   * Clears the timeout and resets the internal state.\n   */\n  cancel = (): void => {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n      this.timeoutId = undefined\n    }\n    this.lastArgs = undefined\n    this.canLeadingExecute = true\n  }\n}\n\n/**\n * Creates a lightweight debounced function that delays invoking the provided function until after a specified wait time.\n * Multiple calls during the wait period will cancel previous pending invocations and reset the timer.\n *\n * This is an alternative to the debounce function in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core version,\n * this function creates a debouncer with no external dependencies, devtools integration, or reactive state.\n *\n * If leading option is true, the function will execute immediately on the first call, then wait the delay\n * before allowing another execution.\n *\n * @example\n * ```ts\n * const debouncedSave = liteDebounce(() => {\n *   saveChanges();\n * }, { wait: 1000 });\n *\n * // Called repeatedly but executes at most once per second\n * inputElement.addEventListener('input', debouncedSave);\n * ```\n *\n * @example\n * ```ts\n * // Leading edge execution - fires immediately then waits\n * const debouncedSearch = liteDebounce((query: string) => {\n *   performSearch(query);\n * }, { wait: 300, leading: true });\n * ```\n */\nexport function liteDebounce<TFn extends AnyFunction>(\n  fn: TFn,\n  options: LiteDebouncerOptions<TFn>,\n): (...args: Parameters<TFn>) => void {\n  const debouncer = new LiteDebouncer(fn, options)\n  return debouncer.maybeExecute\n}\n", "import { LiteDebouncer } from \"@tanstack/pacer-lite/lite-debouncer\"\nimport type { DebounceStrategy, DebounceStrategyOptions } from \"./types\"\nimport type { Transaction } from \"../transactions\"\n\n/**\n * Creates a debounce strategy that delays transaction execution until after\n * a period of inactivity.\n *\n * Ideal for scenarios like search inputs or auto-save fields where you want\n * to wait for the user to stop typing before persisting changes.\n *\n * @param options - Configuration for the debounce behavior\n * @returns A debounce strategy instance\n *\n * @example\n * ```ts\n * const mutate = usePacedMutations({\n *   onMutate: (value) => {\n *     collection.update(id, draft => { draft.value = value })\n *   },\n *   mutationFn: async ({ transaction }) => {\n *     await api.save(transaction.mutations)\n *   },\n *   strategy: debounceStrategy({ wait: 500 })\n * })\n * ```\n */\nexport function debounceStrategy(\n  options: DebounceStrategyOptions\n): DebounceStrategy {\n  const debouncer = new LiteDebouncer(\n    (callback: () => Transaction) => callback(),\n    options\n  )\n\n  return {\n    _type: `debounce`,\n    options,\n    execute: <T extends object = Record<string, unknown>>(\n      fn: () => Transaction<T>\n    ) => {\n      debouncer.maybeExecute(fn as () => Transaction)\n    },\n    cleanup: () => {\n      debouncer.cancel()\n    },\n  }\n}\n", "/**\n * Position type for addItem and getNextItem operations.\n *\n * - 'front': Operate on the front of the queue (FIFO for getNextItem)\n * - 'back': Operate on the back of the queue (LIFO for getNextItem)\n */\nexport type QueuePosition = 'front' | 'back'\n\n/**\n * Options for configuring a lite queuer instance\n */\nexport interface LiteQueuerOptions<TValue> {\n  /**\n   * Default position to add items to the queue\n   * @default 'back'\n   */\n  addItemsTo?: QueuePosition\n  /**\n   * Default position to get items from during processing\n   * @default 'front'\n   */\n  getItemsFrom?: QueuePosition\n  /**\n   * Function to determine priority of items in the queue\n   * Higher priority items will be processed first\n   * Return undefined for items that should use positional ordering\n   */\n  getPriority?: (item: TValue) => number | undefined\n  /**\n   * Initial items to populate the queue with\n   */\n  initialItems?: Array<TValue>\n  /**\n   * Maximum number of items allowed in the queue\n   */\n  maxSize?: number\n  /**\n   * Whether the queuer should start processing items immediately\n   * @default true\n   */\n  started?: boolean\n  /**\n   * Time in milliseconds to wait between processing items\n   * @default 0\n   */\n  wait?: number\n}\n\n/**\n * A lightweight class that creates a queue for processing items.\n *\n * This is an alternative to the Queuer in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core Queuer,\n * this version does not use TanStack Store for state management, has no devtools integration,\n * no callbacks, and provides only essential queueing functionality.\n *\n * The queuer supports FIFO (First In First Out), LIFO (Last In First Out), and priority-based\n * processing of items. Items can be processed automatically with configurable wait times\n * between executions, or processed manually using the execute methods.\n *\n * Features included:\n * - Automatic or manual processing of items\n * - FIFO, LIFO, and priority-based ordering\n * - Queue size limits with item rejection\n * - Configurable wait times between processing\n * - Batch processing capabilities\n * - Start/stop processing control\n * - Callback support for monitoring execution, rejection, and state change events\n *\n * Features NOT included (compared to core Queuer):\n * - No TanStack Store state management\n * - No devtools integration\n * - No item expiration functionality (no onExpire callback)\n * - No dynamic options updates (setOptions)\n * - No detailed state tracking (execution counts, etc.)\n *\n * Queue behavior:\n * - Default: FIFO (add to back, process from front)\n * - LIFO: Configure addItemsTo: 'back', getItemsFrom: 'back'\n * - Priority: Provide getPriority function; higher values processed first\n *\n * @example\n * ```ts\n * // Basic FIFO queue\n * const queue = new LiteQueuer((item: string) => {\n *   console.log('Processing:', item);\n * }, { wait: 100 });\n *\n * queue.addItem('task1');\n * queue.addItem('task2');\n * // Processes: task1, then task2 after 100ms delay\n * ```\n *\n * @example\n * ```ts\n * // Priority queue\n * const priorityQueue = new LiteQueuer((item: Task) => {\n *   processTask(item);\n * }, {\n *   getPriority: task => task.priority,\n *   wait: 500\n * });\n *\n * priorityQueue.addItem({ name: 'low', priority: 1 });\n * priorityQueue.addItem({ name: 'high', priority: 10 });\n * // Processes high priority task first\n * ```\n */\nexport class LiteQueuer<TValue> {\n  private items: Array<TValue> = []\n  private timeoutId: NodeJS.Timeout | null = null\n  private isRunning = true\n  private pendingTick = false\n\n  constructor(\n    public fn: (item: TValue) => void,\n    public options: LiteQueuerOptions<TValue> = {},\n  ) {\n    // Set defaults\n    this.options.addItemsTo = this.options.addItemsTo ?? 'back'\n    this.options.getItemsFrom = this.options.getItemsFrom ?? 'front'\n    this.options.maxSize = this.options.maxSize ?? Infinity\n    this.options.started = this.options.started ?? true\n    this.options.wait = this.options.wait ?? 0\n\n    this.isRunning = this.options.started\n\n    // Add initial items if provided\n    if (this.options.initialItems) {\n      for (const item of this.options.initialItems) {\n        this.addItem(item, this.options.addItemsTo, false)\n      }\n    }\n\n    // Start processing if enabled and has items\n    if (this.isRunning && this.items.length > 0) {\n      this.tick()\n    }\n  }\n\n  /**\n   * Number of items currently in the queue\n   */\n  get size(): number {\n    return this.items.length\n  }\n\n  /**\n   * Whether the queue is empty\n   */\n  get isEmpty(): boolean {\n    return this.items.length === 0\n  }\n\n  /**\n   * Whether the queue is currently running (auto-processing items)\n   */\n  get isQueueRunning(): boolean {\n    return this.isRunning\n  }\n\n  /**\n   * Adds an item to the queue. If the queue is full, the item is rejected.\n   * Items can be inserted at the front or back, and priority ordering is applied if getPriority is configured.\n   *\n   * Returns true if the item was added, false if the queue is full.\n   *\n   * @example\n   * ```ts\n   * queue.addItem('task1');           // Add to default position (back)\n   * queue.addItem('task2', 'front');  // Add to front\n   * ```\n   */\n  addItem = (\n    item: TValue,\n    position: QueuePosition = this.options.addItemsTo!,\n    startProcessing: boolean = true,\n  ): boolean => {\n    // Check size limit\n    if (this.items.length >= this.options.maxSize!) {\n      return false\n    }\n\n    // Handle priority insertion\n    if (this.options.getPriority) {\n      const priority = this.options.getPriority(item)\n      if (priority !== undefined) {\n        // Find insertion point for priority\n        const insertIndex = this.items.findIndex((existing) => {\n          const existingPriority = this.options.getPriority!(existing)\n          // Treat undefined priority as negative infinity for comparison\n          const effectivePriority = existingPriority ?? -Infinity\n          return effectivePriority < priority\n        })\n\n        if (insertIndex === -1) {\n          this.items.push(item)\n        } else {\n          this.items.splice(insertIndex, 0, item)\n        }\n      } else {\n        // No priority, use position\n        this.insertAtPosition(item, position)\n      }\n    } else {\n      // No priority function, use position\n      this.insertAtPosition(item, position)\n    }\n\n    // Start processing if running and not already processing\n    if (startProcessing && this.isRunning && !this.pendingTick) {\n      this.tick()\n    }\n\n    return true\n  }\n\n  private insertAtPosition = (item: TValue, position: QueuePosition): void => {\n    if (position === 'front') {\n      this.items.unshift(item)\n    } else {\n      this.items.push(item)\n    }\n  }\n\n  /**\n   * Removes and returns the next item from the queue without executing the function.\n   * Use for manual queue management. Normally, use execute() to process items.\n   *\n   * @example\n   * ```ts\n   * const nextItem = queue.getNextItem();        // Get from default position (front)\n   * const lastItem = queue.getNextItem('back');  // Get from back (LIFO)\n   * ```\n   */\n  getNextItem = (\n    position: QueuePosition = this.options.getItemsFrom!,\n  ): TValue | undefined => {\n    if (this.items.length === 0) {\n      return undefined\n    }\n\n    let item: TValue | undefined\n\n    // When priority function is provided, always get from front (highest priority)\n    if (this.options.getPriority || position === 'front') {\n      item = this.items.shift()\n    } else {\n      item = this.items.pop()\n    }\n\n    return item\n  }\n\n  /**\n   * Removes and returns the next item from the queue and processes it using the provided function.\n   *\n   * @example\n   * ```ts\n   * queue.execute();        // Execute from default position\n   * queue.execute('back');  // Execute from back (LIFO)\n   * ```\n   */\n  execute = (position?: QueuePosition): TValue | undefined => {\n    const item = this.getNextItem(position)\n    if (item !== undefined) {\n      this.fn(item)\n    }\n    return item\n  }\n\n  /**\n   * Internal method that processes items in the queue with wait intervals\n   */\n  private tick = (): void => {\n    if (!this.isRunning) {\n      this.pendingTick = false\n      return\n    }\n\n    this.pendingTick = true\n\n    // Process items while queue is not empty\n    while (this.items.length > 0) {\n      const item = this.execute(this.options.getItemsFrom)\n      if (item === undefined) {\n        break\n      }\n\n      const wait = this.options.wait!\n      if (wait > 0) {\n        // Schedule next processing after wait time\n        this.timeoutId = setTimeout(() => this.tick(), wait)\n        return\n      }\n\n      // No wait time, continue processing immediately\n    }\n\n    this.pendingTick = false\n  }\n\n  /**\n   * Starts processing items in the queue. If already running, does nothing.\n   */\n  start = (): void => {\n    this.isRunning = true\n    if (!this.pendingTick && this.items.length > 0) {\n      this.tick()\n    }\n  }\n\n  /**\n   * Stops processing items in the queue. Does not clear the queue.\n   */\n  stop = (): void => {\n    this.clearTimeout()\n    this.isRunning = false\n    this.pendingTick = false\n  }\n\n  /**\n   * Clears any pending timeout\n   */\n  private clearTimeout = (): void => {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n      this.timeoutId = null\n    }\n  }\n\n  /**\n   * Returns the next item in the queue without removing it.\n   *\n   * @example\n   * ```ts\n   * const next = queue.peekNextItem();        // Peek at front\n   * const last = queue.peekNextItem('back');  // Peek at back\n   * ```\n   */\n  peekNextItem = (position: QueuePosition = 'front'): TValue | undefined => {\n    if (this.items.length === 0) {\n      return undefined\n    }\n\n    if (this.options.getPriority || position === 'front') {\n      return this.items[0]\n    } else {\n      return this.items[this.items.length - 1]\n    }\n  }\n\n  /**\n   * Returns a copy of all items in the queue.\n   */\n  peekAllItems = (): Array<TValue> => {\n    return [...this.items]\n  }\n\n  /**\n   * Processes a specified number of items immediately with no wait time.\n   * If no numberOfItems is provided, all items will be processed.\n   *\n   * @example\n   * ```ts\n   * queue.flush();     // Process all items immediately\n   * queue.flush(3);    // Process next 3 items immediately\n   * ```\n   */\n  flush = (\n    numberOfItems: number = this.items.length,\n    position?: QueuePosition,\n  ): void => {\n    this.clearTimeout() // Clear any pending timeout\n    for (let i = 0; i < numberOfItems && this.items.length > 0; i++) {\n      this.execute(position)\n    }\n    // Restart normal processing if still running and has items\n    if (this.isRunning && this.items.length > 0 && !this.pendingTick) {\n      this.tick()\n    }\n  }\n\n  /**\n   * Processes all items in the queue as a batch using the provided function.\n   * The queue is cleared after processing.\n   *\n   * @example\n   * ```ts\n   * queue.flushAsBatch((items) => {\n   *   console.log('Processing batch:', items);\n   *   // Process all items together\n   * });\n   * ```\n   */\n  flushAsBatch = (batchFunction: (items: Array<TValue>) => void): void => {\n    const items = this.peekAllItems()\n    this.clear()\n    batchFunction(items)\n  }\n\n  /**\n   * Removes all items from the queue. Does not affect items being processed.\n   */\n  clear = (): void => {\n    this.items = []\n  }\n}\n\n/**\n * Creates a lightweight queue that processes items using the provided function.\n *\n * This is an alternative to the queue function in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core version,\n * this function creates a queuer with no external dependencies, devtools integration, or reactive state.\n *\n * @example\n * ```ts\n * const processItem = liteQueue((item: string) => {\n *   console.log('Processing:', item);\n * }, { wait: 1000 });\n *\n * processItem('task1');\n * processItem('task2');\n * // Processes each item with 1 second delay between them\n * ```\n */\nexport function liteQueue<TValue>(\n  fn: (item: TValue) => void,\n  options: LiteQueuerOptions<TValue> = {},\n): (item: TValue) => boolean {\n  const queuer = new LiteQueuer(fn, options)\n  return (item: TValue) => queuer.addItem(item)\n}\n", "import { LiteQueuer } from \"@tanstack/pacer-lite/lite-queuer\"\nimport type { QueueStrategy, QueueStrategyOptions } from \"./types\"\nimport type { Transaction } from \"../transactions\"\n\n/**\n * Creates a queue strategy that processes all mutations in order with proper serialization.\n *\n * Unlike other strategies that may drop executions, queue ensures every\n * mutation is processed sequentially. Each transaction commit completes before\n * the next one starts. Useful when data consistency is critical and\n * every operation must complete in order.\n *\n * @param options - Configuration for queue behavior (FIFO/LIFO, timing, size limits)\n * @returns A queue strategy instance\n *\n * @example\n * ```ts\n * // FIFO queue - process in order received\n * const mutate = usePacedMutations({\n *   mutationFn: async ({ transaction }) => {\n *     await api.save(transaction.mutations)\n *   },\n *   strategy: queueStrategy({\n *     wait: 200,\n *     addItemsTo: 'back',\n *     getItemsFrom: 'front'\n *   })\n * })\n * ```\n *\n * @example\n * ```ts\n * // LIFO queue - process most recent first\n * const mutate = usePacedMutations({\n *   mutationFn: async ({ transaction }) => {\n *     await api.save(transaction.mutations)\n *   },\n *   strategy: queueStrategy({\n *     wait: 200,\n *     addItemsTo: 'back',\n *     getItemsFrom: 'back'\n *   })\n * })\n * ```\n */\nexport function queueStrategy(options?: QueueStrategyOptions): QueueStrategy {\n  // Manual promise chaining to ensure async serialization\n  // LiteQueuer (unlike AsyncQueuer from @tanstack/pacer) lacks built-in async queue\n  // primitives and concurrency control. We compensate by manually chaining promises\n  // to ensure each transaction completes before the next one starts.\n  let processingChain = Promise.resolve()\n\n  const queuer = new LiteQueuer<() => Transaction>(\n    (fn) => {\n      // Chain each transaction to the previous one's completion\n      processingChain = processingChain\n        .then(async () => {\n          const transaction = fn()\n          // Wait for the transaction to be persisted before processing next item\n          await transaction.isPersisted.promise\n        })\n        .catch(() => {\n          // Errors are handled via transaction.isPersisted.promise and surfaced there.\n          // This catch prevents unhandled promise rejections from breaking the chain,\n          // ensuring subsequent transactions can still execute even if one fails.\n        })\n    },\n    {\n      wait: options?.wait ?? 0,\n      maxSize: options?.maxSize,\n      addItemsTo: options?.addItemsTo ?? `back`, // Default FIFO: add to back\n      getItemsFrom: options?.getItemsFrom ?? `front`, // Default FIFO: get from front\n      started: true, // Start processing immediately\n    }\n  )\n\n  return {\n    _type: `queue`,\n    options,\n    execute: <T extends object = Record<string, unknown>>(\n      fn: () => Transaction<T>\n    ) => {\n      // Add the transaction-creating function to the queue\n      queuer.addItem(fn as () => Transaction)\n    },\n    cleanup: () => {\n      queuer.stop()\n      queuer.clear()\n    },\n  }\n}\n", "import type { AnyFunction } from '@tanstack/pacer/types'\n\n/**\n * Options for configuring a lite throttled function\n */\nexport interface LiteThrottlerOptions<TFn extends AnyFunction = AnyFunction> {\n  /**\n   * Whether to execute on the leading edge of the timeout.\n   * Defaults to true.\n   */\n  leading?: boolean\n  /**\n   * Callback function that is called after the function is executed\n   */\n  onExecute?: (args: Parameters<TFn>, throttler: LiteThrottler<TFn>) => void\n  /**\n   * Whether to execute on the trailing edge of the timeout.\n   * Defaults to true.\n   */\n  trailing?: boolean\n  /**\n   * Time window in milliseconds during which the function can only be executed once.\n   */\n  wait: number\n}\n\n/**\n * A lightweight class that creates a throttled function.\n *\n * This is an alternative to the Throttler in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core Throttler,\n * this version does not use TanStack Store for state management, has no devtools integration,\n * and provides only essential throttling functionality.\n *\n * Throttling ensures a function is called at most once within a specified time window.\n * Unlike debouncing which waits for a pause in calls, throttling guarantees consistent\n * execution timing regardless of call frequency.\n *\n * Supports both leading and trailing edge execution:\n * - Leading: Execute immediately on first call (default: true)\n * - Trailing: Execute after wait period if called during throttle (default: true)\n *\n * Features:\n * - Zero dependencies - no external libraries required\n * - Minimal API surface - only essential methods (maybeExecute, flush, cancel)\n * - Simple state management - uses basic private properties instead of reactive stores\n * - Callback support for monitoring execution events\n * - Lightweight - designed for use in npm packages where bundle size matters\n *\n * @example\n * ```ts\n * const throttler = new LiteThrottler((scrollY: number) => {\n *   updateScrollPosition(scrollY);\n * }, {\n *   wait: 100,\n *   onExecute: (args, throttler) => {\n *     console.log('Updated scroll position:', args[0]);\n *   }\n * });\n *\n * // Will execute at most once per 100ms\n * window.addEventListener('scroll', () => {\n *   throttler.maybeExecute(window.scrollY);\n * });\n * ```\n */\nexport class LiteThrottler<TFn extends AnyFunction> {\n  private timeoutId: NodeJS.Timeout | undefined\n  private lastArgs: Parameters<TFn> | undefined\n  private lastExecutionTime = 0\n  private isPending = false\n\n  constructor(\n    public fn: TFn,\n    public options: LiteThrottlerOptions<TFn>,\n  ) {\n    // Default both leading and trailing to true if neither is specified\n    if (\n      this.options.leading === undefined &&\n      this.options.trailing === undefined\n    ) {\n      this.options.leading = true\n      this.options.trailing = true\n    }\n  }\n\n  /**\n   * Attempts to execute the throttled function. The execution behavior depends on the throttler options:\n   *\n   * - If enough time has passed since the last execution (>= wait period):\n   *   - With leading=true: Executes immediately\n   *   - With leading=false: Waits for the next trailing execution\n   *\n   * - If within the wait period:\n   *   - With trailing=true: Schedules execution for end of wait period\n   *   - With trailing=false: Drops the execution\n   */\n  maybeExecute = (...args: Parameters<TFn>): void => {\n    const now = Date.now()\n    const timeSinceLastExecution = now - this.lastExecutionTime\n\n    // Handle leading execution\n    if (this.options.leading && timeSinceLastExecution >= this.options.wait) {\n      this.execute(...args)\n    } else {\n      // Store the most recent arguments for potential trailing execution\n      this.lastArgs = args\n\n      // Set up trailing execution if not already scheduled\n      if (!this.timeoutId && this.options.trailing) {\n        const timeoutDuration = this.options.wait - timeSinceLastExecution\n        this.isPending = true\n        this.timeoutId = setTimeout(() => {\n          if (this.lastArgs !== undefined) {\n            this.execute(...this.lastArgs)\n          }\n        }, timeoutDuration)\n      }\n    }\n  }\n\n  private execute = (...args: Parameters<TFn>): void => {\n    this.fn(...args)\n    this.options.onExecute?.(args, this)\n    this.lastExecutionTime = Date.now()\n    this.clearTimeout()\n    this.lastArgs = undefined\n    this.isPending = false\n  }\n\n  /**\n   * Processes the current pending execution immediately.\n   * If there's a pending execution, it will be executed right away\n   * and the timeout will be cleared.\n   */\n  flush = (): void => {\n    if (this.isPending && this.lastArgs) {\n      this.execute(...this.lastArgs)\n    }\n  }\n\n  /**\n   * Cancels any pending trailing execution and clears internal state.\n   * If a trailing execution is scheduled, this will prevent that execution from occurring.\n   */\n  cancel = (): void => {\n    this.clearTimeout()\n    this.lastArgs = undefined\n    this.isPending = false\n  }\n\n  private clearTimeout = (): void => {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n      this.timeoutId = undefined\n    }\n  }\n}\n\n/**\n * Creates a lightweight throttled function that limits how often the provided function can execute.\n *\n * This is an alternative to the throttle function in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core version,\n * this function creates a throttler with no external dependencies, devtools integration, or reactive state.\n *\n * Throttling ensures a function executes at most once within a specified time window,\n * regardless of how many times it is called. This is useful for rate-limiting\n * expensive operations or UI updates.\n *\n * @example\n * ```ts\n * const throttledScroll = liteThrottle(() => {\n *   updateScrollIndicator();\n * }, { wait: 100 });\n *\n * // Will execute at most once per 100ms\n * window.addEventListener('scroll', throttledScroll);\n * ```\n *\n * @example\n * ```ts\n * // Leading edge execution - fires immediately then throttles\n * const throttledResize = liteThrottle(() => {\n *   recalculateLayout();\n * }, { wait: 250, leading: true, trailing: false });\n * ```\n */\nexport function liteThrottle<TFn extends AnyFunction>(\n  fn: TFn,\n  options: LiteThrottlerOptions<TFn>,\n): (...args: Parameters<TFn>) => void {\n  const throttler = new LiteThrottler(fn, options)\n  return throttler.maybeExecute\n}\n", "import { LiteThrottler } from \"@tanstack/pacer-lite/lite-throttler\"\nimport type { ThrottleStrategy, ThrottleStrategyOptions } from \"./types\"\nimport type { Transaction } from \"../transactions\"\n\n/**\n * Creates a throttle strategy that ensures transactions are evenly spaced\n * over time.\n *\n * Provides smooth, controlled execution patterns ideal for UI updates like\n * sliders, progress bars, or scroll handlers where you want consistent\n * execution timing.\n *\n * @param options - Configuration for throttle behavior\n * @returns A throttle strategy instance\n *\n * @example\n * ```ts\n * // Throttle slider updates to every 200ms\n * const mutate = usePacedMutations({\n *   onMutate: (volume) => {\n *     settingsCollection.update('volume', draft => { draft.value = volume })\n *   },\n *   mutationFn: async ({ transaction }) => {\n *     await api.updateVolume(transaction.mutations)\n *   },\n *   strategy: throttleStrategy({ wait: 200 })\n * })\n * ```\n *\n * @example\n * ```ts\n * // Throttle with leading and trailing execution\n * const mutate = usePacedMutations({\n *   onMutate: (data) => {\n *     collection.update(id, draft => { Object.assign(draft, data) })\n *   },\n *   mutationFn: async ({ transaction }) => {\n *     await api.save(transaction.mutations)\n *   },\n *   strategy: throttleStrategy({\n *     wait: 500,\n *     leading: true,\n *     trailing: true\n *   })\n * })\n * ```\n */\nexport function throttleStrategy(\n  options: ThrottleStrategyOptions\n): ThrottleStrategy {\n  const throttler = new LiteThrottler(\n    (callback: () => Transaction) => callback(),\n    options\n  )\n\n  return {\n    _type: `throttle`,\n    options,\n    execute: <T extends object = Record<string, unknown>>(\n      fn: () => Transaction<T>\n    ) => {\n      throttler.maybeExecute(fn as () => Transaction)\n    },\n    cleanup: () => {\n      throttler.cancel()\n    },\n  }\n}\n"],
  "mappings": "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",
  "names": ["join", "count", "length", "max", "indexedValue", "clone", "count", "proxy", "value", "count", "output", "operators", "output", "_inner", "output", "_f", "sum", "count", "avg", "min", "minValue", "max", "maxValue", "output", "_f", "output", "_f", "output", "output", "mode", "output", "ib", "fb", "ia", "fa", "i", "output", "_index", "sum", "count", "avg", "min", "max", "aggregates", "keyExtractor", "orderBy", "orderBy", "minValue", "config", "result", "config", "orderBy", "nullCheckOps", "comparisonOps", "count", "join", "AggregateExpr", "FuncExpr", "ValueExpr", "QueryRefClass", "splitWhereClauses", "CollectionRefClass", "join", "joinOperator", "ValClass", "resultPipeline", "result", "compilationResult", "ValClass", "orderBy", "orderBy", "getKey", "areValuesEqual", "_a", "_a", "_b"]
}
