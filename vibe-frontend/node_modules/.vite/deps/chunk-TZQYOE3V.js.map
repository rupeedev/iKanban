{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@lexical+list@0.36.2/node_modules/@lexical/list/LexicalList.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { effect, namedSignals } from '@lexical/extension';\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement, mergeRegister, $findMatchingParent, calculateZoomLevel } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $createParagraphNode, $isElementNode, $isLeafNode, $setPointFromCaret, $normalizeCaret, $getChildCaret, ElementNode, buildImportMap, $isParagraphNode, $applyNodeReplacement, $createTextNode, createCommand, COMMAND_PRIORITY_LOW, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ESCAPE_COMMAND, KEY_SPACE_COMMAND, $getNearestNodeFromDOMNode, KEY_ARROW_LEFT_COMMAND, getNearestEditorFromDOMNode, defineExtension, safeCast, $getNodeByKey, INSERT_PARAGRAPH_COMMAND, $isTextNode, TextNode } from 'lexical';\nimport { getStyleObjectFromCSS } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = $getSelection();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ($isRangeSelection(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isRootOrShadowRoot(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = $createParagraphNode();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ($isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ($isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = $isLeafNode(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = $getSelection();\n  if ($isRangeSelection(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isLeafNode(node)) {\n          const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = $createParagraphNode().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          $setPointFromCaret(selection.anchor, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          $setPointFromCaret(selection.focus, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = getStyleObjectFromCSS(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in getStyleObjectFromCSS(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n  __value;\n  /** @internal */\n  __checked;\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    updateListItemChecked(dom, this, prevNode);\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || $isParagraphNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode) {\n  const parent = listItemNode.getParent();\n  const isCheckbox = $isListNode(parent) && parent.getListType() === 'check' &&\n  // Only add attributes for leaf list items\n  !$isListNode(listItemNode.getFirstChild());\n  if (!isCheckbox) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n  __tag;\n  /** @internal */\n  __start;\n  /** @internal */\n  __listType;\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag || prevNode.__listType !== this.__listType) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if (isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append($isElementNode(node) && !($isListNode(node) || node.isInline()) ? $createTextNode(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return mergeRegister(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = $getNearestNodeFromDOMNode(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = $findMatchingParent(anchorNode, node => $isElementNode(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!isHTMLElement(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if (isHTMLElement(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = calculateZoomLevel(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if (isHTMLElement(event.target)) {\n      const domNode = event.target;\n      const editor = getNearestEditorFromDOMNode(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = $getNearestNodeFromDOMNode(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return isHTMLElement(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = $getNearestNodeFromDOMNode(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = createCommand('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = $getNodeByKey(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ($isTextNode(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = $findMatchingParent(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\n/**\n * Configures {@link ListNode}, {@link ListItemNode} and registers\n * the strict indent transform if `hasStrictIndent` is true (default false).\n */\nconst ListExtension = defineExtension({\n  build(editor, config, state) {\n    return namedSignals(config);\n  },\n  config: safeCast({\n    hasStrictIndent: false\n  }),\n  name: '@lexical/list/List',\n  nodes: [ListNode, ListItemNode],\n  register(editor, config, state) {\n    const stores = state.getOutput();\n    return mergeRegister(registerList(editor), effect(() => stores.hasStrictIndent.value ? registerListStrictIndentTransform(editor) : undefined));\n  }\n});\n\n/**\n * Registers checklist functionality for {@link ListNode} and\n * {@link ListItemNode} with a\n * {@link INSERT_CHECK_LIST_COMMAND} listener and\n * the expected keyboard and mouse interactions for\n * checkboxes.\n */\nconst CheckListExtension = defineExtension({\n  dependencies: [ListExtension],\n  name: '@lexical/list/CheckList',\n  register: registerCheckList\n});\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $insertList, $isListItemNode, $isListNode, $removeList, CheckListExtension, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListExtension, ListItemNode, ListNode, REMOVE_LIST_COMMAND, UPDATE_LIST_START_COMMAND, insertList, registerCheckList, registerList, registerListStrictIndentTransform, removeList };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,SAAS,sBAAsB,SAAS;AACtC,QAAM,IAAI,MAAM,OAAO;AACzB;AAOA,SAAS,cAAc,UAAU;AAC/B,MAAI,QAAQ;AACZ,MAAI,SAAS,SAAS,UAAU;AAChC,SAAO,UAAU,MAAM;AACrB,QAAI,gBAAgB,MAAM,GAAG;AAC3B,YAAM,aAAa,OAAO,UAAU;AACpC,UAAI,YAAY,UAAU,GAAG;AAC3B;AACA,iBAAS,WAAW,UAAU;AAC9B;AAAA,MACF;AACA;AACE,8BAAsB,mDAAmD;AAAA,MAC3E;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAOA,SAAS,gBAAgB,UAAU;AACjC,MAAI,OAAO,SAAS,UAAU;AAC9B,MAAI,CAAC,YAAY,IAAI,GAAG;AACtB;AACE,4BAAsB,mDAAmD;AAAA,IAC3E;AAAA,EACF;AACA,MAAI,SAAS;AACb,SAAO,WAAW,MAAM;AACtB,aAAS,OAAO,UAAU;AAC1B,QAAI,YAAY,MAAM,GAAG;AACvB,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AASA,SAAS,iBAAiB,MAAM;AAC9B,MAAI,gBAAgB,CAAC;AACrB,QAAM,eAAe,KAAK,YAAY,EAAE,OAAO,eAAe;AAC9D,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,UAAM,eAAe,aAAa,CAAC;AACnC,UAAM,aAAa,aAAa,cAAc;AAC9C,QAAI,YAAY,UAAU,GAAG;AAC3B,sBAAgB,cAAc,OAAO,iBAAiB,UAAU,CAAC;AAAA,IACnE,OAAO;AACL,oBAAc,KAAK,YAAY;AAAA,IACjC;AAAA,EACF;AACA,SAAO;AACT;AAOA,SAAS,iBAAiB,MAAM;AAC9B,SAAO,gBAAgB,IAAI,KAAK,YAAY,KAAK,cAAc,CAAC;AAClE;AASA,SAAS,8BAA8B,SAAS;AAO9C,MAAI,eAAe;AACnB,SAAO,aAAa,eAAe,KAAK,QAAQ,aAAa,mBAAmB,KAAK,MAAM;AACzF,UAAM,SAAS,aAAa,UAAU;AACtC,QAAI,UAAU,QAAQ,EAAE,gBAAgB,MAAM,KAAK,YAAY,MAAM,IAAI;AACvE;AAAA,IACF;AACA,mBAAe;AAAA,EACjB;AACA,eAAa,OAAO;AACtB;AAOA,SAAS,gBAAgB,MAAM;AAC7B,QAAM,kBAAkB,oBAAoB;AAC5C,SAAO,gBAAgB,OAAO,IAAI;AACpC;AAEA,SAAS,0BAA0B,YAAY,OAAO;AACpD,SAAO,gBAAgB,UAAU,MAAM,MAAM,WAAW,KAAK,MAAM,WAAW,KAAK,WAAW,GAAG,MAAM,CAAC,CAAC,KAAK,WAAW,gBAAgB,MAAM;AACjJ;AAWA,SAAS,YAAY,UAAU;AAC7B,QAAM,YAAY,cAAc;AAChC,MAAI,cAAc,MAAM;AACtB,QAAI,QAAQ,UAAU,SAAS;AAC/B,QAAI,kBAAkB,SAAS,GAAG;AAChC,YAAM,iBAAiB,UAAU,kBAAkB;AACnD,UAAI,EAAE,mBAAmB,OAAO;AAC9B,8BAAsB,sCAAsC;AAAA,MAC9D;AACA,YAAM,CAAC,MAAM,IAAI;AACjB,YAAM,aAAa,OAAO,QAAQ;AAClC,YAAM,mBAAmB,WAAW,UAAU;AAC9C,UAAI,oBAAoB,UAAU,GAAG;AACnC,cAAM,aAAa,WAAW,cAAc;AAC5C,YAAI,YAAY;AACd,kBAAQ,WAAW,YAAY,EAAE,SAAS;AAAA,QAC5C,OAAO;AACL,gBAAM,YAAY,qBAAqB;AACvC,qBAAW,OAAO,SAAS;AAC3B,kBAAQ,UAAU,OAAO,EAAE,SAAS;AAAA,QACtC;AAAA,MACF,WAAW,0BAA0B,YAAY,KAAK,GAAG;AACvD,cAAM,OAAO,gBAAgB,QAAQ;AACrC,YAAI,oBAAoB,gBAAgB,GAAG;AACzC,qBAAW,QAAQ,IAAI;AACvB,gBAAM,WAAW,oBAAoB;AACrC,cAAI,eAAe,UAAU,GAAG;AAC9B,qBAAS,UAAU,WAAW,cAAc,CAAC;AAC7C,qBAAS,UAAU,WAAW,UAAU,CAAC;AAAA,UAC3C;AACA,eAAK,OAAO,QAAQ;AAAA,QACtB,WAAW,gBAAgB,UAAU,GAAG;AACtC,gBAAM,SAAS,WAAW,iBAAiB;AAC3C,iBAAO,MAAM,OAAO,YAAY,CAAC;AACjC,iBAAO,QAAQ,IAAI;AAAA,QACrB;AACA;AAAA,MACF;AAAA,IACF;AACA,UAAM,UAAU,oBAAI,IAAI;AACxB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM,CAAC;AACpB,UAAI,eAAe,IAAI,KAAK,KAAK,QAAQ,KAAK,CAAC,gBAAgB,IAAI,KAAK,CAAC,QAAQ,IAAI,KAAK,OAAO,CAAC,GAAG;AACnG,2BAAmB,MAAM,QAAQ;AACjC;AAAA,MACF;AACA,UAAI,SAAS,YAAY,IAAI,IAAI,KAAK,UAAU,IAAI,gBAAgB,IAAI,KAAK,KAAK,QAAQ,IAAI,OAAO;AACrG,aAAO,UAAU,MAAM;AACrB,cAAM,YAAY,OAAO,OAAO;AAChC,YAAI,YAAY,MAAM,GAAG;AACvB,cAAI,CAAC,QAAQ,IAAI,SAAS,GAAG;AAC3B,kBAAM,cAAc,gBAAgB,QAAQ;AAC5C,mBAAO,aAAa,OAAO,YAAY,CAAC;AACxC,mBAAO,QAAQ,WAAW;AAC1B,oBAAQ,IAAI,SAAS;AAAA,UACvB;AACA;AAAA,QACF,OAAO;AACL,gBAAM,aAAa,OAAO,UAAU;AACpC,cAAI,oBAAoB,UAAU,KAAK,CAAC,QAAQ,IAAI,SAAS,GAAG;AAC9D,oBAAQ,IAAI,SAAS;AACrB,+BAAmB,QAAQ,QAAQ;AACnC;AAAA,UACF;AACA,mBAAS;AAAA,QACX;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AACA,SAAS,OAAO,MAAM,eAAe;AACnC,OAAK,OAAO,KAAK,gBAAgB,GAAG,GAAG,aAAa;AACtD;AACA,SAAS,mBAAmB,MAAM,UAAU;AAC1C,MAAI,YAAY,IAAI,GAAG;AACrB,WAAO;AAAA,EACT;AACA,QAAM,kBAAkB,KAAK,mBAAmB;AAChD,QAAM,cAAc,KAAK,eAAe;AACxC,QAAM,WAAW,oBAAoB;AACrC,SAAO,UAAU,KAAK,YAAY,CAAC;AACnC,MAAI;AACJ,MAAI,YAAY,eAAe,KAAK,aAAa,gBAAgB,YAAY,GAAG;AAC9E,oBAAgB,OAAO,QAAQ;AAE/B,QAAI,YAAY,WAAW,KAAK,aAAa,YAAY,YAAY,GAAG;AACtE,aAAO,iBAAiB,YAAY,YAAY,CAAC;AACjD,kBAAY,OAAO;AAAA,IACrB;AACA,iBAAa;AAAA,EACf,WAAW,YAAY,WAAW,KAAK,aAAa,YAAY,YAAY,GAAG;AAC7E,gBAAY,qBAAqB,EAAE,aAAa,QAAQ;AACxD,iBAAa;AAAA,EACf,OAAO;AACL,UAAM,OAAO,gBAAgB,QAAQ;AACrC,SAAK,OAAO,QAAQ;AACpB,SAAK,QAAQ,IAAI;AACjB,iBAAa;AAAA,EACf;AAEA,WAAS,UAAU,KAAK,cAAc,CAAC;AACvC,WAAS,UAAU,KAAK,UAAU,CAAC;AACnC,OAAK,OAAO;AACZ,SAAO;AACT;AAQA,SAAS,WAAW,OAAO,OAAO;AAChC,QAAM,YAAY,MAAM,aAAa;AACrC,QAAM,YAAY,MAAM,cAAc;AACtC,MAAI,aAAa,aAAa,iBAAiB,SAAS,KAAK,iBAAiB,SAAS,GAAG;AACxF,eAAW,UAAU,cAAc,GAAG,UAAU,cAAc,CAAC;AAC/D,cAAU,OAAO;AAAA,EACnB;AACA,QAAM,UAAU,MAAM,YAAY;AAClC,MAAI,QAAQ,SAAS,GAAG;AACtB,UAAM,OAAO,GAAG,OAAO;AAAA,EACzB;AACA,QAAM,OAAO;AACf;AAQA,SAAS,cAAc;AACrB,QAAM,YAAY,cAAc;AAChC,MAAI,kBAAkB,SAAS,GAAG;AAChC,UAAM,YAAY,oBAAI,IAAI;AAC1B,UAAM,QAAQ,UAAU,SAAS;AACjC,UAAM,aAAa,UAAU,OAAO,QAAQ;AAC5C,QAAI,0BAA0B,YAAY,KAAK,GAAG;AAChD,gBAAU,IAAI,gBAAgB,UAAU,CAAC;AAAA,IAC3C,OAAO;AACL,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,cAAM,OAAO,MAAM,CAAC;AACpB,YAAI,YAAY,IAAI,GAAG;AACrB,gBAAM,eAAe,sBAAsB,MAAM,YAAY;AAC7D,cAAI,gBAAgB,MAAM;AACxB,sBAAU,IAAI,gBAAgB,YAAY,CAAC;AAAA,UAC7C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,eAAW,YAAY,WAAW;AAChC,UAAI,iBAAiB;AACrB,YAAM,YAAY,iBAAiB,QAAQ;AAC3C,iBAAW,gBAAgB,WAAW;AACpC,cAAM,YAAY,qBAAqB,EAAE,aAAa,UAAU,KAAK,EAAE,cAAc,UAAU,MAAM;AACrG,eAAO,WAAW,aAAa,YAAY,CAAC;AAC5C,uBAAe,YAAY,SAAS;AACpC,yBAAiB;AAQjB,YAAI,aAAa,UAAU,UAAU,OAAO,KAAK;AAC/C,6BAAmB,UAAU,QAAQ,gBAAgB,eAAe,WAAW,MAAM,CAAC,CAAC;AAAA,QACzF;AACA,YAAI,aAAa,UAAU,UAAU,MAAM,KAAK;AAC9C,6BAAmB,UAAU,OAAO,gBAAgB,eAAe,WAAW,MAAM,CAAC,CAAC;AAAA,QACxF;AACA,qBAAa,OAAO;AAAA,MACtB;AACA,eAAS,OAAO;AAAA,IAClB;AAAA,EACF;AACF;AAQA,SAAS,4BAA4B,MAAM;AACzC,QAAM,iBAAiB,KAAK,YAAY,MAAM;AAC9C,MAAI,QAAQ,KAAK,SAAS;AAC1B,aAAW,SAAS,KAAK,YAAY,GAAG;AACtC,QAAI,gBAAgB,KAAK,GAAG;AAC1B,UAAI,MAAM,SAAS,MAAM,OAAO;AAC9B,cAAM,SAAS,KAAK;AAAA,MACtB;AACA,UAAI,kBAAkB,MAAM,UAAU,EAAE,aAAa,MAAM;AACzD,cAAM,WAAW,MAAS;AAAA,MAC5B;AACA,UAAI,CAAC,YAAY,MAAM,cAAc,CAAC,GAAG;AACvC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAOA,SAAS,+BAA+B,MAAM;AAC5C,QAAM,cAAc,KAAK,eAAe;AACxC,MAAI,YAAY,WAAW,KAAK,KAAK,YAAY,MAAM,YAAY,YAAY,GAAG;AAChF,eAAW,MAAM,WAAW;AAAA,EAC9B;AACF;AAQA,SAAS,cAAc,cAAc;AAEnC,QAAM,UAAU,oBAAI,IAAI;AACxB,MAAI,iBAAiB,YAAY,KAAK,QAAQ,IAAI,aAAa,OAAO,CAAC,GAAG;AACxE;AAAA,EACF;AACA,QAAM,SAAS,aAAa,UAAU;AAGtC,QAAM,cAAc,aAAa,eAAe;AAChD,QAAM,kBAAkB,aAAa,mBAAmB;AAGxD,MAAI,iBAAiB,WAAW,KAAK,iBAAiB,eAAe,GAAG;AACtE,UAAM,YAAY,gBAAgB,cAAc;AAChD,QAAI,YAAY,SAAS,GAAG;AAC1B,gBAAU,OAAO,YAAY;AAC7B,YAAM,gBAAgB,YAAY,cAAc;AAChD,UAAI,YAAY,aAAa,GAAG;AAC9B,cAAM,WAAW,cAAc,YAAY;AAC3C,eAAO,WAAW,QAAQ;AAC1B,oBAAY,OAAO;AACnB,gBAAQ,IAAI,YAAY,OAAO,CAAC;AAAA,MAClC;AAAA,IACF;AAAA,EACF,WAAW,iBAAiB,WAAW,GAAG;AAExC,UAAM,YAAY,YAAY,cAAc;AAC5C,QAAI,YAAY,SAAS,GAAG;AAC1B,YAAM,aAAa,UAAU,cAAc;AAC3C,UAAI,eAAe,MAAM;AACvB,mBAAW,aAAa,YAAY;AAAA,MACtC;AAAA,IACF;AAAA,EACF,WAAW,iBAAiB,eAAe,GAAG;AAC5C,UAAM,YAAY,gBAAgB,cAAc;AAChD,QAAI,YAAY,SAAS,GAAG;AAC1B,gBAAU,OAAO,YAAY;AAAA,IAC/B;AAAA,EACF,OAAO;AAGL,QAAI,YAAY,MAAM,GAAG;AACvB,YAAM,cAAc,oBAAoB,EAAE,cAAc,aAAa,cAAc,CAAC,EAAE,aAAa,aAAa,aAAa,CAAC;AAC9H,YAAM,UAAU,gBAAgB,OAAO,YAAY,CAAC,EAAE,cAAc,OAAO,cAAc,CAAC,EAAE,aAAa,OAAO,aAAa,CAAC;AAC9H,kBAAY,OAAO,OAAO;AAC1B,cAAQ,OAAO,YAAY;AAC3B,UAAI,iBAAiB;AACnB,wBAAgB,YAAY,WAAW;AAAA,MACzC,WAAW,aAAa;AACtB,oBAAY,aAAa,WAAW;AAAA,MACtC,OAAO;AACL,eAAO,OAAO,WAAW;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AACF;AAQA,SAAS,eAAe,cAAc;AAGpC,MAAI,iBAAiB,YAAY,GAAG;AAClC;AAAA,EACF;AACA,QAAM,aAAa,aAAa,UAAU;AAC1C,QAAM,sBAAsB,aAAa,WAAW,UAAU,IAAI;AAClE,QAAM,uBAAuB,sBAAsB,oBAAoB,UAAU,IAAI;AAGrF,MAAI,YAAY,oBAAoB,KAAK,gBAAgB,mBAAmB,KAAK,YAAY,UAAU,GAAG;AAGxG,UAAM,aAAa,aAAa,WAAW,cAAc,IAAI;AAC7D,UAAM,YAAY,aAAa,WAAW,aAAa,IAAI;AAC3D,QAAI,aAAa,GAAG,UAAU,GAAG;AAC/B,0BAAoB,aAAa,YAAY;AAC7C,UAAI,WAAW,QAAQ,GAAG;AACxB,4BAAoB,OAAO;AAAA,MAC7B;AAAA,IAGF,WAAW,aAAa,GAAG,SAAS,GAAG;AACrC,0BAAoB,YAAY,YAAY;AAC5C,UAAI,WAAW,QAAQ,GAAG;AACxB,4BAAoB,OAAO;AAAA,MAC7B;AAAA,IACF,OAAO;AAEL,YAAM,WAAW,WAAW,YAAY;AACxC,YAAM,2BAA2B,oBAAoB;AACrD,YAAM,uBAAuB,gBAAgB,QAAQ;AACrD,+BAAyB,OAAO,oBAAoB;AACpD,mBAAa,oBAAoB,EAAE,QAAQ,aAAW,qBAAqB,OAAO,OAAO,CAAC;AAC1F,YAAM,uBAAuB,oBAAoB;AACjD,YAAM,mBAAmB,gBAAgB,QAAQ;AACjD,2BAAqB,OAAO,gBAAgB;AAC5C,aAAO,kBAAkB,aAAa,gBAAgB,CAAC;AAEvD,0BAAoB,aAAa,wBAAwB;AACzD,0BAAoB,YAAY,oBAAoB;AAEpD,0BAAoB,QAAQ,YAAY;AAAA,IAC1C;AAAA,EACF;AACF;AAWA,SAAS,6BAA6B;AACpC,QAAM,YAAY,cAAc;AAChC,MAAI,CAAC,kBAAkB,SAAS,KAAK,CAAC,UAAU,YAAY,GAAG;AAC7D,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,UAAU,OAAO,QAAQ;AACxC,MAAI,CAAC,gBAAgB,MAAM,KAAK,OAAO,gBAAgB,MAAM,GAAG;AAC9D,WAAO;AAAA,EACT;AACA,QAAM,cAAc,gBAAgB,MAAM;AAC1C,QAAM,SAAS,OAAO,UAAU;AAChC,MAAI,CAAC,YAAY,MAAM,GAAG;AACxB,0BAAsB,mDAAmD;AAAA,EAC3E;AACA,QAAM,cAAc,OAAO,UAAU;AACrC,MAAI;AACJ,MAAI,oBAAoB,WAAW,GAAG;AACpC,sBAAkB,qBAAqB;AACvC,gBAAY,YAAY,eAAe;AAAA,EACzC,WAAW,gBAAgB,WAAW,GAAG;AACvC,sBAAkB,oBAAoB;AACtC,gBAAY,YAAY,eAAe;AAAA,EACzC,OAAO;AACL,WAAO;AAAA,EACT;AACA,kBAAgB,aAAa,UAAU,KAAK,EAAE,cAAc,UAAU,MAAM,EAAE,OAAO;AACrF,QAAM,eAAe,OAAO,gBAAgB;AAC5C,MAAI,aAAa,SAAS,GAAG;AAC3B,UAAM,UAAU,gBAAgB,OAAO,YAAY,CAAC;AACpD,QAAI,gBAAgB,eAAe,GAAG;AACpC,YAAM,cAAc,oBAAoB;AACxC,kBAAY,OAAO,OAAO;AAC1B,sBAAgB,YAAY,WAAW;AAAA,IACzC,OAAO;AACL,sBAAgB,YAAY,OAAO;AAAA,IACrC;AACA,YAAQ,OAAO,GAAG,YAAY;AAAA,EAChC;AAGA,gCAA8B,MAAM;AACpC,SAAO;AACT;AAUA,SAAS,uBAAuB,YAAY;AAC1C,QAAM,OAAO,CAAC;AACd,aAAW,aAAa,YAAY;AAClC,QAAI,aAAa,OAAO,cAAc,UAAU;AAC9C,iBAAW,CAAC,CAAC,KAAK,UAAU,SAAS,MAAM,GAAG;AAC5C,aAAK,KAAK,CAAC;AAAA,MACb;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,kBAAkB,KAAK,MAAM,UAAU;AAC9C,QAAM,SAAS,sBAAsB,KAAK,WAAW;AACrD,aAAW,KAAK,QAAQ;AACtB,QAAI,MAAM,YAAY,qBAAqB,CAAC,IAAI,OAAO,CAAC,CAAC;AAAA,EAC3D;AACA,MAAI,UAAU;AACZ,eAAW,KAAK,sBAAsB,SAAS,WAAW,GAAG;AAC3D,UAAI,EAAE,KAAK,SAAS;AAClB,YAAI,MAAM,eAAe,qBAAqB,CAAC,EAAE;AAAA,MACnD;AAAA,IACF;AAAA,EACF;AACF;AAGA,IAAM,eAAN,cAA2B,YAAY;AAAA,EA6BrC,YAAY,QAAQ,GAAG,UAAU,QAAW,KAAK;AAC/C,UAAM,GAAG;AA5BX;AAAA;AAEA;AAAA;AA2BE,SAAK,UAAU,UAAU,SAAY,IAAI;AACzC,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA,EA1BA,UAAU;AACR,WAAO,KAAK,OAAO,YAAY;AAAA,MAC7B,YAAY,UAAQ;AAClB,YAAI,KAAK,aAAa,MAAM;AAC1B;AAAA,QACF;AACA,cAAM,SAAS,KAAK,UAAU;AAC9B,YAAI,YAAY,MAAM,GAAG;AACvB,cAAI,OAAO,YAAY,MAAM,WAAW,KAAK,WAAW,KAAK,MAAM;AACjE,iBAAK,WAAW,MAAS;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AAAA,MACA,SAAS;AAAA,MACT,WAAW,eAAe;AAAA,QACxB,IAAI,OAAO;AAAA,UACT,YAAY;AAAA,UACZ,UAAU;AAAA,QACZ;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAMA,eAAe,UAAU;AACvB,UAAM,eAAe,QAAQ;AAC7B,SAAK,UAAU,SAAS;AACxB,SAAK,YAAY,SAAS;AAAA,EAC5B;AAAA,EACA,UAAU,QAAQ;AAChB,UAAM,UAAU,SAAS,cAAc,IAAI;AAC3C,SAAK,kBAAkB,MAAM,SAAS,MAAM;AAC5C,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,UAAU,KAAK,QAAQ;AACvC,0BAAsB,KAAK,MAAM,QAAQ;AACzC,QAAI,QAAQ,KAAK;AACjB,gCAA4B,KAAK,OAAO,OAAO,IAAI;AACnD,UAAM,YAAY,WAAW,SAAS,UAAU;AAChD,UAAM,YAAY,KAAK;AACvB,QAAI,cAAc,WAAW;AAC3B,UAAI,cAAc,IAAI;AACpB,YAAI,gBAAgB,OAAO;AAAA,MAC7B,OAAO;AACL,YAAI,MAAM,UAAU;AAAA,MACtB;AAAA,IACF;AACA,sBAAkB,KAAK,MAAM,QAAQ;AAAA,EACvC;AAAA,EACA,UAAU,UAAU,KAAK,QAAQ;AAE/B,UAAM,UAAU;AAChB,SAAK,kBAAkB,UAAU,SAAS,MAAM;AAChD,WAAO;AAAA,EACT;AAAA,EACA,eAAe,gBAAgB;AAC7B,WAAO,MAAM,eAAe,cAAc,EAAE,SAAS,eAAe,KAAK,EAAE,WAAW,eAAe,OAAO;AAAA,EAC9G;AAAA,EACA,UAAU,QAAQ;AAChB,UAAM,UAAU,KAAK,UAAU,OAAO,OAAO;AAC7C,UAAM,aAAa,KAAK,cAAc;AACtC,QAAI,YAAY;AACd,cAAQ,MAAM,YAAY;AAAA,IAC5B;AACA,UAAM,YAAY,KAAK,aAAa;AACpC,QAAI,WAAW;AACb,cAAQ,MAAM;AAAA,IAChB;AACA,WAAO;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAAA,EACA,aAAa;AACX,WAAO;AAAA,MACL,GAAG,MAAM,WAAW;AAAA,MACpB,SAAS,KAAK,WAAW;AAAA,MACzB,OAAO,KAAK,SAAS;AAAA,IACvB;AAAA,EACF;AAAA,EACA,UAAU,OAAO;AACf,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM,CAAC;AACpB,UAAI,eAAe,IAAI,KAAK,KAAK,aAAa,IAAI,GAAG;AACnD,cAAM,WAAW,KAAK,YAAY;AAClC,aAAK,OAAO,GAAG,QAAQ;AACvB,aAAK,OAAO;AAAA,MACd,OAAO;AACL,cAAM,OAAO,IAAI;AAAA,MACnB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,QAAQ,iBAAiB,iBAAiB;AACxC,QAAI,gBAAgB,eAAe,GAAG;AACpC,aAAO,MAAM,QAAQ,eAAe;AAAA,IACtC;AACA,SAAK,UAAU,CAAC;AAChB,UAAM,OAAO,KAAK,iBAAiB;AACnC,QAAI,CAAC,YAAY,IAAI,GAAG;AACtB,aAAO;AAAA,IACT;AACA,QAAI,KAAK,YAAY,KAAK,OAAO,GAAG;AAClC,WAAK,aAAa,eAAe;AAAA,IACnC,WAAW,KAAK,WAAW,KAAK,OAAO,GAAG;AACxC,WAAK,YAAY,eAAe;AAAA,IAClC,OAAO;AAEL,YAAM,UAAU,gBAAgB,KAAK,YAAY,CAAC;AAClD,UAAI,cAAc,KAAK,eAAe;AACtC,aAAO,aAAa;AAClB,cAAM,eAAe;AACrB,sBAAc,YAAY,eAAe;AACzC,gBAAQ,OAAO,YAAY;AAAA,MAC7B;AACA,WAAK,YAAY,eAAe;AAChC,sBAAgB,YAAY,OAAO;AAAA,IACrC;AACA,QAAI,iBAAiB;AACnB,UAAI,CAAC,eAAe,eAAe,GAAG;AACpC,8BAAsB,sDAAsD;AAAA,MAC9E;AACA,WAAK,YAAY,EAAE,QAAQ,WAAS;AAClC,wBAAgB,OAAO,KAAK;AAAA,MAC9B,CAAC;AAAA,IACH;AACA,SAAK,OAAO;AACZ,QAAI,KAAK,gBAAgB,MAAM,GAAG;AAChC,WAAK,OAAO;AAAA,IACd;AACA,WAAO;AAAA,EACT;AAAA,EACA,YAAY,MAAM,mBAAmB,MAAM;AACzC,UAAM,WAAW,KAAK,iBAAiB;AACvC,QAAI,CAAC,YAAY,QAAQ,GAAG;AAC1B;AACE,8BAAsB,wDAAwD;AAAA,MAChF;AAAA,IACF;AACA,QAAI,gBAAgB,IAAI,GAAG;AACzB,aAAO,MAAM,YAAY,MAAM,gBAAgB;AAAA,IACjD;AACA,UAAM,WAAW,KAAK,gBAAgB;AAGtC,aAAS,YAAY,MAAM,gBAAgB;AAC3C,QAAI,SAAS,WAAW,GAAG;AACzB,YAAM,cAAc,gBAAgB,SAAS,YAAY,CAAC;AAC1D,eAAS,QAAQ,aAAW,YAAY,OAAO,OAAO,CAAC;AACvD,WAAK,YAAY,aAAa,gBAAgB;AAAA,IAChD;AACA,WAAO;AAAA,EACT;AAAA,EACA,OAAO,qBAAqB;AAC1B,UAAM,cAAc,KAAK,mBAAmB;AAC5C,UAAM,cAAc,KAAK,eAAe;AACxC,UAAM,OAAO,mBAAmB;AAChC,QAAI,eAAe,eAAe,iBAAiB,WAAW,KAAK,iBAAiB,WAAW,GAAG;AAChG,iBAAW,YAAY,cAAc,GAAG,YAAY,cAAc,CAAC;AACnE,kBAAY,OAAO;AAAA,IACrB;AAAA,EACF;AAAA,EACA,eAAe,GAAG,mBAAmB,MAAM;AACzC,UAAM,aAAa,oBAAoB,EAAE,eAAe,KAAK,WAAW,CAAC,EAAE,WAAW,KAAK,WAAW,IAAI,QAAQ,MAAS;AAC3H,SAAK,YAAY,YAAY,gBAAgB;AAC7C,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,WAAW;AACzB,UAAM,YAAY,qBAAqB;AACvC,UAAM,WAAW,KAAK,YAAY;AAClC,aAAS,QAAQ,WAAS,UAAU,OAAO,KAAK,CAAC;AACjD,UAAM,WAAW,KAAK,iBAAiB;AACvC,UAAM,iBAAiB,SAAS,iBAAiB;AACjD,UAAM,aAAa,gBAAgB,cAAc;AACjD,QAAI,SAAS,gBAAgB,MAAM,GAAG;AACpC,UAAI,YAAY;AAGd,iBAAS,OAAO;AAChB,uBAAe,OAAO;AAAA,MACxB,OAAO;AACL,iBAAS,aAAa,SAAS;AAC/B,iBAAS,OAAO;AAGhB,cAAM,SAAS,UAAU;AACzB,cAAM,QAAQ,UAAU;AACxB,cAAM,MAAM,UAAU,OAAO;AAC7B,YAAI,OAAO,SAAS,aAAa,OAAO,QAAQ,EAAE,GAAG,IAAI,GAAG;AAC1D,iBAAO,IAAI,KAAK,OAAO,QAAQ,SAAS;AAAA,QAC1C;AACA,YAAI,MAAM,SAAS,aAAa,MAAM,QAAQ,EAAE,GAAG,IAAI,GAAG;AACxD,gBAAM,IAAI,KAAK,MAAM,QAAQ,SAAS;AAAA,QACxC;AAAA,MACF;AAAA,IACF,OAAO;AACL,eAAS,aAAa,SAAS;AAC/B,WAAK,OAAO;AAAA,IACd;AACA,WAAO;AAAA,EACT;AAAA,EACA,WAAW;AACT,UAAM,OAAO,KAAK,UAAU;AAC5B,WAAO,KAAK;AAAA,EACd;AAAA,EACA,SAAS,OAAO;AACd,UAAM,OAAO,KAAK,YAAY;AAC9B,SAAK,UAAU;AACf,WAAO;AAAA,EACT;AAAA,EACA,aAAa;AACX,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI;AACJ,UAAM,SAAS,KAAK,UAAU;AAC9B,QAAI,YAAY,MAAM,GAAG;AACvB,iBAAW,OAAO,YAAY;AAAA,IAChC;AACA,WAAO,aAAa,UAAU,QAAQ,KAAK,SAAS,IAAI;AAAA,EAC1D;AAAA,EACA,WAAW,SAAS;AAClB,UAAM,OAAO,KAAK,YAAY;AAC9B,SAAK,YAAY;AACjB,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB;AACd,UAAM,OAAO,KAAK,YAAY;AAC9B,WAAO,KAAK,WAAW,CAAC,KAAK,SAAS;AAAA,EACxC;AAAA,EACA,YAAY;AAEV,UAAM,SAAS,KAAK,UAAU;AAC9B,QAAI,WAAW,QAAQ,CAAC,KAAK,WAAW,GAAG;AACzC,aAAO,KAAK,UAAU,EAAE;AAAA,IAC1B;AAEA,QAAI,iBAAiB,OAAO,iBAAiB;AAC7C,QAAI,cAAc;AAClB,WAAO,gBAAgB,cAAc,GAAG;AACtC,uBAAiB,eAAe,iBAAiB,EAAE,iBAAiB;AACpE;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,UAAU,QAAQ;AAChB,QAAI,EAAE,OAAO,WAAW,WAAW;AACjC,4BAAsB,uBAAuB;AAAA,IAC/C;AACA,aAAS,KAAK,MAAM,MAAM;AAC1B,QAAI,EAAE,UAAU,IAAI;AAClB,4BAAsB,oCAAoC;AAAA,IAC5D;AACA,QAAI,gBAAgB,KAAK,UAAU;AACnC,WAAO,kBAAkB,QAAQ;AAC/B,UAAI,gBAAgB,QAAQ;AAC1B,sBAAc,IAAI;AAClB;AAAA,MACF,OAAO;AACL,uBAAe,IAAI;AACnB;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,eAAe,MAAM;AACnB,WAAO,gBAAgB,IAAI;AAAA,EAC7B;AAAA;AAAA,EAGA,eAAe,aAAa;AAC1B,WAAO,gBAAgB,WAAW;AAAA,EACpC;AAAA,EACA,aAAa,MAAM;AACjB,WAAO,gBAAgB,IAAI,KAAK,iBAAiB,IAAI;AAAA,EACvD;AAAA,EACA,iBAAiB,OAAO,WAAW;AACjC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,UAAM,aAAa,UAAU,OAAO,QAAQ;AAC5C,UAAM,YAAY,UAAU,MAAM,QAAQ;AAC1C,WAAO,KAAK,WAAW,UAAU,KAAK,KAAK,WAAW,SAAS,KAAK,KAAK,eAAe,EAAE,WAAW,UAAU,eAAe,EAAE;AAAA,EAClI;AAAA,EACA,mBAAmB;AACjB,WAAO;AAAA,EACT;AAAA,EACA,0BAA0B;AACxB,WAAO,gBAAgB,QAAQ;AAAA,EACjC;AAAA,EACA,oBAAoB;AAClB,WAAO;AAAA,EACT;AACF;AACA,SAAS,4BAA4B,KAAK,oBAAoB,MAAM;AAClE,QAAM,eAAe,CAAC;AACtB,QAAM,kBAAkB,CAAC;AACzB,QAAM,YAAY,mBAAmB;AACrC,QAAM,oBAAoB,YAAY,UAAU,WAAW;AAC3D,MAAI;AACJ,MAAI,aAAa,UAAU,QAAQ;AACjC,8BAA0B,UAAU,OAAO;AAAA,EAC7C;AACA,MAAI,sBAAsB,QAAW;AACnC,iBAAa,KAAK,GAAG,oBAAoB,iBAAiB,CAAC;AAAA,EAC7D;AACA,MAAI,WAAW;AACb,UAAM,aAAa,KAAK,UAAU;AAClC,UAAM,cAAc,YAAY,UAAU,KAAK,WAAW,YAAY,MAAM;AAC5E,UAAM,UAAU,KAAK,WAAW;AAChC,QAAI,CAAC,eAAe,SAAS;AAC3B,sBAAgB,KAAK,UAAU,iBAAiB;AAAA,IAClD;AACA,QAAI,CAAC,eAAe,CAAC,SAAS;AAC5B,sBAAgB,KAAK,UAAU,eAAe;AAAA,IAChD;AACA,QAAI,aAAa;AACf,mBAAa,KAAK,UAAU,UAAU,kBAAkB,UAAU,iBAAiB;AAAA,IACrF;AAAA,EACF;AACA,MAAI,4BAA4B,QAAW;AACzC,UAAM,wBAAwB,oBAAoB,uBAAuB;AACzE,QAAI,KAAK,YAAY,EAAE,KAAK,WAAS,YAAY,KAAK,CAAC,GAAG;AACxD,mBAAa,KAAK,GAAG,qBAAqB;AAAA,IAC5C,OAAO;AACL,sBAAgB,KAAK,GAAG,qBAAqB;AAAA,IAC/C;AAAA,EACF;AACA,MAAI,gBAAgB,SAAS,GAAG;AAC9B,gCAA4B,KAAK,GAAG,eAAe;AAAA,EACrD;AACA,MAAI,aAAa,SAAS,GAAG;AAC3B,2BAAuB,KAAK,GAAG,YAAY;AAAA,EAC7C;AACF;AACA,SAAS,sBAAsB,KAAK,cAAc,kBAAkB;AAClE,QAAM,SAAS,aAAa,UAAU;AACtC,QAAM,aAAa,YAAY,MAAM,KAAK,OAAO,YAAY,MAAM;AAAA,EAEnE,CAAC,YAAY,aAAa,cAAc,CAAC;AACzC,MAAI,CAAC,YAAY;AACf,QAAI,gBAAgB,MAAM;AAC1B,QAAI,gBAAgB,UAAU;AAC9B,QAAI,gBAAgB,cAAc;AAAA,EACpC,OAAO;AACL,QAAI,aAAa,QAAQ,UAAU;AACnC,QAAI,aAAa,YAAY,IAAI;AACjC,QAAI,CAAC,oBAAoB,aAAa,cAAc,iBAAiB,WAAW;AAC9E,UAAI,aAAa,gBAAgB,aAAa,WAAW,IAAI,SAAS,OAAO;AAAA,IAC/E;AAAA,EACF;AACF;AACA,SAAS,wBAAwB,SAAS;AACxC,QAAM,oBAAoB,QAAQ,UAAU,SAAS,gBAAgB;AACrE,MAAI,mBAAmB;AACrB,eAAW,SAAS,QAAQ,UAAU;AACpC,UAAI,MAAM,YAAY,SAAS;AAC7B,eAAO,sBAAsB,KAAK;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AACA,QAAM,kBAAkB,QAAQ,aAAa,cAAc;AAC3D,QAAM,UAAU,oBAAoB,SAAS,OAAO,oBAAoB,UAAU,QAAQ;AAC1F,SAAO;AAAA,IACL,MAAM,oBAAoB,OAAO;AAAA,EACnC;AACF;AACA,SAAS,sBAAsB,SAAS;AACtC,QAAM,kBAAkB,QAAQ,aAAa,MAAM,MAAM;AACzD,MAAI,CAAC,iBAAiB;AACpB,WAAO;AAAA,MACL,MAAM;AAAA,IACR;AAAA,EACF;AACA,QAAM,UAAU,QAAQ,aAAa,SAAS;AAC9C,SAAO;AAAA,IACL,MAAM,oBAAoB,OAAO;AAAA,EACnC;AACF;AAOA,SAAS,oBAAoB,SAAS;AACpC,SAAO,sBAAsB,IAAI,aAAa,QAAW,OAAO,CAAC;AACnE;AAOA,SAAS,gBAAgB,MAAM;AAC7B,SAAO,gBAAgB;AACzB;AAWA,IAAM,WAAN,cAAuB,YAAY;AAAA,EA4BjC,YAAY,WAAW,UAAU,QAAQ,GAAG,KAAK;AAC/C,UAAM,GAAG;AA3BX;AAAA;AAEA;AAAA;AAEA;AAAA;AAwBE,UAAM,YAAY,iBAAiB,QAAQ,KAAK;AAChD,SAAK,aAAa;AAClB,SAAK,QAAQ,cAAc,WAAW,OAAO;AAC7C,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA,EAzBA,UAAU;AACR,WAAO,KAAK,OAAO,QAAQ;AAAA,MACzB,YAAY,UAAQ;AAClB,uCAA+B,IAAI;AACnC,oCAA4B,IAAI;AAAA,MAClC;AAAA,MACA,SAAS;AAAA,MACT,WAAW,eAAe;AAAA,QACxB,IAAI,OAAO;AAAA,UACT,YAAY;AAAA,UACZ,UAAU;AAAA,QACZ;AAAA,QACA,IAAI,OAAO;AAAA,UACT,YAAY;AAAA,UACZ,UAAU;AAAA,QACZ;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAQA,eAAe,UAAU;AACvB,UAAM,eAAe,QAAQ;AAC7B,SAAK,aAAa,SAAS;AAC3B,SAAK,QAAQ,SAAS;AACtB,SAAK,UAAU,SAAS;AAAA,EAC1B;AAAA,EACA,SAAS;AACP,WAAO,KAAK,UAAU,EAAE;AAAA,EAC1B;AAAA,EACA,YAAY,MAAM;AAChB,UAAM,WAAW,KAAK,YAAY;AAClC,aAAS,aAAa;AACtB,aAAS,QAAQ,SAAS,WAAW,OAAO;AAC5C,WAAO;AAAA,EACT;AAAA,EACA,cAAc;AACZ,WAAO,KAAK,UAAU,EAAE;AAAA,EAC1B;AAAA,EACA,WAAW;AACT,WAAO,KAAK,UAAU,EAAE;AAAA,EAC1B;AAAA,EACA,SAAS,OAAO;AACd,UAAM,OAAO,KAAK,YAAY;AAC9B,SAAK,UAAU;AACf,WAAO;AAAA,EACT;AAAA;AAAA,EAIA,UAAU,QAAQ,SAAS;AACzB,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,SAAS,cAAc,GAAG;AACtC,QAAI,KAAK,YAAY,GAAG;AACtB,UAAI,aAAa,SAAS,OAAO,KAAK,OAAO,CAAC;AAAA,IAChD;AAEA,QAAI,oBAAoB,KAAK;AAC7B,4BAAwB,KAAK,OAAO,OAAO,IAAI;AAC/C,WAAO;AAAA,EACT;AAAA,EACA,UAAU,UAAU,KAAK,QAAQ;AAC/B,QAAI,SAAS,UAAU,KAAK,SAAS,SAAS,eAAe,KAAK,YAAY;AAC5E,aAAO;AAAA,IACT;AACA,4BAAwB,KAAK,OAAO,OAAO,IAAI;AAC/C,WAAO;AAAA,EACT;AAAA,EACA,eAAe,gBAAgB;AAC7B,WAAO,MAAM,eAAe,cAAc,EAAE,YAAY,eAAe,QAAQ,EAAE,SAAS,eAAe,KAAK;AAAA,EAChH;AAAA,EACA,UAAU,QAAQ;AAChB,UAAM,UAAU,KAAK,UAAU,OAAO,SAAS,MAAM;AACrD,QAAI,cAAc,OAAO,GAAG;AAC1B,UAAI,KAAK,YAAY,GAAG;AACtB,gBAAQ,aAAa,SAAS,OAAO,KAAK,OAAO,CAAC;AAAA,MACpD;AACA,UAAI,KAAK,eAAe,SAAS;AAC/B,gBAAQ,aAAa,qBAAqB,OAAO;AAAA,MACnD;AAAA,IACF;AACA,WAAO;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAAA,EACA,aAAa;AACX,WAAO;AAAA,MACL,GAAG,MAAM,WAAW;AAAA,MACpB,UAAU,KAAK,YAAY;AAAA,MAC3B,OAAO,KAAK,SAAS;AAAA,MACrB,KAAK,KAAK,OAAO;AAAA,IACnB;AAAA,EACF;AAAA,EACA,aAAa;AACX,WAAO;AAAA,EACT;AAAA,EACA,YAAY;AACV,WAAO;AAAA,EACT;AAAA,EACA,OAAO,OAAO,aAAa,eAAe;AACxC,QAAI,wBAAwB;AAC5B,aAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,YAAM,OAAO,cAAc,CAAC;AAC5B,UAAI,CAAC,gBAAgB,IAAI,GAAG;AAC1B,YAAI,0BAA0B,eAAe;AAC3C,kCAAwB,CAAC,GAAG,aAAa;AAAA,QAC3C;AACA,8BAAsB,CAAC,IAAI,oBAAoB,EAAE,OAAO,eAAe,IAAI,KAAK,EAAE,YAAY,IAAI,KAAK,KAAK,SAAS,KAAK,gBAAgB,KAAK,eAAe,CAAC,IAAI,IAAI;AAAA,MACzK;AAAA,IACF;AACA,WAAO,MAAM,OAAO,OAAO,aAAa,qBAAqB;AAAA,EAC/D;AAAA,EACA,iBAAiB,OAAO;AACtB,WAAO,gBAAgB,KAAK;AAAA,EAC9B;AACF;AACA,SAAS,wBAAwB,KAAK,oBAAoB,MAAM;AAC9D,QAAM,eAAe,CAAC;AACtB,QAAM,kBAAkB,CAAC;AACzB,QAAM,YAAY,mBAAmB;AACrC,MAAI,cAAc,QAAW;AAC3B,UAAM,uBAAuB,UAAU,GAAG,KAAK,KAAK,OAAO,KAAK,CAAC;AACjE,UAAM,YAAY,cAAc,IAAI,IAAI;AACxC,UAAM,sBAAsB,YAAY,qBAAqB;AAC7D,UAAM,qBAAqB,qBAAqB,mBAAmB;AACnE,UAAM,gBAAgB,UAAU,KAAK,KAAK;AAC1C,QAAI;AACJ,UAAM,kBAAkB,UAAU;AAClC,UAAM,qBAAqB,UAAU;AACrC,QAAI,oBAAoB,UAAa,gBAAgB,MAAM;AACzD,4BAAsB,gBAAgB;AAAA,IACxC;AACA,QAAI,kBAAkB,QAAW;AAC/B,mBAAa,KAAK,aAAa;AAAA,IACjC;AACA,QAAI,uBAAuB,UAAa,KAAK,eAAe,SAAS;AACnE,mBAAa,KAAK,kBAAkB;AAAA,IACtC;AACA,QAAI,uBAAuB,QAAW;AACpC,mBAAa,KAAK,GAAG,oBAAoB,kBAAkB,CAAC;AAC5D,eAAS,IAAI,GAAG,IAAI,qBAAqB,QAAQ,KAAK;AACpD,YAAI,MAAM,qBAAqB;AAC7B,0BAAgB,KAAK,KAAK,QAAQ,CAAC;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AACA,QAAI,wBAAwB,QAAW;AACrC,YAAM,wBAAwB,oBAAoB,mBAAmB;AACrE,UAAI,YAAY,GAAG;AACjB,qBAAa,KAAK,GAAG,qBAAqB;AAAA,MAC5C,OAAO;AACL,wBAAgB,KAAK,GAAG,qBAAqB;AAAA,MAC/C;AAAA,IACF;AAAA,EACF;AACA,MAAI,gBAAgB,SAAS,GAAG;AAC9B,gCAA4B,KAAK,GAAG,eAAe;AAAA,EACrD;AACA,MAAI,aAAa,SAAS,GAAG;AAC3B,2BAAuB,KAAK,GAAG,YAAY;AAAA,EAC7C;AACF;AAOA,SAAS,mBAAmB,OAAO;AACjC,QAAM,sBAAsB,CAAC;AAC7B,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,OAAO,MAAM,CAAC;AACpB,QAAI,gBAAgB,IAAI,GAAG;AACzB,0BAAoB,KAAK,IAAI;AAC7B,YAAM,WAAW,KAAK,YAAY;AAClC,UAAI,SAAS,SAAS,GAAG;AACvB,iBAAS,QAAQ,WAAS;AACxB,cAAI,YAAY,KAAK,GAAG;AACtB,gCAAoB,KAAK,gBAAgB,KAAK,CAAC;AAAA,UACjD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,OAAO;AACL,0BAAoB,KAAK,gBAAgB,IAAI,CAAC;AAAA,IAChD;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,eAAe,SAAS;AAC/B,MAAI,QAAQ,aAAa,mBAAmB,MAAM;AAAA,EAElD,QAAQ,UAAU,SAAS,oBAAoB,GAAG;AAChD,WAAO;AAAA,EACT;AAEA,aAAW,SAAS,QAAQ,YAAY;AACtC,QAAI,cAAc,KAAK,KAAK,MAAM,aAAa,cAAc,GAAG;AAC9D,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,iBAAiB,SAAS;AACjC,QAAM,WAAW,QAAQ,SAAS,YAAY;AAC9C,MAAI,OAAO;AACX,MAAI,aAAa,MAAM;AAErB,UAAM,QAAQ,QAAQ;AACtB,WAAO,gBAAgB,UAAU,KAAK;AAAA,EACxC,WAAW,aAAa,MAAM;AAC5B,QAAI,eAAe,OAAO,GAAG;AAC3B,aAAO,gBAAgB,OAAO;AAAA,IAChC,OAAO;AACL,aAAO,gBAAgB,QAAQ;AAAA,IACjC;AAAA,EACF;AACA,SAAO;AAAA,IACL,OAAO;AAAA,IACP;AAAA,EACF;AACF;AACA,IAAM,mBAAmB;AAAA,EACvB,IAAI;AAAA,EACJ,IAAI;AACN;AAQA,SAAS,gBAAgB,WAAW,UAAU,QAAQ,GAAG;AACvD,SAAO,sBAAsB,IAAI,SAAS,UAAU,KAAK,CAAC;AAC5D;AAOA,SAAS,YAAY,MAAM;AACzB,SAAO,gBAAgB;AACzB;AAUA,IAAM,4BAA4B,cAAc,2BAA2B;AAC3E,SAAS,kBAAkB,QAAQ;AACjC,SAAO,cAAc,OAAO,gBAAgB,2BAA2B,MAAM;AAC3E,gBAAY,OAAO;AACnB,WAAO;AAAA,EACT,GAAG,oBAAoB,GAAG,OAAO,gBAAgB,wBAAwB,WAAS;AAChF,WAAO,oBAAoB,OAAO,QAAQ,KAAK;AAAA,EACjD,GAAG,oBAAoB,GAAG,OAAO,gBAAgB,sBAAsB,WAAS;AAC9E,WAAO,oBAAoB,OAAO,QAAQ,IAAI;AAAA,EAChD,GAAG,oBAAoB,GAAG,OAAO,gBAAgB,oBAAoB,MAAM;AACzE,UAAM,aAAa,uBAAuB;AAC1C,QAAI,cAAc,MAAM;AACtB,YAAM,cAAc,OAAO,eAAe;AAC1C,UAAI,eAAe,MAAM;AACvB,oBAAY,MAAM;AAAA,MACpB;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,GAAG,oBAAoB,GAAG,OAAO,gBAAgB,mBAAmB,WAAS;AAC3E,UAAM,aAAa,uBAAuB;AAC1C,QAAI,cAAc,QAAQ,OAAO,WAAW,GAAG;AAC7C,aAAO,OAAO,MAAM;AAClB,cAAM,eAAe,2BAA2B,UAAU;AAC1D,YAAI,gBAAgB,YAAY,GAAG;AACjC,gBAAM,eAAe;AACrB,uBAAa,cAAc;AAAA,QAC7B;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,GAAG,oBAAoB,GAAG,OAAO,gBAAgB,wBAAwB,WAAS;AAChF,WAAO,OAAO,eAAe,EAAE,KAAK,MAAM;AACxC,YAAM,YAAY,cAAc;AAChC,UAAI,kBAAkB,SAAS,KAAK,UAAU,YAAY,GAAG;AAC3D,cAAM;AAAA,UACJ;AAAA,QACF,IAAI;AACJ,cAAM,YAAY,OAAO,SAAS;AAClC,YAAI,aAAa,OAAO,WAAW,GAAG;AACpC,gBAAM,aAAa,OAAO,QAAQ;AAClC,gBAAM,cAAc,oBAAoB,YAAY,UAAQ,eAAe,IAAI,KAAK,CAAC,KAAK,SAAS,CAAC;AACpG,cAAI,gBAAgB,WAAW,GAAG;AAChC,kBAAM,SAAS,YAAY,UAAU;AACrC,gBAAI,YAAY,MAAM,KAAK,OAAO,YAAY,MAAM,YAAY,aAAa,YAAY,mBAAmB,MAAM,aAAa;AAC7H,oBAAM,UAAU,OAAO,gBAAgB,YAAY,KAAK;AACxD,kBAAI,WAAW,QAAQ,SAAS,kBAAkB,SAAS;AACzD,wBAAQ,MAAM;AACd,sBAAM,eAAe;AACrB,uBAAO;AAAA,cACT;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC;AAAA,EACH,GAAG,oBAAoB,GAAG,OAAO,qBAAqB,CAAC,aAAa,gBAAgB;AAClF,QAAI,gBAAgB,MAAM;AACxB,kBAAY,iBAAiB,SAAS,WAAW;AACjD,kBAAY,iBAAiB,eAAe,iBAAiB;AAAA,IAC/D;AACA,QAAI,gBAAgB,MAAM;AACxB,kBAAY,oBAAoB,SAAS,WAAW;AACpD,kBAAY,oBAAoB,eAAe,iBAAiB;AAAA,IAClE;AAAA,EACF,CAAC,CAAC;AACJ;AACA,SAAS,qBAAqB,OAAO,UAAU;AAC7C,QAAM,SAAS,MAAM;AACrB,MAAI,CAAC,cAAc,MAAM,GAAG;AAC1B;AAAA,EACF;AAGA,QAAM,aAAa,OAAO;AAC1B,MAAI,cAAc,UAAU,MAAM,WAAW,YAAY,QAAQ,WAAW,YAAY,OAAO;AAC7F;AAAA,EACF;AACA,QAAM,aAAa,OAAO;AAG1B,MAAI,CAAC,cAAc,WAAW,sBAAsB,SAAS;AAC3D;AAAA,EACF;AACA,QAAM,OAAO,OAAO,sBAAsB;AAC1C,QAAM,OAAO,mBAAmB,MAAM;AACtC,QAAM,UAAU,MAAM,UAAU;AAGhC,QAAM,eAAe,OAAO,mBAAmB,OAAO,iBAAiB,QAAQ,UAAU,IAAI;AAAA,IAC3F,OAAO;AAAA,EACT;AACA,QAAM,sBAAsB,WAAW,aAAa,KAAK;AAGzD,QAAM,eAAe,MAAM,gBAAgB;AAC3C,QAAM,mBAAmB,eAAe,KAAK;AAE7C,MAAI,OAAO,QAAQ,QAAQ,UAAU,KAAK,QAAQ,oBAAoB,UAAU,KAAK,QAAQ,sBAAsB,mBAAmB,UAAU,KAAK,OAAO,oBAAoB,UAAU,KAAK,OAAO,sBAAsB,kBAAkB;AAC5O,aAAS;AAAA,EACX;AACF;AACA,SAAS,YAAY,OAAO;AAC1B,uBAAqB,OAAO,MAAM;AAChC,QAAI,cAAc,MAAM,MAAM,GAAG;AAC/B,YAAM,UAAU,MAAM;AACtB,YAAM,SAAS,4BAA4B,OAAO;AAClD,UAAI,UAAU,QAAQ,OAAO,WAAW,GAAG;AACzC,eAAO,OAAO,MAAM;AAClB,gBAAM,OAAO,2BAA2B,OAAO;AAC/C,cAAI,gBAAgB,IAAI,GAAG;AACzB,oBAAQ,MAAM;AACd,iBAAK,cAAc;AAAA,UACrB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,CAAC;AACH;AACA,SAAS,kBAAkB,OAAO;AAChC,uBAAqB,OAAO,MAAM;AAEhC,UAAM,eAAe;AAAA,EACvB,CAAC;AACH;AACA,SAAS,yBAAyB;AAChC,QAAM,gBAAgB,SAAS;AAC/B,SAAO,cAAc,aAAa,KAAK,cAAc,YAAY,QAAQ,cAAc,cAAc;AAAA,EAErG,cAAc,WAAW,sBAAsB,UAAU,gBAAgB;AAC3E;AACA,SAAS,yBAAyB,MAAM,UAAU;AAChD,MAAI,UAAU,WAAW,KAAK,mBAAmB,IAAI,KAAK,eAAe;AACzE,MAAI,SAAS;AAGb,SAAO,WAAW,QAAQ,gBAAgB,MAAM,GAAG;AAEjD,aAAS,OAAO,iBAAiB,EAAE,UAAU;AAC7C,QAAI,UAAU,MAAM;AAClB,gBAAU,WAAW,OAAO,mBAAmB,IAAI,OAAO,eAAe;AAAA,IAC3E;AAAA,EACF;AAGA,SAAO,gBAAgB,OAAO,GAAG;AAC/B,UAAM,aAAa,WAAW,QAAQ,aAAa,IAAI,QAAQ,cAAc;AAC7E,QAAI,CAAC,YAAY,UAAU,GAAG;AAC5B,aAAO;AAAA,IACT;AACA,cAAU,WAAW,WAAW,aAAa,IAAI,WAAW,cAAc;AAAA,EAC5E;AACA,SAAO;AACT;AACA,SAAS,oBAAoB,OAAO,QAAQ,UAAU;AACpD,QAAM,aAAa,uBAAuB;AAC1C,MAAI,cAAc,MAAM;AACtB,WAAO,OAAO,MAAM;AAClB,YAAM,WAAW,2BAA2B,UAAU;AACtD,UAAI,CAAC,gBAAgB,QAAQ,GAAG;AAC9B;AAAA,MACF;AACA,YAAM,eAAe,yBAAyB,UAAU,QAAQ;AAChE,UAAI,gBAAgB,MAAM;AACxB,qBAAa,YAAY;AACzB,cAAM,MAAM,OAAO,gBAAgB,aAAa,KAAK;AACrD,YAAI,OAAO,MAAM;AACf,gBAAM,eAAe;AACrB,qBAAW,MAAM;AACf,gBAAI,MAAM;AAAA,UACZ,GAAG,CAAC;AAAA,QACN;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAUA,IAAM,4BAA4B,cAAc,2BAA2B;AAC3E,IAAM,gCAAgC,cAAc,+BAA+B;AACnF,IAAM,8BAA8B,cAAc,6BAA6B;AAC/E,IAAM,sBAAsB,cAAc,qBAAqB;AAC/D,SAAS,aAAa,QAAQ;AAC5B,QAAM,iBAAiB,cAAc,OAAO,gBAAgB,6BAA6B,MAAM;AAC7F,gBAAY,QAAQ;AACpB,WAAO;AAAA,EACT,GAAG,oBAAoB,GAAG,OAAO,gBAAgB,2BAA2B,aAAW;AACrF,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI;AACJ,UAAM,WAAW,cAAc,WAAW;AAC1C,QAAI,CAAC,YAAY,QAAQ,GAAG;AAC1B,aAAO;AAAA,IACT;AACA,QAAI,SAAS,YAAY,MAAM,UAAU;AACvC,eAAS,SAAS,QAAQ;AAC1B,kCAA4B,QAAQ;AAAA,IACtC;AACA,WAAO;AAAA,EACT,GAAG,oBAAoB,GAAG,OAAO,gBAAgB,+BAA+B,MAAM;AACpF,gBAAY,QAAQ;AACpB,WAAO;AAAA,EACT,GAAG,oBAAoB,GAAG,OAAO,gBAAgB,qBAAqB,MAAM;AAC1E,gBAAY;AACZ,WAAO;AAAA,EACT,GAAG,oBAAoB,GAAG,OAAO,gBAAgB,0BAA0B,MAAM,2BAA2B,GAAG,oBAAoB,GAAG,OAAO,sBAAsB,cAAc,UAAQ;AACvL,UAAM,aAAa,KAAK,cAAc;AACtC,QAAI,YAAY;AACd,UAAI,YAAY,UAAU,GAAG;AAC3B,cAAM,QAAQ,WAAW,SAAS;AAClC,cAAM,SAAS,WAAW,UAAU;AACpC,YAAI,KAAK,aAAa,MAAM,OAAO;AACjC,eAAK,aAAa,KAAK;AAAA,QACzB;AACA,YAAI,KAAK,cAAc,MAAM,QAAQ;AACnC,eAAK,cAAc,MAAM;AAAA,QAC3B;AAAA,MACF;AAAA,IACF,OAAO;AAEL,YAAM,YAAY,cAAc;AAChC,UAAI,kBAAkB,SAAS,MAAM,UAAU,UAAU,KAAK,aAAa,KAAK,UAAU,WAAW,KAAK,cAAc,MAAM,UAAU,YAAY,KAAK,KAAK,GAAG,UAAU,OAAO,QAAQ,CAAC,GAAG;AAC5L,aAAK,aAAa,UAAU,KAAK,EAAE,cAAc,UAAU,MAAM;AAAA,MACnE;AAAA,IACF;AAAA,EACF,CAAC,GAAG,OAAO,sBAAsB,UAAU,UAAQ;AACjD,UAAM,qBAAqB,KAAK,UAAU;AAC1C,QAAI,gBAAgB,kBAAkB,KAAK,KAAK,GAAG,mBAAmB,cAAc,CAAC,GAAG;AACtF,YAAM,QAAQ,KAAK,SAAS;AAC5B,YAAM,SAAS,KAAK,UAAU;AAC9B,UAAI,UAAU,mBAAmB,aAAa,KAAK,WAAW,mBAAmB,cAAc,GAAG;AAChG,2BAAmB,aAAa,KAAK,EAAE,cAAc,MAAM;AAAA,MAC7D;AAAA,IACF;AAAA,EACF,CAAC,CAAC;AACF,SAAO;AACT;AACA,SAAS,kCAAkC,QAAQ;AACjD,QAAM,0BAA0B,kBAAgB;AAC9C,UAAM,WAAW,aAAa,UAAU;AACxC,QAAI,YAAY,aAAa,cAAc,CAAC,KAAK,CAAC,YAAY,QAAQ,GAAG;AACvE;AAAA,IACF;AACA,UAAM,uBAAuB,oBAAoB,cAAc,UAAQ,gBAAgB,IAAI,KAAK,YAAY,KAAK,UAAU,CAAC,KAAK,gBAAgB,KAAK,mBAAmB,CAAC,CAAC;AAC3K,QAAI,yBAAyB,QAAQ,aAAa,UAAU,IAAI,GAAG;AACjE,mBAAa,UAAU,CAAC;AAAA,IAC1B,WAAW,gBAAgB,oBAAoB,GAAG;AAChD,YAAM,mBAAmB,qBAAqB,mBAAmB;AACjE,UAAI,gBAAgB,gBAAgB,GAAG;AACrC,cAAM,kBAAkB,6BAA6B,gBAAgB;AACrE,cAAM,cAAc,gBAAgB,UAAU;AAC9C,YAAI,YAAY,WAAW,GAAG;AAC5B,gBAAM,YAAY,cAAc,WAAW;AAC3C,gBAAM,QAAQ,cAAc,QAAQ;AACpC,cAAI,YAAY,IAAI,OAAO;AACzB,yBAAa,UAAU,SAAS;AAAA,UAClC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,QAAM,+BAA+B,cAAY;AAC/C,UAAM,QAAQ,CAAC,QAAQ;AACvB,WAAO,MAAM,SAAS,GAAG;AACvB,YAAM,OAAO,MAAM,MAAM;AACzB,UAAI,CAAC,YAAY,IAAI,GAAG;AACtB;AAAA,MACF;AACA,iBAAW,SAAS,KAAK,YAAY,GAAG;AACtC,YAAI,gBAAgB,KAAK,GAAG;AAC1B,kCAAwB,KAAK;AAC7B,gBAAM,aAAa,MAAM,cAAc;AACvC,cAAI,YAAY,UAAU,GAAG;AAC3B,kBAAM,KAAK,UAAU;AAAA,UACvB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO,OAAO,sBAAsB,UAAU,4BAA4B;AAC5E;AACA,SAAS,6BAA6B,cAAc;AAClD,MAAI,UAAU;AACd,MAAI,aAAa,QAAQ,cAAc;AACvC,SAAO,YAAY,UAAU,GAAG;AAC9B,UAAM,YAAY,WAAW,aAAa;AAC1C,QAAI,gBAAgB,SAAS,GAAG;AAC9B,gBAAU;AACV,mBAAa,QAAQ,cAAc;AAAA,IACrC,OAAO;AACL;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAcA,SAAS,WAAW,QAAQ,UAAU;AACpC,SAAO,OAAO,MAAM,YAAY,QAAQ,CAAC;AAC3C;AAWA,SAAS,WAAW,QAAQ;AAC1B,SAAO,OAAO,MAAM,YAAY,CAAC;AACnC;AAKA,IAAM,gBAAgB,gBAAgB;AAAA,EACpC,MAAM,QAAQ,QAAQ,OAAO;AAC3B,WAAO,aAAa,MAAM;AAAA,EAC5B;AAAA,EACA,QAAQ,SAAS;AAAA,IACf,iBAAiB;AAAA,EACnB,CAAC;AAAA,EACD,MAAM;AAAA,EACN,OAAO,CAAC,UAAU,YAAY;AAAA,EAC9B,SAAS,QAAQ,QAAQ,OAAO;AAC9B,UAAM,SAAS,MAAM,UAAU;AAC/B,WAAO,cAAc,aAAa,MAAM,GAAG,EAAO,MAAM,OAAO,gBAAgB,QAAQ,kCAAkC,MAAM,IAAI,MAAS,CAAC;AAAA,EAC/I;AACF,CAAC;AASD,IAAM,qBAAqB,gBAAgB;AAAA,EACzC,cAAc,CAAC,aAAa;AAAA,EAC5B,MAAM;AAAA,EACN,UAAU;AACZ,CAAC;",
  "names": []
}
