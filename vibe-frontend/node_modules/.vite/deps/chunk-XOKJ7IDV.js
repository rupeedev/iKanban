import {
  $createHeadingNode,
  $createQuoteNode,
  $isHeadingNode,
  $isQuoteNode,
  HeadingNode,
  QuoteNode
} from "./chunk-VVTC5WRD.js";
import {
  $createListItemNode,
  $createListNode,
  $isListItemNode,
  $isListNode,
  ListItemNode,
  ListNode
} from "./chunk-TZQYOE3V.js";
import {
  $createCodeNode,
  $isCodeNode,
  CodeNode
} from "./chunk-WAABUVNB.js";
import {
  $createLinkNode,
  $isAutoLinkNode,
  $isLinkNode,
  LinkNode
} from "./chunk-YS2X4MTG.js";
import {
  $createLineBreakNode,
  $createParagraphNode,
  $createRangeSelection,
  $createTextNode,
  $findMatchingParent,
  $getRoot,
  $getSelection,
  $isDecoratorNode,
  $isElementNode,
  $isLineBreakNode,
  $isParagraphNode,
  $isRangeSelection,
  $isRootOrShadowRoot,
  $isTextNode,
  $setSelection,
  COLLABORATION_TAG,
  HISTORIC_TAG
} from "./chunk-FWUGA2FG.js";

// ../node_modules/.pnpm/@lexical+markdown@0.36.2/node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs
function indexBy(list, callback) {
  const index = {};
  for (const item of list) {
    const key = callback(item);
    if (!key) {
      continue;
    }
    if (index[key]) {
      index[key].push(item);
    } else {
      index[key] = [item];
    }
  }
  return index;
}
function transformersByType(transformers) {
  const byType = indexBy(transformers, (t) => t.type);
  return {
    element: byType.element || [],
    multilineElement: byType["multiline-element"] || [],
    textFormat: byType["text-format"] || [],
    textMatch: byType["text-match"] || []
  };
}
var PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\s]/;
var MARKDOWN_EMPTY_LINE_REG_EXP = /^\s{0,3}$/;
function isEmptyParagraph(node) {
  if (!$isParagraphNode(node)) {
    return false;
  }
  const firstChild = node.getFirstChild();
  return firstChild == null || node.getChildrenSize() === 1 && $isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());
}
function createMarkdownExport(transformers, shouldPreserveNewLines = false) {
  const byType = transformersByType(transformers);
  const elementTransformers = [...byType.multilineElement, ...byType.element];
  const isNewlineDelimited = !shouldPreserveNewLines;
  const textFormatTransformers = byType.textFormat.filter((transformer) => transformer.format.length === 1).sort((a, b) => {
    return Number(a.format.includes("code")) - Number(b.format.includes("code"));
  });
  return (node) => {
    const output = [];
    const children = (node || $getRoot()).getChildren();
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const result = exportTopLevelElements(child, elementTransformers, textFormatTransformers, byType.textMatch);
      if (result != null) {
        output.push(
          // separate consecutive group of texts with a line break: eg. ["hello", "world"] -> ["hello", "/nworld"]
          isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? "\n".concat(result) : result
        );
      }
    }
    return output.join("\n");
  };
}
function exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {
  for (const transformer of elementTransformers) {
    if (!transformer.export) {
      continue;
    }
    const result = transformer.export(node, (_node) => exportChildren(_node, textTransformersIndex, textMatchTransformers));
    if (result != null) {
      return result;
    }
  }
  if ($isElementNode(node)) {
    return exportChildren(node, textTransformersIndex, textMatchTransformers);
  } else if ($isDecoratorNode(node)) {
    return node.getTextContent();
  } else {
    return null;
  }
}
function exportChildren(node, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags) {
  const output = [];
  const children = node.getChildren();
  if (!unclosedTags) {
    unclosedTags = [];
  }
  if (!unclosableTags) {
    unclosableTags = [];
  }
  mainLoop: for (const child of children) {
    for (const transformer of textMatchTransformers) {
      if (!transformer.export) {
        continue;
      }
      const result = transformer.export(child, (parentNode) => exportChildren(
        parentNode,
        textTransformersIndex,
        textMatchTransformers,
        unclosedTags,
        // Add current unclosed tags to the list of unclosable tags - we don't want nested tags from
        // textmatch transformers to close the outer ones, as that may result in invalid markdown.
        // E.g. **text [text**](https://lexical.io)
        // is invalid markdown, as the closing ** is inside the link.
        //
        [...unclosableTags, ...unclosedTags]
      ), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex, unclosedTags, unclosableTags));
      if (result != null) {
        output.push(result);
        continue mainLoop;
      }
    }
    if ($isLineBreakNode(child)) {
      output.push("\n");
    } else if ($isTextNode(child)) {
      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex, unclosedTags, unclosableTags));
    } else if ($isElementNode(child)) {
      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags));
    } else if ($isDecoratorNode(child)) {
      output.push(child.getTextContent());
    }
  }
  return output.join("");
}
function exportTextFormat(node, textContent, textTransformers, unclosedTags, unclosableTags) {
  let output = node.getFormat() === 0 ? textContent : escapeLeadingAndTrailingWhitespaces(textContent);
  if (!node.hasFormat("code")) {
    output = output.replace(/([*_`~\\])/g, "\\$1");
  }
  let openingTags = "";
  let closingTagsBefore = "";
  let closingTagsAfter = "";
  const prevNode = getTextSibling(node, true);
  const nextNode = getTextSibling(node, false);
  const applied = /* @__PURE__ */ new Set();
  for (const transformer of textTransformers) {
    const format = transformer.format[0];
    const tag = transformer.tag;
    if (hasFormat(node, format) && !applied.has(format)) {
      applied.add(format);
      if (!hasFormat(prevNode, format) || !unclosedTags.find((element) => element.tag === tag)) {
        unclosedTags.push({
          format,
          tag
        });
        openingTags += tag;
      }
    }
  }
  for (let i = 0; i < unclosedTags.length; i++) {
    const nodeHasFormat = hasFormat(node, unclosedTags[i].format);
    const nextNodeHasFormat = hasFormat(nextNode, unclosedTags[i].format);
    if (nodeHasFormat && nextNodeHasFormat) {
      continue;
    }
    const unhandledUnclosedTags = [...unclosedTags];
    while (unhandledUnclosedTags.length > i) {
      const unclosedTag = unhandledUnclosedTags.pop();
      if (unclosableTags && unclosedTag && unclosableTags.find((element) => element.tag === unclosedTag.tag)) {
        continue;
      }
      if (unclosedTag && typeof unclosedTag.tag === "string") {
        if (!nodeHasFormat) {
          closingTagsBefore += unclosedTag.tag;
        } else if (!nextNodeHasFormat) {
          closingTagsAfter += unclosedTag.tag;
        }
      }
      unclosedTags.pop();
    }
    break;
  }
  output = openingTags + output + closingTagsAfter;
  return closingTagsBefore + output;
}
function getTextSibling(node, backward) {
  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();
  if (!sibling) {
    const parent = node.getParentOrThrow();
    if (parent.isInline()) {
      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();
    }
  }
  while (sibling) {
    if ($isElementNode(sibling)) {
      if (!sibling.isInline()) {
        break;
      }
      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();
      if ($isTextNode(descendant)) {
        return descendant;
      } else {
        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();
      }
    }
    if ($isTextNode(sibling)) {
      return sibling;
    }
    if (!$isElementNode(sibling)) {
      return null;
    }
  }
  return null;
}
function hasFormat(node, format) {
  return $isTextNode(node) && node.hasFormat(format);
}
function escapeLeadingAndTrailingWhitespaces(textContent) {
  return textContent.replace(/^\s+|\s+$/g, (match) => {
    return [...match].map((char) => "&#" + char.codePointAt(0) + ";").join("");
  });
}
function findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex) {
  const textContent = textNode.getTextContent();
  const match = findOutermostMatch(textContent, textFormatTransformersIndex);
  if (!match) {
    return null;
  }
  const textFormatMatchStart = match.index || 0;
  const textFormatMatchEnd = textFormatMatchStart + match[0].length;
  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];
  return {
    endIndex: textFormatMatchEnd,
    match,
    startIndex: textFormatMatchStart,
    transformer
  };
}
function findOutermostMatch(textContent, textTransformersIndex) {
  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);
  if (openTagsMatch == null) {
    return null;
  }
  for (const match of openTagsMatch) {
    const tag = match.replace(/^\s/, "");
    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];
    if (fullMatchRegExp == null) {
      continue;
    }
    const fullMatch = textContent.match(fullMatchRegExp);
    const transformer = textTransformersIndex.transformersByTag[tag];
    if (fullMatch != null && transformer != null) {
      if (transformer.intraword !== false) {
        return fullMatch;
      }
      const {
        index = 0
      } = fullMatch;
      const beforeChar = textContent[index - 1];
      const afterChar = textContent[index + fullMatch[0].length];
      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {
        return fullMatch;
      }
    }
  }
  return null;
}
function importTextFormatTransformer(textNode, startIndex, endIndex, transformer, match) {
  const textContent = textNode.getTextContent();
  let transformedNode, nodeAfter, nodeBefore;
  if (match[0] === textContent) {
    transformedNode = textNode;
  } else {
    if (startIndex === 0) {
      [transformedNode, nodeAfter] = textNode.splitText(endIndex);
    } else {
      [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);
    }
  }
  transformedNode.setTextContent(match[2]);
  if (transformer) {
    for (const format of transformer.format) {
      if (!transformedNode.hasFormat(format)) {
        transformedNode.toggleFormat(format);
      }
    }
  }
  return {
    nodeAfter,
    nodeBefore,
    transformedNode
  };
}
function findOutermostTextMatchTransformer(textNode_, textMatchTransformers) {
  const textNode = textNode_;
  let foundMatchStartIndex = void 0;
  let foundMatchEndIndex = void 0;
  let foundMatchTransformer = void 0;
  let foundMatch = void 0;
  for (const transformer of textMatchTransformers) {
    if (!transformer.replace || !transformer.importRegExp) {
      continue;
    }
    const match = textNode.getTextContent().match(transformer.importRegExp);
    if (!match) {
      continue;
    }
    const startIndex = match.index || 0;
    const endIndex = transformer.getEndIndex ? transformer.getEndIndex(textNode, match) : startIndex + match[0].length;
    if (endIndex === false) {
      continue;
    }
    if (foundMatchStartIndex === void 0 || foundMatchEndIndex === void 0 || // Wraps previous match or is strictly before it.
    startIndex < foundMatchStartIndex && (endIndex > foundMatchEndIndex || endIndex <= foundMatchStartIndex)) {
      foundMatchStartIndex = startIndex;
      foundMatchEndIndex = endIndex;
      foundMatchTransformer = transformer;
      foundMatch = match;
    }
  }
  if (foundMatchStartIndex === void 0 || foundMatchEndIndex === void 0 || foundMatchTransformer === void 0 || foundMatch === void 0) {
    return null;
  }
  return {
    endIndex: foundMatchEndIndex,
    match: foundMatch,
    startIndex: foundMatchStartIndex,
    transformer: foundMatchTransformer
  };
}
function importFoundTextMatchTransformer(textNode, startIndex, endIndex, transformer, match) {
  let transformedNode, nodeAfter, nodeBefore;
  if (startIndex === 0) {
    [transformedNode, nodeAfter] = textNode.splitText(endIndex);
  } else {
    [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);
  }
  if (!transformer.replace) {
    return null;
  }
  const potentialTransformedNode = transformer.replace(transformedNode, match);
  return {
    nodeAfter,
    nodeBefore,
    transformedNode: potentialTransformedNode || void 0
  };
}
function canContainTransformableMarkdown(node) {
  return $isTextNode(node) && !node.hasFormat("code");
}
function importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {
  let foundTextFormat = findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex);
  let foundTextMatch = findOutermostTextMatchTransformer(textNode, textMatchTransformers);
  if (foundTextFormat && foundTextMatch) {
    if (foundTextFormat.startIndex <= foundTextMatch.startIndex && foundTextFormat.endIndex >= foundTextMatch.endIndex || // foundTextMatch is not contained within foundTextFormat
    foundTextMatch.startIndex > foundTextFormat.endIndex) {
      foundTextMatch = null;
    } else {
      foundTextFormat = null;
    }
  }
  if (foundTextFormat) {
    const result = importTextFormatTransformer(textNode, foundTextFormat.startIndex, foundTextFormat.endIndex, foundTextFormat.transformer, foundTextFormat.match);
    if (canContainTransformableMarkdown(result.nodeAfter)) {
      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);
    }
    if (canContainTransformableMarkdown(result.nodeBefore)) {
      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);
    }
    if (canContainTransformableMarkdown(result.transformedNode)) {
      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);
    }
  } else if (foundTextMatch) {
    const result = importFoundTextMatchTransformer(textNode, foundTextMatch.startIndex, foundTextMatch.endIndex, foundTextMatch.transformer, foundTextMatch.match);
    if (!result) {
      return;
    }
    if (canContainTransformableMarkdown(result.nodeAfter)) {
      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);
    }
    if (canContainTransformableMarkdown(result.nodeBefore)) {
      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);
    }
    if (canContainTransformableMarkdown(result.transformedNode)) {
      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);
    }
  }
  const textContent = textNode.getTextContent();
  const escapedText = textContent.replace(/\\([*_`~\\])/g, "$1").replace(/&#(\d+);/g, (_, codePoint) => {
    return String.fromCodePoint(codePoint);
  });
  textNode.setTextContent(escapedText);
}
function createMarkdownImport(transformers, shouldPreserveNewLines = false) {
  const byType = transformersByType(transformers);
  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);
  return (markdownString, node) => {
    const lines = markdownString.split("\n");
    const linesLength = lines.length;
    const root = node || $getRoot();
    root.clear();
    for (let i = 0; i < linesLength; i++) {
      const lineText = lines[i];
      const [imported, shiftedIndex] = $importMultiline(lines, i, byType.multilineElement, root);
      if (imported) {
        i = shiftedIndex;
        continue;
      }
      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch, shouldPreserveNewLines);
    }
    const children = root.getChildren();
    for (const child of children) {
      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {
        child.remove();
      }
    }
    if ($getSelection() !== null) {
      root.selectStart();
    }
  };
}
function $importMultiline(lines, startLineIndex, multilineElementTransformers, rootNode) {
  for (const transformer of multilineElementTransformers) {
    const {
      handleImportAfterStartMatch,
      regExpEnd,
      regExpStart,
      replace
    } = transformer;
    const startMatch = lines[startLineIndex].match(regExpStart);
    if (!startMatch) {
      continue;
    }
    if (handleImportAfterStartMatch) {
      const result = handleImportAfterStartMatch({
        lines,
        rootNode,
        startLineIndex,
        startMatch,
        transformer
      });
      if (result === null) {
        continue;
      } else if (result) {
        return result;
      }
    }
    const regexpEndRegex = typeof regExpEnd === "object" && "regExp" in regExpEnd ? regExpEnd.regExp : regExpEnd;
    const isEndOptional = regExpEnd && typeof regExpEnd === "object" && "optional" in regExpEnd ? regExpEnd.optional : !regExpEnd;
    let endLineIndex = startLineIndex;
    const linesLength = lines.length;
    while (endLineIndex < linesLength) {
      const endMatch = regexpEndRegex ? lines[endLineIndex].match(regexpEndRegex) : null;
      if (!endMatch) {
        if (!isEndOptional || isEndOptional && endLineIndex < linesLength - 1) {
          endLineIndex++;
          continue;
        }
      }
      if (endMatch && startLineIndex === endLineIndex && endMatch.index === startMatch.index) {
        endLineIndex++;
        continue;
      }
      const linesInBetween = [];
      if (endMatch && startLineIndex === endLineIndex) {
        linesInBetween.push(lines[startLineIndex].slice(startMatch[0].length, -endMatch[0].length));
      } else {
        for (let i = startLineIndex; i <= endLineIndex; i++) {
          if (i === startLineIndex) {
            const text = lines[i].slice(startMatch[0].length);
            linesInBetween.push(text);
          } else if (i === endLineIndex && endMatch) {
            const text = lines[i].slice(0, -endMatch[0].length);
            linesInBetween.push(text);
          } else {
            linesInBetween.push(lines[i]);
          }
        }
      }
      if (replace(rootNode, null, startMatch, endMatch, linesInBetween, true) !== false) {
        return [true, endLineIndex];
      }
      break;
    }
  }
  return [false, startLineIndex];
}
function $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers, shouldPreserveNewLines) {
  const textNode = $createTextNode(lineText);
  const elementNode = $createParagraphNode();
  elementNode.append(textNode);
  rootNode.append(elementNode);
  for (const {
    regExp,
    replace
  } of elementTransformers) {
    const match = lineText.match(regExp);
    if (match) {
      textNode.setTextContent(lineText.slice(match[0].length));
      if (replace(elementNode, [textNode], match, true) !== false) {
        break;
      }
    }
  }
  importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);
  if (elementNode.isAttached() && lineText.length > 0) {
    const previousNode = elementNode.getPreviousSibling();
    if (!shouldPreserveNewLines && // Only append if we're not preserving newlines
    ($isParagraphNode(previousNode) || $isQuoteNode(previousNode) || $isListNode(previousNode))) {
      let targetNode = previousNode;
      if ($isListNode(previousNode)) {
        const lastDescendant = previousNode.getLastDescendant();
        if (lastDescendant == null) {
          targetNode = null;
        } else {
          targetNode = $findMatchingParent(lastDescendant, $isListItemNode);
        }
      }
      if (targetNode != null && targetNode.getTextContentSize() > 0) {
        targetNode.splice(targetNode.getChildrenSize(), 0, [$createLineBreakNode(), ...elementNode.getChildren()]);
        elementNode.remove();
      }
    }
  }
}
function createTextFormatTransformersIndex(textTransformers) {
  const transformersByTag = {};
  const fullMatchRegExpByTag = {};
  const openTagsRegExp = [];
  const escapeRegExp = `(?<![\\\\])`;
  for (const transformer of textTransformers) {
    const {
      tag
    } = transformer;
    transformersByTag[tag] = transformer;
    const tagRegExp = tag.replace(/(\*|\^|\+)/g, "\\$1");
    openTagsRegExp.push(tagRegExp);
    if (tag.length === 1) {
      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\${tagRegExp}])(${tagRegExp})((\\\\${tagRegExp})?.*?[^${tagRegExp}\\s](\\\\${tagRegExp})?)((?<!\\\\)|(?<=\\\\\\\\))(${tagRegExp})(?![\\\\${tagRegExp}])`);
    } else {
      fullMatchRegExpByTag[tag] = new RegExp(`(?<!\\\\)(${tagRegExp})((\\\\${tagRegExp})?.*?[^\\s](\\\\${tagRegExp})?)((?<!\\\\)|(?<=\\\\\\\\))(${tagRegExp})(?!\\\\)`);
    }
  }
  return {
    // Reg exp to find open tag + content + close tag
    fullMatchRegExpByTag,
    // Regexp to locate *any* potential opening tag (longest first).
    openTagsRegExp: new RegExp(`${escapeRegExp}(${openTagsRegExp.join("|")})`, "g"),
    transformersByTag
  };
}
function formatDevErrorMessage(message) {
  throw new Error(message);
}
var ORDERED_LIST_REGEX = /^(\s*)(\d{1,})\.\s/;
var UNORDERED_LIST_REGEX = /^(\s*)[-*+]\s/;
var CHECK_LIST_REGEX = /^(\s*)(?:-\s)?\s?(\[(\s|x)?\])\s/i;
var HEADING_REGEX = /^(#{1,6})\s/;
var QUOTE_REGEX = /^>\s/;
var CODE_START_REGEX = /^[ \t]*```([\w-]+)?/;
var CODE_END_REGEX = /[ \t]*```$/;
var CODE_SINGLE_LINE_REGEX = /^[ \t]*```[^`]+(?:(?:`{1,2}|`{4,})[^`]+)*```(?:[^`]|$)/;
var TABLE_ROW_REG_EXP = /^(?:\|)(.+)(?:\|)\s?$/;
var TABLE_ROW_DIVIDER_REG_EXP = /^(\| ?:?-*:? ?)+\|\s?$/;
var createBlockNode = (createNode) => {
  return (parentNode, children, match, isImport) => {
    const node = createNode(match);
    node.append(...children);
    parentNode.replace(node);
    if (!isImport) {
      node.select(0, 0);
    }
  };
};
var LIST_INDENT_SIZE = 4;
function getIndent(whitespaces) {
  const tabs = whitespaces.match(/\t/g);
  const spaces = whitespaces.match(/ /g);
  let indent = 0;
  if (tabs) {
    indent += tabs.length;
  }
  if (spaces) {
    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);
  }
  return indent;
}
var listReplace = (listType) => {
  return (parentNode, children, match, isImport) => {
    const previousNode = parentNode.getPreviousSibling();
    const nextNode = parentNode.getNextSibling();
    const listItem = $createListItemNode(listType === "check" ? match[3] === "x" : void 0);
    if ($isListNode(nextNode) && nextNode.getListType() === listType) {
      const firstChild = nextNode.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(listItem);
      } else {
        nextNode.append(listItem);
      }
      parentNode.remove();
    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {
      previousNode.append(listItem);
      parentNode.remove();
    } else {
      const list = $createListNode(listType, listType === "number" ? Number(match[2]) : void 0);
      list.append(listItem);
      parentNode.replace(list);
    }
    listItem.append(...children);
    if (!isImport) {
      listItem.select(0, 0);
    }
    const indent = getIndent(match[1]);
    if (indent) {
      listItem.setIndent(indent);
    }
  };
};
var listExport = (listNode, exportChildren2, depth) => {
  const output = [];
  const children = listNode.getChildren();
  let index = 0;
  for (const listItemNode of children) {
    if ($isListItemNode(listItemNode)) {
      if (listItemNode.getChildrenSize() === 1) {
        const firstChild = listItemNode.getFirstChild();
        if ($isListNode(firstChild)) {
          output.push(listExport(firstChild, exportChildren2, depth + 1));
          continue;
        }
      }
      const indent = " ".repeat(depth * LIST_INDENT_SIZE);
      const listType = listNode.getListType();
      const prefix = listType === "number" ? `${listNode.getStart() + index}. ` : listType === "check" ? `- [${listItemNode.getChecked() ? "x" : " "}] ` : "- ";
      output.push(indent + prefix + exportChildren2(listItemNode));
      index++;
    }
  }
  return output.join("\n");
};
var HEADING = {
  dependencies: [HeadingNode],
  export: (node, exportChildren2) => {
    if (!$isHeadingNode(node)) {
      return null;
    }
    const level = Number(node.getTag().slice(1));
    return "#".repeat(level) + " " + exportChildren2(node);
  },
  regExp: HEADING_REGEX,
  replace: createBlockNode((match) => {
    const tag = "h" + match[1].length;
    return $createHeadingNode(tag);
  }),
  type: "element"
};
var QUOTE = {
  dependencies: [QuoteNode],
  export: (node, exportChildren2) => {
    if (!$isQuoteNode(node)) {
      return null;
    }
    const lines = exportChildren2(node).split("\n");
    const output = [];
    for (const line of lines) {
      output.push("> " + line);
    }
    return output.join("\n");
  },
  regExp: QUOTE_REGEX,
  replace: (parentNode, children, _match, isImport) => {
    if (isImport) {
      const previousNode = parentNode.getPreviousSibling();
      if ($isQuoteNode(previousNode)) {
        previousNode.splice(previousNode.getChildrenSize(), 0, [$createLineBreakNode(), ...children]);
        parentNode.remove();
        return;
      }
    }
    const node = $createQuoteNode();
    node.append(...children);
    parentNode.replace(node);
    if (!isImport) {
      node.select(0, 0);
    }
  },
  type: "element"
};
var CODE = {
  dependencies: [CodeNode],
  export: (node) => {
    if (!$isCodeNode(node)) {
      return null;
    }
    const textContent = node.getTextContent();
    return "```" + (node.getLanguage() || "") + (textContent ? "\n" + textContent : "") + "\n```";
  },
  regExpEnd: {
    optional: true,
    regExp: CODE_END_REGEX
  },
  regExpStart: CODE_START_REGEX,
  replace: (rootNode, children, startMatch, endMatch, linesInBetween, isImport) => {
    let codeBlockNode;
    let code;
    if (!children && linesInBetween) {
      if (linesInBetween.length === 1) {
        if (endMatch) {
          codeBlockNode = $createCodeNode();
          code = startMatch[1] + linesInBetween[0];
        } else {
          codeBlockNode = $createCodeNode(startMatch[1]);
          code = linesInBetween[0].startsWith(" ") ? linesInBetween[0].slice(1) : linesInBetween[0];
        }
      } else {
        codeBlockNode = $createCodeNode(startMatch[1]);
        if (linesInBetween[0].trim().length === 0) {
          while (linesInBetween.length > 0 && !linesInBetween[0].length) {
            linesInBetween.shift();
          }
        } else {
          linesInBetween[0] = linesInBetween[0].startsWith(" ") ? linesInBetween[0].slice(1) : linesInBetween[0];
        }
        while (linesInBetween.length > 0 && !linesInBetween[linesInBetween.length - 1].length) {
          linesInBetween.pop();
        }
        code = linesInBetween.join("\n");
      }
      const textNode = $createTextNode(code);
      codeBlockNode.append(textNode);
      rootNode.append(codeBlockNode);
    } else if (children) {
      createBlockNode((match) => {
        return $createCodeNode(match ? match[1] : void 0);
      })(rootNode, children, startMatch, isImport);
    }
  },
  type: "multiline-element"
};
var UNORDERED_LIST = {
  dependencies: [ListNode, ListItemNode],
  export: (node, exportChildren2) => {
    return $isListNode(node) ? listExport(node, exportChildren2, 0) : null;
  },
  regExp: UNORDERED_LIST_REGEX,
  replace: listReplace("bullet"),
  type: "element"
};
var CHECK_LIST = {
  dependencies: [ListNode, ListItemNode],
  export: (node, exportChildren2) => {
    return $isListNode(node) ? listExport(node, exportChildren2, 0) : null;
  },
  regExp: CHECK_LIST_REGEX,
  replace: listReplace("check"),
  type: "element"
};
var ORDERED_LIST = {
  dependencies: [ListNode, ListItemNode],
  export: (node, exportChildren2) => {
    return $isListNode(node) ? listExport(node, exportChildren2, 0) : null;
  },
  regExp: ORDERED_LIST_REGEX,
  replace: listReplace("number"),
  type: "element"
};
var INLINE_CODE = {
  format: ["code"],
  tag: "`",
  type: "text-format"
};
var HIGHLIGHT = {
  format: ["highlight"],
  tag: "==",
  type: "text-format"
};
var BOLD_ITALIC_STAR = {
  format: ["bold", "italic"],
  tag: "***",
  type: "text-format"
};
var BOLD_ITALIC_UNDERSCORE = {
  format: ["bold", "italic"],
  intraword: false,
  tag: "___",
  type: "text-format"
};
var BOLD_STAR = {
  format: ["bold"],
  tag: "**",
  type: "text-format"
};
var BOLD_UNDERSCORE = {
  format: ["bold"],
  intraword: false,
  tag: "__",
  type: "text-format"
};
var STRIKETHROUGH = {
  format: ["strikethrough"],
  tag: "~~",
  type: "text-format"
};
var ITALIC_STAR = {
  format: ["italic"],
  tag: "*",
  type: "text-format"
};
var ITALIC_UNDERSCORE = {
  format: ["italic"],
  intraword: false,
  tag: "_",
  type: "text-format"
};
var LINK = {
  dependencies: [LinkNode],
  export: (node, exportChildren2, exportFormat) => {
    if (!$isLinkNode(node) || $isAutoLinkNode(node)) {
      return null;
    }
    const title = node.getTitle();
    const textContent = exportChildren2(node);
    const linkContent = title ? `[${textContent}](${node.getURL()} "${title}")` : `[${textContent}](${node.getURL()})`;
    return linkContent;
  },
  importRegExp: /(?:\[(.*?)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))/,
  regExp: /(?:\[(.*?)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))$/,
  replace: (textNode, match) => {
    const [, linkText, linkUrl, linkTitle] = match;
    const linkNode = $createLinkNode(linkUrl, {
      title: linkTitle
    });
    const openBracketAmount = linkText.split("[").length - 1;
    const closeBracketAmount = linkText.split("]").length - 1;
    let parsedLinkText = linkText;
    let outsideLinkText = "";
    if (openBracketAmount < closeBracketAmount) {
      return;
    } else if (openBracketAmount > closeBracketAmount) {
      const linkTextParts = linkText.split("[");
      outsideLinkText = "[" + linkTextParts[0];
      parsedLinkText = linkTextParts.slice(1).join("[");
    }
    const linkTextNode = $createTextNode(parsedLinkText);
    linkTextNode.setFormat(textNode.getFormat());
    linkNode.append(linkTextNode);
    textNode.replace(linkNode);
    if (outsideLinkText) {
      linkNode.insertBefore($createTextNode(outsideLinkText));
    }
    return linkTextNode;
  },
  trigger: ")",
  type: "text-match"
};
var ELEMENT_TRANSFORMERS = [HEADING, QUOTE, UNORDERED_LIST, ORDERED_LIST];
var MULTILINE_ELEMENT_TRANSFORMERS = [CODE];
var TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];
var TEXT_MATCH_TRANSFORMERS = [LINK];
var TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...MULTILINE_ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];
function normalizeMarkdown(input, shouldMergeAdjacentLines = false) {
  const lines = input.split("\n");
  let inCodeBlock = false;
  const sanitizedLines = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lastLine = sanitizedLines[sanitizedLines.length - 1];
    if (CODE_SINGLE_LINE_REGEX.test(line)) {
      sanitizedLines.push(line);
      continue;
    }
    if (CODE_START_REGEX.test(line) || CODE_END_REGEX.test(line)) {
      inCodeBlock = !inCodeBlock;
      sanitizedLines.push(line);
      continue;
    }
    if (inCodeBlock) {
      sanitizedLines.push(line);
      continue;
    }
    if (line === "" || lastLine === "" || !lastLine || HEADING_REGEX.test(lastLine) || HEADING_REGEX.test(line) || QUOTE_REGEX.test(line) || ORDERED_LIST_REGEX.test(line) || UNORDERED_LIST_REGEX.test(line) || CHECK_LIST_REGEX.test(line) || TABLE_ROW_REG_EXP.test(line) || TABLE_ROW_DIVIDER_REG_EXP.test(line) || !shouldMergeAdjacentLines) {
      sanitizedLines.push(line);
    } else {
      sanitizedLines[sanitizedLines.length - 1] = lastLine + line;
    }
  }
  return sanitizedLines.join("\n");
}
function runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {
  const grandParentNode = parentNode.getParent();
  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {
    return false;
  }
  const textContent = anchorNode.getTextContent();
  if (textContent[anchorOffset - 1] !== " ") {
    return false;
  }
  for (const {
    regExp,
    replace
  } of elementTransformers) {
    const match = textContent.match(regExp);
    if (match && match[0].length === (match[0].endsWith(" ") ? anchorOffset : anchorOffset - 1)) {
      const nextSiblings = anchorNode.getNextSiblings();
      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);
      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;
      if (replace(parentNode, siblings, match, false) !== false) {
        leadingNode.remove();
        return true;
      }
    }
  }
  return false;
}
function runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {
  const grandParentNode = parentNode.getParent();
  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {
    return false;
  }
  const textContent = anchorNode.getTextContent();
  if (textContent[anchorOffset - 1] !== " ") {
    return false;
  }
  for (const {
    regExpStart,
    replace,
    regExpEnd
  } of elementTransformers) {
    if (regExpEnd && !("optional" in regExpEnd) || regExpEnd && "optional" in regExpEnd && !regExpEnd.optional) {
      continue;
    }
    const match = textContent.match(regExpStart);
    if (match && match[0].length === (match[0].endsWith(" ") ? anchorOffset : anchorOffset - 1)) {
      const nextSiblings = anchorNode.getNextSiblings();
      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);
      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;
      if (replace(parentNode, siblings, match, null, null, false) !== false) {
        leadingNode.remove();
        return true;
      }
    }
  }
  return false;
}
function runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {
  let textContent = anchorNode.getTextContent();
  const lastChar = textContent[anchorOffset - 1];
  const transformers = transformersByTrigger[lastChar];
  if (transformers == null) {
    return false;
  }
  if (anchorOffset < textContent.length) {
    textContent = textContent.slice(0, anchorOffset);
  }
  for (const transformer of transformers) {
    if (!transformer.replace || !transformer.regExp) {
      continue;
    }
    const match = textContent.match(transformer.regExp);
    if (match === null) {
      continue;
    }
    const startIndex = match.index || 0;
    const endIndex = startIndex + match[0].length;
    let replaceNode;
    if (startIndex === 0) {
      [replaceNode] = anchorNode.splitText(endIndex);
    } else {
      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);
    }
    replaceNode.selectNext(0, 0);
    transformer.replace(replaceNode, match);
    return true;
  }
  return false;
}
function $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {
  const textContent = anchorNode.getTextContent();
  const closeTagEndIndex = anchorOffset - 1;
  const closeChar = textContent[closeTagEndIndex];
  const matchers = textFormatTransformers[closeChar];
  if (!matchers) {
    return false;
  }
  for (const matcher of matchers) {
    const {
      tag
    } = matcher;
    const tagLength = tag.length;
    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;
    if (tagLength > 1) {
      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {
        continue;
      }
    }
    if (textContent[closeTagStartIndex - 1] === " ") {
      continue;
    }
    const afterCloseTagChar = textContent[closeTagEndIndex + 1];
    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {
      continue;
    }
    const closeNode = anchorNode;
    let openNode = closeNode;
    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);
    let sibling = openNode;
    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {
      if ($isLineBreakNode(sibling)) {
        break;
      }
      if ($isTextNode(sibling)) {
        if (sibling.hasFormat("code")) {
          continue;
        }
        const siblingTextContent = sibling.getTextContent();
        openNode = sibling;
        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);
      }
    }
    if (openTagStartIndex < 0) {
      continue;
    }
    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {
      continue;
    }
    const prevOpenNodeText = openNode.getTextContent();
    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {
      continue;
    }
    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];
    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {
      continue;
    }
    const prevCloseNodeText = closeNode.getTextContent();
    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);
    closeNode.setTextContent(closeNodeText);
    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;
    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));
    const selection = $getSelection();
    const nextSelection = $createRangeSelection();
    $setSelection(nextSelection);
    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;
    nextSelection.anchor.set(openNode.__key, openTagStartIndex, "text");
    nextSelection.focus.set(closeNode.__key, newOffset, "text");
    for (const format of matcher.format) {
      if (!nextSelection.hasFormat(format)) {
        nextSelection.formatText(format);
      }
    }
    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);
    for (const format of matcher.format) {
      if (nextSelection.hasFormat(format)) {
        nextSelection.toggleFormat(format);
      }
    }
    if ($isRangeSelection(selection)) {
      nextSelection.format = selection.format;
    }
    return true;
  }
  return false;
}
function getOpenTagStartIndex(string, maxIndex, tag) {
  const tagLength = tag.length;
  for (let i = maxIndex; i >= tagLength; i--) {
    const startIndex = i - tagLength;
    if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation
    string[startIndex + tagLength] !== " ") {
      return startIndex;
    }
  }
  return -1;
}
function isEqualSubString(stringA, aStart, stringB, bStart, length) {
  for (let i = 0; i < length; i++) {
    if (stringA[aStart + i] !== stringB[bStart + i]) {
      return false;
    }
  }
  return true;
}
function registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {
  const byType = transformersByType(transformers);
  const textFormatTransformersByTrigger = indexBy(byType.textFormat, ({
    tag
  }) => tag[tag.length - 1]);
  const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({
    trigger
  }) => trigger);
  for (const transformer of transformers) {
    const type = transformer.type;
    if (type === "element" || type === "text-match" || type === "multiline-element") {
      const dependencies = transformer.dependencies;
      for (const node of dependencies) {
        if (!editor.hasNode(node)) {
          {
            formatDevErrorMessage(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);
          }
        }
      }
    }
  }
  const $transform = (parentNode, anchorNode, anchorOffset) => {
    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {
      return;
    }
    if (runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)) {
      return;
    }
    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {
      return;
    }
    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger);
  };
  return editor.registerUpdateListener(({
    tags,
    dirtyLeaves,
    editorState,
    prevEditorState
  }) => {
    if (tags.has(COLLABORATION_TAG) || tags.has(HISTORIC_TAG)) {
      return;
    }
    if (editor.isComposing()) {
      return;
    }
    const selection = editorState.read($getSelection);
    const prevSelection = prevEditorState.read($getSelection);
    if (!$isRangeSelection(prevSelection) || !$isRangeSelection(selection) || !selection.isCollapsed() || selection.is(prevSelection)) {
      return;
    }
    const anchorKey = selection.anchor.key;
    const anchorOffset = selection.anchor.offset;
    const anchorNode = editorState._nodeMap.get(anchorKey);
    if (!$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {
      return;
    }
    editor.update(() => {
      if (!canContainTransformableMarkdown(anchorNode)) {
        return;
      }
      const parentNode = anchorNode.getParent();
      if (parentNode === null || $isCodeNode(parentNode)) {
        return;
      }
      $transform(parentNode, anchorNode, selection.anchor.offset);
    });
  });
}
function $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false, shouldMergeAdjacentLines = false) {
  const sanitizedMarkdown = shouldPreserveNewLines ? markdown : normalizeMarkdown(markdown, shouldMergeAdjacentLines);
  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);
  return importMarkdown(sanitizedMarkdown, node);
}
function $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {
  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);
  return exportMarkdown(node);
}

export {
  HEADING,
  QUOTE,
  CODE,
  UNORDERED_LIST,
  CHECK_LIST,
  ORDERED_LIST,
  INLINE_CODE,
  HIGHLIGHT,
  BOLD_ITALIC_STAR,
  BOLD_ITALIC_UNDERSCORE,
  BOLD_STAR,
  BOLD_UNDERSCORE,
  STRIKETHROUGH,
  ITALIC_STAR,
  ITALIC_UNDERSCORE,
  LINK,
  ELEMENT_TRANSFORMERS,
  MULTILINE_ELEMENT_TRANSFORMERS,
  TEXT_FORMAT_TRANSFORMERS,
  TEXT_MATCH_TRANSFORMERS,
  TRANSFORMERS,
  registerMarkdownShortcuts,
  $convertFromMarkdownString,
  $convertToMarkdownString
};
//# sourceMappingURL=chunk-XOKJ7IDV.js.map
