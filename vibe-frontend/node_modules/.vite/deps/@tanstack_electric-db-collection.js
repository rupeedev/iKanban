import {
  require_browser
} from "./chunk-Z3GGOGKV.js";
import {
  DeduplicatedLoadSubset,
  TanStackDBError,
  and
} from "./chunk-F4MVZ6SI.js";
import {
  Store
} from "./chunk-2WLN4XKE.js";
import "./chunk-WOGQ2CNA.js";
import {
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@microsoft/fetch-event-source/lib/esm/parse.js
async function getBytes(stream, onChunk) {
  const reader = stream.getReader();
  let result;
  while (!(result = await reader.read()).done) {
    onChunk(result.value);
  }
}
function getLines(onLine) {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  return function onChunk(arr) {
    if (buffer === void 0) {
      buffer = arr;
      position = 0;
      fieldLength = -1;
    } else {
      buffer = concat(buffer, arr);
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === 10) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case 58:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case 13:
            discardTrailingNewline = true;
          case 10:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      }
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}
function getMessages(onId, onRetry, onMessage) {
  let message = newMessage();
  const decoder = new TextDecoder();
  return function onLine(line, fieldLength) {
    if (line.length === 0) {
      onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);
      message = newMessage();
    } else if (fieldLength > 0) {
      const field = decoder.decode(line.subarray(0, fieldLength));
      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);
      const value = decoder.decode(line.subarray(valueOffset));
      switch (field) {
        case "data":
          message.data = message.data ? message.data + "\n" + value : value;
          break;
        case "event":
          message.event = value;
          break;
        case "id":
          onId(message.id = value);
          break;
        case "retry":
          const retry = parseInt(value, 10);
          if (!isNaN(retry)) {
            onRetry(message.retry = retry);
          }
          break;
      }
    }
  };
}
function concat(a, b) {
  const res = new Uint8Array(a.length + b.length);
  res.set(a);
  res.set(b, a.length);
  return res;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}

// node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var EventStreamContentType = "text/event-stream";
var DefaultRetryInterval = 1e3;
var LastEventId = "last-event-id";
function fetchEventSource(input, _a) {
  var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
  return new Promise((resolve, reject) => {
    const headers = Object.assign({}, inputHeaders);
    if (!headers.accept) {
      headers.accept = EventStreamContentType;
    }
    let curRequestController;
    function onVisibilityChange() {
      curRequestController.abort();
      if (!document.hidden) {
        create();
      }
    }
    if (!openWhenHidden) {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    let retryInterval = DefaultRetryInterval;
    let retryTimer = 0;
    function dispose() {
      document.removeEventListener("visibilitychange", onVisibilityChange);
      window.clearTimeout(retryTimer);
      curRequestController.abort();
    }
    inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener("abort", () => {
      dispose();
      resolve();
    });
    const fetch2 = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;
    const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;
    async function create() {
      var _a2;
      curRequestController = new AbortController();
      try {
        const response = await fetch2(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));
        await onopen(response);
        await getBytes(response.body, getLines(getMessages((id) => {
          if (id) {
            headers[LastEventId] = id;
          } else {
            delete headers[LastEventId];
          }
        }, (retry) => {
          retryInterval = retry;
        }, onmessage)));
        onclose === null || onclose === void 0 ? void 0 : onclose();
        dispose();
        resolve();
      } catch (err) {
        if (!curRequestController.signal.aborted) {
          try {
            const interval = (_a2 = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a2 !== void 0 ? _a2 : retryInterval;
            window.clearTimeout(retryTimer);
            retryTimer = window.setTimeout(create, interval);
          } catch (innerErr) {
            dispose();
            reject(innerErr);
          }
        }
      }
    }
    create();
  });
}
function defaultOnOpen(response) {
  const contentType = response.headers.get("content-type");
  if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {
    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);
  }
}

// node_modules/@electric-sql/client/dist/index.mjs
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var FetchError = class _FetchError extends Error {
  constructor(status, text, json, headers, url, message) {
    super(
      message || `HTTP Error ${status} at ${url}: ${text != null ? text : JSON.stringify(json)}`
    );
    this.url = url;
    this.name = `FetchError`;
    this.status = status;
    this.text = text;
    this.json = json;
    this.headers = headers;
  }
  static async fromResponse(response, url) {
    const status = response.status;
    const headers = Object.fromEntries([...response.headers.entries()]);
    let text = void 0;
    let json = void 0;
    const contentType = response.headers.get(`content-type`);
    if (!response.bodyUsed) {
      if (contentType && contentType.includes(`application/json`)) {
        json = await response.json();
      } else {
        text = await response.text();
      }
    }
    return new _FetchError(status, text, json, headers, url);
  }
};
var FetchBackoffAbortError = class extends Error {
  constructor() {
    super(`Fetch with backoff aborted`);
    this.name = `FetchBackoffAbortError`;
  }
};
var MissingShapeUrlError = class extends Error {
  constructor() {
    super(`Invalid shape options: missing required url parameter`);
    this.name = `MissingShapeUrlError`;
  }
};
var InvalidSignalError = class extends Error {
  constructor() {
    super(`Invalid signal option. It must be an instance of AbortSignal.`);
    this.name = `InvalidSignalError`;
  }
};
var MissingShapeHandleError = class extends Error {
  constructor() {
    super(
      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`
    );
    this.name = `MissingShapeHandleError`;
  }
};
var ReservedParamError = class extends Error {
  constructor(reservedParams) {
    super(
      `Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`
    );
    this.name = `ReservedParamError`;
  }
};
var ParserNullValueError = class extends Error {
  constructor(columnName) {
    super(`Column "${columnName != null ? columnName : `unknown`}" does not allow NULL values`);
    this.name = `ParserNullValueError`;
  }
};
var MissingHeadersError = class extends Error {
  constructor(url, missingHeaders) {
    let msg = `The response for the shape request to ${url} didn't include the following required headers:
`;
    missingHeaders.forEach((h) => {
      msg += `- ${h}
`;
    });
    msg += `
This is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`;
    msg += `
For more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`;
    super(msg);
  }
};
var parseNumber = (value) => Number(value);
var parseBool = (value) => value === `true` || value === `t`;
var parseBigInt = (value) => BigInt(value);
var parseJson = (value) => JSON.parse(value);
var identityParser = (v) => v;
var defaultParser = {
  int2: parseNumber,
  int4: parseNumber,
  int8: parseBigInt,
  bool: parseBool,
  float4: parseNumber,
  float8: parseNumber,
  json: parseJson,
  jsonb: parseJson
};
function pgArrayParser(value, parser) {
  let i = 0;
  let char = null;
  let str = ``;
  let quoted = false;
  let last = 0;
  let p = void 0;
  function extractValue(x, start, end) {
    let val = x.slice(start, end);
    val = val === `NULL` ? null : val;
    return parser ? parser(val) : val;
  }
  function loop(x) {
    const xs = [];
    for (; i < x.length; i++) {
      char = x[i];
      if (quoted) {
        if (char === `\\`) {
          str += x[++i];
        } else if (char === `"`) {
          xs.push(parser ? parser(str) : str);
          str = ``;
          quoted = x[i + 1] === `"`;
          last = i + 2;
        } else {
          str += char;
        }
      } else if (char === `"`) {
        quoted = true;
      } else if (char === `{`) {
        last = ++i;
        xs.push(loop(x));
      } else if (char === `}`) {
        quoted = false;
        last < i && xs.push(extractValue(x, last, i));
        last = i + 1;
        break;
      } else if (char === `,` && p !== `}` && p !== `"`) {
        xs.push(extractValue(x, last, i));
        last = i + 1;
      }
      p = char;
    }
    last < i && xs.push(xs.push(extractValue(x, last, i + 1)));
    return xs;
  }
  return loop(value)[0];
}
var MessageParser = class {
  constructor(parser, transformer) {
    this.parser = __spreadValues(__spreadValues({}, defaultParser), parser);
    this.transformer = transformer;
  }
  parse(messages, schema) {
    return JSON.parse(messages, (key, value) => {
      if ((key === `value` || key === `old_value`) && typeof value === `object` && value !== null) {
        return this.transformMessageValue(value, schema);
      }
      return value;
    });
  }
  /**
   * Parse an array of ChangeMessages from a snapshot response.
   * Applies type parsing and transformations to the value and old_value properties.
   */
  parseSnapshotData(messages, schema) {
    return messages.map((message) => {
      const msg = message;
      if (msg.value && typeof msg.value === `object` && msg.value !== null) {
        msg.value = this.transformMessageValue(msg.value, schema);
      }
      if (msg.old_value && typeof msg.old_value === `object` && msg.old_value !== null) {
        msg.old_value = this.transformMessageValue(msg.old_value, schema);
      }
      return msg;
    });
  }
  /**
   * Transform a message value or old_value object by parsing its columns.
   */
  transformMessageValue(value, schema) {
    const row = value;
    Object.keys(row).forEach((key) => {
      row[key] = this.parseRow(key, row[key], schema);
    });
    return this.transformer ? this.transformer(row) : row;
  }
  // Parses the message values using the provided parser based on the schema information
  parseRow(key, value, schema) {
    var _b;
    const columnInfo = schema[key];
    if (!columnInfo) {
      return value;
    }
    const _a = columnInfo, { type: typ, dims: dimensions } = _a, additionalInfo = __objRest(_a, ["type", "dims"]);
    const typeParser = (_b = this.parser[typ]) != null ? _b : identityParser;
    const parser = makeNullableParser(typeParser, columnInfo, key);
    if (dimensions && dimensions > 0) {
      const nullablePgArrayParser = makeNullableParser(
        (value2, _) => pgArrayParser(value2, parser),
        columnInfo,
        key
      );
      return nullablePgArrayParser(value);
    }
    return parser(value, additionalInfo);
  }
};
function makeNullableParser(parser, columnInfo, columnName) {
  var _a;
  const isNullable = !((_a = columnInfo.not_null) != null ? _a : false);
  return (value) => {
    if (value === null) {
      if (!isNullable) {
        throw new ParserNullValueError(columnName != null ? columnName : `unknown`);
      }
      return null;
    }
    return parser(value, columnInfo);
  };
}
function quoteIdentifier(identifier) {
  const escaped = identifier.replace(/"/g, `""`);
  return `"${escaped}"`;
}
function encodeWhereClause(whereClause, encode) {
  if (!whereClause || !encode) return whereClause != null ? whereClause : ``;
  const sqlKeywords = /* @__PURE__ */ new Set([
    `SELECT`,
    `FROM`,
    `WHERE`,
    `AND`,
    `OR`,
    `NOT`,
    `IN`,
    `IS`,
    `NULL`,
    `NULLS`,
    `FIRST`,
    `LAST`,
    `TRUE`,
    `FALSE`,
    `LIKE`,
    `ILIKE`,
    `BETWEEN`,
    `ASC`,
    `DESC`,
    `LIMIT`,
    `OFFSET`,
    `ORDER`,
    `BY`,
    `GROUP`,
    `HAVING`,
    `DISTINCT`,
    `AS`,
    `ON`,
    `JOIN`,
    `LEFT`,
    `RIGHT`,
    `INNER`,
    `OUTER`,
    `CROSS`,
    `CASE`,
    `WHEN`,
    `THEN`,
    `ELSE`,
    `END`,
    `CAST`,
    `LOWER`,
    `UPPER`,
    `COALESCE`,
    `NULLIF`
  ]);
  const quotedRanges = [];
  let pos = 0;
  while (pos < whereClause.length) {
    const ch = whereClause[pos];
    if (ch === `'` || ch === `"`) {
      const start = pos;
      const quoteChar = ch;
      pos++;
      while (pos < whereClause.length) {
        if (whereClause[pos] === quoteChar) {
          if (whereClause[pos + 1] === quoteChar) {
            pos += 2;
          } else {
            pos++;
            break;
          }
        } else {
          pos++;
        }
      }
      quotedRanges.push({ start, end: pos });
    } else {
      pos++;
    }
  }
  const isInQuotedString = (pos2) => {
    return quotedRanges.some((range) => pos2 >= range.start && pos2 < range.end);
  };
  const identifierPattern = new RegExp("(?<![a-zA-Z0-9_])([a-zA-Z_][a-zA-Z0-9_]*)(?![a-zA-Z0-9_])", "g");
  return whereClause.replace(identifierPattern, (match, _p1, offset) => {
    if (isInQuotedString(offset)) {
      return match;
    }
    if (sqlKeywords.has(match.toUpperCase())) {
      return match;
    }
    if (match.startsWith(`$`)) {
      return match;
    }
    const encoded = encode(match);
    return encoded;
  });
}
function isChangeMessage(message) {
  return `key` in message;
}
function isControlMessage(message) {
  return !isChangeMessage(message);
}
function isUpToDateMessage(message) {
  return isControlMessage(message) && message.headers.control === `up-to-date`;
}
function getOffset(message) {
  if (message.headers.control != `up-to-date`) return;
  const lsn = message.headers.global_last_seen_lsn;
  return lsn ? `${lsn}_0` : void 0;
}
function isVisibleInSnapshot(txid, snapshot) {
  const xid = BigInt(txid);
  const xmin = BigInt(snapshot.xmin);
  const xmax = BigInt(snapshot.xmax);
  const xip = snapshot.xip_list.map(BigInt);
  return xid < xmin || xid < xmax && !xip.includes(xid);
}
var LIVE_CACHE_BUSTER_HEADER = `electric-cursor`;
var SHAPE_HANDLE_HEADER = `electric-handle`;
var CHUNK_LAST_OFFSET_HEADER = `electric-offset`;
var SHAPE_SCHEMA_HEADER = `electric-schema`;
var CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`;
var COLUMNS_QUERY_PARAM = `columns`;
var LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`;
var EXPIRED_HANDLE_QUERY_PARAM = `expired_handle`;
var SHAPE_HANDLE_QUERY_PARAM = `handle`;
var LIVE_QUERY_PARAM = `live`;
var OFFSET_QUERY_PARAM = `offset`;
var TABLE_QUERY_PARAM = `table`;
var WHERE_QUERY_PARAM = `where`;
var REPLICA_PARAM = `replica`;
var WHERE_PARAMS_PARAM = `params`;
var EXPERIMENTAL_LIVE_SSE_QUERY_PARAM = `experimental_live_sse`;
var LIVE_SSE_QUERY_PARAM = `live_sse`;
var FORCE_DISCONNECT_AND_REFRESH = `force-disconnect-and-refresh`;
var PAUSE_STREAM = `pause-stream`;
var LOG_MODE_QUERY_PARAM = `log`;
var SUBSET_PARAM_WHERE = `subset__where`;
var SUBSET_PARAM_LIMIT = `subset__limit`;
var SUBSET_PARAM_OFFSET = `subset__offset`;
var SUBSET_PARAM_ORDER_BY = `subset__order_by`;
var SUBSET_PARAM_WHERE_PARAMS = `subset__params`;
var SUBSET_PARAM_WHERE_EXPR = `subset__where_expr`;
var SUBSET_PARAM_ORDER_BY_EXPR = `subset__order_by_expr`;
var ELECTRIC_PROTOCOL_QUERY_PARAMS = [
  LIVE_QUERY_PARAM,
  LIVE_SSE_QUERY_PARAM,
  SHAPE_HANDLE_QUERY_PARAM,
  OFFSET_QUERY_PARAM,
  LIVE_CACHE_BUSTER_QUERY_PARAM,
  EXPIRED_HANDLE_QUERY_PARAM,
  LOG_MODE_QUERY_PARAM,
  SUBSET_PARAM_WHERE,
  SUBSET_PARAM_LIMIT,
  SUBSET_PARAM_OFFSET,
  SUBSET_PARAM_ORDER_BY,
  SUBSET_PARAM_WHERE_PARAMS,
  SUBSET_PARAM_WHERE_EXPR,
  SUBSET_PARAM_ORDER_BY_EXPR
];
var HTTP_RETRY_STATUS_CODES = [429];
var BackoffDefaults = {
  initialDelay: 100,
  maxDelay: 6e4,
  // Cap at 60s - reasonable for long-lived connections
  multiplier: 1.3,
  maxRetries: Infinity
  // Retry forever - clients may go offline and come back
};
function parseRetryAfterHeader(retryAfter) {
  if (!retryAfter) return 0;
  const retryAfterSec = Number(retryAfter);
  if (Number.isFinite(retryAfterSec) && retryAfterSec > 0) {
    return retryAfterSec * 1e3;
  }
  const retryDate = Date.parse(retryAfter);
  if (!isNaN(retryDate)) {
    const deltaMs = retryDate - Date.now();
    return Math.max(0, Math.min(deltaMs, 36e5));
  }
  return 0;
}
function createFetchWithBackoff(fetchClient, backoffOptions = BackoffDefaults) {
  const {
    initialDelay,
    maxDelay,
    multiplier,
    debug: debug2 = false,
    onFailedAttempt,
    maxRetries = Infinity
  } = backoffOptions;
  return async (...args) => {
    var _a;
    const url = args[0];
    const options = args[1];
    let delay = initialDelay;
    let attempt = 0;
    while (true) {
      try {
        const result = await fetchClient(...args);
        if (result.ok) {
          return result;
        }
        const err = await FetchError.fromResponse(result, url.toString());
        throw err;
      } catch (e) {
        onFailedAttempt == null ? void 0 : onFailedAttempt();
        if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {
          throw new FetchBackoffAbortError();
        } else if (e instanceof FetchError && !HTTP_RETRY_STATUS_CODES.includes(e.status) && e.status >= 400 && e.status < 500) {
          throw e;
        } else {
          attempt++;
          if (attempt > maxRetries) {
            if (debug2) {
              console.log(
                `Max retries reached (${attempt}/${maxRetries}), giving up`
              );
            }
            throw e;
          }
          const serverMinimumMs = e instanceof FetchError && e.headers ? parseRetryAfterHeader(e.headers[`retry-after`]) : 0;
          const jitter = Math.random() * delay;
          const clientBackoffMs = Math.min(jitter, maxDelay);
          const waitMs = Math.max(serverMinimumMs, clientBackoffMs);
          if (debug2) {
            const source = serverMinimumMs > 0 ? `server+client` : `client`;
            console.log(
              `Retry attempt #${attempt} after ${waitMs}ms (${source}, serverMin=${serverMinimumMs}ms, clientBackoff=${clientBackoffMs}ms)`
            );
          }
          await new Promise((resolve) => setTimeout(resolve, waitMs));
          delay = Math.min(delay * multiplier, maxDelay);
        }
      }
    }
  };
}
var NO_BODY_STATUS_CODES = [201, 204, 205];
function createFetchWithConsumedMessages(fetchClient) {
  return async (...args) => {
    var _a, _b;
    const url = args[0];
    const res = await fetchClient(...args);
    try {
      if (res.status < 200 || NO_BODY_STATUS_CODES.includes(res.status)) {
        return res;
      }
      const text = await res.text();
      return new Response(text, res);
    } catch (err) {
      if ((_b = (_a = args[1]) == null ? void 0 : _a.signal) == null ? void 0 : _b.aborted) {
        throw new FetchBackoffAbortError();
      }
      throw new FetchError(
        res.status,
        void 0,
        void 0,
        Object.fromEntries([...res.headers.entries()]),
        url.toString(),
        err instanceof Error ? err.message : typeof err === `string` ? err : `failed to read body`
      );
    }
  };
}
var ChunkPrefetchDefaults = {
  maxChunksToPrefetch: 2
};
function createFetchWithChunkBuffer(fetchClient, prefetchOptions = ChunkPrefetchDefaults) {
  const { maxChunksToPrefetch } = prefetchOptions;
  let prefetchQueue;
  const prefetchClient = async (...args) => {
    const url = args[0].toString();
    const prefetchedRequest = prefetchQueue == null ? void 0 : prefetchQueue.consume(...args);
    if (prefetchedRequest) {
      return prefetchedRequest;
    }
    prefetchQueue == null ? void 0 : prefetchQueue.abort();
    prefetchQueue = void 0;
    const response = await fetchClient(...args);
    const nextUrl = getNextChunkUrl(url, response);
    if (nextUrl) {
      prefetchQueue = new PrefetchQueue({
        fetchClient,
        maxPrefetchedRequests: maxChunksToPrefetch,
        url: nextUrl,
        requestInit: args[1]
      });
    }
    return response;
  };
  return prefetchClient;
}
var requiredElectricResponseHeaders = [
  `electric-offset`,
  `electric-handle`
];
var requiredLiveResponseHeaders = [`electric-cursor`];
var requiredNonLiveResponseHeaders = [`electric-schema`];
function createFetchWithResponseHeadersCheck(fetchClient) {
  return async (...args) => {
    const response = await fetchClient(...args);
    if (response.ok) {
      const headers = response.headers;
      const missingHeaders = [];
      const addMissingHeaders = (requiredHeaders) => missingHeaders.push(...requiredHeaders.filter((h) => !headers.has(h)));
      const input = args[0];
      const urlString = input.toString();
      const url = new URL(urlString);
      const isSnapshotRequest = [
        SUBSET_PARAM_WHERE,
        SUBSET_PARAM_WHERE_PARAMS,
        SUBSET_PARAM_LIMIT,
        SUBSET_PARAM_OFFSET,
        SUBSET_PARAM_ORDER_BY
      ].some((p) => url.searchParams.has(p));
      if (isSnapshotRequest) {
        return response;
      }
      addMissingHeaders(requiredElectricResponseHeaders);
      if (url.searchParams.get(LIVE_QUERY_PARAM) === `true`) {
        addMissingHeaders(requiredLiveResponseHeaders);
      }
      if (!url.searchParams.has(LIVE_QUERY_PARAM) || url.searchParams.get(LIVE_QUERY_PARAM) === `false`) {
        addMissingHeaders(requiredNonLiveResponseHeaders);
      }
      if (missingHeaders.length > 0) {
        throw new MissingHeadersError(urlString, missingHeaders);
      }
    }
    return response;
  };
}
var _fetchClient;
var _maxPrefetchedRequests;
var _prefetchQueue;
var _queueHeadUrl;
var _queueTailUrl;
var _PrefetchQueue_instances;
var prefetch_fn;
var PrefetchQueue = class {
  constructor(options) {
    __privateAdd(this, _PrefetchQueue_instances);
    __privateAdd(this, _fetchClient);
    __privateAdd(this, _maxPrefetchedRequests);
    __privateAdd(this, _prefetchQueue, /* @__PURE__ */ new Map());
    __privateAdd(this, _queueHeadUrl);
    __privateAdd(this, _queueTailUrl);
    var _a;
    __privateSet(this, _fetchClient, (_a = options.fetchClient) != null ? _a : (...args) => fetch(...args));
    __privateSet(this, _maxPrefetchedRequests, options.maxPrefetchedRequests);
    __privateSet(this, _queueHeadUrl, options.url.toString());
    __privateSet(this, _queueTailUrl, __privateGet(this, _queueHeadUrl));
    __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, options.url, options.requestInit);
  }
  abort() {
    __privateGet(this, _prefetchQueue).forEach(([_, aborter]) => aborter.abort());
    __privateGet(this, _prefetchQueue).clear();
  }
  consume(...args) {
    const url = args[0].toString();
    const entry = __privateGet(this, _prefetchQueue).get(url);
    if (!entry || url !== __privateGet(this, _queueHeadUrl)) return;
    const [request, aborter] = entry;
    if (aborter.signal.aborted) {
      __privateGet(this, _prefetchQueue).delete(url);
      return;
    }
    __privateGet(this, _prefetchQueue).delete(url);
    request.then((response) => {
      const nextUrl = getNextChunkUrl(url, response);
      __privateSet(this, _queueHeadUrl, nextUrl);
      if (__privateGet(this, _queueTailUrl) && !__privateGet(this, _prefetchQueue).has(__privateGet(this, _queueTailUrl))) {
        __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, __privateGet(this, _queueTailUrl), args[1]);
      }
    }).catch(() => {
    });
    return request;
  }
};
_fetchClient = /* @__PURE__ */ new WeakMap();
_maxPrefetchedRequests = /* @__PURE__ */ new WeakMap();
_prefetchQueue = /* @__PURE__ */ new WeakMap();
_queueHeadUrl = /* @__PURE__ */ new WeakMap();
_queueTailUrl = /* @__PURE__ */ new WeakMap();
_PrefetchQueue_instances = /* @__PURE__ */ new WeakSet();
prefetch_fn = function(...args) {
  var _a, _b;
  const url = args[0].toString();
  if (__privateGet(this, _prefetchQueue).size >= __privateGet(this, _maxPrefetchedRequests)) return;
  const aborter = new AbortController();
  try {
    const { signal, cleanup } = chainAborter(aborter, (_a = args[1]) == null ? void 0 : _a.signal);
    const request = __privateGet(this, _fetchClient).call(this, url, __spreadProps(__spreadValues({}, (_b = args[1]) != null ? _b : {}), { signal }));
    __privateGet(this, _prefetchQueue).set(url, [request, aborter]);
    request.then((response) => {
      if (!response.ok || aborter.signal.aborted) return;
      const nextUrl = getNextChunkUrl(url, response);
      if (!nextUrl || nextUrl === url) {
        __privateSet(this, _queueTailUrl, void 0);
        return;
      }
      __privateSet(this, _queueTailUrl, nextUrl);
      return __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, nextUrl, args[1]);
    }).catch(() => {
    }).finally(cleanup);
  } catch (_) {
  }
};
function getNextChunkUrl(url, res) {
  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER);
  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER);
  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER);
  if (!shapeHandle || !lastOffset || isUpToDate) return;
  const nextUrl = new URL(url);
  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return;
  const expiredHandle = nextUrl.searchParams.get(EXPIRED_HANDLE_QUERY_PARAM);
  if (expiredHandle && shapeHandle === expiredHandle) {
    console.warn(
      `[Electric] Received stale cached response with expired shape handle. This should not happen and indicates a proxy/CDN caching misconfiguration. The response contained handle "${shapeHandle}" which was previously marked as expired. Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. Skipping prefetch to prevent infinite 409 loop.`
    );
    return;
  }
  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle);
  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset);
  nextUrl.searchParams.sort();
  return nextUrl.toString();
}
function chainAborter(aborter, sourceSignal) {
  let cleanup = noop;
  if (!sourceSignal) {
  } else if (sourceSignal.aborted) {
    aborter.abort();
  } else {
    const abortParent = () => aborter.abort();
    sourceSignal.addEventListener(`abort`, abortParent, {
      once: true,
      signal: aborter.signal
    });
    cleanup = () => sourceSignal.removeEventListener(`abort`, abortParent);
  }
  return {
    signal: aborter.signal,
    cleanup
  };
}
function noop() {
}
function compileExpression(expr, columnMapper) {
  switch (expr.type) {
    case `ref`: {
      const mappedColumn = columnMapper ? columnMapper(expr.column) : expr.column;
      return quoteIdentifier(mappedColumn);
    }
    case `val`:
      return `$${expr.paramIndex}`;
    case `func`:
      return compileFunction(expr, columnMapper);
    default: {
      const _exhaustive = expr;
      throw new Error(`Unknown expression type: ${JSON.stringify(_exhaustive)}`);
    }
  }
}
function compileFunction(expr, columnMapper) {
  const args = expr.args.map((arg) => compileExpression(arg, columnMapper));
  switch (expr.name) {
    case `eq`:
      return `${args[0]} = ${args[1]}`;
    case `gt`:
      return `${args[0]} > ${args[1]}`;
    case `gte`:
      return `${args[0]} >= ${args[1]}`;
    case `lt`:
      return `${args[0]} < ${args[1]}`;
    case `lte`:
      return `${args[0]} <= ${args[1]}`;
    case `and`:
      return args.map((a) => `(${a})`).join(` AND `);
    case `or`:
      return args.map((a) => `(${a})`).join(` OR `);
    case `not`:
      return `NOT (${args[0]})`;
    case `in`:
      return `${args[0]} = ANY(${args[1]})`;
    case `like`:
      return `${args[0]} LIKE ${args[1]}`;
    case `ilike`:
      return `${args[0]} ILIKE ${args[1]}`;
    case `isNull`:
    case `isUndefined`:
      return `${args[0]} IS NULL`;
    case `upper`:
      return `UPPER(${args[0]})`;
    case `lower`:
      return `LOWER(${args[0]})`;
    case `length`:
      return `LENGTH(${args[0]})`;
    case `concat`:
      return `CONCAT(${args.join(`, `)})`;
    case `coalesce`:
      return `COALESCE(${args.join(`, `)})`;
    default:
      throw new Error(`Unknown function: ${expr.name}`);
  }
}
function compileOrderBy(clauses, columnMapper) {
  return clauses.map((clause) => {
    const mappedColumn = columnMapper ? columnMapper(clause.column) : clause.column;
    let sql = quoteIdentifier(mappedColumn);
    if (clause.direction === `desc`) sql += ` DESC`;
    if (clause.nulls === `first`) sql += ` NULLS FIRST`;
    if (clause.nulls === `last`) sql += ` NULLS LAST`;
    return sql;
  }).join(`, `);
}
var ExpiredShapesCache = class {
  constructor() {
    this.data = {};
    this.max = 250;
    this.storageKey = `electric_expired_shapes`;
    this.load();
  }
  getExpiredHandle(shapeUrl) {
    const entry = this.data[shapeUrl];
    if (entry) {
      entry.lastUsed = Date.now();
      this.save();
      return entry.expiredHandle;
    }
    return null;
  }
  markExpired(shapeUrl, handle) {
    this.data[shapeUrl] = { expiredHandle: handle, lastUsed: Date.now() };
    const keys = Object.keys(this.data);
    if (keys.length > this.max) {
      const oldest = keys.reduce(
        (min, k) => this.data[k].lastUsed < this.data[min].lastUsed ? k : min
      );
      delete this.data[oldest];
    }
    this.save();
  }
  save() {
    if (typeof localStorage === `undefined`) return;
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.data));
    } catch (e) {
    }
  }
  load() {
    if (typeof localStorage === `undefined`) return;
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        this.data = JSON.parse(stored);
      }
    } catch (e) {
      this.data = {};
    }
  }
  clear() {
    this.data = {};
    this.save();
  }
};
var expiredShapesCache = new ExpiredShapesCache();
var UpToDateTracker = class {
  constructor() {
    this.data = {};
    this.storageKey = `electric_up_to_date_tracker`;
    this.cacheTTL = 6e4;
    this.maxEntries = 250;
    this.writeThrottleMs = 6e4;
    this.lastWriteTime = 0;
    this.load();
    this.cleanup();
  }
  /**
   * Records that a shape received an up-to-date message with a specific cursor.
   * This timestamp and cursor are used to detect cache replay scenarios.
   * Updates in-memory immediately, but throttles localStorage writes.
   */
  recordUpToDate(shapeKey, cursor) {
    this.data[shapeKey] = {
      timestamp: Date.now(),
      cursor
    };
    const keys = Object.keys(this.data);
    if (keys.length > this.maxEntries) {
      const oldest = keys.reduce(
        (min, k) => this.data[k].timestamp < this.data[min].timestamp ? k : min
      );
      delete this.data[oldest];
    }
    this.scheduleSave();
  }
  /**
   * Schedules a throttled save to localStorage.
   * Writes immediately if enough time has passed, otherwise schedules for later.
   */
  scheduleSave() {
    const now = Date.now();
    const timeSinceLastWrite = now - this.lastWriteTime;
    if (timeSinceLastWrite >= this.writeThrottleMs) {
      this.lastWriteTime = now;
      this.save();
    } else if (!this.pendingSaveTimer) {
      const delay = this.writeThrottleMs - timeSinceLastWrite;
      this.pendingSaveTimer = setTimeout(() => {
        this.lastWriteTime = Date.now();
        this.pendingSaveTimer = void 0;
        this.save();
      }, delay);
    }
  }
  /**
   * Checks if we should enter replay mode for this shape.
   * Returns the last seen cursor if there's a recent up-to-date (< 60s),
   * which means we'll likely be replaying cached responses.
   * Returns null if no recent up-to-date exists.
   */
  shouldEnterReplayMode(shapeKey) {
    const entry = this.data[shapeKey];
    if (!entry) {
      return null;
    }
    const age = Date.now() - entry.timestamp;
    if (age >= this.cacheTTL) {
      return null;
    }
    return entry.cursor;
  }
  /**
   * Cleans up expired entries from the cache.
   * Called on initialization and can be called periodically.
   */
  cleanup() {
    const now = Date.now();
    const keys = Object.keys(this.data);
    let modified = false;
    for (const key of keys) {
      const age = now - this.data[key].timestamp;
      if (age > this.cacheTTL) {
        delete this.data[key];
        modified = true;
      }
    }
    if (modified) {
      this.save();
    }
  }
  save() {
    if (typeof localStorage === `undefined`) return;
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.data));
    } catch (e) {
    }
  }
  load() {
    if (typeof localStorage === `undefined`) return;
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        this.data = JSON.parse(stored);
      }
    } catch (e) {
      this.data = {};
    }
  }
  /**
   * Clears all tracked up-to-date timestamps.
   * Useful for testing or manual cache invalidation.
   */
  clear() {
    this.data = {};
    if (this.pendingSaveTimer) {
      clearTimeout(this.pendingSaveTimer);
      this.pendingSaveTimer = void 0;
    }
    this.save();
  }
};
var upToDateTracker = new UpToDateTracker();
var SnapshotTracker = class {
  constructor() {
    this.activeSnapshots = /* @__PURE__ */ new Map();
    this.xmaxSnapshots = /* @__PURE__ */ new Map();
    this.snapshotsByDatabaseLsn = /* @__PURE__ */ new Map();
  }
  /**
   * Add a new snapshot for tracking
   */
  addSnapshot(metadata, keys) {
    var _a, _b, _c, _d;
    this.activeSnapshots.set(metadata.snapshot_mark, {
      xmin: BigInt(metadata.xmin),
      xmax: BigInt(metadata.xmax),
      xip_list: metadata.xip_list.map(BigInt),
      keys
    });
    const xmaxSet = (_b = (_a = this.xmaxSnapshots.get(BigInt(metadata.xmax))) == null ? void 0 : _a.add(metadata.snapshot_mark)) != null ? _b : /* @__PURE__ */ new Set([metadata.snapshot_mark]);
    this.xmaxSnapshots.set(BigInt(metadata.xmax), xmaxSet);
    const databaseLsnSet = (_d = (_c = this.snapshotsByDatabaseLsn.get(BigInt(metadata.database_lsn))) == null ? void 0 : _c.add(metadata.snapshot_mark)) != null ? _d : /* @__PURE__ */ new Set([metadata.snapshot_mark]);
    this.snapshotsByDatabaseLsn.set(
      BigInt(metadata.database_lsn),
      databaseLsnSet
    );
  }
  /**
   * Remove a snapshot from tracking
   */
  removeSnapshot(snapshotMark) {
    this.activeSnapshots.delete(snapshotMark);
  }
  /**
   * Check if a change message should be filtered because its already in an active snapshot
   * Returns true if the message should be filtered out (not processed)
   */
  shouldRejectMessage(message) {
    const txids = message.headers.txids || [];
    if (txids.length === 0) return false;
    const xid = Math.max(...txids);
    for (const [xmax, snapshots] of this.xmaxSnapshots.entries()) {
      if (xid >= xmax) {
        for (const snapshot of snapshots) {
          this.removeSnapshot(snapshot);
        }
      }
    }
    return [...this.activeSnapshots.values()].some(
      (x) => x.keys.has(message.key) && isVisibleInSnapshot(xid, x)
    );
  }
  lastSeenUpdate(newDatabaseLsn) {
    for (const [dbLsn, snapshots] of this.snapshotsByDatabaseLsn.entries()) {
      if (dbLsn <= newDatabaseLsn) {
        for (const snapshot of snapshots) {
          this.removeSnapshot(snapshot);
        }
      }
    }
  }
};
var RESERVED_PARAMS = /* @__PURE__ */ new Set([
  LIVE_CACHE_BUSTER_QUERY_PARAM,
  SHAPE_HANDLE_QUERY_PARAM,
  LIVE_QUERY_PARAM,
  OFFSET_QUERY_PARAM
]);
async function resolveValue(value) {
  if (typeof value === `function`) {
    return value();
  }
  return value;
}
async function toInternalParams(params) {
  const entries = Object.entries(params);
  const resolvedEntries = await Promise.all(
    entries.map(async ([key, value]) => {
      if (value === void 0) return [key, void 0];
      const resolvedValue = await resolveValue(value);
      return [
        key,
        Array.isArray(resolvedValue) ? resolvedValue.join(`,`) : resolvedValue
      ];
    })
  );
  return Object.fromEntries(
    resolvedEntries.filter(([_, value]) => value !== void 0)
  );
}
async function resolveHeaders(headers) {
  if (!headers) return {};
  const entries = Object.entries(headers);
  const resolvedEntries = await Promise.all(
    entries.map(async ([key, value]) => [key, await resolveValue(value)])
  );
  return Object.fromEntries(resolvedEntries);
}
function canonicalShapeKey(url) {
  const cleanUrl = new URL(url.origin + url.pathname);
  for (const [key, value] of url.searchParams) {
    if (!ELECTRIC_PROTOCOL_QUERY_PARAMS.includes(key)) {
      cleanUrl.searchParams.set(key, value);
    }
  }
  cleanUrl.searchParams.sort();
  return cleanUrl.toString();
}
var _error;
var _fetchClient2;
var _sseFetchClient;
var _messageParser;
var _subscribers;
var _started;
var _state;
var _lastOffset;
var _liveCacheBuster;
var _lastSyncedAt;
var _isUpToDate;
var _isMidStream;
var _connected;
var _shapeHandle;
var _mode;
var _schema;
var _onError;
var _requestAbortController;
var _isRefreshing;
var _tickPromise;
var _tickPromiseResolver;
var _tickPromiseRejecter;
var _messageChain;
var _snapshotTracker;
var _activeSnapshotRequests;
var _midStreamPromise;
var _midStreamPromiseResolver;
var _lastSeenCursor;
var _currentFetchUrl;
var _lastSseConnectionStartTime;
var _minSseConnectionDuration;
var _consecutiveShortSseConnections;
var _maxShortSseConnections;
var _sseFallbackToLongPolling;
var _sseBackoffBaseDelay;
var _sseBackoffMaxDelay;
var _unsubscribeFromVisibilityChanges;
var _ShapeStream_instances;
var replayMode_get;
var start_fn;
var requestShape_fn;
var constructUrl_fn;
var createAbortListener_fn;
var onInitialResponse_fn;
var onMessages_fn;
var fetchShape_fn;
var requestShapeLongPoll_fn;
var requestShapeSSE_fn;
var pause_fn;
var resume_fn;
var nextTick_fn;
var waitForStreamEnd_fn;
var publish_fn;
var sendErrorToSubscribers_fn;
var subscribeToVisibilityChanges_fn;
var reset_fn;
var ShapeStream = class {
  constructor(options) {
    __privateAdd(this, _ShapeStream_instances);
    __privateAdd(this, _error, null);
    __privateAdd(this, _fetchClient2);
    __privateAdd(this, _sseFetchClient);
    __privateAdd(this, _messageParser);
    __privateAdd(this, _subscribers, /* @__PURE__ */ new Map());
    __privateAdd(this, _started, false);
    __privateAdd(this, _state, `active`);
    __privateAdd(this, _lastOffset);
    __privateAdd(this, _liveCacheBuster);
    __privateAdd(this, _lastSyncedAt);
    __privateAdd(this, _isUpToDate, false);
    __privateAdd(this, _isMidStream, true);
    __privateAdd(this, _connected, false);
    __privateAdd(this, _shapeHandle);
    __privateAdd(this, _mode);
    __privateAdd(this, _schema);
    __privateAdd(this, _onError);
    __privateAdd(this, _requestAbortController);
    __privateAdd(this, _isRefreshing, false);
    __privateAdd(this, _tickPromise);
    __privateAdd(this, _tickPromiseResolver);
    __privateAdd(this, _tickPromiseRejecter);
    __privateAdd(this, _messageChain, Promise.resolve([]));
    __privateAdd(this, _snapshotTracker, new SnapshotTracker());
    __privateAdd(this, _activeSnapshotRequests, 0);
    __privateAdd(this, _midStreamPromise);
    __privateAdd(this, _midStreamPromiseResolver);
    __privateAdd(this, _lastSeenCursor);
    __privateAdd(this, _currentFetchUrl);
    __privateAdd(this, _lastSseConnectionStartTime);
    __privateAdd(this, _minSseConnectionDuration, 1e3);
    __privateAdd(this, _consecutiveShortSseConnections, 0);
    __privateAdd(this, _maxShortSseConnections, 3);
    __privateAdd(this, _sseFallbackToLongPolling, false);
    __privateAdd(this, _sseBackoffBaseDelay, 100);
    __privateAdd(this, _sseBackoffMaxDelay, 5e3);
    __privateAdd(this, _unsubscribeFromVisibilityChanges);
    var _a, _b, _c, _d;
    this.options = __spreadValues({ subscribe: true }, options);
    validateOptions(this.options);
    __privateSet(this, _lastOffset, (_a = this.options.offset) != null ? _a : `-1`);
    __privateSet(this, _liveCacheBuster, ``);
    __privateSet(this, _shapeHandle, this.options.handle);
    let transformer;
    if (options.columnMapper) {
      const applyColumnMapper = (row) => {
        const result = {};
        for (const [dbKey, value] of Object.entries(row)) {
          const appKey = options.columnMapper.decode(dbKey);
          result[appKey] = value;
        }
        return result;
      };
      transformer = options.transformer ? (row) => options.transformer(applyColumnMapper(row)) : applyColumnMapper;
    } else {
      transformer = options.transformer;
    }
    __privateSet(this, _messageParser, new MessageParser(options.parser, transformer));
    __privateSet(this, _onError, this.options.onError);
    __privateSet(this, _mode, (_b = this.options.log) != null ? _b : `full`);
    const baseFetchClient = (_c = options.fetchClient) != null ? _c : (...args) => fetch(...args);
    const backOffOpts = __spreadProps(__spreadValues({}, (_d = options.backoffOptions) != null ? _d : BackoffDefaults), {
      onFailedAttempt: () => {
        var _a2, _b2;
        __privateSet(this, _connected, false);
        (_b2 = (_a2 = options.backoffOptions) == null ? void 0 : _a2.onFailedAttempt) == null ? void 0 : _b2.call(_a2);
      }
    });
    const fetchWithBackoffClient = createFetchWithBackoff(
      baseFetchClient,
      backOffOpts
    );
    __privateSet(this, _sseFetchClient, createFetchWithResponseHeadersCheck(
      createFetchWithChunkBuffer(fetchWithBackoffClient)
    ));
    __privateSet(this, _fetchClient2, createFetchWithConsumedMessages(__privateGet(this, _sseFetchClient)));
    __privateMethod(this, _ShapeStream_instances, subscribeToVisibilityChanges_fn).call(this);
  }
  get shapeHandle() {
    return __privateGet(this, _shapeHandle);
  }
  get error() {
    return __privateGet(this, _error);
  }
  get isUpToDate() {
    return __privateGet(this, _isUpToDate);
  }
  get lastOffset() {
    return __privateGet(this, _lastOffset);
  }
  get mode() {
    return __privateGet(this, _mode);
  }
  subscribe(callback, onError = () => {
  }) {
    const subscriptionId = Math.random();
    __privateGet(this, _subscribers).set(subscriptionId, [callback, onError]);
    if (!__privateGet(this, _started)) __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
    return () => {
      __privateGet(this, _subscribers).delete(subscriptionId);
    };
  }
  unsubscribeAll() {
    var _a;
    __privateGet(this, _subscribers).clear();
    (_a = __privateGet(this, _unsubscribeFromVisibilityChanges)) == null ? void 0 : _a.call(this);
  }
  /** Unix time at which we last synced. Undefined when `isLoading` is true. */
  lastSyncedAt() {
    return __privateGet(this, _lastSyncedAt);
  }
  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */
  lastSynced() {
    if (__privateGet(this, _lastSyncedAt) === void 0) return Infinity;
    return Date.now() - __privateGet(this, _lastSyncedAt);
  }
  /** Indicates if we are connected to the Electric sync service. */
  isConnected() {
    return __privateGet(this, _connected);
  }
  /** True during initial fetch. False afterwise.  */
  isLoading() {
    return !__privateGet(this, _isUpToDate);
  }
  hasStarted() {
    return __privateGet(this, _started);
  }
  isPaused() {
    return __privateGet(this, _state) === `paused`;
  }
  /**
   * Refreshes the shape stream.
   * This preemptively aborts any ongoing long poll and reconnects without
   * long polling, ensuring that the stream receives an up to date message with the
   * latest LSN from Postgres at that point in time.
   */
  async forceDisconnectAndRefresh() {
    var _a, _b;
    __privateSet(this, _isRefreshing, true);
    if (__privateGet(this, _isUpToDate) && !((_a = __privateGet(this, _requestAbortController)) == null ? void 0 : _a.signal.aborted)) {
      (_b = __privateGet(this, _requestAbortController)) == null ? void 0 : _b.abort(FORCE_DISCONNECT_AND_REFRESH);
    }
    await __privateMethod(this, _ShapeStream_instances, nextTick_fn).call(this);
    __privateSet(this, _isRefreshing, false);
  }
  /**
   * Request a snapshot for subset of data and inject it into the subscribed data stream.
   *
   * Only available when mode is `changes_only`.
   * Returns the insertion point & the data, but more importantly injects the data
   * into the subscribed data stream. Returned value is unlikely to be useful for the caller,
   * unless the caller has complicated additional logic.
   *
   * Data will be injected in a way that's also tracking further incoming changes, and it'll
   * skip the ones that are already in the snapshot.
   *
   * @param opts - The options for the snapshot request.
   * @returns The metadata and the data for the snapshot.
   */
  async requestSnapshot(opts) {
    if (__privateGet(this, _mode) === `full`) {
      throw new Error(
        `Snapshot requests are not supported in ${__privateGet(this, _mode)} mode, as the consumer is guaranteed to observe all data`
      );
    }
    if (!__privateGet(this, _started)) await __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
    await __privateMethod(this, _ShapeStream_instances, waitForStreamEnd_fn).call(this);
    __privateWrapper(this, _activeSnapshotRequests)._++;
    try {
      if (__privateGet(this, _activeSnapshotRequests) === 1) {
        __privateMethod(this, _ShapeStream_instances, pause_fn).call(this);
      }
      const { metadata, data } = await this.fetchSnapshot(opts);
      const dataWithEndBoundary = data.concat([
        { headers: __spreadValues({ control: `snapshot-end` }, metadata) },
        { headers: __spreadValues({ control: `subset-end` }, opts) }
      ]);
      __privateGet(this, _snapshotTracker).addSnapshot(
        metadata,
        new Set(data.map((message) => message.key))
      );
      __privateMethod(this, _ShapeStream_instances, onMessages_fn).call(this, dataWithEndBoundary, false);
      return {
        metadata,
        data
      };
    } finally {
      __privateWrapper(this, _activeSnapshotRequests)._--;
      if (__privateGet(this, _activeSnapshotRequests) === 0) {
        __privateMethod(this, _ShapeStream_instances, resume_fn).call(this);
      }
    }
  }
  /**
   * Fetch a snapshot for subset of data.
   * Returns the metadata and the data, but does not inject it into the subscribed data stream.
   *
   * @param opts - The options for the snapshot request.
   * @returns The metadata and the data for the snapshot.
   */
  async fetchSnapshot(opts) {
    var _a;
    const { fetchUrl, requestHeaders } = await __privateMethod(this, _ShapeStream_instances, constructUrl_fn).call(this, this.options.url, true, opts);
    const response = await __privateGet(this, _fetchClient2).call(this, fetchUrl.toString(), {
      headers: requestHeaders
    });
    if (!response.ok) {
      throw new FetchError(
        response.status,
        void 0,
        void 0,
        Object.fromEntries([...response.headers.entries()]),
        fetchUrl.toString()
      );
    }
    const schema = (_a = __privateGet(this, _schema)) != null ? _a : getSchemaFromHeaders(response.headers, {
      required: true,
      url: fetchUrl.toString()
    });
    const { metadata, data: rawData } = await response.json();
    const data = __privateGet(this, _messageParser).parseSnapshotData(
      rawData,
      schema
    );
    return {
      metadata,
      data
    };
  }
};
_error = /* @__PURE__ */ new WeakMap();
_fetchClient2 = /* @__PURE__ */ new WeakMap();
_sseFetchClient = /* @__PURE__ */ new WeakMap();
_messageParser = /* @__PURE__ */ new WeakMap();
_subscribers = /* @__PURE__ */ new WeakMap();
_started = /* @__PURE__ */ new WeakMap();
_state = /* @__PURE__ */ new WeakMap();
_lastOffset = /* @__PURE__ */ new WeakMap();
_liveCacheBuster = /* @__PURE__ */ new WeakMap();
_lastSyncedAt = /* @__PURE__ */ new WeakMap();
_isUpToDate = /* @__PURE__ */ new WeakMap();
_isMidStream = /* @__PURE__ */ new WeakMap();
_connected = /* @__PURE__ */ new WeakMap();
_shapeHandle = /* @__PURE__ */ new WeakMap();
_mode = /* @__PURE__ */ new WeakMap();
_schema = /* @__PURE__ */ new WeakMap();
_onError = /* @__PURE__ */ new WeakMap();
_requestAbortController = /* @__PURE__ */ new WeakMap();
_isRefreshing = /* @__PURE__ */ new WeakMap();
_tickPromise = /* @__PURE__ */ new WeakMap();
_tickPromiseResolver = /* @__PURE__ */ new WeakMap();
_tickPromiseRejecter = /* @__PURE__ */ new WeakMap();
_messageChain = /* @__PURE__ */ new WeakMap();
_snapshotTracker = /* @__PURE__ */ new WeakMap();
_activeSnapshotRequests = /* @__PURE__ */ new WeakMap();
_midStreamPromise = /* @__PURE__ */ new WeakMap();
_midStreamPromiseResolver = /* @__PURE__ */ new WeakMap();
_lastSeenCursor = /* @__PURE__ */ new WeakMap();
_currentFetchUrl = /* @__PURE__ */ new WeakMap();
_lastSseConnectionStartTime = /* @__PURE__ */ new WeakMap();
_minSseConnectionDuration = /* @__PURE__ */ new WeakMap();
_consecutiveShortSseConnections = /* @__PURE__ */ new WeakMap();
_maxShortSseConnections = /* @__PURE__ */ new WeakMap();
_sseFallbackToLongPolling = /* @__PURE__ */ new WeakMap();
_sseBackoffBaseDelay = /* @__PURE__ */ new WeakMap();
_sseBackoffMaxDelay = /* @__PURE__ */ new WeakMap();
_unsubscribeFromVisibilityChanges = /* @__PURE__ */ new WeakMap();
_ShapeStream_instances = /* @__PURE__ */ new WeakSet();
replayMode_get = function() {
  return __privateGet(this, _lastSeenCursor) !== void 0;
};
start_fn = async function() {
  var _a, _b, _c, _d, _e;
  __privateSet(this, _started, true);
  try {
    await __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
  } catch (err) {
    __privateSet(this, _error, err);
    if (__privateGet(this, _onError)) {
      const retryOpts = await __privateGet(this, _onError).call(this, err);
      if (retryOpts && typeof retryOpts === `object`) {
        if (retryOpts.params) {
          this.options.params = __spreadValues(__spreadValues({}, (_a = this.options.params) != null ? _a : {}), retryOpts.params);
        }
        if (retryOpts.headers) {
          this.options.headers = __spreadValues(__spreadValues({}, (_b = this.options.headers) != null ? _b : {}), retryOpts.headers);
        }
        __privateSet(this, _error, null);
        __privateSet(this, _started, false);
        await __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
        return;
      }
      if (err instanceof Error) {
        __privateMethod(this, _ShapeStream_instances, sendErrorToSubscribers_fn).call(this, err);
      }
      __privateSet(this, _connected, false);
      (_c = __privateGet(this, _tickPromiseRejecter)) == null ? void 0 : _c.call(this);
      return;
    }
    if (err instanceof Error) {
      __privateMethod(this, _ShapeStream_instances, sendErrorToSubscribers_fn).call(this, err);
    }
    __privateSet(this, _connected, false);
    (_d = __privateGet(this, _tickPromiseRejecter)) == null ? void 0 : _d.call(this);
    throw err;
  }
  __privateSet(this, _connected, false);
  (_e = __privateGet(this, _tickPromiseRejecter)) == null ? void 0 : _e.call(this);
};
requestShape_fn = async function() {
  var _a, _b;
  if (__privateGet(this, _state) === `pause-requested`) {
    __privateSet(this, _state, `paused`);
    return;
  }
  if (!this.options.subscribe && (((_a = this.options.signal) == null ? void 0 : _a.aborted) || __privateGet(this, _isUpToDate))) {
    return;
  }
  const resumingFromPause = __privateGet(this, _state) === `paused`;
  __privateSet(this, _state, `active`);
  const { url, signal } = this.options;
  const { fetchUrl, requestHeaders } = await __privateMethod(this, _ShapeStream_instances, constructUrl_fn).call(this, url, resumingFromPause);
  const abortListener = await __privateMethod(this, _ShapeStream_instances, createAbortListener_fn).call(this, signal);
  const requestAbortController = __privateGet(this, _requestAbortController);
  try {
    await __privateMethod(this, _ShapeStream_instances, fetchShape_fn).call(this, {
      fetchUrl,
      requestAbortController,
      headers: requestHeaders,
      resumingFromPause
    });
  } catch (e) {
    if ((e instanceof FetchError || e instanceof FetchBackoffAbortError) && requestAbortController.signal.aborted && requestAbortController.signal.reason === FORCE_DISCONNECT_AND_REFRESH) {
      return __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
    }
    if (e instanceof FetchBackoffAbortError) {
      const currentState = __privateGet(this, _state);
      if (requestAbortController.signal.aborted && requestAbortController.signal.reason === PAUSE_STREAM && currentState === `pause-requested`) {
        __privateSet(this, _state, `paused`);
      }
      return;
    }
    if (!(e instanceof FetchError)) throw e;
    if (e.status == 409) {
      if (__privateGet(this, _shapeHandle)) {
        const shapeKey = canonicalShapeKey(fetchUrl);
        expiredShapesCache.markExpired(shapeKey, __privateGet(this, _shapeHandle));
      }
      const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER] || `${__privateGet(this, _shapeHandle)}-next`;
      __privateMethod(this, _ShapeStream_instances, reset_fn).call(this, newShapeHandle);
      await __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, Array.isArray(e.json) ? e.json : [e.json]);
      return __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
    } else {
      throw e;
    }
  } finally {
    if (abortListener && signal) {
      signal.removeEventListener(`abort`, abortListener);
    }
    __privateSet(this, _requestAbortController, void 0);
  }
  (_b = __privateGet(this, _tickPromiseResolver)) == null ? void 0 : _b.call(this);
  return __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
};
constructUrl_fn = async function(url, resumingFromPause, subsetParams) {
  var _a, _b, _c, _d, _e, _f;
  const [requestHeaders, params] = await Promise.all([
    resolveHeaders(this.options.headers),
    this.options.params ? toInternalParams(convertWhereParamsToObj(this.options.params)) : void 0
  ]);
  if (params) validateParams(params);
  const fetchUrl = new URL(url);
  if (params) {
    if (params.table) setQueryParam(fetchUrl, TABLE_QUERY_PARAM, params.table);
    if (params.where && typeof params.where === `string`) {
      const encodedWhere = encodeWhereClause(
        params.where,
        (_a = this.options.columnMapper) == null ? void 0 : _a.encode
      );
      setQueryParam(fetchUrl, WHERE_QUERY_PARAM, encodedWhere);
    }
    if (params.columns) {
      const originalColumns = await resolveValue((_b = this.options.params) == null ? void 0 : _b.columns);
      if (Array.isArray(originalColumns)) {
        let encodedColumns = originalColumns.map(String);
        if (this.options.columnMapper) {
          encodedColumns = encodedColumns.map(
            this.options.columnMapper.encode
          );
        }
        const serializedColumns = encodedColumns.map(quoteIdentifier).join(`,`);
        setQueryParam(fetchUrl, COLUMNS_QUERY_PARAM, serializedColumns);
      } else {
        setQueryParam(fetchUrl, COLUMNS_QUERY_PARAM, params.columns);
      }
    }
    if (params.replica) setQueryParam(fetchUrl, REPLICA_PARAM, params.replica);
    if (params.params)
      setQueryParam(fetchUrl, WHERE_PARAMS_PARAM, params.params);
    const customParams = __spreadValues({}, params);
    delete customParams.table;
    delete customParams.where;
    delete customParams.columns;
    delete customParams.replica;
    delete customParams.params;
    for (const [key, value] of Object.entries(customParams)) {
      setQueryParam(fetchUrl, key, value);
    }
  }
  if (subsetParams) {
    if (subsetParams.whereExpr) {
      const compiledWhere = compileExpression(
        subsetParams.whereExpr,
        (_c = this.options.columnMapper) == null ? void 0 : _c.encode
      );
      setQueryParam(fetchUrl, SUBSET_PARAM_WHERE, compiledWhere);
      fetchUrl.searchParams.set(
        SUBSET_PARAM_WHERE_EXPR,
        JSON.stringify(subsetParams.whereExpr)
      );
    } else if (subsetParams.where && typeof subsetParams.where === `string`) {
      const encodedWhere = encodeWhereClause(
        subsetParams.where,
        (_d = this.options.columnMapper) == null ? void 0 : _d.encode
      );
      setQueryParam(fetchUrl, SUBSET_PARAM_WHERE, encodedWhere);
    }
    if (subsetParams.params)
      fetchUrl.searchParams.set(
        SUBSET_PARAM_WHERE_PARAMS,
        JSON.stringify(subsetParams.params)
      );
    if (subsetParams.limit)
      setQueryParam(fetchUrl, SUBSET_PARAM_LIMIT, subsetParams.limit);
    if (subsetParams.offset)
      setQueryParam(fetchUrl, SUBSET_PARAM_OFFSET, subsetParams.offset);
    if (subsetParams.orderByExpr) {
      const compiledOrderBy = compileOrderBy(
        subsetParams.orderByExpr,
        (_e = this.options.columnMapper) == null ? void 0 : _e.encode
      );
      setQueryParam(fetchUrl, SUBSET_PARAM_ORDER_BY, compiledOrderBy);
      fetchUrl.searchParams.set(
        SUBSET_PARAM_ORDER_BY_EXPR,
        JSON.stringify(subsetParams.orderByExpr)
      );
    } else if (subsetParams.orderBy && typeof subsetParams.orderBy === `string`) {
      const encodedOrderBy = encodeWhereClause(
        subsetParams.orderBy,
        (_f = this.options.columnMapper) == null ? void 0 : _f.encode
      );
      setQueryParam(fetchUrl, SUBSET_PARAM_ORDER_BY, encodedOrderBy);
    }
  }
  fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, __privateGet(this, _lastOffset));
  fetchUrl.searchParams.set(LOG_MODE_QUERY_PARAM, __privateGet(this, _mode));
  const isSnapshotRequest = subsetParams !== void 0;
  if (__privateGet(this, _isUpToDate) && !isSnapshotRequest) {
    if (!__privateGet(this, _isRefreshing) && !resumingFromPause) {
      fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`);
    }
    fetchUrl.searchParams.set(
      LIVE_CACHE_BUSTER_QUERY_PARAM,
      __privateGet(this, _liveCacheBuster)
    );
  }
  if (__privateGet(this, _shapeHandle)) {
    fetchUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, __privateGet(this, _shapeHandle));
  }
  const shapeKey = canonicalShapeKey(fetchUrl);
  const expiredHandle = expiredShapesCache.getExpiredHandle(shapeKey);
  if (expiredHandle) {
    fetchUrl.searchParams.set(EXPIRED_HANDLE_QUERY_PARAM, expiredHandle);
  }
  fetchUrl.searchParams.sort();
  return {
    fetchUrl,
    requestHeaders
  };
};
createAbortListener_fn = async function(signal) {
  var _a;
  __privateSet(this, _requestAbortController, new AbortController());
  if (signal) {
    const abortListener = () => {
      var _a2;
      (_a2 = __privateGet(this, _requestAbortController)) == null ? void 0 : _a2.abort(signal.reason);
    };
    signal.addEventListener(`abort`, abortListener, { once: true });
    if (signal.aborted) {
      (_a = __privateGet(this, _requestAbortController)) == null ? void 0 : _a.abort(signal.reason);
    }
    return abortListener;
  }
};
onInitialResponse_fn = async function(response) {
  var _a;
  const { headers, status } = response;
  const shapeHandle = headers.get(SHAPE_HANDLE_HEADER);
  if (shapeHandle) {
    const shapeKey = __privateGet(this, _currentFetchUrl) ? canonicalShapeKey(__privateGet(this, _currentFetchUrl)) : null;
    const expiredHandle = shapeKey ? expiredShapesCache.getExpiredHandle(shapeKey) : null;
    if (shapeHandle !== expiredHandle) {
      __privateSet(this, _shapeHandle, shapeHandle);
    } else {
      console.warn(
        `[Electric] Received stale cached response with expired shape handle. This should not happen and indicates a proxy/CDN caching misconfiguration. The response contained handle "${shapeHandle}" which was previously marked as expired. Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. Ignoring the stale handle and continuing with handle "${__privateGet(this, _shapeHandle)}".`
      );
    }
  }
  const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER);
  if (lastOffset) {
    __privateSet(this, _lastOffset, lastOffset);
  }
  const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER);
  if (liveCacheBuster) {
    __privateSet(this, _liveCacheBuster, liveCacheBuster);
  }
  __privateSet(this, _schema, (_a = __privateGet(this, _schema)) != null ? _a : getSchemaFromHeaders(headers));
  if (status === 204) {
    __privateSet(this, _lastSyncedAt, Date.now());
  }
};
onMessages_fn = async function(batch, isSseMessage = false) {
  var _a;
  if (batch.length > 0) {
    __privateSet(this, _isMidStream, true);
    const lastMessage = batch[batch.length - 1];
    if (isUpToDateMessage(lastMessage)) {
      if (isSseMessage) {
        const offset = getOffset(lastMessage);
        if (offset) {
          __privateSet(this, _lastOffset, offset);
        }
      }
      __privateSet(this, _lastSyncedAt, Date.now());
      __privateSet(this, _isUpToDate, true);
      __privateSet(this, _isMidStream, false);
      (_a = __privateGet(this, _midStreamPromiseResolver)) == null ? void 0 : _a.call(this);
      if (__privateGet(this, _ShapeStream_instances, replayMode_get) && !isSseMessage) {
        const currentCursor = __privateGet(this, _liveCacheBuster);
        if (currentCursor === __privateGet(this, _lastSeenCursor)) {
          return;
        }
      }
      __privateSet(this, _lastSeenCursor, void 0);
      if (__privateGet(this, _currentFetchUrl)) {
        const shapeKey = canonicalShapeKey(__privateGet(this, _currentFetchUrl));
        upToDateTracker.recordUpToDate(shapeKey, __privateGet(this, _liveCacheBuster));
      }
    }
    const messagesToProcess = batch.filter((message) => {
      if (isChangeMessage(message)) {
        return !__privateGet(this, _snapshotTracker).shouldRejectMessage(message);
      }
      return true;
    });
    await __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, messagesToProcess);
  }
};
fetchShape_fn = async function(opts) {
  var _a;
  __privateSet(this, _currentFetchUrl, opts.fetchUrl);
  if (!__privateGet(this, _isUpToDate) && !__privateGet(this, _ShapeStream_instances, replayMode_get)) {
    const shapeKey = canonicalShapeKey(opts.fetchUrl);
    const lastSeenCursor = upToDateTracker.shouldEnterReplayMode(shapeKey);
    if (lastSeenCursor) {
      __privateSet(this, _lastSeenCursor, lastSeenCursor);
    }
  }
  const useSse = (_a = this.options.liveSse) != null ? _a : this.options.experimentalLiveSse;
  if (__privateGet(this, _isUpToDate) && useSse && !__privateGet(this, _isRefreshing) && !opts.resumingFromPause && !__privateGet(this, _sseFallbackToLongPolling)) {
    opts.fetchUrl.searchParams.set(EXPERIMENTAL_LIVE_SSE_QUERY_PARAM, `true`);
    opts.fetchUrl.searchParams.set(LIVE_SSE_QUERY_PARAM, `true`);
    return __privateMethod(this, _ShapeStream_instances, requestShapeSSE_fn).call(this, opts);
  }
  return __privateMethod(this, _ShapeStream_instances, requestShapeLongPoll_fn).call(this, opts);
};
requestShapeLongPoll_fn = async function(opts) {
  const { fetchUrl, requestAbortController, headers } = opts;
  const response = await __privateGet(this, _fetchClient2).call(this, fetchUrl.toString(), {
    signal: requestAbortController.signal,
    headers
  });
  __privateSet(this, _connected, true);
  await __privateMethod(this, _ShapeStream_instances, onInitialResponse_fn).call(this, response);
  const schema = __privateGet(this, _schema);
  const res = await response.text();
  const messages = res || `[]`;
  const batch = __privateGet(this, _messageParser).parse(messages, schema);
  await __privateMethod(this, _ShapeStream_instances, onMessages_fn).call(this, batch);
};
requestShapeSSE_fn = async function(opts) {
  const { fetchUrl, requestAbortController, headers } = opts;
  const fetch2 = __privateGet(this, _sseFetchClient);
  __privateSet(this, _lastSseConnectionStartTime, Date.now());
  const sseHeaders = __spreadProps(__spreadValues({}, headers), {
    Accept: `text/event-stream`
  });
  try {
    let buffer = [];
    await fetchEventSource(fetchUrl.toString(), {
      headers: sseHeaders,
      fetch: fetch2,
      onopen: async (response) => {
        __privateSet(this, _connected, true);
        await __privateMethod(this, _ShapeStream_instances, onInitialResponse_fn).call(this, response);
      },
      onmessage: (event) => {
        if (event.data) {
          const schema = __privateGet(this, _schema);
          const message = __privateGet(this, _messageParser).parse(
            event.data,
            schema
          );
          buffer.push(message);
          if (isUpToDateMessage(message)) {
            __privateMethod(this, _ShapeStream_instances, onMessages_fn).call(this, buffer, true);
            buffer = [];
          }
        }
      },
      onerror: (error) => {
        throw error;
      },
      signal: requestAbortController.signal
    });
  } catch (error) {
    if (requestAbortController.signal.aborted) {
      throw new FetchBackoffAbortError();
    }
    throw error;
  } finally {
    const connectionDuration = Date.now() - __privateGet(this, _lastSseConnectionStartTime);
    const wasAborted = requestAbortController.signal.aborted;
    if (connectionDuration < __privateGet(this, _minSseConnectionDuration) && !wasAborted) {
      __privateWrapper(this, _consecutiveShortSseConnections)._++;
      if (__privateGet(this, _consecutiveShortSseConnections) >= __privateGet(this, _maxShortSseConnections)) {
        __privateSet(this, _sseFallbackToLongPolling, true);
        console.warn(
          `[Electric] SSE connections are closing immediately (possibly due to proxy buffering or misconfiguration). Falling back to long polling. Your proxy must support streaming SSE responses (not buffer the complete response). Configuration: Nginx add 'X-Accel-Buffering: no', Caddy add 'flush_interval -1' to reverse_proxy. Note: Do NOT disable caching entirely - Electric uses cache headers to enable request collapsing for efficiency.`
        );
      } else {
        const maxDelay = Math.min(
          __privateGet(this, _sseBackoffMaxDelay),
          __privateGet(this, _sseBackoffBaseDelay) * Math.pow(2, __privateGet(this, _consecutiveShortSseConnections))
        );
        const delayMs = Math.floor(Math.random() * maxDelay);
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
    } else if (connectionDuration >= __privateGet(this, _minSseConnectionDuration)) {
      __privateSet(this, _consecutiveShortSseConnections, 0);
    }
  }
};
pause_fn = function() {
  var _a;
  if (__privateGet(this, _started) && __privateGet(this, _state) === `active`) {
    __privateSet(this, _state, `pause-requested`);
    (_a = __privateGet(this, _requestAbortController)) == null ? void 0 : _a.abort(PAUSE_STREAM);
  }
};
resume_fn = function() {
  var _a;
  if (__privateGet(this, _started) && (__privateGet(this, _state) === `paused` || __privateGet(this, _state) === `pause-requested`)) {
    if ((_a = this.options.signal) == null ? void 0 : _a.aborted) {
      return;
    }
    if (__privateGet(this, _state) === `pause-requested`) {
      __privateSet(this, _state, `active`);
    }
    __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
  }
};
nextTick_fn = async function() {
  if (__privateGet(this, _tickPromise)) {
    return __privateGet(this, _tickPromise);
  }
  __privateSet(this, _tickPromise, new Promise((resolve, reject) => {
    __privateSet(this, _tickPromiseResolver, resolve);
    __privateSet(this, _tickPromiseRejecter, reject);
  }));
  __privateGet(this, _tickPromise).finally(() => {
    __privateSet(this, _tickPromise, void 0);
    __privateSet(this, _tickPromiseResolver, void 0);
    __privateSet(this, _tickPromiseRejecter, void 0);
  });
  return __privateGet(this, _tickPromise);
};
waitForStreamEnd_fn = async function() {
  if (!__privateGet(this, _isMidStream)) {
    return;
  }
  if (__privateGet(this, _midStreamPromise)) {
    return __privateGet(this, _midStreamPromise);
  }
  __privateSet(this, _midStreamPromise, new Promise((resolve) => {
    __privateSet(this, _midStreamPromiseResolver, resolve);
  }));
  __privateGet(this, _midStreamPromise).finally(() => {
    __privateSet(this, _midStreamPromise, void 0);
    __privateSet(this, _midStreamPromiseResolver, void 0);
  });
  return __privateGet(this, _midStreamPromise);
};
publish_fn = async function(messages) {
  __privateSet(this, _messageChain, __privateGet(this, _messageChain).then(
    () => Promise.all(
      Array.from(__privateGet(this, _subscribers).values()).map(async ([callback, __]) => {
        try {
          await callback(messages);
        } catch (err) {
          queueMicrotask(() => {
            throw err;
          });
        }
      })
    )
  ));
  return __privateGet(this, _messageChain);
};
sendErrorToSubscribers_fn = function(error) {
  __privateGet(this, _subscribers).forEach(([_, errorFn]) => {
    errorFn == null ? void 0 : errorFn(error);
  });
};
subscribeToVisibilityChanges_fn = function() {
  if (typeof document === `object` && typeof document.hidden === `boolean` && typeof document.addEventListener === `function`) {
    const visibilityHandler = () => {
      if (document.hidden) {
        __privateMethod(this, _ShapeStream_instances, pause_fn).call(this);
      } else {
        __privateMethod(this, _ShapeStream_instances, resume_fn).call(this);
      }
    };
    document.addEventListener(`visibilitychange`, visibilityHandler);
    __privateSet(this, _unsubscribeFromVisibilityChanges, () => {
      document.removeEventListener(`visibilitychange`, visibilityHandler);
    });
  }
};
reset_fn = function(handle) {
  __privateSet(this, _lastOffset, `-1`);
  __privateSet(this, _liveCacheBuster, ``);
  __privateSet(this, _shapeHandle, handle);
  __privateSet(this, _isUpToDate, false);
  __privateSet(this, _isMidStream, true);
  __privateSet(this, _connected, false);
  __privateSet(this, _schema, void 0);
  __privateSet(this, _activeSnapshotRequests, 0);
  __privateSet(this, _consecutiveShortSseConnections, 0);
  __privateSet(this, _sseFallbackToLongPolling, false);
};
ShapeStream.Replica = {
  FULL: `full`,
  DEFAULT: `default`
};
function getSchemaFromHeaders(headers, options) {
  const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER);
  if (!schemaHeader) {
    if ((options == null ? void 0 : options.required) && (options == null ? void 0 : options.url)) {
      throw new MissingHeadersError(options.url, [SHAPE_SCHEMA_HEADER]);
    }
    return {};
  }
  return JSON.parse(schemaHeader);
}
function validateParams(params) {
  if (!params) return;
  const reservedParams = Object.keys(params).filter(
    (key) => RESERVED_PARAMS.has(key)
  );
  if (reservedParams.length > 0) {
    throw new ReservedParamError(reservedParams);
  }
}
function validateOptions(options) {
  if (!options.url) {
    throw new MissingShapeUrlError();
  }
  if (options.signal && !(options.signal instanceof AbortSignal)) {
    throw new InvalidSignalError();
  }
  if (options.offset !== void 0 && options.offset !== `-1` && options.offset !== `now` && !options.handle) {
    throw new MissingShapeHandleError();
  }
  validateParams(options.params);
  return;
}
function setQueryParam(url, key, value) {
  if (value === void 0 || value == null) {
    return;
  } else if (typeof value === `string`) {
    url.searchParams.set(key, value);
  } else if (typeof value === `object`) {
    for (const [k, v] of Object.entries(value)) {
      url.searchParams.set(`${key}[${k}]`, v);
    }
  } else {
    url.searchParams.set(key, value.toString());
  }
}
function convertWhereParamsToObj(allPgParams) {
  if (Array.isArray(allPgParams.params)) {
    return __spreadProps(__spreadValues({}, allPgParams), {
      params: Object.fromEntries(allPgParams.params.map((v, i) => [i + 1, v]))
    });
  }
  return allPgParams;
}
var _data;
var _subscribers2;
var _insertedKeys;
var _requestedSubSnapshots;
var _reexecuteSnapshotsPending;
var _status;
var _error2;
var _Shape_instances;
var process_fn;
var reexecuteSnapshots_fn;
var awaitUpToDate_fn;
var updateShapeStatus_fn;
var handleError_fn;
var notify_fn;
_data = /* @__PURE__ */ new WeakMap();
_subscribers2 = /* @__PURE__ */ new WeakMap();
_insertedKeys = /* @__PURE__ */ new WeakMap();
_requestedSubSnapshots = /* @__PURE__ */ new WeakMap();
_reexecuteSnapshotsPending = /* @__PURE__ */ new WeakMap();
_status = /* @__PURE__ */ new WeakMap();
_error2 = /* @__PURE__ */ new WeakMap();
_Shape_instances = /* @__PURE__ */ new WeakSet();
process_fn = function(messages) {
  let shouldNotify = false;
  messages.forEach((message) => {
    if (isChangeMessage(message)) {
      shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `syncing`);
      if (this.mode === `full`) {
        switch (message.headers.operation) {
          case `insert`:
            __privateGet(this, _data).set(message.key, message.value);
            break;
          case `update`:
            __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));
            break;
          case `delete`:
            __privateGet(this, _data).delete(message.key);
            break;
        }
      } else {
        switch (message.headers.operation) {
          case `insert`:
            __privateGet(this, _insertedKeys).add(message.key);
            __privateGet(this, _data).set(message.key, message.value);
            break;
          case `update`:
            if (__privateGet(this, _insertedKeys).has(message.key)) {
              __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));
            }
            break;
          case `delete`:
            if (__privateGet(this, _insertedKeys).has(message.key)) {
              __privateGet(this, _data).delete(message.key);
              __privateGet(this, _insertedKeys).delete(message.key);
            }
            break;
        }
      }
    }
    if (isControlMessage(message)) {
      switch (message.headers.control) {
        case `up-to-date`:
          shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `up-to-date`);
          if (__privateGet(this, _reexecuteSnapshotsPending)) {
            __privateSet(this, _reexecuteSnapshotsPending, false);
            void __privateMethod(this, _Shape_instances, reexecuteSnapshots_fn).call(this);
          }
          break;
        case `must-refetch`:
          __privateGet(this, _data).clear();
          __privateGet(this, _insertedKeys).clear();
          __privateSet(this, _error2, false);
          shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `syncing`);
          __privateSet(this, _reexecuteSnapshotsPending, true);
          break;
      }
    }
  });
  if (shouldNotify) __privateMethod(this, _Shape_instances, notify_fn).call(this);
};
reexecuteSnapshots_fn = async function() {
  await __privateMethod(this, _Shape_instances, awaitUpToDate_fn).call(this);
  await Promise.all(
    Array.from(__privateGet(this, _requestedSubSnapshots)).map(async (jsonParams) => {
      try {
        const snapshot = JSON.parse(jsonParams);
        await this.stream.requestSnapshot(snapshot);
      } catch (_) {
      }
    })
  );
};
awaitUpToDate_fn = async function() {
  if (this.stream.isUpToDate) return;
  await new Promise((resolve) => {
    const check = () => {
      if (this.stream.isUpToDate) {
        clearInterval(interval);
        unsub();
        resolve();
      }
    };
    const interval = setInterval(check, 10);
    const unsub = this.stream.subscribe(
      () => check(),
      () => check()
    );
    check();
  });
};
updateShapeStatus_fn = function(status) {
  const stateChanged = __privateGet(this, _status) !== status;
  __privateSet(this, _status, status);
  return stateChanged && status === `up-to-date`;
};
handleError_fn = function(e) {
  if (e instanceof FetchError) {
    __privateSet(this, _error2, e);
    __privateMethod(this, _Shape_instances, notify_fn).call(this);
  }
};
notify_fn = function() {
  __privateGet(this, _subscribers2).forEach((callback) => {
    callback({ value: this.currentValue, rows: this.currentRows });
  });
};

// node_modules/@tanstack/electric-db-collection/dist/esm/electric.js
var import_debug = __toESM(require_browser(), 1);

// node_modules/@tanstack/electric-db-collection/dist/esm/errors.js
var ElectricDBCollectionError = class extends TanStackDBError {
  constructor(message, collectionId) {
    super(`${collectionId ? `[${collectionId}] ` : ``}${message}`);
    this.name = `ElectricDBCollectionError`;
  }
};
var ExpectedNumberInAwaitTxIdError = class extends ElectricDBCollectionError {
  constructor(txIdType, collectionId) {
    super(`Expected number in awaitTxId, received ${txIdType}`, collectionId);
    this.name = `ExpectedNumberInAwaitTxIdError`;
  }
};
var TimeoutWaitingForTxIdError = class extends ElectricDBCollectionError {
  constructor(txId, collectionId) {
    super(`Timeout waiting for txId: ${txId}`, collectionId);
    this.name = `TimeoutWaitingForTxIdError`;
  }
};
var TimeoutWaitingForMatchError = class extends ElectricDBCollectionError {
  constructor(collectionId) {
    super(`Timeout waiting for custom match function`, collectionId);
    this.name = `TimeoutWaitingForMatchError`;
  }
};
var StreamAbortedError = class extends ElectricDBCollectionError {
  constructor(collectionId) {
    super(`Stream aborted`, collectionId);
    this.name = `StreamAbortedError`;
  }
};

// node_modules/@tanstack/electric-db-collection/dist/esm/pg-serializer.js
function serialize(value) {
  if (value === null || value === void 0) {
    return ``;
  }
  if (typeof value === `string`) {
    return value;
  }
  if (typeof value === `number`) {
    return value.toString();
  }
  if (typeof value === `bigint`) {
    return value.toString();
  }
  if (typeof value === `boolean`) {
    return value ? `true` : `false`;
  }
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (Array.isArray(value)) {
    const elements = value.map((item) => {
      if (item === null || item === void 0) {
        return `NULL`;
      }
      if (typeof item === `string`) {
        const escaped = item.replace(/\\/g, `\\\\`).replace(/"/g, `\\"`);
        return `"${escaped}"`;
      }
      return serialize(item);
    });
    return `{${elements.join(`,`)}}`;
  }
  let valueStr;
  try {
    valueStr = JSON.stringify(value);
  } catch {
    valueStr = String(value);
  }
  throw new Error(`Cannot serialize value: ${valueStr}`);
}

// node_modules/@tanstack/electric-db-collection/dist/esm/sql-compiler.js
function compileSQL(options) {
  const { where, orderBy, limit } = options;
  const params = [];
  const compiledSQL = { params };
  if (where) {
    compiledSQL.where = compileBasicExpression(where, params);
  }
  if (orderBy) {
    compiledSQL.orderBy = compileOrderBy2(orderBy, params);
  }
  if (limit) {
    compiledSQL.limit = limit;
  }
  if (!where) {
    compiledSQL.where = `true = true`;
  }
  const paramsRecord = params.reduce(
    (acc, param, index) => {
      const serialized = serialize(param);
      if (serialized !== ``) {
        acc[`${index + 1}`] = serialized;
      }
      return acc;
    },
    {}
  );
  return {
    ...compiledSQL,
    params: paramsRecord
  };
}
function quoteIdentifier2(name) {
  return `"${name}"`;
}
function compileBasicExpression(exp, params) {
  switch (exp.type) {
    case `val`:
      params.push(exp.value);
      return `$${params.length}`;
    case `ref`:
      if (exp.path.length !== 1) {
        throw new Error(
          `Compiler can't handle nested properties: ${exp.path.join(`.`)}`
        );
      }
      return quoteIdentifier2(exp.path[0]);
    case `func`:
      return compileFunction2(exp, params);
    default:
      throw new Error(`Unknown expression type`);
  }
}
function compileOrderBy2(orderBy, params) {
  const compiledOrderByClauses = orderBy.map(
    (clause) => compileOrderByClause(clause, params)
  );
  return compiledOrderByClauses.join(`,`);
}
function compileOrderByClause(clause, params) {
  const { expression, compareOptions } = clause;
  let sql = compileBasicExpression(expression, params);
  if (compareOptions.direction === `desc`) {
    sql = `${sql} DESC`;
  }
  if (compareOptions.nulls === `first`) {
    sql = `${sql} NULLS FIRST`;
  }
  if (compareOptions.nulls === `last`) {
    sql = `${sql} NULLS LAST`;
  }
  return sql;
}
function isNullValue(exp) {
  return exp.type === `val` && (exp.value === null || exp.value === void 0);
}
function compileFunction2(exp, params = []) {
  const { name, args } = exp;
  const opName = getOpName(name);
  if (isComparisonOp(name)) {
    const nullArgIndex = args.findIndex(
      (arg) => isNullValue(arg)
    );
    if (nullArgIndex !== -1) {
      throw new Error(
        `Cannot use null/undefined value with '${name}' operator. Comparisons with null always evaluate to UNKNOWN in SQL. Use isNull() or isUndefined() to check for null values, or filter out null values before building the query.`
      );
    }
  }
  const compiledArgs = args.map(
    (arg) => compileBasicExpression(arg, params)
  );
  if (name === `isNull` || name === `isUndefined`) {
    if (compiledArgs.length !== 1) {
      throw new Error(`${name} expects 1 argument`);
    }
    return `${compiledArgs[0]} ${opName}`;
  }
  if (name === `not`) {
    if (compiledArgs.length !== 1) {
      throw new Error(`NOT expects 1 argument`);
    }
    const arg = args[0];
    if (arg && arg.type === `func`) {
      const funcArg = arg;
      if (funcArg.name === `isNull` || funcArg.name === `isUndefined`) {
        const innerArg = compileBasicExpression(funcArg.args[0], params);
        return `${innerArg} IS NOT NULL`;
      }
    }
    return `${opName} (${compiledArgs[0]})`;
  }
  if (isBinaryOp(name)) {
    if ((name === `and` || name === `or`) && compiledArgs.length > 2) {
      return compiledArgs.map((arg) => `(${arg})`).join(` ${opName} `);
    }
    if (compiledArgs.length !== 2) {
      throw new Error(`Binary operator ${name} expects 2 arguments`);
    }
    const [lhs, rhs] = compiledArgs;
    if (isBooleanComparisonOp(name)) {
      const lhsArg = args[0];
      const rhsArg = args[1];
      if (rhsArg && rhsArg.type === `val` && typeof rhsArg.value === `boolean`) {
        const boolValue = rhsArg.value;
        params.pop();
        if (name === `lt`) {
          if (boolValue === true) {
            params.push(false);
            return `${lhs} = $${params.length}`;
          } else {
            return `false`;
          }
        } else if (name === `gt`) {
          if (boolValue === false) {
            params.push(true);
            return `${lhs} = $${params.length}`;
          } else {
            return `false`;
          }
        } else if (name === `lte`) {
          if (boolValue === true) {
            return `true`;
          } else {
            params.push(false);
            return `${lhs} = $${params.length}`;
          }
        } else if (name === `gte`) {
          if (boolValue === false) {
            return `true`;
          } else {
            params.push(true);
            return `${lhs} = $${params.length}`;
          }
        }
      }
      if (lhsArg && lhsArg.type === `val` && typeof lhsArg.value === `boolean`) {
        const boolValue = lhsArg.value;
        params.pop();
        params.pop();
        const rhsCompiled = compileBasicExpression(rhsArg, params);
        if (name === `lt`) {
          if (boolValue === true) {
            return `false`;
          } else {
            params.push(true);
            return `${rhsCompiled} = $${params.length}`;
          }
        } else if (name === `gt`) {
          if (boolValue === true) {
            params.push(false);
            return `${rhsCompiled} = $${params.length}`;
          } else {
            return `false`;
          }
        } else if (name === `lte`) {
          if (boolValue === false) {
            return `true`;
          } else {
            params.push(true);
            return `${rhsCompiled} = $${params.length}`;
          }
        } else if (name === `gte`) {
          if (boolValue === true) {
            return `true`;
          } else {
            params.push(false);
            return `${rhsCompiled} = $${params.length}`;
          }
        }
      }
    }
    if (name === `in`) {
      return `${lhs} ${opName}(${rhs})`;
    }
    return `${lhs} ${opName} ${rhs}`;
  }
  return `${opName}(${compiledArgs.join(`,`)})`;
}
function isBinaryOp(name) {
  const binaryOps = [
    `eq`,
    `gt`,
    `gte`,
    `lt`,
    `lte`,
    `and`,
    `or`,
    `in`,
    `like`,
    `ilike`
  ];
  return binaryOps.includes(name);
}
function isComparisonOp(name) {
  const comparisonOps = [`eq`, `gt`, `gte`, `lt`, `lte`, `like`, `ilike`];
  return comparisonOps.includes(name);
}
function isBooleanComparisonOp(name) {
  return [`gt`, `gte`, `lt`, `lte`].includes(name);
}
function getOpName(name) {
  const opNames = {
    eq: `=`,
    gt: `>`,
    gte: `>=`,
    lt: `<`,
    lte: `<=`,
    add: `+`,
    and: `AND`,
    or: `OR`,
    not: `NOT`,
    isUndefined: `IS NULL`,
    isNull: `IS NULL`,
    in: `= ANY`,
    // Use = ANY syntax for array parameters
    like: `LIKE`,
    ilike: `ILIKE`,
    upper: `UPPER`,
    lower: `LOWER`,
    length: `LENGTH`,
    concat: `CONCAT`,
    coalesce: `COALESCE`
  };
  const opName = opNames[name];
  if (!opName) {
    throw new Error(`Unknown operator/function: ${name}`);
  }
  return opName;
}

// node_modules/@tanstack/electric-db-collection/dist/esm/tag-index.js
var TAG_WILDCARD = `_`;
function getValue(tag, position) {
  if (position >= tag.length) {
    throw new Error(`Position out of bounds`);
  }
  return tag[position];
}
function getPositionalValue(pattern) {
  return pattern;
}
function getTagLength(tag) {
  return tag.length;
}
function tagMatchesPattern(tag, pattern) {
  const { pos, value } = getPositionalValue(pattern);
  const tagValue = getValue(tag, pos);
  return tagValue === value || tagValue === TAG_WILDCARD;
}
function addTagToIndex(tag, rowId, index, tagLength) {
  for (let i = 0; i < tagLength; i++) {
    const value = getValue(tag, i);
    if (value !== TAG_WILDCARD) {
      const positionIndex = index[i];
      if (!positionIndex.has(value)) {
        positionIndex.set(value, /* @__PURE__ */ new Set());
      }
      const tags = positionIndex.get(value);
      tags.add(rowId);
    }
  }
}
function removeTagFromIndex(tag, rowId, index, tagLength) {
  for (let i = 0; i < tagLength; i++) {
    const value = getValue(tag, i);
    if (value !== TAG_WILDCARD) {
      const positionIndex = index[i];
      if (positionIndex) {
        const rowSet = positionIndex.get(value);
        if (rowSet) {
          rowSet.delete(rowId);
          if (rowSet.size === 0) {
            positionIndex.delete(value);
          }
        }
      }
    }
  }
}
function findRowsMatchingPattern(pattern, index) {
  const { pos, value } = getPositionalValue(pattern);
  const positionIndex = index[pos];
  const rowSet = positionIndex == null ? void 0 : positionIndex.get(value);
  return rowSet ?? /* @__PURE__ */ new Set();
}
function isMoveOutMessage(message) {
  return message.headers.event === `move-out`;
}

// node_modules/@tanstack/electric-db-collection/dist/esm/electric.js
var debug = import_debug.default.debug(`ts/db:electric`);
var ELECTRIC_TEST_HOOKS = Symbol(`electricTestHooks`);
function isUpToDateMessage2(message) {
  return isControlMessage(message) && message.headers.control === `up-to-date`;
}
function isMustRefetchMessage(message) {
  return isControlMessage(message) && message.headers.control === `must-refetch`;
}
function isSnapshotEndMessage(message) {
  return isControlMessage(message) && message.headers.control === `snapshot-end`;
}
function isSubsetEndMessage(message) {
  return isControlMessage(message) && message.headers.control === `subset-end`;
}
function parseSnapshotMessage(message) {
  return {
    xmin: message.headers.xmin,
    xmax: message.headers.xmax,
    xip_list: message.headers.xip_list
  };
}
function hasTxids(message) {
  return `txids` in message.headers && Array.isArray(message.headers.txids);
}
function createLoadSubsetDedupe({
  stream,
  syncMode,
  isBufferingInitialSync,
  begin,
  write,
  commit,
  collectionId
}) {
  if (syncMode === `eager`) {
    return null;
  }
  const loadSubset = async (opts) => {
    if (isBufferingInitialSync()) {
      const snapshotParams = compileSQL(opts);
      try {
        const { data: rows } = await stream.fetchSnapshot(snapshotParams);
        if (!isBufferingInitialSync()) {
          debug(
            `${collectionId ? `[${collectionId}] ` : ``}Ignoring snapshot - sync completed while fetching`
          );
          return;
        }
        if (rows.length > 0) {
          begin();
          for (const row of rows) {
            write({
              type: `insert`,
              value: row.value,
              metadata: {
                ...row.headers
              }
            });
          }
          commit();
          debug(
            `${collectionId ? `[${collectionId}] ` : ``}Applied snapshot with ${rows.length} rows`
          );
        }
      } catch (error) {
        debug(
          `${collectionId ? `[${collectionId}] ` : ``}Error fetching snapshot: %o`,
          error
        );
        throw error;
      }
    } else if (syncMode === `progressive`) {
      return;
    } else {
      const { cursor, where, orderBy, limit } = opts;
      if (cursor) {
        const promises = [];
        const whereCurrentOpts = {
          where: where ? and(where, cursor.whereCurrent) : cursor.whereCurrent,
          orderBy
          // No limit - get all ties
        };
        const whereCurrentParams = compileSQL(whereCurrentOpts);
        promises.push(stream.requestSnapshot(whereCurrentParams));
        debug(
          `${collectionId ? `[${collectionId}] ` : ``}Requesting cursor.whereCurrent snapshot (all ties)`
        );
        const whereFromOpts = {
          where: where ? and(where, cursor.whereFrom) : cursor.whereFrom,
          orderBy,
          limit
        };
        const whereFromParams = compileSQL(whereFromOpts);
        promises.push(stream.requestSnapshot(whereFromParams));
        debug(
          `${collectionId ? `[${collectionId}] ` : ``}Requesting cursor.whereFrom snapshot (with limit ${limit})`
        );
        await Promise.all(promises);
      } else {
        const snapshotParams = compileSQL(opts);
        await stream.requestSnapshot(snapshotParams);
      }
    }
  };
  return new DeduplicatedLoadSubset({ loadSubset });
}
function electricCollectionOptions(config) {
  const seenTxids = new Store(/* @__PURE__ */ new Set([]));
  const seenSnapshots = new Store([]);
  const internalSyncMode = config.syncMode ?? `eager`;
  const finalSyncMode = internalSyncMode === `progressive` ? `on-demand` : internalSyncMode;
  const pendingMatches = new Store(/* @__PURE__ */ new Map());
  const currentBatchMessages = new Store([]);
  const batchCommitted = new Store(false);
  const removePendingMatches = (matchIds) => {
    if (matchIds.length > 0) {
      pendingMatches.setState((current) => {
        const newMatches = new Map(current);
        matchIds.forEach((id) => newMatches.delete(id));
        return newMatches;
      });
    }
  };
  const resolveMatchedPendingMatches = () => {
    const matchesToResolve = [];
    pendingMatches.state.forEach((match, matchId) => {
      if (match.matched) {
        clearTimeout(match.timeoutId);
        match.resolve(true);
        matchesToResolve.push(matchId);
        debug(
          `${config.id ? `[${config.id}] ` : ``}awaitMatch resolved on up-to-date for match %s`,
          matchId
        );
      }
    });
    removePendingMatches(matchesToResolve);
  };
  const sync = createElectricSync(config.shapeOptions, {
    seenTxids,
    seenSnapshots,
    syncMode: internalSyncMode,
    pendingMatches,
    currentBatchMessages,
    batchCommitted,
    removePendingMatches,
    resolveMatchedPendingMatches,
    collectionId: config.id,
    testHooks: config[ELECTRIC_TEST_HOOKS]
  });
  const awaitTxId = async (txId, timeout = 5e3) => {
    debug(
      `${config.id ? `[${config.id}] ` : ``}awaitTxId called with txid %d`,
      txId
    );
    if (typeof txId !== `number`) {
      throw new ExpectedNumberInAwaitTxIdError(typeof txId, config.id);
    }
    const hasTxid = seenTxids.state.has(txId);
    if (hasTxid) return true;
    const hasSnapshot = seenSnapshots.state.some(
      (snapshot) => isVisibleInSnapshot(txId, snapshot)
    );
    if (hasSnapshot) return true;
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        unsubscribeSeenTxids();
        unsubscribeSeenSnapshots();
        reject(new TimeoutWaitingForTxIdError(txId, config.id));
      }, timeout);
      const unsubscribeSeenTxids = seenTxids.subscribe(() => {
        if (seenTxids.state.has(txId)) {
          debug(
            `${config.id ? `[${config.id}] ` : ``}awaitTxId found match for txid %o`,
            txId
          );
          clearTimeout(timeoutId);
          unsubscribeSeenTxids();
          unsubscribeSeenSnapshots();
          resolve(true);
        }
      });
      const unsubscribeSeenSnapshots = seenSnapshots.subscribe(() => {
        const visibleSnapshot = seenSnapshots.state.find(
          (snapshot) => isVisibleInSnapshot(txId, snapshot)
        );
        if (visibleSnapshot) {
          debug(
            `${config.id ? `[${config.id}] ` : ``}awaitTxId found match for txid %o in snapshot %o`,
            txId,
            visibleSnapshot
          );
          clearTimeout(timeoutId);
          unsubscribeSeenSnapshots();
          unsubscribeSeenTxids();
          resolve(true);
        }
      });
    });
  };
  const awaitMatch = async (matchFn, timeout = 3e3) => {
    debug(
      `${config.id ? `[${config.id}] ` : ``}awaitMatch called with custom function`
    );
    return new Promise((resolve, reject) => {
      const matchId = Math.random().toString(36);
      const cleanupMatch = () => {
        pendingMatches.setState((current) => {
          const newMatches = new Map(current);
          newMatches.delete(matchId);
          return newMatches;
        });
      };
      const onTimeout = () => {
        cleanupMatch();
        reject(new TimeoutWaitingForMatchError(config.id));
      };
      const timeoutId = setTimeout(onTimeout, timeout);
      const checkMatch = (message) => {
        if (matchFn(message)) {
          debug(
            `${config.id ? `[${config.id}] ` : ``}awaitMatch found matching message, waiting for up-to-date`
          );
          pendingMatches.setState((current) => {
            const newMatches = new Map(current);
            const existing = newMatches.get(matchId);
            if (existing) {
              newMatches.set(matchId, { ...existing, matched: true });
            }
            return newMatches;
          });
          return true;
        }
        return false;
      };
      for (const message of currentBatchMessages.state) {
        if (matchFn(message)) {
          if (batchCommitted.state) {
            debug(
              `${config.id ? `[${config.id}] ` : ``}awaitMatch found immediate match in committed batch, resolving immediately`
            );
            clearTimeout(timeoutId);
            resolve(true);
            return;
          }
          debug(
            `${config.id ? `[${config.id}] ` : ``}awaitMatch found immediate match in current batch, waiting for up-to-date`
          );
          pendingMatches.setState((current) => {
            const newMatches = new Map(current);
            newMatches.set(matchId, {
              matchFn: checkMatch,
              resolve,
              reject,
              timeoutId,
              matched: true
              // Already matched, will resolve on up-to-date
            });
            return newMatches;
          });
          return;
        }
      }
      pendingMatches.setState((current) => {
        const newMatches = new Map(current);
        newMatches.set(matchId, {
          matchFn: checkMatch,
          resolve,
          reject,
          timeoutId,
          matched: false
        });
        return newMatches;
      });
    });
  };
  const processMatchingStrategy = async (result) => {
    if (result && `txid` in result) {
      const timeout = result.timeout;
      if (Array.isArray(result.txid)) {
        await Promise.all(result.txid.map((txid) => awaitTxId(txid, timeout)));
      } else {
        await awaitTxId(result.txid, timeout);
      }
    }
  };
  const wrappedOnInsert = config.onInsert ? async (params) => {
    const handlerResult = await config.onInsert(params);
    await processMatchingStrategy(handlerResult);
    return handlerResult;
  } : void 0;
  const wrappedOnUpdate = config.onUpdate ? async (params) => {
    const handlerResult = await config.onUpdate(params);
    await processMatchingStrategy(handlerResult);
    return handlerResult;
  } : void 0;
  const wrappedOnDelete = config.onDelete ? async (params) => {
    const handlerResult = await config.onDelete(params);
    await processMatchingStrategy(handlerResult);
    return handlerResult;
  } : void 0;
  const {
    shapeOptions: _shapeOptions,
    onInsert: _onInsert,
    onUpdate: _onUpdate,
    onDelete: _onDelete,
    ...restConfig
  } = config;
  return {
    ...restConfig,
    syncMode: finalSyncMode,
    sync,
    onInsert: wrappedOnInsert,
    onUpdate: wrappedOnUpdate,
    onDelete: wrappedOnDelete,
    utils: {
      awaitTxId,
      awaitMatch
    }
  };
}
function createElectricSync(shapeOptions, options) {
  const {
    seenTxids,
    seenSnapshots,
    syncMode,
    pendingMatches,
    currentBatchMessages,
    batchCommitted,
    removePendingMatches,
    resolveMatchedPendingMatches,
    collectionId,
    testHooks
  } = options;
  const MAX_BATCH_MESSAGES = 1e3;
  const relationSchema = new Store(void 0);
  const tagCache = /* @__PURE__ */ new Map();
  const parseTag = (tag) => {
    const cachedTag = tagCache.get(tag);
    if (cachedTag) {
      return cachedTag;
    }
    const parsedTag = tag.split(`|`);
    tagCache.set(tag, parsedTag);
    return parsedTag;
  };
  const rowTagSets = /* @__PURE__ */ new Map();
  const tagIndex = [];
  let tagLength = void 0;
  const initializeTagIndex = (length) => {
    if (tagIndex.length < length) {
      for (let i = tagIndex.length; i < length; i++) {
        tagIndex[i] = /* @__PURE__ */ new Map();
      }
    }
  };
  const addTagsToRow = (tags, rowId, rowTagSet) => {
    for (const tag of tags) {
      const parsedTag = parseTag(tag);
      if (tagLength === void 0) {
        tagLength = getTagLength(parsedTag);
        initializeTagIndex(tagLength);
      }
      const currentTagLength = getTagLength(parsedTag);
      if (currentTagLength !== tagLength) {
        debug(
          `${collectionId ? `[${collectionId}] ` : ``}Tag length mismatch: expected ${tagLength}, got ${currentTagLength}`
        );
        continue;
      }
      rowTagSet.add(tag);
      addTagToIndex(parsedTag, rowId, tagIndex, tagLength);
    }
  };
  const removeTagsFromRow = (removedTags, rowId, rowTagSet) => {
    if (tagLength === void 0) {
      return;
    }
    for (const tag of removedTags) {
      const parsedTag = parseTag(tag);
      rowTagSet.delete(tag);
      removeTagFromIndex(parsedTag, rowId, tagIndex, tagLength);
      tagCache.delete(tag);
    }
  };
  const processTagsForChangeMessage = (tags, removedTags, rowId) => {
    if (!rowTagSets.has(rowId)) {
      rowTagSets.set(rowId, /* @__PURE__ */ new Set());
    }
    const rowTagSet = rowTagSets.get(rowId);
    if (tags) {
      addTagsToRow(tags, rowId, rowTagSet);
    }
    if (removedTags) {
      removeTagsFromRow(removedTags, rowId, rowTagSet);
    }
    return rowTagSet;
  };
  const clearTagTrackingState = () => {
    rowTagSets.clear();
    tagIndex.length = 0;
    tagLength = void 0;
  };
  const clearTagsForRow = (rowId) => {
    if (tagLength === void 0) {
      return;
    }
    const rowTagSet = rowTagSets.get(rowId);
    if (!rowTagSet) {
      return;
    }
    for (const tag of rowTagSet) {
      const parsedTag = parseTag(tag);
      const currentTagLength = getTagLength(parsedTag);
      if (currentTagLength === tagLength) {
        removeTagFromIndex(parsedTag, rowId, tagIndex, tagLength);
      }
      tagCache.delete(tag);
    }
    rowTagSets.delete(rowId);
  };
  const removeMatchingTagsFromRow = (rowId, pattern) => {
    const rowTagSet = rowTagSets.get(rowId);
    if (!rowTagSet) {
      return false;
    }
    for (const tag of rowTagSet) {
      const parsedTag = parseTag(tag);
      if (tagMatchesPattern(parsedTag, pattern)) {
        rowTagSet.delete(tag);
        removeTagFromIndex(parsedTag, rowId, tagIndex, tagLength);
      }
    }
    if (rowTagSet.size === 0) {
      rowTagSets.delete(rowId);
      return true;
    }
    return false;
  };
  const processMoveOutEvent = (patterns, begin, write, transactionStarted) => {
    if (tagLength === void 0) {
      debug(
        `${collectionId ? `[${collectionId}] ` : ``}Received move-out message but no tag length set yet, ignoring`
      );
      return transactionStarted;
    }
    let txStarted = transactionStarted;
    for (const pattern of patterns) {
      const affectedRowIds = findRowsMatchingPattern(pattern, tagIndex);
      for (const rowId of affectedRowIds) {
        if (removeMatchingTagsFromRow(rowId, pattern)) {
          if (!txStarted) {
            begin();
            txStarted = true;
          }
          write({
            type: `delete`,
            key: rowId
          });
        }
      }
    }
    return txStarted;
  };
  const getSyncMetadata = () => {
    var _a;
    const schema = relationSchema.state || `public`;
    return {
      relation: ((_a = shapeOptions.params) == null ? void 0 : _a.table) ? [schema, shapeOptions.params.table] : void 0
    };
  };
  let unsubscribeStream;
  return {
    sync: (params) => {
      const { begin, write, commit, markReady, truncate, collection } = params;
      let progressiveReadyGate = null;
      const wrappedMarkReady = (isBuffering) => {
        if (isBuffering && syncMode === `progressive` && (testHooks == null ? void 0 : testHooks.beforeMarkingReady)) {
          progressiveReadyGate = testHooks.beforeMarkingReady();
          progressiveReadyGate.then(() => {
            markReady();
          });
        } else {
          markReady();
        }
      };
      const abortController = new AbortController();
      if (shapeOptions.signal) {
        shapeOptions.signal.addEventListener(
          `abort`,
          () => {
            abortController.abort();
          },
          {
            once: true
          }
        );
        if (shapeOptions.signal.aborted) {
          abortController.abort();
        }
      }
      abortController.signal.addEventListener(`abort`, () => {
        pendingMatches.setState((current) => {
          current.forEach((match) => {
            clearTimeout(match.timeoutId);
            match.reject(new StreamAbortedError());
          });
          return /* @__PURE__ */ new Map();
        });
      });
      const stream = new ShapeStream({
        ...shapeOptions,
        // In on-demand mode, we only want to sync changes, so we set the log to `changes_only`
        log: syncMode === `on-demand` ? `changes_only` : void 0,
        // In on-demand mode, we only need the changes from the point of time the collection was created
        // so we default to `now` when there is no saved offset.
        offset: shapeOptions.offset ?? (syncMode === `on-demand` ? `now` : void 0),
        signal: abortController.signal,
        onError: (errorParams) => {
          markReady();
          if (shapeOptions.onError) {
            return shapeOptions.onError(errorParams);
          } else {
            console.error(
              `An error occurred while syncing collection: ${collection.id}, 
it has been marked as ready to avoid blocking apps waiting for '.preload()' to finish. 
You can provide an 'onError' handler on the shapeOptions to handle this error, and this message will not be logged.`,
              errorParams
            );
          }
          return;
        }
      });
      let transactionStarted = false;
      const newTxids = /* @__PURE__ */ new Set();
      const newSnapshots = [];
      let hasReceivedUpToDate = false;
      const isBufferingInitialSync = () => syncMode === `progressive` && !hasReceivedUpToDate;
      const bufferedMessages = [];
      const processChangeMessage = (changeMessage) => {
        if (!isChangeMessage(changeMessage)) {
          return;
        }
        const tags = changeMessage.headers.tags;
        const removedTags = changeMessage.headers.removed_tags;
        const hasTags = tags || removedTags;
        const rowId = collection.getKeyFromItem(changeMessage.value);
        const operation = changeMessage.headers.operation;
        if (operation === `delete`) {
          clearTagsForRow(rowId);
        } else if (hasTags) {
          processTagsForChangeMessage(tags, removedTags, rowId);
        }
        write({
          type: changeMessage.headers.operation,
          value: changeMessage.value,
          // Include the primary key and relation info in the metadata
          metadata: {
            ...changeMessage.headers
          }
        });
      };
      const loadSubsetDedupe = createLoadSubsetDedupe({
        stream,
        syncMode,
        isBufferingInitialSync,
        begin,
        write,
        commit,
        collectionId
      });
      unsubscribeStream = stream.subscribe((messages) => {
        var _a, _b;
        let commitPoint = null;
        batchCommitted.setState(() => false);
        for (const message of messages) {
          if (isChangeMessage(message) || isMoveOutMessage(message)) {
            currentBatchMessages.setState((currentBuffer) => {
              const newBuffer = [...currentBuffer, message];
              if (newBuffer.length > MAX_BATCH_MESSAGES) {
                newBuffer.splice(0, newBuffer.length - MAX_BATCH_MESSAGES);
              }
              return newBuffer;
            });
          }
          if (hasTxids(message) && !isBufferingInitialSync()) {
            (_a = message.headers.txids) == null ? void 0 : _a.forEach((txid) => newTxids.add(txid));
          }
          const matchesToRemove = [];
          pendingMatches.state.forEach((match, matchId) => {
            if (!match.matched) {
              try {
                match.matchFn(message);
              } catch (err) {
                clearTimeout(match.timeoutId);
                match.reject(
                  err instanceof Error ? err : new Error(String(err))
                );
                matchesToRemove.push(matchId);
                debug(`matchFn error: %o`, err);
              }
            }
          });
          removePendingMatches(matchesToRemove);
          if (isChangeMessage(message)) {
            const schema = message.headers.schema;
            if (schema && typeof schema === `string`) {
              relationSchema.setState(() => schema);
            }
            if (isBufferingInitialSync()) {
              bufferedMessages.push(message);
            } else {
              if (!transactionStarted) {
                begin();
                transactionStarted = true;
              }
              processChangeMessage(message);
            }
          } else if (isSnapshotEndMessage(message)) {
            if (!isBufferingInitialSync()) {
              newSnapshots.push(parseSnapshotMessage(message));
            }
          } else if (isUpToDateMessage2(message)) {
            commitPoint = `up-to-date`;
          } else if (isSubsetEndMessage(message)) {
            if (commitPoint !== `up-to-date`) {
              commitPoint = `subset-end`;
            }
          } else if (isMoveOutMessage(message)) {
            if (isBufferingInitialSync()) {
              bufferedMessages.push(message);
            } else {
              transactionStarted = processMoveOutEvent(
                message.headers.patterns,
                begin,
                write,
                transactionStarted
              );
            }
          } else if (isMustRefetchMessage(message)) {
            debug(
              `${collectionId ? `[${collectionId}] ` : ``}Received must-refetch message, starting transaction with truncate`
            );
            if (!transactionStarted) {
              begin();
              transactionStarted = true;
            }
            truncate();
            clearTagTrackingState();
            loadSubsetDedupe == null ? void 0 : loadSubsetDedupe.reset();
            commitPoint = null;
            hasReceivedUpToDate = false;
            bufferedMessages.length = 0;
          }
        }
        if (commitPoint !== null) {
          if (isBufferingInitialSync() && commitPoint === `up-to-date`) {
            debug(
              `${collectionId ? `[${collectionId}] ` : ``}Progressive mode: Performing atomic swap with ${bufferedMessages.length} buffered messages`
            );
            begin();
            truncate();
            clearTagTrackingState();
            for (const bufferedMsg of bufferedMessages) {
              if (isChangeMessage(bufferedMsg)) {
                processChangeMessage(bufferedMsg);
                if (hasTxids(bufferedMsg)) {
                  (_b = bufferedMsg.headers.txids) == null ? void 0 : _b.forEach(
                    (txid) => newTxids.add(txid)
                  );
                }
              } else if (isSnapshotEndMessage(bufferedMsg)) {
                newSnapshots.push(parseSnapshotMessage(bufferedMsg));
              } else if (isMoveOutMessage(bufferedMsg)) {
                processMoveOutEvent(
                  bufferedMsg.headers.patterns,
                  begin,
                  write,
                  transactionStarted
                );
              }
            }
            commit();
            bufferedMessages.length = 0;
            debug(
              `${collectionId ? `[${collectionId}] ` : ``}Progressive mode: Atomic swap complete, now in normal sync mode`
            );
          } else {
            if (transactionStarted) {
              commit();
              transactionStarted = false;
            }
          }
          wrappedMarkReady(isBufferingInitialSync());
          if (commitPoint === `up-to-date`) {
            hasReceivedUpToDate = true;
          }
          seenTxids.setState((currentTxids) => {
            const clonedSeen = new Set(currentTxids);
            if (newTxids.size > 0) {
              debug(
                `${collectionId ? `[${collectionId}] ` : ``}new txids synced from pg %O`,
                Array.from(newTxids)
              );
            }
            newTxids.forEach((txid) => clonedSeen.add(txid));
            newTxids.clear();
            return clonedSeen;
          });
          seenSnapshots.setState((currentSnapshots) => {
            const seen = [...currentSnapshots, ...newSnapshots];
            newSnapshots.forEach(
              (snapshot) => debug(
                `${collectionId ? `[${collectionId}] ` : ``}new snapshot synced from pg %o`,
                snapshot
              )
            );
            newSnapshots.length = 0;
            return seen;
          });
          batchCommitted.setState(() => true);
          resolveMatchedPendingMatches();
        }
      });
      return {
        loadSubset: loadSubsetDedupe == null ? void 0 : loadSubsetDedupe.loadSubset,
        cleanup: () => {
          unsubscribeStream();
          abortController.abort();
          loadSubsetDedupe == null ? void 0 : loadSubsetDedupe.reset();
        }
      };
    },
    // Expose the getSyncMetadata function
    getSyncMetadata
  };
}
export {
  ElectricDBCollectionError,
  ExpectedNumberInAwaitTxIdError,
  StreamAbortedError,
  TimeoutWaitingForMatchError,
  TimeoutWaitingForTxIdError,
  electricCollectionOptions,
  isChangeMessage,
  isControlMessage
};
//# sourceMappingURL=@tanstack_electric-db-collection.js.map
