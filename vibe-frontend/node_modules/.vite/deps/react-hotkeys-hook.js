import {
  require_jsx_runtime
} from "./chunk-7BUGFXDR.js";
import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/react-hotkeys-hook/packages/react-hotkeys-hook/dist/index.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var j = ["shift", "alt", "meta", "mod", "ctrl", "control"];
var Q = {
  esc: "escape",
  return: "enter",
  left: "arrowleft",
  right: "arrowright",
  up: "arrowup",
  down: "arrowdown",
  ShiftLeft: "shift",
  ShiftRight: "shift",
  AltLeft: "alt",
  AltRight: "alt",
  MetaLeft: "meta",
  MetaRight: "meta",
  OSLeft: "meta",
  OSRight: "meta",
  ControlLeft: "ctrl",
  ControlRight: "ctrl"
};
function K(e) {
  return (Q[e.trim()] || e.trim()).toLowerCase().replace(/key|digit|numpad/, "");
}
function D(e) {
  return j.includes(e);
}
function H(e, r = ",") {
  return e.toLowerCase().split(r);
}
function P(e, r = "+", o = ">", i = false, u) {
  let n = [], c = false;
  e = e.trim(), e.includes(o) ? (c = true, n = e.toLocaleLowerCase().split(o).map((f) => K(f))) : n = e.toLocaleLowerCase().split(r).map((f) => K(f));
  const y = {
    alt: n.includes("alt"),
    ctrl: n.includes("ctrl") || n.includes("control"),
    shift: n.includes("shift"),
    meta: n.includes("meta"),
    mod: n.includes("mod"),
    useKey: i
  }, d = n.filter((f) => !j.includes(f));
  return {
    ...y,
    keys: d,
    description: u,
    isSequence: c,
    hotkey: e
  };
}
typeof document < "u" && (document.addEventListener("keydown", (e) => {
  e.code !== void 0 && I([K(e.code)]);
}), document.addEventListener("keyup", (e) => {
  e.code !== void 0 && _([K(e.code)]);
})), typeof window < "u" && (window.addEventListener("blur", () => {
  L.clear();
}), window.addEventListener("contextmenu", () => {
  setTimeout(() => {
    L.clear();
  }, 0);
}));
var L = /* @__PURE__ */ new Set();
function R(e) {
  return Array.isArray(e);
}
function U(e, r = ",") {
  return (R(e) ? e : e.split(r)).every((i) => L.has(i.trim().toLowerCase()));
}
function I(e) {
  const r = Array.isArray(e) ? e : [e];
  L.has("meta") && L.forEach((o) => !D(o) && L.delete(o.toLowerCase())), r.forEach((o) => L.add(o.toLowerCase()));
}
function _(e) {
  const r = Array.isArray(e) ? e : [e];
  e === "meta" ? L.clear() : r.forEach((o) => L.delete(o.toLowerCase()));
}
function V(e, r, o) {
  (typeof o == "function" && o(e, r) || o === true) && e.preventDefault();
}
function X(e, r, o) {
  return typeof o == "function" ? o(e, r) : o === true || o === void 0;
}
var Y = [
  "input",
  "textarea",
  "select",
  "searchbox",
  "slider",
  "spinbutton",
  "menuitem",
  "menuitemcheckbox",
  "menuitemradio",
  "option",
  "radio",
  "textbox"
];
function Z(e) {
  return F(e, Y);
}
function F(e, r = false) {
  const { target: o, composed: i } = e;
  let u, n;
  return ee(o) && i ? (u = e.composedPath()[0] && e.composedPath()[0].tagName, n = e.composedPath()[0] && e.composedPath()[0].role) : (u = o && o.tagName, n = o && o.role), R(r) ? !!(u && r && r.some((c) => c.toLowerCase() === u.toLowerCase() || c === n)) : !!(u && r && r);
}
function ee(e) {
  return !!e.tagName && !e.tagName.startsWith("-") && e.tagName.includes("-");
}
function te(e, r) {
  return e.length === 0 && r ? (console.warn(
    'A hotkey has the "scopes" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>'
  ), true) : r ? e.some((o) => r.includes(o)) || e.includes("*") : true;
}
var re = (e, r, o = false) => {
  const { alt: i, meta: u, mod: n, shift: c, ctrl: y, keys: d, useKey: f } = r, { code: p, key: t, ctrlKey: a, metaKey: l, shiftKey: g, altKey: k } = e, m = K(p);
  if (f && (d == null ? void 0 : d.length) === 1 && d.includes(t))
    return true;
  if (!(d == null ? void 0 : d.includes(m)) && !["ctrl", "control", "unknown", "meta", "alt", "shift", "os"].includes(m))
    return false;
  if (!o) {
    if (i !== k && m !== "alt" || c !== g && m !== "shift")
      return false;
    if (n) {
      if (!l && !a)
        return false;
    } else if (u !== l && m !== "meta" && m !== "os" || y !== a && m !== "ctrl" && m !== "control")
      return false;
  }
  return d && d.length === 1 && d.includes(m) ? true : d ? U(d) : !d;
};
var $ = (0, import_react.createContext)(void 0);
var oe = () => (0, import_react.useContext)($);
function ne({ addHotkey: e, removeHotkey: r, children: o }) {
  return (0, import_jsx_runtime.jsx)($.Provider, { value: { addHotkey: e, removeHotkey: r }, children: o });
}
function x(e, r) {
  return e && r && typeof e == "object" && typeof r == "object" ? Object.keys(e).length === Object.keys(r).length && // @ts-expect-error TS7053
  Object.keys(e).reduce((o, i) => o && x(e[i], r[i]), true) : e === r;
}
var W = (0, import_react.createContext)({
  hotkeys: [],
  activeScopes: [],
  // This array has to be empty instead of containing '*' as default, to check if the provider is set or not
  toggleScope: () => {
  },
  enableScope: () => {
  },
  disableScope: () => {
  }
});
var se = () => (0, import_react.useContext)(W);
var de = ({ initiallyActiveScopes: e = ["*"], children: r }) => {
  const [o, i] = (0, import_react.useState)(e), [u, n] = (0, import_react.useState)([]), c = (0, import_react.useCallback)((t) => {
    i((a) => a.includes("*") ? [t] : Array.from(/* @__PURE__ */ new Set([...a, t])));
  }, []), y = (0, import_react.useCallback)((t) => {
    i((a) => a.filter((l) => l !== t));
  }, []), d = (0, import_react.useCallback)((t) => {
    i((a) => a.includes(t) ? a.filter((l) => l !== t) : a.includes("*") ? [t] : Array.from(/* @__PURE__ */ new Set([...a, t])));
  }, []), f = (0, import_react.useCallback)((t) => {
    n((a) => [...a, t]);
  }, []), p = (0, import_react.useCallback)((t) => {
    n((a) => a.filter((l) => !x(l, t)));
  }, []);
  return (0, import_jsx_runtime.jsx)(
    W.Provider,
    {
      value: { activeScopes: o, hotkeys: u, enableScope: c, disableScope: y, toggleScope: d },
      children: (0, import_jsx_runtime.jsx)(ne, { addHotkey: f, removeHotkey: p, children: r })
    }
  );
};
function ie(e) {
  const r = (0, import_react.useRef)(void 0);
  return x(r.current, e) || (r.current = e), r.current;
}
var N = (e) => {
  e.stopPropagation(), e.preventDefault(), e.stopImmediatePropagation();
};
var ue = typeof window < "u" ? import_react.useLayoutEffect : import_react.useEffect;
function fe(e, r, o, i) {
  const u = (0, import_react.useRef)(null), n = (0, import_react.useRef)(false), c = Array.isArray(o) ? Array.isArray(i) ? void 0 : i : o, y = R(e) ? e.join(c == null ? void 0 : c.delimiter) : e, d = Array.isArray(o) ? o : Array.isArray(i) ? i : void 0, f = (0, import_react.useCallback)(r, d ?? []), p = (0, import_react.useRef)(f);
  d ? p.current = f : p.current = r;
  const t = ie(c), { activeScopes: a } = se(), l = oe();
  return ue(() => {
    if ((t == null ? void 0 : t.enabled) === false || !te(a, t == null ? void 0 : t.scopes))
      return;
    let g = [], k;
    const m = (s, B = false) => {
      var _a;
      if (!(Z(s) && !F(s, t == null ? void 0 : t.enableOnFormTags))) {
        if (u.current !== null) {
          const v = u.current.getRootNode();
          if ((v instanceof Document || v instanceof ShadowRoot) && v.activeElement !== u.current && !u.current.contains(v.activeElement)) {
            N(s);
            return;
          }
        }
        ((_a = s.target) == null ? void 0 : _a.isContentEditable) && !(t == null ? void 0 : t.enableOnContentEditable) || H(y, t == null ? void 0 : t.delimiter).forEach((v) => {
          var _a2, _b, _c, _d;
          if (v.includes((t == null ? void 0 : t.splitKey) ?? "+") && v.includes((t == null ? void 0 : t.sequenceSplitKey) ?? ">")) {
            console.warn(
              `Hotkey ${v} contains both ${(t == null ? void 0 : t.splitKey) ?? "+"} and ${(t == null ? void 0 : t.sequenceSplitKey) ?? ">"} which is not supported.`
            );
            return;
          }
          const h = P(
            v,
            t == null ? void 0 : t.splitKey,
            t == null ? void 0 : t.sequenceSplitKey,
            t == null ? void 0 : t.useKey,
            t == null ? void 0 : t.description
          );
          if (h.isSequence) {
            k = setTimeout(() => {
              g = [];
            }, (t == null ? void 0 : t.sequenceTimeoutMs) ?? 1e3);
            const C = h.useKey ? s.key : K(s.code);
            if (D(C.toLowerCase()))
              return;
            g.push(C);
            const G = (_a2 = h.keys) == null ? void 0 : _a2[g.length - 1];
            if (C !== G) {
              g = [], k && clearTimeout(k);
              return;
            }
            g.length === ((_b = h.keys) == null ? void 0 : _b.length) && (p.current(s, h), k && clearTimeout(k), g = []);
          } else if (re(s, h, t == null ? void 0 : t.ignoreModifiers) || ((_c = h.keys) == null ? void 0 : _c.includes("*"))) {
            if (((_d = t == null ? void 0 : t.ignoreEventWhen) == null ? void 0 : _d.call(t, s)) || B && n.current)
              return;
            if (V(s, h, t == null ? void 0 : t.preventDefault), !X(s, h, t == null ? void 0 : t.enabled)) {
              N(s);
              return;
            }
            p.current(s, h), B || (n.current = true);
          }
        });
      }
    }, O = (s) => {
      s.code !== void 0 && (I(K(s.code)), ((t == null ? void 0 : t.keydown) === void 0 && (t == null ? void 0 : t.keyup) !== true || (t == null ? void 0 : t.keydown)) && m(s));
    }, q = (s) => {
      s.code !== void 0 && (_(K(s.code)), n.current = false, (t == null ? void 0 : t.keyup) && m(s, true));
    }, E = u.current || (c == null ? void 0 : c.document) || document;
    return E.addEventListener("keyup", q, c == null ? void 0 : c.eventListenerOptions), E.addEventListener("keydown", O, c == null ? void 0 : c.eventListenerOptions), l && H(y, t == null ? void 0 : t.delimiter).forEach(
      (s) => l.addHotkey(
        P(
          s,
          t == null ? void 0 : t.splitKey,
          t == null ? void 0 : t.sequenceSplitKey,
          t == null ? void 0 : t.useKey,
          t == null ? void 0 : t.description
        )
      )
    ), () => {
      E.removeEventListener("keyup", q, c == null ? void 0 : c.eventListenerOptions), E.removeEventListener("keydown", O, c == null ? void 0 : c.eventListenerOptions), l && H(y, t == null ? void 0 : t.delimiter).forEach(
        (s) => l.removeHotkey(
          P(
            s,
            t == null ? void 0 : t.splitKey,
            t == null ? void 0 : t.sequenceSplitKey,
            t == null ? void 0 : t.useKey,
            t == null ? void 0 : t.description
          )
        )
      ), g = [], k && clearTimeout(k);
    };
  }, [y, t, a]), u;
}
function le(e = false) {
  const [r, o] = (0, import_react.useState)(/* @__PURE__ */ new Set()), [i, u] = (0, import_react.useState)(false), n = (0, import_react.useCallback)(
    (f) => {
      f.code !== void 0 && (f.preventDefault(), f.stopPropagation(), o((p) => {
        const t = new Set(p);
        return t.add(K(e ? f.key : f.code)), t;
      }));
    },
    [e]
  ), c = (0, import_react.useCallback)(() => {
    typeof document < "u" && (document.removeEventListener("keydown", n), u(false));
  }, [n]), y = (0, import_react.useCallback)(() => {
    o(/* @__PURE__ */ new Set()), typeof document < "u" && (c(), document.addEventListener("keydown", n), u(true));
  }, [n, c]), d = (0, import_react.useCallback)(() => {
    o(/* @__PURE__ */ new Set());
  }, []);
  return [r, { start: y, stop: c, resetKeys: d, isRecording: i }];
}
export {
  de as HotkeysProvider,
  U as isHotkeyPressed,
  fe as useHotkeys,
  se as useHotkeysContext,
  le as useRecordHotkeys
};
//# sourceMappingURL=react-hotkeys-hook.js.map
