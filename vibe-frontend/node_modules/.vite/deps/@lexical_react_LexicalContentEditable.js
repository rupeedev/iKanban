import {
  $canShowPlaceholderCurry
} from "./chunk-FROWL7C5.js";
import {
  useLexicalComposerContext
} from "./chunk-3KRADT7E.js";
import {
  mergeRegister
} from "./chunk-RBMJ4EHG.js";
import "./chunk-GDWONKOB.js";
import {
  require_jsx_runtime
} from "./chunk-7BUGFXDR.js";
import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@lexical/react/LexicalContentEditable.dev.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl = CAN_USE_DOM ? import_react.useLayoutEffect : import_react.useEffect;
function mergeRefs(...refs) {
  return (value) => {
    for (const ref of refs) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    }
  };
}
function ContentEditableElementImpl({
  editor,
  ariaActiveDescendant,
  ariaAutoComplete,
  ariaControls,
  ariaDescribedBy,
  ariaErrorMessage,
  ariaExpanded,
  ariaInvalid,
  ariaLabel,
  ariaLabelledBy,
  ariaMultiline,
  ariaOwns,
  ariaRequired,
  autoCapitalize,
  className,
  id,
  role = "textbox",
  spellCheck = true,
  style,
  tabIndex,
  "data-testid": testid,
  ...rest
}, ref) {
  const [isEditable, setEditable] = (0, import_react.useState)(editor.isEditable());
  const handleRef = (0, import_react.useCallback)((rootElement) => {
    if (rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView) {
      editor.setRootElement(rootElement);
    } else {
      editor.setRootElement(null);
    }
  }, [editor]);
  const mergedRefs = (0, import_react.useMemo)(() => mergeRefs(ref, handleRef), [handleRef, ref]);
  useLayoutEffectImpl(() => {
    setEditable(editor.isEditable());
    return editor.registerEditableListener((currentIsEditable) => {
      setEditable(currentIsEditable);
    });
  }, [editor]);
  return (0, import_jsx_runtime.jsx)("div", {
    "aria-activedescendant": isEditable ? ariaActiveDescendant : void 0,
    "aria-autocomplete": isEditable ? ariaAutoComplete : "none",
    "aria-controls": isEditable ? ariaControls : void 0,
    "aria-describedby": ariaDescribedBy,
    ...ariaErrorMessage != null ? {
      "aria-errormessage": ariaErrorMessage
    } : {},
    "aria-expanded": isEditable && role === "combobox" ? !!ariaExpanded : void 0,
    ...ariaInvalid != null ? {
      "aria-invalid": ariaInvalid
    } : {},
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-multiline": ariaMultiline,
    "aria-owns": isEditable ? ariaOwns : void 0,
    "aria-readonly": isEditable ? void 0 : true,
    "aria-required": ariaRequired,
    autoCapitalize,
    className,
    contentEditable: isEditable,
    "data-testid": testid,
    id,
    ref: mergedRefs,
    role,
    spellCheck,
    style,
    tabIndex,
    ...rest
  });
}
var ContentEditableElement = (0, import_react.forwardRef)(ContentEditableElementImpl);
function canShowPlaceholderFromCurrentEditorState(editor) {
  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));
  return currentCanShowPlaceholder;
}
function useCanShowPlaceholder(editor) {
  const [canShowPlaceholder, setCanShowPlaceholder] = (0, import_react.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));
  useLayoutEffectImpl(() => {
    function resetCanShowPlaceholder() {
      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);
      setCanShowPlaceholder(currentCanShowPlaceholder);
    }
    resetCanShowPlaceholder();
    return mergeRegister(editor.registerUpdateListener(() => {
      resetCanShowPlaceholder();
    }), editor.registerEditableListener(() => {
      resetCanShowPlaceholder();
    }));
  }, [editor]);
  return canShowPlaceholder;
}
var ContentEditable = (0, import_react.forwardRef)(ContentEditableImpl);
function ContentEditableImpl(props, ref) {
  const {
    placeholder,
    ...rest
  } = props;
  const [editor] = useLexicalComposerContext();
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [(0, import_jsx_runtime.jsx)(ContentEditableElement, {
      editor,
      ...rest,
      ref
    }), placeholder != null && (0, import_jsx_runtime.jsx)(Placeholder, {
      editor,
      content: placeholder
    })]
  });
}
function Placeholder({
  content,
  editor
}) {
  const showPlaceholder = useCanShowPlaceholder(editor);
  const [isEditable, setEditable] = (0, import_react.useState)(editor.isEditable());
  (0, import_react.useLayoutEffect)(() => {
    setEditable(editor.isEditable());
    return editor.registerEditableListener((currentIsEditable) => {
      setEditable(currentIsEditable);
    });
  }, [editor]);
  if (!showPlaceholder) {
    return null;
  }
  let placeholder = null;
  if (typeof content === "function") {
    placeholder = content(isEditable);
  } else if (content !== null) {
    placeholder = content;
  }
  if (placeholder === null) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("div", {
    "aria-hidden": true,
    children: placeholder
  });
}
export {
  ContentEditable,
  ContentEditableElement
};
//# sourceMappingURL=@lexical_react_LexicalContentEditable.js.map
