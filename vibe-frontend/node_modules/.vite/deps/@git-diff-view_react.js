"use client";
import {
  DefaultDiffExpansionStep,
  DiffFile,
  DiffFileLineType,
  DiffHunk,
  DiffHunkExpansionType,
  DiffHunkHeader,
  DiffLine,
  DiffLineType,
  DiffParser,
  File,
  HiddenBidiCharsRegex,
  SplitSide,
  _cacheMap,
  _getAST,
  assertNever,
  changeDefaultComposeLength,
  checkCurrentLineIsHidden,
  checkDiffLineIncludeChange,
  composeLen,
  diffChanges,
  disableCache,
  escapeHtml,
  getCurrentComposeLength,
  getDiffRange,
  getFile,
  getHunkHeaderExpansionType,
  getLang,
  getLargestLineNumber,
  getPlainDiffTemplate,
  getPlainLineTemplate,
  getSplitContentLines,
  getSplitLines,
  getSyntaxDiffTemplate,
  getSyntaxLineTemplate,
  getUnifiedContentLine,
  getUnifiedLines,
  highlighter,
  isTransformEnabled,
  numIterator,
  parseInstance,
  processAST,
  processTransformForFile,
  processTransformTemplateContent,
  relativeChanges,
  resetDefaultComposeLength,
  resetTransform,
  setTransformForFile,
  setTransformForTemplateContent,
  versions
} from "./chunk-RLOSB6UA.js";
import "./chunk-CPGV4UXP.js";
import "./chunk-GHEXYBN7.js";
import {
  require_shim
} from "./chunk-WRDHQGWG.js";
import "./chunk-HTVXVXIR.js";
import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@git-diff-view/react/dist/esm/index.mjs
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_shim2 = __toESM(require_shim(), 1);

// node_modules/@vue/shared/dist/shared.esm-bundler.js
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
var EMPTY_OBJ = true ? Object.freeze({}) : {};
var EMPTY_ARR = true ? Object.freeze([]) : [];
var extend = Object.assign;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isSet = (val) => toTypeString(val) === "[object Set]";
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isPlainObject = (val) => toTypeString(val) === "[object Object]";
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var isReservedProp = makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
var isBuiltInDirective = makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var camelizeRE = /-\w/g;
var camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());
  }
);
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
var capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
var GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
var isGloballyAllowed = makeMap(GLOBALS_ALLOWED);
var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
var isHTMLTag = makeMap(HTML_TAGS);
var isSVGTag = makeMap(SVG_TAGS);
var isMathMLTag = makeMap(MATH_TAGS);
var isVoidTag = makeMap(VOID_TAGS);
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
var isBooleanAttr = makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
var isKnownHtmlAttr = makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
var isKnownSvgAttr = makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
var isKnownMathMLAttr = makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);

// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
var activeEffectScope;
var EffectScope = class {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this._on = 0;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (true) {
      warn(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
};
function effectScope(detached) {
  return new EffectScope(detached);
}
var activeSub;
var pausedQueueEffects = /* @__PURE__ */ new WeakSet();
var ReactiveEffect = class {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      if (activeSub !== this) {
        warn(
          "Active effect was not restored correctly - this is likely a Vue internal bug."
        );
      }
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
};
var batchDepth = 0;
var batchedSub;
var batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed) {
  if (computed.flags & 4 && !(computed.flags & 16)) {
    return;
  }
  computed.flags &= -17;
  if (computed.globalVersion === globalVersion) {
    return;
  }
  computed.globalVersion = globalVersion;
  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {
    return;
  }
  computed.flags |= 2;
  const dep = computed.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed;
  shouldTrack = true;
  try {
    prepareDeps(computed);
    const value = computed.fn(computed._value);
    if (dep.version === 0 || hasChanged(value, computed._value)) {
      computed.flags |= 128;
      computed._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed);
    computed.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subsHead === link) {
    dep.subsHead = nextSub;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
var globalVersion = 0;
var Link = class {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
};
var Dep = class {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
    if (true) {
      this.subsHead = void 0;
    }
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    if (activeSub.onTrack) {
      activeSub.onTrack(
        extend(
          {
            effect: activeSub
          },
          debugInfo
        )
      );
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (true) {
        for (let head = this.subsHead; head; head = head.nextSub) {
          if (head.sub.onTrigger && !(head.sub.flags & 8)) {
            head.sub.onTrigger(
              extend(
                {
                  effect: head.sub
                },
                debugInfo
              )
            );
          }
        }
      }
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
};
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l = computed.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    if (link.dep.subsHead === void 0) {
      link.dep.subsHead = link;
    }
    link.dep.subs = link;
  }
}
var targetMap = /* @__PURE__ */ new WeakMap();
var ITERATE_KEY = Symbol(
  true ? "Object iterate" : ""
);
var MAP_KEY_ITERATE_KEY = Symbol(
  true ? "Map keys iterate" : ""
);
var ARRAY_ITERATE_KEY = Symbol(
  true ? "Array iterate" : ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    if (true) {
      dep.track({
        target,
        type,
        key
      });
    } else {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      if (true) {
        dep.trigger({
          target,
          type,
          key,
          newValue,
          oldValue,
          oldTarget
        });
      } else {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
function toWrapped(target, item) {
  if (isReadonly(target)) {
    return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);
  }
  return toReactive(item);
}
var arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, (item) => toWrapped(this, item));
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toWrapped(this, value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(
      this,
      "filter",
      fn,
      thisArg,
      (v) => v.map((item) => toWrapped(this, item)),
      arguments
    );
  },
  find(fn, thisArg) {
    return apply(
      this,
      "find",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(
      this,
      "findLast",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", (item) => toWrapped(this, item));
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (!result.done) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
var arrayProto = Array.prototype;
function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toWrapped(self2, item), index, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toWrapped(self2, item), index, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
var isNonTrackableKeys = makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(
  Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty2(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
var BaseReactiveHandler = class {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty2;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      const value = targetIsArray && isIntegerKey(key) ? res : res.value;
      return isReadonly2 && isObject(value) ? readonly(value) : value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
};
var MutableReactiveHandler = class extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    const isArrayWithIntegerKey = isArray(target) && isIntegerKey(key);
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          if (true) {
            warn(
              `Set operation on key "${String(key)}" failed: target is readonly.`,
              target[key]
            );
          }
          return true;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
};
var ReadonlyReactiveHandler = class extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (true) {
      warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    if (true) {
      warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
};
var mutableHandlers = new MutableReactiveHandler();
var readonlyHandlers = new ReadonlyReactiveHandler();
var shallowReactiveHandlers = new MutableReactiveHandler(true);
var shallowReadonlyHandlers = new ReadonlyReactiveHandler(true);
var toShallow = (value) => value;
var getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn(
        `${capitalize(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return target.size;
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0,
            oldTarget
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
var mutableCollectionHandlers = {
  get: createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, false)
};
var shallowReadonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has.call(target, rawKey)) {
    const type = toRawType(target);
    warn(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (true) {
      warn(
        `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
          target
        )}`
      );
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
var toReactive = (value) => isObject(value) ? reactive(value) : value;
var toReadonly = (value) => isObject(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
var RefImpl = class {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    if (true) {
      this.dep.track({
        target: this,
        type: "get",
        key: "value"
      });
    } else {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      if (true) {
        this.dep.trigger({
          target: this,
          type: "set",
          key: "value",
          newValue,
          oldValue
        });
      } else {
        this.dep.trigger();
      }
    }
  }
};
var ReactiveFlags = {
  "SKIP": "__v_skip",
  "IS_REACTIVE": "__v_isReactive",
  "IS_READONLY": "__v_isReadonly",
  "IS_SHALLOW": "__v_isShallow",
  "RAW": "__v_raw",
  "IS_REF": "__v_isRef"
};

// node_modules/reactivity-store/dist/esm/index.mjs
var import_react = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
var isServer = typeof window === "undefined";
var InternalNameSpace;
(function(InternalNameSpace2) {
  InternalNameSpace2["$$__ignore__$$"] = "$$__ignore__$$";
  InternalNameSpace2["$$__persist__$$"] = "$$__persist__$$";
  InternalNameSpace2["$$__subscribe__$$"] = "$$__subscribe__$$";
  InternalNameSpace2["$$__redux_dev_tool__$$"] = "$$__redux_dev_tool__$$";
})(InternalNameSpace || (InternalNameSpace = {}));
var jobs = /* @__PURE__ */ new Set();
var MAX_UPDATE = 20;
var process$1 = false;
var updateCount = 0;
var flushQueue = () => {
  const all = [...jobs.values()].slice(0);
  jobs.clear();
  for (const job of all) {
    job.notify();
  }
  process$1 = false;
  if (jobs.size) {
    updateCount++;
    if (updateCount > MAX_UPDATE) {
      throw new Error(`[reactivity-store] have a infinity update for current store, pendingJobs: ${new Set(jobs)}`);
    }
    flushQueue();
  }
};
var queueJob = (job) => {
  jobs.add(job);
  if (process$1)
    return;
  process$1 = true;
  updateCount = 0;
  Promise.resolve().then(flushQueue);
};
var currentController = null;
function getCurrentController() {
  return currentController;
}
var ControllerEffect = class extends ReactiveEffect {
  get _isControllerEffect() {
    return true;
  }
  constructor(getter) {
    super(getter);
    if (true) {
      this._devVersion = "3.5.22";
    }
  }
};
var catchError = (cb, instance2) => {
  return () => {
    if (!instance2._isActive)
      return;
    if (true) {
      instance2._devRunCount = instance2._devRunCount || 0;
      instance2._devRunCount++;
    }
    try {
      const res = cb();
      if (isPromise(res)) {
        throw new Error(`[reactivity-store] selector should be a pure function, but current is a async function`);
      }
      return res;
    } catch (e) {
      if (true) {
        console.error(`[reactivity-store] have an error for current selector, ${e === null || e === void 0 ? void 0 : e.message}, maybe you use the middleware with wrong usage, %o`, instance2);
      }
      return null;
    }
  };
};
var Controller = class {
  constructor(_getState, _compare, _lifeCycle, _namespace, _onUpdate) {
    this._getState = _getState;
    this._compare = _compare;
    this._lifeCycle = _lifeCycle;
    this._namespace = _namespace;
    this._onUpdate = _onUpdate;
    this._listeners = /* @__PURE__ */ new Set();
    this._updateCount = 0;
    this._isActive = true;
    this.notify = () => {
      var _a;
      if (!this._isActive)
        return;
      if (isServer) {
        console.error(`[reactivity-store] unexpected update for reactivity-store, should not update a state on the server`);
      }
      this._updateCount++;
      try {
        (_a = this._onUpdate) === null || _a === void 0 ? void 0 : _a.call(this);
      } catch (e) {
        if (true) {
          console.error(`[reactivity-store] have an error for current updater, ${e === null || e === void 0 ? void 0 : e.message}, please check your subscribe, %o`, this);
        }
        this._lifeCycle.canUpdateComponent = false;
      }
      this._listeners.forEach((f) => f());
    };
    this._scheduler = () => {
      const p = getCurrentController();
      currentController = this;
      const newState = this._effect.run();
      currentController = p;
      if (!this._isActive)
        return;
      const isSame = this._compare(this._state, newState);
      this._state = newState;
      if (!isSame) {
        if (this._lifeCycle.canUpdateComponent) {
          if (this._lifeCycle.syncUpdateComponent) {
            this.notify();
          } else {
            queueJob(this);
          }
        }
      }
    };
    this.subscribe = (listener) => {
      this._listeners.add(listener);
      return () => this._listeners.delete(listener);
    };
    this.getState = () => {
      return this._updateCount;
    };
    this.getEffect = () => {
      return this._effect;
    };
    this.getSelectorState = () => {
      return this._getStateSafe();
    };
    this.getLifeCycle = () => {
      return this._lifeCycle;
    };
    this._getStateSafe = catchError(_getState, this);
    this._effect = new ControllerEffect(this._getStateSafe);
    this._effect.scheduler = this._scheduler;
    if (true) {
      this._devVersion = "0.3.12";
    }
  }
  // TODO move into constructor function?
  run() {
    const p = getCurrentController();
    currentController = this;
    this._state = this._effect.run();
    currentController = p;
  }
  stop() {
    this._effect.stop();
    this._listeners.clear();
    this._isActive = false;
    this._state = null;
  }
  setActive(d) {
    this._isActive = d;
  }
};
var createLifeCycle = () => ({
  onBeforeMount: [],
  onBeforeUpdate: [],
  onBeforeUnmount: [],
  onMounted: [],
  onUpdated: [],
  onUnmounted: [],
  hasHookInstall: false,
  canUpdateComponent: true,
  syncUpdateComponent: false
});
function _traverse(value, seen) {
  if (!isObject(value) || value[ReactiveFlags.SKIP] || (0, import_react.isValidElement)(value)) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function traverseShallow(value) {
  if (!isObject(value) || value[ReactiveFlags.SKIP] || (0, import_react.isValidElement)(value)) {
    return value;
  }
  if (isRef(value)) {
    value.value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      value[i];
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      value[key];
    }
  }
  return value;
}
function traverse(value, seen) {
  if (true) {
    const start = Date.now();
    const re = _traverse(value, seen);
    const end = Date.now();
    if (end - start > 5) {
      console.warn(`[reactivity-store] 'traverse' current data: %o take a lot of time`, re);
    }
    return re;
  } else {
    return _traverse(value, seen);
  }
}
function checkHasReactive(value) {
  let hasReactive = false;
  function traverse2(value2, seen) {
    if (!isObject(value2))
      return;
    if (hasReactive)
      return;
    if (isReactive(value2) || isRef(value2) || isProxy(value2)) {
      hasReactive = true;
      return;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value2)) {
      return;
    }
    seen.add(value2);
    if (isArray(value2)) {
      for (let i = 0; i < value2.length; i++) {
        traverse2(value2[i], seen);
      }
    } else if (isSet(value2) || isMap(value2)) {
      value2.forEach((v) => {
        traverse2(v, seen);
      });
    } else if (isPlainObject(value2)) {
      for (const key in value2) {
        traverse2(value2[key], seen);
      }
    }
    return;
  }
  traverse2(value);
  return hasReactive;
}
function checkHasMiddleware(value) {
  if (value && (value === null || value === void 0 ? void 0 : value["$$__state__$$"]) && (value === null || value === void 0 ? void 0 : value["$$__middleware__$$"])) {
    return true;
  }
}
var namespaceMap = /* @__PURE__ */ Object.create(null);
var setNamespaceMap = (key, value) => {
  namespaceMap[key] = value;
};
var delNamespace = (key) => {
  delete namespaceMap[key];
};
var useCallbackRef = (callback) => {
  const callbackRef = (0, import_react.useRef)(callback);
  callbackRef.current = callback;
  const memoCallback = (0, import_react.useCallback)((...args) => {
    var _a;
    return (_a = callbackRef.current) === null || _a === void 0 ? void 0 : _a.call(null, ...args);
  }, []);
  return memoCallback;
};
var useSubscribeCallbackRef = (callback, deepSelector) => {
  const callbackRef = (0, import_react.useRef)();
  callbackRef.current = typeof callback === "function" ? callback : null;
  const memoCallback = useCallbackRef((arg) => {
    if (callbackRef.current) {
      const re = callbackRef.current(arg);
      if (deepSelector) {
        traverse(re);
      } else {
        traverseShallow(re);
      }
      return re;
    } else {
      if (deepSelector) {
        traverse(arg);
      } else {
        traverseShallow(arg);
      }
      return arg;
    }
  });
  return memoCallback;
};
var usePrevValue = (v) => {
  const vRef = (0, import_react.useRef)(v);
  (0, import_react.useEffect)(() => {
    vRef.current = v;
  }, [v]);
  return vRef.current;
};
var createHook = (reactiveState, readonlyState, initialState, lifeCycle, deepSelector = true, stableSelector = false, stableCompare = true, namespace, actions = void 0) => {
  const controllerList = /* @__PURE__ */ new Set();
  if (!isServer && namespace) {
    setNamespaceMap(namespace, initialState);
  }
  let active = true;
  namespace = namespace || InternalNameSpace.$$__ignore__$$;
  const generateUseHook = (type) => {
    const currentIsDeep = type === "default" ? deepSelector : type === "deep" || type === "deep-stable";
    const currentIsStable = type === "default" ? stableSelector : type === "deep-stable" || type === "shallow-stable";
    function useReactiveHookWithSelector(selector, compare) {
      const ref2 = (0, import_react.useRef)();
      const selectorRef = useSubscribeCallbackRef(selector, currentIsDeep);
      const getSelected = useCallbackRef(() => {
        if (selector) {
          ref2.current = selector(Object.assign(Object.assign({}, readonlyState), actions));
        } else {
          ref2.current = Object.assign(Object.assign({}, readonlyState), actions);
        }
      });
      const memoCompare = useCallbackRef((p, n) => {
        if (compare && typeof compare === "function") {
          return compare(p, n);
        }
        return false;
      });
      const prevSelector = currentIsStable ? selector : usePrevValue(selector);
      const prevCompare = stableCompare ? compare : usePrevValue(compare);
      const ControllerInstance = (0, import_react.useMemo)(() => new Controller(() => selectorRef(reactiveState), memoCompare, lifeCycle, namespace, getSelected), []);
      (0, import_shim.useSyncExternalStore)(ControllerInstance.subscribe, ControllerInstance.getState, ControllerInstance.getState);
      (0, import_react.useMemo)(() => {
        ControllerInstance.run();
        getSelected();
      }, [ControllerInstance, getSelected]);
      (0, import_react.useMemo)(() => {
        if (prevSelector !== selector) {
          ControllerInstance.run();
          getSelected();
        }
      }, [ControllerInstance, prevSelector, selector]);
      (0, import_react.useMemo)(() => {
        if (prevCompare !== compare) {
          ControllerInstance.run();
          getSelected();
        }
      }, [ControllerInstance, prevCompare, compare]);
      if (true) {
        ControllerInstance._devSelector = selector;
        ControllerInstance._devCompare = compare;
        ControllerInstance._devActions = actions;
        ControllerInstance._devWithDeep = currentIsDeep;
        ControllerInstance._devWithStable = currentIsStable;
        ControllerInstance._devType = type;
        ControllerInstance._devState = initialState;
        ControllerInstance._devResult = ref2.current;
      }
      (0, import_react.useEffect)(() => {
        ControllerInstance.setActive(true);
        controllerList.add(ControllerInstance);
        return () => {
          if (true) {
            ControllerInstance.setActive(false);
          } else {
            ControllerInstance.stop();
          }
          controllerList.delete(ControllerInstance);
        };
      }, [ControllerInstance]);
      return ref2.current;
    }
    return useReactiveHookWithSelector;
  };
  const defaultHook = generateUseHook("default");
  const deepHook = generateUseHook("deep");
  const deepStableHook = generateUseHook("deep-stable");
  const shallowHook = generateUseHook("shallow");
  const shallowStableHook = generateUseHook("shallow-stable");
  function useSelector(selector, compare) {
    return defaultHook(selector, compare);
  }
  const typedUseSelector = useSelector;
  typedUseSelector.getState = () => {
    if (true) {
      console.warn("[reactivity-store] `getState` is deprecated, use `getReactiveState` or `getReadonlyState` instead");
    }
    return toRaw(initialState);
  };
  typedUseSelector.getLifeCycle = () => lifeCycle;
  typedUseSelector.getActions = () => actions;
  typedUseSelector.getReactiveState = () => reactiveState;
  typedUseSelector.getReadonlyState = () => readonlyState;
  typedUseSelector.useDeepSelector = deepHook;
  typedUseSelector.useDeepStableSelector = deepStableHook;
  typedUseSelector.useShallowSelector = shallowHook;
  typedUseSelector.useShallowStableSelector = shallowStableHook;
  typedUseSelector.subscribe = (selector, cb, shallow) => {
    const subscribeSelector = () => {
      const re = selector(reactiveState);
      if (isPromise(re)) {
        console.error(`[reactivity-store/subscribe] selector should return a plain object, but current is a promise`);
      }
      if (shallow) {
        traverseShallow(re);
      } else {
        traverse(re);
      }
      return re;
    };
    const controller = new Controller(subscribeSelector, Object.is, lifeCycle, InternalNameSpace.$$__subscribe__$$, () => cb());
    controller.run();
    controllerList.add(controller);
    return () => {
      controllerList.delete(controller);
      controller.stop();
    };
  };
  typedUseSelector.getIsActive = () => active;
  typedUseSelector.clear = () => {
    controllerList.forEach((i) => i.stop());
    if (!isServer && namespace) {
      delNamespace(namespace);
    }
    active = false;
  };
  return typedUseSelector;
};
var getFinalState = (state) => {
  if (state["$$__state__$$"])
    return state["$$__state__$$"];
  return state;
};
var _internalCreateStore = (creator, name = "createStore", lifeCycle) => {
  const state = creator();
  if (isPromise(state)) {
    console.error(`[reactivity-store] '${name}' expect receive a reactive object but got a promise %o, this is a unexpected usage. should not return a promise in this 'creator' function`, state);
  }
  if (!isObject(state)) {
    console.error(`[reactivity-store] '${name}' expect receive a reactive object but got a ${state}, this is a unexpected usage. should return a reactive object in this 'creator' function`);
  }
  if (checkHasMiddleware(state)) {
    console.error(`[reactivity-store] '${name}' not support middleware usage, please change to use 'createState'`);
  }
  if (!checkHasReactive(state)) {
    console.error(`[reactivity-store] '${name}' expect receive a reactive object but got a plain object %o, this is a unexpected usage. should return a reactive object in this 'creator' function`, state);
  }
  const _state = getFinalState(state);
  const rawState = toRaw(_state);
  const reactiveState = reactive(_state);
  const readonlyState = readonly(_state);
  const lifeCycleInstance = lifeCycle || createLifeCycle();
  const useSelector = createHook(reactiveState, readonlyState, rawState, lifeCycleInstance);
  return useSelector;
};
var internalCreateStore = (creator, name = "createStore", lifeCycle) => {
  const scope = effectScope();
  const useSelector = scope.run(() => _internalCreateStore(creator, name, lifeCycle));
  useSelector.scope = scope;
  return useSelector;
};
var createStore = (creator) => {
  return internalCreateStore(creator);
};

// node_modules/@git-diff-view/react/dist/esm/index.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
var _TextMeasure_instances;
var _TextMeasure_key;
var _TextMeasure_map;
var _TextMeasure_getInstance;
var canvasCtx = null;
var getKey = (font, text) => {
  return `${font.fontFamily}-${font.fontStyle}-${font.fontSize}-${text}`;
};
var getStableKey = (font, text) => {
  return getKey(font, "0".repeat(text.length));
};
var TextMeasure = class {
  constructor() {
    _TextMeasure_instances.add(this);
    _TextMeasure_key.set(this, "");
    _TextMeasure_map.set(this, {});
  }
  measure(text, font) {
    const currentKey = getStableKey(font, text);
    if (__classPrivateFieldGet(this, _TextMeasure_map, "f")[currentKey]) {
      return __classPrivateFieldGet(this, _TextMeasure_map, "f")[currentKey];
    }
    const instance2 = __classPrivateFieldGet(this, _TextMeasure_instances, "m", _TextMeasure_getInstance).call(this);
    if (font) {
      const currentFontKey = `${font.fontFamily}-${font.fontStyle}-${font.fontSize}`;
      if (__classPrivateFieldGet(this, _TextMeasure_key, "f") !== currentFontKey) {
        __classPrivateFieldSet(this, _TextMeasure_key, currentFontKey);
        instance2.font = `${font.fontStyle || ""} ${font.fontSize || ""} ${font.fontFamily || ""}`;
      }
    } else {
      instance2.font = "";
    }
    const textWidth = instance2.measureText(text).width;
    return textWidth;
  }
};
_TextMeasure_key = /* @__PURE__ */ new WeakMap(), _TextMeasure_map = /* @__PURE__ */ new WeakMap(), _TextMeasure_instances = /* @__PURE__ */ new WeakSet(), _TextMeasure_getInstance = function _TextMeasure_getInstance2() {
  canvasCtx = canvasCtx || document.createElement("canvas").getContext("2d");
  return canvasCtx;
};
var instance = null;
var getTextMeasureInstance = () => {
  instance = instance || new TextMeasure();
  return instance;
};
var addContentBGName = "--diff-add-content--";
var delContentBGName = "--diff-del-content--";
var borderColorName = "--diff-border--";
var addLineNumberBGName = "--diff-add-lineNumber--";
var delLineNumberBGName = "--diff-del-lineNumber--";
var plainContentBGName = "--diff-plain-content--";
var expandContentBGName = "--diff-expand-content--";
var plainLineNumberColorName = "--diff-plain-lineNumber-color--";
var expandLineNumberColorName = "--diff-expand-lineNumber-color--";
var plainLineNumberBGName = "--diff-plain-lineNumber--";
var expandLineNumberBGName = "--diff-expand-lineNumber--";
var hunkContentBGName = "--diff-hunk-content--";
var hunkContentColorName = "--diff-hunk-content-color--";
var hunkLineNumberBGName = "--diff-hunk-lineNumber--";
var addContentHighlightBGName = "--diff-add-content-highlight--";
var delContentHighlightBGName = "--diff-del-content-highlight--";
var addWidgetBGName = "--diff-add-widget--";
var addWidgetColorName = "--diff-add-widget-color--";
var emptyBGName = "--diff-empty-content--";
var getContentBG = (isAdded, isDelete, hasDiff) => {
  return isAdded ? `var(${addContentBGName})` : isDelete ? `var(${delContentBGName})` : hasDiff ? `var(${plainContentBGName})` : `var(${expandContentBGName})`;
};
var getLineNumberBG = (isAdded, isDelete, hasDiff) => {
  return isAdded ? `var(${addLineNumberBGName})` : isDelete ? `var(${delLineNumberBGName})` : hasDiff ? `var(${plainLineNumberBGName})` : `var(${expandLineNumberBGName})`;
};
var removeAllSelection = () => {
  const selection = window.getSelection();
  for (let i = 0; i < selection.rangeCount; i++) {
    selection.removeRange(selection.getRangeAt(i));
  }
};
var syncScroll = (left, right) => {
  const onScroll = function(event) {
    if (event === null || event.target === null)
      return;
    if (event.target === left) {
      right.scrollTop = left.scrollTop;
      right.scrollLeft = left.scrollLeft;
    } else {
      left.scrollTop = right.scrollTop;
      left.scrollLeft = right.scrollLeft;
    }
  };
  if (!left.onscroll) {
    left.onscroll = onScroll;
  }
  if (!right.onscroll) {
    right.onscroll = onScroll;
  }
  return () => {
    left.onscroll = null;
    right.onscroll = null;
  };
};
var diffFontSizeName = "--diff-font-size--";
var diffAsideWidthName = "--diff-aside-width--";
var memoFunc = (func) => {
  const cache = {};
  return (key) => {
    if (cache[key]) {
      return cache[key];
    }
    const result = func(key);
    cache[key] = result;
    return result;
  };
};
var NewLineSymbol;
(function(NewLineSymbol2) {
  NewLineSymbol2[NewLineSymbol2["CRLF"] = 1] = "CRLF";
  NewLineSymbol2[NewLineSymbol2["CR"] = 2] = "CR";
  NewLineSymbol2[NewLineSymbol2["LF"] = 3] = "LF";
  NewLineSymbol2[NewLineSymbol2["NEWLINE"] = 4] = "NEWLINE";
  NewLineSymbol2[NewLineSymbol2["NORMAL"] = 5] = "NORMAL";
  NewLineSymbol2[NewLineSymbol2["NULL"] = 6] = "NULL";
})(NewLineSymbol || (NewLineSymbol = {}));
var getSymbol = (symbol) => {
  switch (symbol) {
    case NewLineSymbol.LF:
      return "";
    case NewLineSymbol.CR:
      return "";
    case NewLineSymbol.CRLF:
      return "";
    default:
      return "";
  }
};
var DiffModeEnum;
(function(DiffModeEnum2) {
  DiffModeEnum2[DiffModeEnum2["SplitGitHub"] = 1] = "SplitGitHub";
  DiffModeEnum2[DiffModeEnum2["SplitGitLab"] = 2] = "SplitGitLab";
  DiffModeEnum2[DiffModeEnum2["Split"] = 3] = "Split";
  DiffModeEnum2[DiffModeEnum2["Unified"] = 4] = "Unified";
})(DiffModeEnum || (DiffModeEnum = {}));
var useIsMounted = () => {
  const [isMounted, setIsMounted] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    setIsMounted(true);
  }, []);
  return isMounted;
};
var useUnmount = (cb, deps) => {
  const ref2 = (0, import_react2.useRef)(cb);
  ref2.current = cb;
  (0, import_react2.useEffect)(() => ref2.current, deps);
};
var isClient = typeof window !== "undefined";
var useSafeLayout = isClient ? import_react2.useLayoutEffect : import_react2.useEffect;
var useTextWidth = ({ text, font }) => {
  const [width, setWidth] = (0, import_react2.useState)(() => {
    const fontSize = parseInt(font.fontSize);
    let baseSize = 6;
    baseSize += fontSize > 10 ? (fontSize - 10) * 0.6 : 0;
    return baseSize * text.length;
  });
  useSafeLayout(() => {
    const width2 = getTextMeasureInstance().measure(text, font);
    setWidth(width2);
  }, [text, font]);
  return width;
};
var DiffSplitAddWidget = ({ side, className, lineNumber, onWidgetClick, onOpenAddWidget }) => {
  return React.createElement(
    "div",
    { className: "diff-add-widget-wrapper invisible select-none transition-transform hover:scale-110 group-hover:visible" + (className ? " " + className : ""), style: {
      width: `calc(var(${diffFontSizeName}) * 1.4)`,
      height: `calc(var(${diffFontSizeName}) * 1.4)`
    } },
    React.createElement("button", { className: "diff-add-widget z-[1] flex h-full w-full origin-center cursor-pointer items-center justify-center rounded-md text-[1.2em]", style: {
      color: `var(${addWidgetColorName})`,
      backgroundColor: `var(${addWidgetBGName})`
    }, onClick: () => {
      onOpenAddWidget(lineNumber, side);
      onWidgetClick === null || onWidgetClick === void 0 ? void 0 : onWidgetClick(lineNumber, side);
    } }, "+")
  );
};
var DiffUnifiedAddWidget = ({ lineNumber, side, onWidgetClick, onOpenAddWidget }) => {
  return React.createElement(
    "div",
    { className: "diff-add-widget-wrapper invisible absolute left-[100%] top-[1px] translate-x-[-50%] select-none transition-transform hover:scale-110 group-hover:visible", style: {
      width: `calc(var(${diffFontSizeName}) * 1.4)`,
      height: `calc(var(${diffFontSizeName}) * 1.4)`
    } },
    React.createElement("button", { className: "diff-add-widget z-[1] flex h-full w-full origin-center cursor-pointer items-center justify-center rounded-md text-[1.2em]", style: {
      color: `var(${addWidgetColorName})`,
      backgroundColor: `var(${addWidgetBGName})`
    }, onClick: () => {
      onOpenAddWidget(lineNumber, side);
      onWidgetClick === null || onWidgetClick === void 0 ? void 0 : onWidgetClick(lineNumber, side);
    } }, "+")
  );
};
var DiffNoNewLine = () => {
  return React.createElement(
    "svg",
    { "aria-label": "No newline at end of file", role: "img", viewBox: "0 0 16 16", version: "1.1", fill: "currentColor" },
    React.createElement("path", { d: "M4.25 7.25a.75.75 0 0 0 0 1.5h7.5a.75.75 0 0 0 0-1.5h-7.5Z" }),
    React.createElement("path", { d: "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Zm-1.5 0a6.5 6.5 0 1 0-13 0 6.5 6.5 0 0 0 13 0Z" })
  );
};
var temp = {};
var formatStringToCamelCase = (str) => {
  if (str.startsWith("--"))
    return str;
  const splitted = str.split("-");
  if (splitted.length === 1)
    return splitted[0];
  return splitted[0] + splitted.slice(1).map((word) => word[0].toUpperCase() + word.slice(1)).join("");
};
var getStyleObjectFromString = memoFunc((str) => {
  if (!str)
    return temp;
  const style = {};
  str.split(";").forEach((el) => {
    const [property, value] = el.split(":");
    if (!property)
      return;
    const formattedProperty = formatStringToCamelCase(property.trim());
    style[formattedProperty] = value.trim();
  });
  return style;
});
var DiffString = ({ rawLine, diffLine, operator, plainLine, enableWrap, enableTemplate }) => {
  const changes = diffLine === null || diffLine === void 0 ? void 0 : diffLine.changes;
  if (changes === null || changes === void 0 ? void 0 : changes.hasLineChange) {
    const isNewLineSymbolChanged = changes.newLineSymbol;
    if (enableTemplate && !(diffLine === null || diffLine === void 0 ? void 0 : diffLine.plainTemplate) && typeof getPlainDiffTemplate === "function") {
      getPlainDiffTemplate({ diffLine, rawLine, operator });
    }
    if (enableTemplate && (diffLine === null || diffLine === void 0 ? void 0 : diffLine.plainTemplate)) {
      return React.createElement(
        "span",
        { className: "diff-line-content-raw" },
        React.createElement("span", { "data-template": true, dangerouslySetInnerHTML: { __html: diffLine.plainTemplate } }),
        isNewLineSymbolChanged === NewLineSymbol.NEWLINE && React.createElement(
          "span",
          { "data-no-newline-at-end-of-file-symbol": true, className: enableWrap ? "block !text-red-500" : "inline-block align-middle !text-red-500", style: {
            width: `var(${diffFontSizeName})`,
            height: `var(${diffFontSizeName})`
          } },
          React.createElement(DiffNoNewLine, null)
        )
      );
    } else {
      const range = changes.range;
      const str1 = rawLine.slice(0, range.location);
      const str2 = rawLine.slice(range.location, range.location + range.length);
      const str3 = rawLine.slice(range.location + range.length);
      const isLast = str2.includes("\n");
      const _str2 = isLast ? str2.replace("\n", "").replace("\r", "") : str2;
      return React.createElement(
        "span",
        { className: "diff-line-content-raw" },
        React.createElement(
          "span",
          { "data-range-start": range.location, "data-range-end": range.location + range.length },
          str1,
          React.createElement("span", { "data-diff-highlight": true, className: "rounded-[0.2em]", style: {
            backgroundColor: operator === "add" ? `var(${addContentHighlightBGName})` : `var(${delContentHighlightBGName})`
          } }, isLast ? React.createElement(
            React.Fragment,
            null,
            _str2,
            React.createElement("span", { "data-newline-symbol": true }, getSymbol(isNewLineSymbolChanged))
          ) : str2),
          str3
        ),
        isNewLineSymbolChanged === NewLineSymbol.NEWLINE && React.createElement(
          "span",
          { "data-no-newline-at-end-of-file-symbol": true, className: enableWrap ? "block !text-red-500" : "inline-block align-middle !text-red-500", style: {
            width: `var(${diffFontSizeName})`,
            height: `var(${diffFontSizeName})`
          } },
          React.createElement(DiffNoNewLine, null)
        )
      );
    }
  }
  if (enableTemplate && plainLine && !(plainLine === null || plainLine === void 0 ? void 0 : plainLine.template)) {
    plainLine.template = getPlainLineTemplate(plainLine.value);
  }
  if (enableTemplate && (plainLine === null || plainLine === void 0 ? void 0 : plainLine.template)) {
    return React.createElement(
      "span",
      { className: "diff-line-content-raw" },
      React.createElement("span", { "data-template": true, dangerouslySetInnerHTML: { __html: plainLine.template } })
    );
  }
  return React.createElement("span", { className: "diff-line-content-raw" }, rawLine);
};
var DiffSyntax = ({ rawLine, diffLine, operator, syntaxLine, enableWrap, enableTemplate }) => {
  var _a, _b;
  if (!syntaxLine) {
    return React.createElement(DiffString, { rawLine, diffLine, operator, enableWrap, enableTemplate });
  }
  const changes = diffLine === null || diffLine === void 0 ? void 0 : diffLine.changes;
  if (changes === null || changes === void 0 ? void 0 : changes.hasLineChange) {
    const isNewLineSymbolChanged = changes.newLineSymbol;
    if (enableTemplate && !(diffLine === null || diffLine === void 0 ? void 0 : diffLine.syntaxTemplate) && typeof getSyntaxDiffTemplate === "function") {
      getSyntaxDiffTemplate({ diffLine, syntaxLine, operator });
    }
    if (enableTemplate && (diffLine === null || diffLine === void 0 ? void 0 : diffLine.syntaxTemplate)) {
      return React.createElement(
        "span",
        { className: "diff-line-syntax-raw" },
        React.createElement("span", { "data-template": true, dangerouslySetInnerHTML: { __html: diffLine.syntaxTemplate } }),
        isNewLineSymbolChanged === NewLineSymbol.NEWLINE && React.createElement(
          "span",
          { "data-no-newline-at-end-of-file-symbol": true, className: enableWrap ? "block !text-red-500" : "inline-block align-middle !text-red-500", style: {
            width: `var(${diffFontSizeName})`,
            height: `var(${diffFontSizeName})`
          } },
          React.createElement(DiffNoNewLine, null)
        )
      );
    } else {
      const range = changes.range;
      return React.createElement(
        "span",
        { className: "diff-line-syntax-raw" },
        React.createElement("span", { "data-range-start": range.location, "data-range-end": range.location + range.length }, (_a = syntaxLine.nodeList) === null || _a === void 0 ? void 0 : _a.map(({ node, wrapper }, index) => {
          var _a2, _b2, _c, _d, _e, _f;
          if (node.endIndex < range.location || range.location + range.length < node.startIndex) {
            return React.createElement("span", { key: index, "data-start": node.startIndex, "data-end": node.endIndex, className: (_b2 = (_a2 = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _a2 === void 0 ? void 0 : _a2.className) === null || _b2 === void 0 ? void 0 : _b2.join(" "), style: getStyleObjectFromString(((_c = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _c === void 0 ? void 0 : _c.style) || "") }, node.value);
          } else {
            const index1 = range.location - node.startIndex;
            const index2 = index1 < 0 ? 0 : index1;
            const str1 = node.value.slice(0, index2);
            const str2 = node.value.slice(index2, index1 + range.length);
            const str3 = node.value.slice(index1 + range.length);
            const isStart = str1.length || range.location === node.startIndex;
            const isEnd = str3.length || node.endIndex === range.location + range.length - 1;
            const isLast = str2.includes("\n");
            const _str2 = isLast ? str2.replace("\n", "").replace("\r", "") : str2;
            return React.createElement(
              "span",
              { key: index, "data-start": node.startIndex, "data-end": node.endIndex, className: (_e = (_d = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _d === void 0 ? void 0 : _d.className) === null || _e === void 0 ? void 0 : _e.join(" "), style: getStyleObjectFromString(((_f = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _f === void 0 ? void 0 : _f.style) || "") },
              str1,
              React.createElement("span", { "data-diff-highlight": true, style: {
                backgroundColor: operator === "add" ? `var(${addContentHighlightBGName})` : `var(${delContentHighlightBGName})`,
                borderTopLeftRadius: isStart ? "0.2em" : void 0,
                borderBottomLeftRadius: isStart ? "0.2em" : void 0,
                borderTopRightRadius: isEnd || isLast ? "0.2em" : void 0,
                borderBottomRightRadius: isEnd || isLast ? "0.2em" : void 0
              } }, isLast ? React.createElement(
                React.Fragment,
                null,
                _str2,
                React.createElement("span", { "data-newline-symbol": true }, getSymbol(isNewLineSymbolChanged))
              ) : str2),
              str3
            );
          }
        })),
        isNewLineSymbolChanged === NewLineSymbol.NEWLINE && React.createElement(
          "span",
          { "data-no-newline-at-end-of-file-symbol": true, className: enableWrap ? "block !text-red-500" : "inline-block align-middle !text-red-500", style: {
            width: `var(${diffFontSizeName})`,
            height: `var(${diffFontSizeName})`
          } },
          React.createElement(DiffNoNewLine, null)
        )
      );
    }
  }
  if (enableTemplate && !syntaxLine.template) {
    syntaxLine.template = getSyntaxLineTemplate(syntaxLine);
  }
  if (enableTemplate && (syntaxLine === null || syntaxLine === void 0 ? void 0 : syntaxLine.template)) {
    return React.createElement(
      "span",
      { className: "diff-line-syntax-raw" },
      React.createElement("span", { "data-template": true, dangerouslySetInnerHTML: { __html: syntaxLine.template } })
    );
  }
  return React.createElement("span", { className: "diff-line-syntax-raw" }, (_b = syntaxLine === null || syntaxLine === void 0 ? void 0 : syntaxLine.nodeList) === null || _b === void 0 ? void 0 : _b.map(({ node, wrapper }, index) => {
    var _a2, _b2, _c;
    return React.createElement("span", { key: index, "data-start": node.startIndex, "data-end": node.endIndex, className: (_b2 = (_a2 = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _a2 === void 0 ? void 0 : _a2.className) === null || _b2 === void 0 ? void 0 : _b2.join(" "), style: getStyleObjectFromString(((_c = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _c === void 0 ? void 0 : _c.style) || "") }, node.value);
  }));
};
var DiffContent = ({ diffLine, diffFile, rawLine, plainLine, syntaxLine, enableWrap, enableHighlight }) => {
  var _a, _b, _c;
  const isAdded = (diffLine === null || diffLine === void 0 ? void 0 : diffLine.type) === DiffLineType.Add;
  const isDelete = (diffLine === null || diffLine === void 0 ? void 0 : diffLine.type) === DiffLineType.Delete;
  const isMaxLineLengthToIgnoreSyntax = ((_a = syntaxLine === null || syntaxLine === void 0 ? void 0 : syntaxLine.nodeList) === null || _a === void 0 ? void 0 : _a.length) > 150;
  const isEnableTemplate = (_c = (_b = diffFile.getIsEnableTemplate) === null || _b === void 0 ? void 0 : _b.call(diffFile)) !== null && _c !== void 0 ? _c : true;
  return React.createElement(
    "div",
    {
      className: "diff-line-content-item pl-[2.0em]",
      // data-val={rawLine}
      style: {
        whiteSpace: enableWrap ? "pre-wrap" : "pre",
        wordBreak: enableWrap ? "break-all" : "initial"
      }
    },
    React.createElement("span", { "data-operator": isAdded ? "+" : isDelete ? "-" : void 0, className: "diff-line-content-operator ml-[-1.5em] inline-block w-[1.5em] select-none indent-[0.2em]" }, isAdded ? "+" : isDelete ? "-" : " "),
    enableHighlight && syntaxLine && !isMaxLineLengthToIgnoreSyntax ? React.createElement(DiffSyntax, { operator: isAdded ? "add" : isDelete ? "del" : void 0, rawLine, diffLine, syntaxLine, enableWrap, enableTemplate: isEnableTemplate }) : React.createElement(DiffString, { operator: isAdded ? "add" : isDelete ? "del" : void 0, rawLine, diffLine, plainLine, enableWrap, enableTemplate: isEnableTemplate })
  );
};
var DiffViewContext = (0, import_react2.createContext)(null);
DiffViewContext.displayName = "DiffViewContext";
var useDiffViewContext = () => (0, import_react2.useContext)(DiffViewContext);
var DiffWidgetContext = (0, import_react2.createContext)(null);
DiffWidgetContext.displayName = "DiffWidgetContext";
var useDiffWidgetContext = () => (0, import_react2.useContext)(DiffWidgetContext);
var InternalDiffSplitLine$1 = ({ index, diffFile, lineNumber, side, enableAddWidget, enableHighlight }) => {
  var _a, _b;
  const getCurrentSyntaxLine = side === SplitSide.old ? diffFile.getOldSyntaxLine : diffFile.getNewSyntaxLine;
  const getCurrentPlainLine = side === SplitSide.old ? diffFile.getOldPlainLine : diffFile.getNewPlainLine;
  const oldLine = diffFile.getSplitLeftLine(index);
  const newLine = diffFile.getSplitRightLine(index);
  const currentLine = side === SplitSide.old ? oldLine : newLine;
  const hasDiff = !!(currentLine === null || currentLine === void 0 ? void 0 : currentLine.diff);
  const hasContent = !!(currentLine === null || currentLine === void 0 ? void 0 : currentLine.lineNumber);
  const hasChange = checkDiffLineIncludeChange(currentLine === null || currentLine === void 0 ? void 0 : currentLine.diff);
  const isAdded = ((_a = currentLine === null || currentLine === void 0 ? void 0 : currentLine.diff) === null || _a === void 0 ? void 0 : _a.type) === DiffLineType.Add;
  const isDelete = ((_b = currentLine === null || currentLine === void 0 ? void 0 : currentLine.diff) === null || _b === void 0 ? void 0 : _b.type) === DiffLineType.Delete;
  const { useDiffContext } = useDiffViewContext();
  const onAddWidgetClick = useDiffContext.getReadonlyState().onAddWidgetClick;
  const { useWidget } = useDiffWidgetContext();
  const setWidget = useWidget.getReadonlyState().setWidget;
  const contentBG = getContentBG(isAdded, isDelete, hasDiff);
  const lineNumberBG = getLineNumberBG(isAdded, isDelete, hasDiff);
  const syntaxLine = getCurrentSyntaxLine(currentLine.lineNumber);
  const plainLine = getCurrentPlainLine(currentLine.lineNumber);
  return React.createElement("tr", { "data-line": lineNumber, "data-state": hasDiff || !hasContent ? "diff" : "plain", "data-side": SplitSide[side], className: "diff-line" + (hasContent ? " group" : "") }, hasContent ? React.createElement(
    React.Fragment,
    null,
    React.createElement(
      "td",
      { className: `diff-line-${SplitSide[side]}-num sticky left-0 z-[1] w-[1%] min-w-[40px] select-none pl-[10px] pr-[10px] text-right align-top`, style: {
        backgroundColor: lineNumberBG,
        color: `var(${hasDiff ? plainLineNumberColorName : expandLineNumberColorName})`,
        width: `var(${diffAsideWidthName})`,
        minWidth: `var(${diffAsideWidthName})`,
        maxWidth: `var(${diffAsideWidthName})`
      } },
      hasDiff && enableAddWidget && React.createElement(DiffSplitAddWidget, { index, lineNumber: currentLine.lineNumber, side, diffFile, onWidgetClick: (...props) => {
        var _a2;
        return (_a2 = onAddWidgetClick.current) === null || _a2 === void 0 ? void 0 : _a2.call(onAddWidgetClick, ...props);
      }, className: "absolute left-[100%] z-[1] translate-x-[-50%]", onOpenAddWidget: (lineNumber2, side2) => setWidget({ lineNumber: lineNumber2, side: side2 }) }),
      React.createElement("span", { "data-line-num": currentLine.lineNumber, style: { opacity: hasChange ? void 0 : 0.5 } }, currentLine.lineNumber)
    ),
    React.createElement(
      "td",
      { className: `diff-line-${SplitSide[side]}-content pr-[10px] align-top`, style: { backgroundColor: contentBG } },
      React.createElement(DiffContent, { enableWrap: false, diffFile, rawLine: (currentLine === null || currentLine === void 0 ? void 0 : currentLine.value) || "", diffLine: currentLine === null || currentLine === void 0 ? void 0 : currentLine.diff, plainLine, syntaxLine, enableHighlight })
    )
  ) : React.createElement(
    "td",
    { className: `diff-line-${SplitSide[side]}-placeholder select-none`, style: { backgroundColor: `var(${emptyBGName})` }, colSpan: 2 },
    React.createElement("span", null, "")
  ));
};
var DiffSplitContentLine$1 = ({ index, diffFile, lineNumber, side, enableAddWidget, enableHighlight }) => {
  const getCurrentLine = side === SplitSide.old ? diffFile.getSplitLeftLine : diffFile.getSplitRightLine;
  const currentLine = getCurrentLine(index);
  if (currentLine === null || currentLine === void 0 ? void 0 : currentLine.isHidden)
    return null;
  return React.createElement(InternalDiffSplitLine$1, { index, diffFile, lineNumber, side, enableAddWidget, enableHighlight });
};
var useDomWidth = ({ selector, enable }) => {
  const [width, setWidth] = (0, import_react2.useState)(0);
  const { useDiffContext } = useDiffViewContext();
  const { id, mounted } = useDiffContext.useShallowStableSelector((s) => ({ id: s.id, mounted: s.mounted }));
  (0, import_react2.useEffect)(() => {
    if (enable) {
      const container = document.querySelector(`#diff-root${id}`);
      const wrapper = container === null || container === void 0 ? void 0 : container.querySelector(selector);
      if (!wrapper)
        return;
      const typedWrapper = wrapper;
      const cb = () => {
        var _a;
        const rect = wrapper === null || wrapper === void 0 ? void 0 : wrapper.getBoundingClientRect();
        setWidth((_a = rect === null || rect === void 0 ? void 0 : rect.width) !== null && _a !== void 0 ? _a : 0);
      };
      cb();
      const cleanCb = () => {
        var _a;
        typedWrapper.__observeCallback.delete(cb);
        if (typedWrapper.__observeCallback.size === 0) {
          (_a = typedWrapper.__observeInstance) === null || _a === void 0 ? void 0 : _a.disconnect();
          typedWrapper.removeAttribute("data-observe");
          delete typedWrapper.__observeCallback;
          delete typedWrapper.__observeInstance;
        }
      };
      if (typedWrapper.__observeCallback) {
        typedWrapper.__observeCallback.add(cb);
        return () => cleanCb();
      }
      typedWrapper.__observeCallback = /* @__PURE__ */ new Set();
      typedWrapper.__observeCallback.add(cb);
      const observer = new ResizeObserver(() => typedWrapper.__observeCallback.forEach((cb2) => cb2()));
      typedWrapper.__observeInstance = observer;
      observer.observe(typedWrapper);
      typedWrapper.setAttribute("data-observe", "height");
      return () => cleanCb();
    }
  }, [selector, enable, id, mounted]);
  return width;
};
var useSyncHeight = ({ selector, wrapper, side, enable }) => {
  const { useDiffContext } = useDiffViewContext();
  const { id, mounted } = useDiffContext.useShallowStableSelector((s) => ({ id: s.id, mounted: s.mounted }));
  (0, import_react2.useEffect)(() => {
    if (enable) {
      const container = document.querySelector(`#diff-root${id}`);
      const elements = Array.from((container === null || container === void 0 ? void 0 : container.querySelectorAll(selector)) || []);
      const wrappers = wrapper ? Array.from((container === null || container === void 0 ? void 0 : container.querySelectorAll(wrapper)) || []) : elements;
      if (elements.length === 2 && wrappers.length === 2) {
        const ele1 = elements[0];
        const ele2 = elements[1];
        const wrapper1 = wrappers[0];
        const wrapper2 = wrappers[1];
        const target = ele1.getAttribute("data-side") === side ? ele1 : ele2;
        const typedTarget = target;
        const cb = () => {
          ele1.style.height = "auto";
          ele2.style.height = "auto";
          const rect1 = ele1.getBoundingClientRect();
          const rect2 = ele2.getBoundingClientRect();
          const maxHeight = Math.max(rect1.height, rect2.height);
          wrapper1.style.height = maxHeight + "px";
          wrapper2.style.height = maxHeight + "px";
          wrapper1.setAttribute("data-sync-height", String(maxHeight));
          wrapper2.setAttribute("data-sync-height", String(maxHeight));
        };
        cb();
        const cleanCb = () => {
          var _a;
          typedTarget.__observeCallback.delete(cb);
          if (typedTarget.__observeCallback.size === 0) {
            (_a = typedTarget.__observeInstance) === null || _a === void 0 ? void 0 : _a.disconnect();
            typedTarget.removeAttribute("data-observe");
            delete typedTarget.__observeCallback;
            delete typedTarget.__observeInstance;
          }
        };
        if (typedTarget.__observeCallback) {
          typedTarget.__observeCallback.add(cb);
          return () => cleanCb();
        }
        typedTarget.__observeCallback = /* @__PURE__ */ new Set();
        typedTarget.__observeCallback.add(cb);
        const observer = new ResizeObserver(() => typedTarget.__observeCallback.forEach((cb2) => cb2()));
        typedTarget.__observeInstance = observer;
        observer.observe(target);
        target.setAttribute("data-observe", "height");
        return () => cleanCb();
      }
    }
  }, [selector, enable, side, id, wrapper, mounted]);
};
var InternalDiffSplitExtendLine$1 = ({ index, diffFile, oldLineExtend, newLineExtend, side, lineNumber }) => {
  const { useDiffContext } = useDiffViewContext();
  const oldLine = diffFile.getSplitLeftLine(index);
  const newLine = diffFile.getSplitRightLine(index);
  const renderExtendLine = useDiffContext.useShallowStableSelector((s) => s.renderExtendLine);
  const currentExtend = side === SplitSide.old ? oldLineExtend : newLineExtend;
  const otherSide = side === SplitSide.old ? SplitSide.new : SplitSide.old;
  const currentLineNumber = side === SplitSide.old ? oldLine.lineNumber : newLine.lineNumber;
  const currentSideHasExtend = (currentExtend === null || currentExtend === void 0 ? void 0 : currentExtend.data) !== void 0 && (currentExtend === null || currentExtend === void 0 ? void 0 : currentExtend.data) !== null;
  const hasExtend = (oldLineExtend === null || oldLineExtend === void 0 ? void 0 : oldLineExtend.data) !== void 0 && (oldLineExtend === null || oldLineExtend === void 0 ? void 0 : oldLineExtend.data) !== null || (newLineExtend === null || newLineExtend === void 0 ? void 0 : newLineExtend.data) !== void 0 && (newLineExtend === null || newLineExtend === void 0 ? void 0 : newLineExtend.data) !== null;
  const currentExtendRendered = hasExtend && (renderExtendLine === null || renderExtendLine === void 0 ? void 0 : renderExtendLine({
    diffFile,
    side,
    lineNumber: currentLineNumber,
    data: currentExtend === null || currentExtend === void 0 ? void 0 : currentExtend.data,
    onUpdate: diffFile.notifyAll
  }));
  useSyncHeight({
    selector: `div[data-line="${lineNumber}-extend-content"]`,
    wrapper: `tr[data-line="${lineNumber}-extend"]`,
    side: SplitSide[currentSideHasExtend ? side : otherSide],
    enable: hasExtend && typeof renderExtendLine === "function"
  });
  const width = useDomWidth({
    selector: side === SplitSide.old ? ".old-diff-table-wrapper" : ".new-diff-table-wrapper",
    enable: currentSideHasExtend && typeof renderExtendLine === "function"
  });
  if (!renderExtendLine)
    return null;
  return React.createElement("tr", { "data-line": `${lineNumber}-extend`, "data-state": "extend", "data-side": SplitSide[side], className: "diff-line diff-line-extend" }, currentSideHasExtend ? React.createElement(
    "td",
    { className: `diff-line-extend-${SplitSide[side]}-content p-0`, colSpan: 2 },
    React.createElement("div", { "data-line": `${lineNumber}-extend-content`, "data-side": SplitSide[side], className: "diff-line-extend-wrapper sticky left-0 z-[1]", style: { width } }, width > 0 && currentExtendRendered)
  ) : React.createElement(
    "td",
    { className: `diff-line-extend-${SplitSide[side]}-placeholder select-none p-0`, style: { backgroundColor: `var(${emptyBGName})` }, colSpan: 2 },
    React.createElement("div", { "data-line": `${lineNumber}-extend-content`, "data-side": SplitSide[side] })
  ));
};
var DiffSplitExtendLine$1 = ({ index, diffFile, side, lineNumber }) => {
  const { useDiffContext } = useDiffViewContext();
  const oldLine = diffFile.getSplitLeftLine(index);
  const newLine = diffFile.getSplitRightLine(index);
  const { oldLineExtend, newLineExtend } = useDiffContext(React.useCallback((s) => {
    var _a, _b, _c, _d;
    return {
      oldLineExtend: (_b = (_a = s.extendData) === null || _a === void 0 ? void 0 : _a.oldFile) === null || _b === void 0 ? void 0 : _b[oldLine === null || oldLine === void 0 ? void 0 : oldLine.lineNumber],
      newLineExtend: (_d = (_c = s.extendData) === null || _c === void 0 ? void 0 : _c.newFile) === null || _d === void 0 ? void 0 : _d[newLine === null || newLine === void 0 ? void 0 : newLine.lineNumber]
    };
  }, [oldLine === null || oldLine === void 0 ? void 0 : oldLine.lineNumber, newLine === null || newLine === void 0 ? void 0 : newLine.lineNumber]));
  const hasExtend = (oldLineExtend === null || oldLineExtend === void 0 ? void 0 : oldLineExtend.data) || (newLineExtend === null || newLineExtend === void 0 ? void 0 : newLineExtend.data);
  const enableExpand = diffFile.getExpandEnabled();
  const currentLine = side === SplitSide.old ? oldLine : newLine;
  const currentIsShow = hasExtend && (!currentLine.isHidden || !enableExpand);
  if (!currentIsShow)
    return null;
  return React.createElement(InternalDiffSplitExtendLine$1, { side, index, diffFile, lineNumber, oldLineExtend, newLineExtend });
};
var ExpandDown = ({ className }) => {
  return React.createElement(
    "svg",
    { "aria-hidden": "true", height: "16", viewBox: "0 0 16 16", version: "1.1", width: "16", className },
    React.createElement("path", { d: "m8.177 14.323 2.896-2.896a.25.25 0 0 0-.177-.427H8.75V7.764a.75.75 0 1 0-1.5 0V11H5.104a.25.25 0 0 0-.177.427l2.896 2.896a.25.25 0 0 0 .354 0ZM2.25 5a.75.75 0 0 0 0-1.5h-.5a.75.75 0 0 0 0 1.5h.5ZM6 4.25a.75.75 0 0 1-.75.75h-.5a.75.75 0 0 1 0-1.5h.5a.75.75 0 0 1 .75.75ZM8.25 5a.75.75 0 0 0 0-1.5h-.5a.75.75 0 0 0 0 1.5h.5ZM12 4.25a.75.75 0 0 1-.75.75h-.5a.75.75 0 0 1 0-1.5h.5a.75.75 0 0 1 .75.75Zm2.25.75a.75.75 0 0 0 0-1.5h-.5a.75.75 0 0 0 0 1.5h.5Z" })
  );
};
var ExpandUp = ({ className }) => {
  return React.createElement(
    "svg",
    { "aria-hidden": "true", height: "16", viewBox: "0 0 16 16", version: "1.1", width: "16", className },
    React.createElement("path", { d: "M7.823 1.677 4.927 4.573A.25.25 0 0 0 5.104 5H7.25v3.236a.75.75 0 1 0 1.5 0V5h2.146a.25.25 0 0 0 .177-.427L8.177 1.677a.25.25 0 0 0-.354 0ZM13.75 11a.75.75 0 0 0 0 1.5h.5a.75.75 0 0 0 0-1.5h-.5Zm-3.75.75a.75.75 0 0 1 .75-.75h.5a.75.75 0 0 1 0 1.5h-.5a.75.75 0 0 1-.75-.75ZM7.75 11a.75.75 0 0 0 0 1.5h.5a.75.75 0 0 0 0-1.5h-.5ZM4 11.75a.75.75 0 0 1 .75-.75h.5a.75.75 0 0 1 0 1.5h-.5a.75.75 0 0 1-.75-.75ZM1.75 11a.75.75 0 0 0 0 1.5h.5a.75.75 0 0 0 0-1.5h-.5Z" })
  );
};
var ExpandAll = ({ className }) => {
  return React.createElement(
    "svg",
    { "aria-hidden": "true", height: "16", viewBox: "0 0 16 16", version: "1.1", width: "16", className },
    React.createElement("path", { d: "m8.177.677 2.896 2.896a.25.25 0 0 1-.177.427H8.75v1.25a.75.75 0 0 1-1.5 0V4H5.104a.25.25 0 0 1-.177-.427L7.823.677a.25.25 0 0 1 .354 0ZM7.25 10.75a.75.75 0 0 1 1.5 0V12h2.146a.25.25 0 0 1 .177.427l-2.896 2.896a.25.25 0 0 1-.354 0l-2.896-2.896A.25.25 0 0 1 5.104 12H7.25v-1.25Zm-5-2a.75.75 0 0 0 0-1.5h-.5a.75.75 0 0 0 0 1.5h.5ZM6 8a.75.75 0 0 1-.75.75h-.5a.75.75 0 0 1 0-1.5h.5A.75.75 0 0 1 6 8Zm2.25.75a.75.75 0 0 0 0-1.5h-.5a.75.75 0 0 0 0 1.5h.5ZM12 8a.75.75 0 0 1-.75.75h-.5a.75.75 0 0 1 0-1.5h.5A.75.75 0 0 1 12 8Zm2.25.75a.75.75 0 0 0 0-1.5h-.5a.75.75 0 0 0 0 1.5h.5Z" })
  );
};
var InternalDiffSplitHunkLineGitHub = ({ index, diffFile, side, lineNumber }) => {
  var _a;
  const currentHunk = diffFile.getSplitHunkLine(index);
  const expandEnabled = diffFile.getExpandEnabled();
  useSyncHeight({
    selector: `tr[data-line="${lineNumber}-hunk"]`,
    side: SplitSide[SplitSide.old],
    enable: side === SplitSide.new
  });
  const enableHunkAction = side === SplitSide.old;
  const couldExpand = expandEnabled && currentHunk && currentHunk.splitInfo;
  const isExpandAll = currentHunk && currentHunk.splitInfo && currentHunk.splitInfo.endHiddenIndex - currentHunk.splitInfo.startHiddenIndex < composeLen;
  const isFirstLine = currentHunk && currentHunk.isFirst;
  const isLastLine = currentHunk && currentHunk.isLast;
  return React.createElement("tr", { "data-line": `${lineNumber}-hunk`, "data-state": "hunk", "data-side": SplitSide[side], className: "diff-line diff-line-hunk" }, enableHunkAction ? React.createElement(
    React.Fragment,
    null,
    React.createElement("td", { className: "diff-line-hunk-action sticky left-0 w-[1%] min-w-[40px] select-none p-[1px]", style: {
      backgroundColor: `var(${hunkLineNumberBGName})`,
      color: `var(${plainLineNumberColorName})`,
      width: `var(${diffAsideWidthName})`,
      minWidth: `var(${diffAsideWidthName})`,
      maxWidth: `var(${diffAsideWidthName})`
    } }, couldExpand ? isFirstLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
      React.createElement(ExpandUp, { className: "fill-current" })
    ) : isLastLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip relative flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
      React.createElement(ExpandDown, { className: "fill-current" })
    ) : isExpandAll ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand All", "data-title": "Expand All", onClick: () => diffFile.onSplitHunkExpand("all", index) },
      React.createElement(ExpandAll, { className: "fill-current" })
    ) : React.createElement(
      React.Fragment,
      null,
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
        React.createElement(ExpandDown, { className: "fill-current" })
      ),
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
        React.createElement(ExpandUp, { className: "fill-current" })
      )
    ) : React.createElement("div", { className: "min-h-[28px]" }, "")),
    React.createElement(
      "td",
      { className: "diff-line-hunk-content pr-[10px] align-middle", style: { backgroundColor: `var(${hunkContentBGName})` } },
      React.createElement("div", { className: "pl-[1.5em]", style: {
        color: `var(${hunkContentColorName})`
      } }, ((_a = currentHunk.splitInfo) === null || _a === void 0 ? void 0 : _a.plainText) || currentHunk.text)
    )
  ) : React.createElement(
    "td",
    { className: "diff-line-hunk-placeholder select-none", colSpan: 2, style: { backgroundColor: `var(${hunkContentBGName})` } },
    React.createElement("div", { className: "min-h-[28px]" }, "")
  ));
};
var InternalDiffSplitHunkLineGitLab = ({ index, diffFile, side, lineNumber }) => {
  var _a;
  const currentHunk = diffFile.getSplitHunkLine(index);
  const expandEnabled = diffFile.getExpandEnabled();
  useSyncHeight({
    selector: `tr[data-line="${lineNumber}-hunk"]`,
    side: SplitSide[side],
    enable: true
  });
  const couldExpand = expandEnabled && currentHunk && currentHunk.splitInfo;
  const isExpandAll = currentHunk && currentHunk.splitInfo && currentHunk.splitInfo.endHiddenIndex - currentHunk.splitInfo.startHiddenIndex < composeLen;
  const isFirstLine = currentHunk && currentHunk.isFirst;
  const isLastLine = currentHunk && currentHunk.isLast;
  return React.createElement(
    "tr",
    { "data-line": `${lineNumber}-hunk`, "data-state": "hunk", "data-side": SplitSide[side], className: "diff-line diff-line-hunk" },
    React.createElement("td", { className: "diff-line-hunk-action sticky left-0 w-[1%] min-w-[40px] select-none p-[1px]", style: {
      backgroundColor: `var(${hunkLineNumberBGName})`,
      color: `var(${plainLineNumberColorName})`,
      width: `var(${diffAsideWidthName})`,
      minWidth: `var(${diffAsideWidthName})`,
      maxWidth: `var(${diffAsideWidthName})`
    } }, couldExpand ? isFirstLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
      React.createElement(ExpandUp, { className: "fill-current" })
    ) : isLastLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip relative flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
      React.createElement(ExpandDown, { className: "fill-current" })
    ) : isExpandAll ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand All", "data-title": "Expand All", onClick: () => diffFile.onSplitHunkExpand("all", index) },
      React.createElement(ExpandAll, { className: "fill-current" })
    ) : React.createElement(
      React.Fragment,
      null,
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
        React.createElement(ExpandDown, { className: "fill-current" })
      ),
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
        React.createElement(ExpandUp, { className: "fill-current" })
      )
    ) : React.createElement("div", { className: "min-h-[28px]" }, "")),
    React.createElement(
      "td",
      { className: "diff-line-hunk-content pr-[10px] align-middle", style: { backgroundColor: `var(${hunkContentBGName})` } },
      React.createElement("div", { className: "pl-[1.5em]", style: {
        color: `var(${hunkContentColorName})`
      } }, ((_a = currentHunk.splitInfo) === null || _a === void 0 ? void 0 : _a.plainText) || currentHunk.text)
    )
  );
};
var InternalDiffSplitHunkLine$1 = ({ index, diffFile, side, lineNumber }) => {
  const { useDiffContext } = useDiffViewContext();
  const diffViewMode = useDiffContext.useShallowStableSelector((s) => s.mode);
  if (diffViewMode === DiffModeEnum.SplitGitHub || diffViewMode === DiffModeEnum.Split || diffViewMode === DiffModeEnum.Unified) {
    return React.createElement(InternalDiffSplitHunkLineGitHub, { index, diffFile, side, lineNumber });
  } else {
    return React.createElement(InternalDiffSplitHunkLineGitLab, { index, diffFile, side, lineNumber });
  }
};
var DiffSplitHunkLine$1 = ({ index, diffFile, side, lineNumber }) => {
  const currentHunk = diffFile.getSplitHunkLine(index);
  const currentIsShow = currentHunk && currentHunk.splitInfo && currentHunk.splitInfo.startHiddenIndex < currentHunk.splitInfo.endHiddenIndex;
  const currentIsPureHunk = currentHunk && diffFile._getIsPureDiffRender() && !currentHunk.splitInfo;
  if (!currentIsShow && !currentIsPureHunk)
    return null;
  return React.createElement(InternalDiffSplitHunkLine$1, { index, diffFile, side, lineNumber });
};
var InternalDiffSplitWidgetLine$1 = ({ index, side, diffFile, lineNumber }) => {
  const { useWidget } = useDiffWidgetContext();
  const { useDiffContext } = useDiffViewContext();
  const oldLine = diffFile.getSplitLeftLine(index);
  const newLine = diffFile.getSplitRightLine(index);
  const widgetSide = useWidget.useShallowStableSelector((s) => s.widgetSide);
  const widgetLineNumber = useWidget.getReadonlyState().widgetLineNumber;
  const setWidget = useWidget.getReadonlyState().setWidget;
  const oldLineWidget = oldLine.lineNumber && widgetSide === SplitSide.old && widgetLineNumber === oldLine.lineNumber;
  const newLineWidget = newLine.lineNumber && widgetSide === SplitSide.new && widgetLineNumber === newLine.lineNumber;
  const currentLine = side === SplitSide.old ? oldLine : newLine;
  const otherSide = side === SplitSide.old ? SplitSide.new : SplitSide.old;
  const currentHasWidget = side === SplitSide.old ? oldLineWidget : newLineWidget;
  const hasWidget = oldLineWidget || newLineWidget;
  const renderWidgetLine = useDiffContext.useShallowStableSelector((s) => s.renderWidgetLine);
  const currentWidgetRendered = currentHasWidget && (renderWidgetLine === null || renderWidgetLine === void 0 ? void 0 : renderWidgetLine({
    diffFile,
    side,
    lineNumber: currentLine.lineNumber,
    onClose: () => setWidget({})
  }));
  useSyncHeight({
    selector: `div[data-line="${lineNumber}-widget-content"]`,
    wrapper: `tr[data-line="${lineNumber}-widget"]`,
    side: SplitSide[currentHasWidget ? side : otherSide],
    enable: hasWidget && typeof renderWidgetLine === "function"
  });
  const width = useDomWidth({
    selector: side === SplitSide.old ? ".old-diff-table-wrapper" : ".new-diff-table-wrapper",
    enable: !!currentHasWidget && typeof renderWidgetLine === "function"
  });
  if (!renderWidgetLine)
    return null;
  return React.createElement("tr", { "data-line": `${lineNumber}-widget`, "data-state": "widget", "data-side": SplitSide[side], className: "diff-line diff-line-widget" }, currentHasWidget ? React.createElement(
    "td",
    { className: `diff-line-widget-${SplitSide[side]}-content p-0`, colSpan: 2 },
    React.createElement("div", { "data-line": `${lineNumber}-widget-content`, "data-side": SplitSide[side], className: "diff-line-widget-wrapper sticky left-0 z-[1]", style: { width } }, width > 0 && currentWidgetRendered)
  ) : React.createElement(
    "td",
    { className: `diff-line-widget-${SplitSide[side]}-placeholder p-0`, style: { backgroundColor: `var(${emptyBGName})` }, colSpan: 2 },
    React.createElement("div", { "data-line": `${lineNumber}-widget-content`, "data-side": SplitSide[side] })
  ));
};
var DiffSplitWidgetLine$1 = ({ index, side, diffFile, lineNumber }) => {
  const { useWidget } = useDiffWidgetContext();
  const currentIsShow = useWidget.useShallowSelector(React.useCallback((s) => {
    const widgetLineNumber = s.widgetLineNumber;
    const widgetSide = s.widgetSide;
    const oldLine = diffFile.getSplitLeftLine(index);
    const newLine = diffFile.getSplitRightLine(index);
    const oldLineWidget = oldLine.lineNumber && widgetSide === SplitSide.old && widgetLineNumber === oldLine.lineNumber;
    const newLineWidget = newLine.lineNumber && widgetSide === SplitSide.new && widgetLineNumber === newLine.lineNumber;
    const currentIsShow2 = oldLineWidget || newLineWidget;
    return currentIsShow2;
  }, [diffFile, index]), (p, c) => p === c);
  if (!currentIsShow)
    return null;
  return React.createElement(InternalDiffSplitWidgetLine$1, { index, side, diffFile, lineNumber });
};
var DiffSplitViewTable = ({ side, diffFile, enableAddWidget, enableHighlight, onMouseDown }) => {
  const className = side === SplitSide.new ? "new-diff-table" : "old-diff-table";
  const lines = getSplitContentLines(diffFile);
  return React.createElement(
    "table",
    { className: className + " w-full border-collapse border-spacing-0", "data-mode": SplitSide[side] },
    React.createElement(
      "colgroup",
      null,
      React.createElement("col", { className: `diff-table-${SplitSide[side]}-num-col` }),
      React.createElement("col", { className: `diff-table-${SplitSide[side]}-content-col` })
    ),
    React.createElement(
      "thead",
      { className: "hidden" },
      React.createElement(
        "tr",
        null,
        React.createElement(
          "th",
          { scope: "col" },
          SplitSide[side],
          " line number"
        ),
        React.createElement(
          "th",
          { scope: "col" },
          SplitSide[side],
          " line content"
        )
      )
    ),
    React.createElement(
      "tbody",
      { className: "diff-table-body leading-[1.4]", onMouseDownCapture: onMouseDown },
      lines.map((line) => React.createElement(
        import_react2.Fragment,
        { key: line.index },
        React.createElement(DiffSplitHunkLine$1, { index: line.index, side, lineNumber: line.lineNumber, diffFile }),
        React.createElement(DiffSplitContentLine$1, { index: line.index, side, lineNumber: line.lineNumber, diffFile, enableAddWidget, enableHighlight }),
        React.createElement(DiffSplitWidgetLine$1, { index: line.index, side, lineNumber: line.lineNumber, diffFile }),
        React.createElement(DiffSplitExtendLine$1, { index: line.index, side, lineNumber: line.lineNumber, diffFile })
      )),
      React.createElement(DiffSplitHunkLine$1, { side, index: diffFile.splitLineLength, lineNumber: diffFile.splitLineLength, diffFile })
    )
  );
};
var DiffSplitViewNormal = (0, import_react2.memo)(({ diffFile }) => {
  const ref1 = (0, import_react2.useRef)(null);
  const ref2 = (0, import_react2.useRef)(null);
  const ref3 = (0, import_react2.useRef)();
  const tempRef = (0, import_react2.useRef)();
  const splitLineLength = Math.max(diffFile.splitLineLength, diffFile.fileLineLength);
  const { useDiffContext } = useDiffViewContext();
  const { fontSize, enableAddWidget, enableHighlight } = useDiffContext.useShallowStableSelector((s) => ({
    fontSize: s.fontSize,
    enableAddWidget: s.enableAddWidget,
    enableHighlight: s.enableHighlight
  }));
  (0, import_shim2.useSyncExternalStore)(diffFile.subscribe, diffFile.getUpdateCount, diffFile.getUpdateCount);
  (0, import_react2.useEffect)(() => {
    const left = ref1.current;
    const right = ref2.current;
    if (!left || !right)
      return;
    return syncScroll(left, right);
  }, []);
  const font = React.useMemo(() => ({ fontSize: fontSize + "px", fontFamily: "Menlo, Consolas, monospace" }), [fontSize]);
  const _width = useTextWidth({
    text: splitLineLength.toString(),
    font
  });
  const width = Math.max(40, _width + 25);
  const setStyle = (side) => {
    if (!ref3.current)
      return;
    if (!side) {
      ref3.current.textContent = "";
    } else {
      const id = `diff-root${diffFile.getId()}`;
      ref3.current.textContent = `#${id} [data-state="extend"] {user-select: none} 
#${id} [data-state="hunk"] {user-select: none} 
#${id} [data-state="widget"] {user-select: none}`;
    }
  };
  const onMouseDown = (e) => {
    let ele = e.target;
    if (ele && ele instanceof HTMLElement && ele.nodeName === "BUTTON") {
      removeAllSelection();
      return;
    }
    while (ele && ele instanceof HTMLElement) {
      const state = ele.getAttribute("data-state");
      const side = ele.getAttribute("data-side");
      if (side) {
        if (tempRef.current !== SplitSide[side]) {
          tempRef.current = SplitSide[side];
          setStyle(SplitSide[side]);
          removeAllSelection();
        }
      }
      if (state) {
        if (state === "extend" || state === "hunk" || state === "widget") {
          if (tempRef.current !== void 0) {
            tempRef.current = void 0;
            setStyle(void 0);
            removeAllSelection();
          }
          return;
        } else {
          return;
        }
      }
      ele = ele.parentElement;
    }
  };
  return React.createElement(
    "div",
    { className: "split-diff-view split-diff-view-normal flex w-full basis-[50%]" },
    React.createElement("style", { "data-select-style": true, ref: ref3 }),
    React.createElement(
      "div",
      { className: "old-diff-table-wrapper diff-table-scroll-container w-full overflow-x-auto overflow-y-hidden", ref: ref1, style: {
        // @ts-ignore
        [diffAsideWidthName]: `${Math.round(width)}px`,
        overscrollBehaviorX: "none",
        fontFamily: "Menlo, Consolas, monospace",
        fontSize: `var(${diffFontSizeName})`
      } },
      React.createElement(DiffSplitViewTable, { side: SplitSide.old, diffFile, enableAddWidget, enableHighlight, onMouseDown })
    ),
    React.createElement("div", { className: "diff-split-line w-[1.5px]", style: { backgroundColor: `var(${borderColorName})` } }),
    React.createElement(
      "div",
      { className: "new-diff-table-wrapper diff-table-scroll-container w-full overflow-x-auto overflow-y-hidden", ref: ref2, style: {
        // @ts-ignore
        [diffAsideWidthName]: `${Math.round(width)}px`,
        overscrollBehaviorX: "none",
        fontFamily: "Menlo, Consolas, monospace",
        fontSize: `var(${diffFontSizeName})`
      } },
      React.createElement(DiffSplitViewTable, { side: SplitSide.new, diffFile, enableAddWidget, enableHighlight, onMouseDown })
    )
  );
});
DiffSplitViewNormal.displayName = "DiffSplitViewNormal";
var InternalDiffSplitLine = ({ index, diffFile, lineNumber, enableAddWidget, enableHighlight }) => {
  var _a, _b;
  const oldLine = diffFile.getSplitLeftLine(index);
  const newLine = diffFile.getSplitRightLine(index);
  const oldSyntaxLine = diffFile.getOldSyntaxLine(oldLine === null || oldLine === void 0 ? void 0 : oldLine.lineNumber);
  const oldPlainLine = diffFile.getOldPlainLine(oldLine.lineNumber);
  const newSyntaxLine = diffFile.getNewSyntaxLine(newLine === null || newLine === void 0 ? void 0 : newLine.lineNumber);
  const newPlainLine = diffFile.getNewPlainLine(newLine.lineNumber);
  const hasDiff = !!(oldLine === null || oldLine === void 0 ? void 0 : oldLine.diff) || !!(newLine === null || newLine === void 0 ? void 0 : newLine.diff);
  const hasChange = checkDiffLineIncludeChange(oldLine === null || oldLine === void 0 ? void 0 : oldLine.diff) || checkDiffLineIncludeChange(newLine === null || newLine === void 0 ? void 0 : newLine.diff);
  const oldLineIsDelete = ((_a = oldLine === null || oldLine === void 0 ? void 0 : oldLine.diff) === null || _a === void 0 ? void 0 : _a.type) === DiffLineType.Delete;
  const newLineIsAdded = ((_b = newLine === null || newLine === void 0 ? void 0 : newLine.diff) === null || _b === void 0 ? void 0 : _b.type) === DiffLineType.Add;
  const { useDiffContext } = useDiffViewContext();
  const onAddWidgetClick = useDiffContext.getReadonlyState().onAddWidgetClick;
  const { useWidget } = useDiffWidgetContext();
  const setWidget = useWidget.getReadonlyState().setWidget;
  const hasOldLine = !!oldLine.lineNumber;
  const hasNewLine = !!newLine.lineNumber;
  const oldLineContentBG = getContentBG(false, oldLineIsDelete, hasDiff);
  const oldLineNumberBG = getLineNumberBG(false, oldLineIsDelete, hasDiff);
  const newLineContentBG = getContentBG(newLineIsAdded, false, hasDiff);
  const newLineNumberBG = getLineNumberBG(newLineIsAdded, false, hasDiff);
  return React.createElement(
    "tr",
    { "data-line": lineNumber, "data-state": hasDiff ? "diff" : "plain", className: "diff-line" },
    hasOldLine ? React.createElement(
      React.Fragment,
      null,
      React.createElement(
        "td",
        { className: "diff-line-old-num group relative w-[1%] min-w-[40px] select-none pl-[10px] pr-[10px] text-right align-top", "data-side": SplitSide[SplitSide.old], style: { backgroundColor: oldLineNumberBG, color: `var(${plainLineNumberColorName})` } },
        hasDiff && enableAddWidget && React.createElement(DiffSplitAddWidget, { index, lineNumber: oldLine.lineNumber, side: SplitSide.old, diffFile, onWidgetClick: (...props) => {
          var _a2;
          return (_a2 = onAddWidgetClick.current) === null || _a2 === void 0 ? void 0 : _a2.call(onAddWidgetClick, ...props);
        }, className: "absolute left-[100%] z-[1] translate-x-[-50%]", onOpenAddWidget: (lineNumber2, side) => setWidget({ lineNumber: lineNumber2, side }) }),
        React.createElement("span", { "data-line-num": oldLine.lineNumber, style: { opacity: hasChange ? void 0 : 0.5 } }, oldLine.lineNumber)
      ),
      React.createElement(
        "td",
        { className: "diff-line-old-content group relative pr-[10px] align-top", "data-side": SplitSide[SplitSide.old], style: { backgroundColor: oldLineContentBG } },
        hasDiff && enableAddWidget && React.createElement(DiffSplitAddWidget, { index, lineNumber: oldLine.lineNumber, side: SplitSide.old, diffFile, onWidgetClick: (...props) => {
          var _a2;
          return (_a2 = onAddWidgetClick.current) === null || _a2 === void 0 ? void 0 : _a2.call(onAddWidgetClick, ...props);
        }, className: "absolute right-[100%] z-[1] translate-x-[50%]", onOpenAddWidget: (lineNumber2, side) => setWidget({ lineNumber: lineNumber2, side }) }),
        React.createElement(DiffContent, { enableWrap: true, diffFile, rawLine: oldLine.value, diffLine: oldLine.diff, plainLine: oldPlainLine, syntaxLine: oldSyntaxLine, enableHighlight })
      )
    ) : React.createElement(
      "td",
      { className: "diff-line-old-placeholder select-none", "data-side": SplitSide[SplitSide.old], style: { backgroundColor: `var(${emptyBGName})` }, colSpan: 2 },
      React.createElement("span", null, "")
    ),
    hasNewLine ? React.createElement(
      React.Fragment,
      null,
      React.createElement(
        "td",
        { className: "diff-line-new-num group relative w-[1%] min-w-[40px] select-none border-l-[1px] pl-[10px] pr-[10px] text-right align-top", "data-side": SplitSide[SplitSide.new], style: {
          backgroundColor: newLineNumberBG,
          color: `var(${hasDiff ? plainLineNumberColorName : expandLineNumberColorName})`,
          borderLeftColor: `var(${borderColorName})`,
          borderLeftStyle: "solid"
        } },
        hasDiff && enableAddWidget && React.createElement(DiffSplitAddWidget, { index, lineNumber: newLine.lineNumber, side: SplitSide.new, diffFile, onWidgetClick: (...props) => {
          var _a2;
          return (_a2 = onAddWidgetClick.current) === null || _a2 === void 0 ? void 0 : _a2.call(onAddWidgetClick, ...props);
        }, className: "absolute left-[100%] z-[1] translate-x-[-50%]", onOpenAddWidget: (lineNumber2, side) => setWidget({ lineNumber: lineNumber2, side }) }),
        React.createElement("span", { "data-line-num": newLine.lineNumber, style: { opacity: hasChange ? void 0 : 0.5 } }, newLine.lineNumber)
      ),
      React.createElement(
        "td",
        { className: "diff-line-new-content group relative pr-[10px] align-top", "data-side": SplitSide[SplitSide.new], style: { backgroundColor: newLineContentBG } },
        hasDiff && enableAddWidget && React.createElement(DiffSplitAddWidget, { index, lineNumber: newLine.lineNumber, side: SplitSide.new, diffFile, onWidgetClick: (...props) => {
          var _a2;
          return (_a2 = onAddWidgetClick.current) === null || _a2 === void 0 ? void 0 : _a2.call(onAddWidgetClick, ...props);
        }, className: "absolute right-[100%] z-[1] translate-x-[50%]", onOpenAddWidget: (lineNumber2, side) => setWidget({ lineNumber: lineNumber2, side }) }),
        React.createElement(DiffContent, { enableWrap: true, diffFile, rawLine: newLine.value || "", diffLine: newLine.diff, plainLine: newPlainLine, syntaxLine: newSyntaxLine, enableHighlight })
      )
    ) : React.createElement(
      "td",
      { className: "diff-line-new-placeholder select-none border-l-[1px]", style: {
        backgroundColor: `var(${emptyBGName})`,
        borderLeftColor: `var(${borderColorName})`,
        borderLeftStyle: "solid"
      }, "data-side": SplitSide[SplitSide.new], colSpan: 2 },
      React.createElement("span", null, "")
    )
  );
};
var DiffSplitContentLine = ({ index, diffFile, lineNumber, enableAddWidget, enableHighlight }) => {
  const oldLine = diffFile.getSplitLeftLine(index);
  const newLine = diffFile.getSplitRightLine(index);
  if ((oldLine === null || oldLine === void 0 ? void 0 : oldLine.isHidden) && (newLine === null || newLine === void 0 ? void 0 : newLine.isHidden))
    return null;
  return React.createElement(InternalDiffSplitLine, { index, diffFile, lineNumber, enableAddWidget, enableHighlight });
};
var InternalDiffSplitExtendLine = ({ index, diffFile, lineNumber, oldLineExtend, newLineExtend }) => {
  const { useDiffContext } = useDiffViewContext();
  const oldLine = diffFile.getSplitLeftLine(index);
  const newLine = diffFile.getSplitRightLine(index);
  const renderExtendLine = useDiffContext.useShallowStableSelector((s) => s.renderExtendLine);
  if (!renderExtendLine)
    return null;
  const oldExtendRendered = (oldLineExtend === null || oldLineExtend === void 0 ? void 0 : oldLineExtend.data) && (renderExtendLine === null || renderExtendLine === void 0 ? void 0 : renderExtendLine({
    diffFile,
    side: SplitSide.old,
    lineNumber: oldLine.lineNumber,
    data: oldLineExtend.data,
    onUpdate: diffFile.notifyAll
  }));
  const newExtendRendered = (newLineExtend === null || newLineExtend === void 0 ? void 0 : newLineExtend.data) && (renderExtendLine === null || renderExtendLine === void 0 ? void 0 : renderExtendLine({
    diffFile,
    side: SplitSide.new,
    lineNumber: newLine.lineNumber,
    data: newLineExtend.data,
    onUpdate: diffFile.notifyAll
  }));
  return React.createElement(
    "tr",
    { "data-line": `${lineNumber}-extend`, "data-state": "extend", className: "diff-line diff-line-extend" },
    oldExtendRendered ? React.createElement(
      "td",
      { className: "diff-line-extend-old-content p-0", colSpan: 2 },
      React.createElement("div", { className: "diff-line-extend-wrapper" }, oldExtendRendered)
    ) : React.createElement("td", { className: "diff-line-extend-old-placeholder select-none p-0", style: { backgroundColor: `var(${emptyBGName})` }, colSpan: 2 }),
    newExtendRendered ? React.createElement(
      "td",
      { className: "diff-line-extend-new-content border-l-[1px] p-0", style: { borderLeftColor: `var(${borderColorName})`, borderLeftStyle: "solid" }, colSpan: 2 },
      React.createElement("div", { className: "diff-line-extend-wrapper" }, newExtendRendered)
    ) : React.createElement("td", { className: "diff-line-extend-new-placeholder select-none border-l-[1px] p-0", style: {
      backgroundColor: `var(${emptyBGName})`,
      borderLeftColor: `var(${borderColorName})`,
      borderLeftStyle: "solid"
    }, colSpan: 2 })
  );
};
var DiffSplitExtendLine = ({ index, diffFile, lineNumber }) => {
  const { useDiffContext } = useDiffViewContext();
  const oldLine = diffFile.getSplitLeftLine(index);
  const newLine = diffFile.getSplitRightLine(index);
  const { oldLineExtend, newLineExtend } = useDiffContext(React.useCallback((s) => {
    var _a, _b, _c, _d;
    return {
      oldLineExtend: (_b = (_a = s.extendData) === null || _a === void 0 ? void 0 : _a.oldFile) === null || _b === void 0 ? void 0 : _b[oldLine === null || oldLine === void 0 ? void 0 : oldLine.lineNumber],
      newLineExtend: (_d = (_c = s.extendData) === null || _c === void 0 ? void 0 : _c.newFile) === null || _d === void 0 ? void 0 : _d[newLine === null || newLine === void 0 ? void 0 : newLine.lineNumber]
    };
  }, [oldLine === null || oldLine === void 0 ? void 0 : oldLine.lineNumber, newLine === null || newLine === void 0 ? void 0 : newLine.lineNumber]));
  const hasExtend = (oldLineExtend === null || oldLineExtend === void 0 ? void 0 : oldLineExtend.data) || (newLineExtend === null || newLineExtend === void 0 ? void 0 : newLineExtend.data);
  const enableExpand = diffFile.getExpandEnabled();
  const currentIsShow = hasExtend && (!(oldLine === null || oldLine === void 0 ? void 0 : oldLine.isHidden) && !(newLine === null || newLine === void 0 ? void 0 : newLine.isHidden) || !enableExpand);
  if (!currentIsShow)
    return null;
  return React.createElement(InternalDiffSplitExtendLine, { index, diffFile, lineNumber, oldLineExtend, newLineExtend });
};
var DiffSplitHunkLineGitHub = ({ index, diffFile, lineNumber }) => {
  var _a;
  const currentHunk = diffFile.getSplitHunkLine(index);
  const expandEnabled = diffFile.getExpandEnabled();
  const couldExpand = expandEnabled && currentHunk && currentHunk.splitInfo;
  const isExpandAll = currentHunk && currentHunk.splitInfo && currentHunk.splitInfo.endHiddenIndex - currentHunk.splitInfo.startHiddenIndex < composeLen;
  const isFirstLine = currentHunk && currentHunk.isFirst;
  const isLastLine = currentHunk && currentHunk.isLast;
  return React.createElement(
    "tr",
    { "data-line": `${lineNumber}-hunk`, "data-state": "hunk", className: "diff-line diff-line-hunk" },
    React.createElement("td", { className: "diff-line-hunk-action relative w-[1%] min-w-[40px] select-none p-[1px]", style: {
      backgroundColor: `var(${hunkLineNumberBGName})`,
      color: `var(${plainLineNumberColorName})`
    } }, couldExpand ? isFirstLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
      React.createElement(ExpandUp, { className: "fill-current" })
    ) : isLastLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
      React.createElement(ExpandDown, { className: "fill-current" })
    ) : isExpandAll ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand All", "data-title": "Expand All", onClick: () => diffFile.onSplitHunkExpand("all", index) },
      React.createElement(ExpandAll, { className: "fill-current" })
    ) : React.createElement(
      React.Fragment,
      null,
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
        React.createElement(ExpandDown, { className: "fill-current" })
      ),
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
        React.createElement(ExpandUp, { className: "fill-current" })
      )
    ) : React.createElement("div", { className: "min-h-[28px]" }, "")),
    React.createElement(
      "td",
      { className: "diff-line-hunk-content pr-[10px] align-middle", style: { backgroundColor: `var(${hunkContentBGName})` }, colSpan: 3 },
      React.createElement("div", { className: "pl-[1.5em]", style: {
        color: `var(${hunkContentColorName})`
      } }, ((_a = currentHunk.splitInfo) === null || _a === void 0 ? void 0 : _a.plainText) || currentHunk.text)
    )
  );
};
var DiffSplitHunkLineGitLab = ({ index, diffFile, lineNumber }) => {
  var _a, _b;
  const currentHunk = diffFile.getSplitHunkLine(index);
  const expandEnabled = diffFile.getExpandEnabled();
  const couldExpand = expandEnabled && currentHunk && currentHunk.splitInfo;
  const isExpandAll = currentHunk && currentHunk.splitInfo && currentHunk.splitInfo.endHiddenIndex - currentHunk.splitInfo.startHiddenIndex < composeLen;
  const isFirstLine = currentHunk && currentHunk.isFirst;
  const isLastLine = currentHunk && currentHunk.isLast;
  return React.createElement(
    "tr",
    { "data-line": `${lineNumber}-hunk`, "data-state": "hunk", className: "diff-line diff-line-hunk" },
    React.createElement("td", { className: "diff-line-hunk-action relative w-[1%] min-w-[40px] select-none p-[1px]", style: {
      backgroundColor: `var(${hunkLineNumberBGName})`,
      color: `var(${plainLineNumberColorName})`
    } }, couldExpand ? isFirstLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
      React.createElement(ExpandUp, { className: "fill-current" })
    ) : isLastLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
      React.createElement(ExpandDown, { className: "fill-current" })
    ) : isExpandAll ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand All", "data-title": "Expand All", onClick: () => diffFile.onSplitHunkExpand("all", index) },
      React.createElement(ExpandAll, { className: "fill-current" })
    ) : React.createElement(
      React.Fragment,
      null,
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
        React.createElement(ExpandDown, { className: "fill-current" })
      ),
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
        React.createElement(ExpandUp, { className: "fill-current" })
      )
    ) : React.createElement("div", { className: "min-h-[28px]" }, "")),
    React.createElement(
      "td",
      { className: "diff-line-hunk-content pr-[10px] align-middle", style: { backgroundColor: `var(${hunkContentBGName})` } },
      React.createElement("div", { className: "pl-[1.5em]", style: {
        color: `var(${hunkContentColorName})`
      } }, ((_a = currentHunk.splitInfo) === null || _a === void 0 ? void 0 : _a.plainText) || currentHunk.text)
    ),
    React.createElement("td", { className: "diff-line-hunk-action relative z-[1] w-[1%] min-w-[40px] select-none border-l-[1px] p-[1px]", style: {
      backgroundColor: `var(${hunkLineNumberBGName})`,
      color: `var(${plainLineNumberColorName})`,
      borderLeftColor: `var(${borderColorName})`,
      borderLeftStyle: "solid"
    } }, couldExpand ? isFirstLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
      React.createElement(ExpandUp, { className: "fill-current" })
    ) : isLastLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
      React.createElement(ExpandDown, { className: "fill-current" })
    ) : isExpandAll ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand All", "data-title": "Expand All", onClick: () => diffFile.onSplitHunkExpand("all", index) },
      React.createElement(ExpandAll, { className: "fill-current" })
    ) : React.createElement(
      React.Fragment,
      null,
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onSplitHunkExpand("down", index) },
        React.createElement(ExpandDown, { className: "fill-current" })
      ),
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onSplitHunkExpand("up", index) },
        React.createElement(ExpandUp, { className: "fill-current" })
      )
    ) : React.createElement("div", { className: "min-h-[28px]" }, "")),
    React.createElement(
      "td",
      { className: "diff-line-hunk-content relative pr-[10px] align-middle", style: { backgroundColor: `var(${hunkContentBGName})` } },
      React.createElement("div", { className: "pl-[1.5em]", style: {
        color: `var(${hunkContentColorName})`
      } }, ((_b = currentHunk.splitInfo) === null || _b === void 0 ? void 0 : _b.plainText) || currentHunk.text)
    )
  );
};
var InternalDiffSplitHunkLine = ({ index, diffFile, lineNumber }) => {
  const { useDiffContext } = useDiffViewContext();
  const diffViewMode = useDiffContext.useShallowStableSelector((s) => s.mode);
  if (diffViewMode === DiffModeEnum.SplitGitHub || diffViewMode === DiffModeEnum.Split || diffViewMode === DiffModeEnum.Unified) {
    return React.createElement(DiffSplitHunkLineGitHub, { index, diffFile, lineNumber });
  } else {
    return React.createElement(DiffSplitHunkLineGitLab, { index, diffFile, lineNumber });
  }
};
var DiffSplitHunkLine = ({ index, diffFile, lineNumber }) => {
  const currentHunk = diffFile.getSplitHunkLine(index);
  const currentIsShow = currentHunk && currentHunk.splitInfo && currentHunk.splitInfo.startHiddenIndex < currentHunk.splitInfo.endHiddenIndex;
  const currentIsPureHunk = currentHunk && diffFile._getIsPureDiffRender() && !currentHunk.splitInfo;
  if (!currentIsShow && !currentIsPureHunk)
    return null;
  return React.createElement(InternalDiffSplitHunkLine, { index, diffFile, lineNumber });
};
var InternalDiffSplitWidgetLine = ({ index, diffFile, lineNumber }) => {
  const { useWidget } = useDiffWidgetContext();
  const setWidget = useWidget.getReadonlyState().setWidget;
  const { useDiffContext } = useDiffViewContext();
  const renderWidgetLine = useDiffContext.useShallowStableSelector((s) => s.renderWidgetLine);
  const oldLine = diffFile.getSplitLeftLine(index);
  const newLine = diffFile.getSplitRightLine(index);
  const widgetSide = useWidget.useShallowStableSelector((s) => s.widgetSide);
  const widgetLineNumber = useWidget.getReadonlyState().widgetLineNumber;
  const oldLineWidget = oldLine.lineNumber && widgetSide === SplitSide.old && widgetLineNumber === oldLine.lineNumber;
  const newLineWidget = newLine.lineNumber && widgetSide === SplitSide.new && widgetLineNumber === newLine.lineNumber;
  const oldWidgetRendered = oldLineWidget && (renderWidgetLine === null || renderWidgetLine === void 0 ? void 0 : renderWidgetLine({ diffFile, side: SplitSide.old, lineNumber: oldLine.lineNumber, onClose: () => setWidget({}) }));
  const newWidgetRendered = newLineWidget && (renderWidgetLine === null || renderWidgetLine === void 0 ? void 0 : renderWidgetLine({ diffFile, side: SplitSide.new, lineNumber: newLine.lineNumber, onClose: () => setWidget({}) }));
  if (!renderWidgetLine)
    return null;
  return React.createElement(
    "tr",
    { "data-line": `${lineNumber}-widget`, "data-state": "widget", className: "diff-line diff-line-widget" },
    oldWidgetRendered ? React.createElement(
      "td",
      { className: "diff-line-widget-old-content p-0", colSpan: 2 },
      React.createElement("div", { className: "diff-line-widget-wrapper" }, oldWidgetRendered)
    ) : React.createElement("td", { className: "diff-line-widget-old-placeholder select-none p-0", style: { backgroundColor: `var(${emptyBGName})` }, colSpan: 2 }),
    newWidgetRendered ? React.createElement(
      "td",
      { className: "diff-line-widget-new-content border-l-[1px] p-0", colSpan: 2, style: { borderLeftColor: `var(${borderColorName})`, borderLeftStyle: "solid" } },
      React.createElement("div", { className: "diff-line-widget-wrapper" }, newWidgetRendered)
    ) : React.createElement("td", { className: "diff-line-widget-new-placeholder select-none border-l-[1px] p-0", style: {
      backgroundColor: `var(${emptyBGName})`,
      borderLeftColor: `var(${borderColorName})`,
      borderLeftStyle: "solid"
    }, colSpan: 2 })
  );
};
var DiffSplitWidgetLine = ({ index, diffFile, lineNumber }) => {
  const { useWidget } = useDiffWidgetContext();
  const currentIsShow = useWidget.useShallowSelector(React.useCallback((s) => {
    const widgetLineNumber = s.widgetLineNumber;
    const widgetSide = s.widgetSide;
    const oldLine = diffFile.getSplitLeftLine(index);
    const newLine = diffFile.getSplitRightLine(index);
    const oldLineWidget = oldLine.lineNumber && widgetSide === SplitSide.old && widgetLineNumber === oldLine.lineNumber;
    const newLineWidget = newLine.lineNumber && widgetSide === SplitSide.new && widgetLineNumber === newLine.lineNumber;
    const currentIsShow2 = oldLineWidget || newLineWidget;
    return currentIsShow2;
  }, [diffFile, index]), (p, c) => p === c);
  if (!currentIsShow)
    return null;
  return React.createElement(InternalDiffSplitWidgetLine, { index, diffFile, lineNumber });
};
var DiffSplitViewWrap = (0, import_react2.memo)(({ diffFile }) => {
  const splitLineLength = Math.max(diffFile.splitLineLength, diffFile.fileLineLength);
  const { useDiffContext } = useDiffViewContext();
  const ref2 = (0, import_react2.useRef)(null);
  const tempRef = (0, import_react2.useRef)();
  const { fontSize, enableAddWidget, enableHighlight } = useDiffContext.useShallowStableSelector((s) => ({
    fontSize: s.fontSize,
    enableAddWidget: s.enableAddWidget,
    enableHighlight: s.enableHighlight
  }));
  (0, import_shim2.useSyncExternalStore)(diffFile.subscribe, diffFile.getUpdateCount, diffFile.getUpdateCount);
  const font = (0, import_react2.useMemo)(() => ({ fontSize: fontSize + "px", fontFamily: "Menlo, Consolas, monospace" }), [fontSize]);
  const _width = useTextWidth({
    text: splitLineLength.toString(),
    font
  });
  const width = Math.max(40, _width + 25);
  const lines = getSplitContentLines(diffFile);
  const setStyle = (side) => {
    if (!ref2.current)
      return;
    if (!side) {
      ref2.current.textContent = "";
    } else {
      const id = `diff-root${diffFile.getId()}`;
      const targetSide = side === SplitSide.old ? SplitSide.new : SplitSide.old;
      ref2.current.textContent = `#${id} [data-side="${SplitSide[targetSide]}"] {user-select: none} 
#${id} [data-state="extend"] {user-select: none} 
#${id} [data-state="hunk"] {user-select: none} 
#${id} [data-state="widget"] {user-select: none}`;
    }
  };
  const onMouseDown = (e) => {
    let ele = e.target;
    if (ele && ele instanceof HTMLElement && ele.nodeName === "BUTTON") {
      removeAllSelection();
      return;
    }
    while (ele && ele instanceof HTMLElement) {
      const state = ele.getAttribute("data-state");
      const side = ele.getAttribute("data-side");
      if (side) {
        if (tempRef.current !== SplitSide[side]) {
          tempRef.current = SplitSide[side];
          setStyle(SplitSide[side]);
          removeAllSelection();
        }
      }
      if (state) {
        if (state === "extend" || state === "hunk" || state === "widget") {
          if (tempRef.current !== void 0) {
            tempRef.current = void 0;
            setStyle(void 0);
            removeAllSelection();
          }
          return;
        } else {
          return;
        }
      }
      ele = ele.parentElement;
    }
  };
  return React.createElement(
    "div",
    { className: "split-diff-view split-diff-view-wrap w-full" },
    React.createElement(
      "div",
      { className: "diff-table-wrapper w-full", style: {
        // @ts-ignore
        [diffAsideWidthName]: `${Math.round(width)}px`,
        fontFamily: "Menlo, Consolas, monospace",
        fontSize: `var(${diffFontSizeName})`
      } },
      React.createElement("style", { "data-select-style": true, ref: ref2 }),
      React.createElement(
        "table",
        { className: "diff-table w-full table-fixed border-collapse border-spacing-0" },
        React.createElement(
          "colgroup",
          null,
          React.createElement("col", { className: "diff-table-old-num-col", width: Math.round(width) }),
          React.createElement("col", { className: "diff-table-old-content-col" }),
          React.createElement("col", { className: "diff-table-new-num-col", width: Math.round(width) }),
          React.createElement("col", { className: "diff-table-new-content-col" })
        ),
        React.createElement(
          "thead",
          { className: "hidden" },
          React.createElement(
            "tr",
            null,
            React.createElement("th", { scope: "col" }, "old line number"),
            React.createElement("th", { scope: "col" }, "old line content"),
            React.createElement("th", { scope: "col" }, "new line number"),
            React.createElement("th", { scope: "col" }, "new line content")
          )
        ),
        React.createElement(
          "tbody",
          { className: "diff-table-body leading-[1.4]", onMouseDownCapture: onMouseDown },
          lines.map((line) => React.createElement(
            import_react2.Fragment,
            { key: line.index },
            React.createElement(DiffSplitHunkLine, { index: line.index, lineNumber: line.lineNumber, diffFile }),
            React.createElement(DiffSplitContentLine, { index: line.index, lineNumber: line.lineNumber, diffFile, enableAddWidget, enableHighlight }),
            React.createElement(DiffSplitWidgetLine, { index: line.index, lineNumber: line.lineNumber, diffFile }),
            React.createElement(DiffSplitExtendLine, { index: line.index, lineNumber: line.lineNumber, diffFile })
          )),
          React.createElement(DiffSplitHunkLine, { index: diffFile.splitLineLength, lineNumber: diffFile.splitLineLength, diffFile })
        )
      )
    )
  );
});
DiffSplitViewWrap.displayName = "DiffSplitViewWrap";
var createDiffConfigStore = (props, diffFileId) => {
  return createStore(() => {
    var _a, _b;
    const id = ref(diffFileId);
    const setId = (_id) => id.value = _id;
    const mode = ref(props.diffViewMode);
    const setMode = (_mode) => mode.value = _mode;
    const mounted = ref(props.isMounted);
    const setMounted = (_mounted) => mounted.value = _mounted;
    const enableWrap = ref(props.diffViewWrap);
    const setEnableWrap = (_enableWrap) => enableWrap.value = _enableWrap;
    const enableAddWidget = ref(props.diffViewAddWidget);
    const setEnableAddWidget = (_enableAddWidget) => enableAddWidget.value = _enableAddWidget;
    const enableHighlight = ref(props.diffViewHighlight);
    const setEnableHighlight = (_enableHighlight) => enableHighlight.value = _enableHighlight;
    const fontSize = ref(props.diffViewFontSize);
    const setFontSize = (_fontSize) => fontSize.value = _fontSize;
    const extendData = ref({
      oldFile: Object.assign({}, (_a = props.extendData) === null || _a === void 0 ? void 0 : _a.oldFile),
      newFile: Object.assign({}, (_b = props.extendData) === null || _b === void 0 ? void 0 : _b.newFile)
    });
    const setExtendData = (_extendData) => {
      const existOldKeys = Object.keys(extendData.value.oldFile || {});
      const inComingOldKeys = Object.keys(_extendData.oldFile || {});
      for (const key of existOldKeys) {
        if (!inComingOldKeys.includes(key)) {
          delete extendData.value.oldFile[key];
        }
      }
      for (const key of inComingOldKeys) {
        extendData.value.oldFile[key] = _extendData.oldFile[key];
      }
      const existNewKeys = Object.keys(extendData.value.newFile || {});
      const inComingNewKeys = Object.keys(_extendData.newFile || {});
      for (const key of existNewKeys) {
        if (!inComingNewKeys.includes(key)) {
          delete extendData.value.newFile[key];
        }
      }
      for (const key of inComingNewKeys) {
        extendData.value.newFile[key] = _extendData.newFile[key];
      }
    };
    const renderWidgetLine = ref(props.renderWidgetLine);
    const setRenderWidgetLine = (_renderWidgetLine) => renderWidgetLine.value = _renderWidgetLine;
    const renderExtendLine = ref(props.renderExtendLine);
    const setRenderExtendLine = (_renderExtendLine) => renderExtendLine.value = _renderExtendLine;
    const onCreateUseWidgetHook = ref(props.onCreateUseWidgetHook);
    const setOnCreateUseWidgetHook = (_onCreateUseWidgetHook) => onCreateUseWidgetHook.value = _onCreateUseWidgetHook;
    const onAddWidgetClick = { current: props.onAddWidgetClick };
    const setOnAddWidgetClick = (_onAddWidgetClick) => onAddWidgetClick.current = _onAddWidgetClick.current;
    return {
      id,
      setId,
      mode,
      setMode,
      mounted,
      setMounted,
      enableWrap,
      setEnableWrap,
      enableAddWidget,
      setEnableAddWidget,
      enableHighlight,
      setEnableHighlight,
      fontSize,
      setFontSize,
      extendData,
      setExtendData,
      renderWidgetLine,
      setRenderWidgetLine,
      renderExtendLine,
      setRenderExtendLine,
      onAddWidgetClick,
      setOnAddWidgetClick,
      onCreateUseWidgetHook,
      setOnCreateUseWidgetHook
    };
  });
};
var createDiffWidgetStore = (useDiffContextRef) => {
  return createStore(() => {
    const widgetSide = ref(void 0);
    const widgetLineNumber = ref(void 0);
    const setWidget = ({ side, lineNumber }) => {
      var _a, _b;
      const { renderWidgetLine } = ((_b = (_a = useDiffContextRef.current) === null || _a === void 0 ? void 0 : _a.getReadonlyState) === null || _b === void 0 ? void 0 : _b.call(_a)) || {};
      if (typeof renderWidgetLine !== "function")
        return;
      widgetSide.value = side;
      widgetLineNumber.value = lineNumber;
    };
    return { widgetSide, widgetLineNumber, setWidget };
  });
};
var DiffSplitView = (0, import_react2.memo)(({ diffFile }) => {
  const { useDiffContext } = useDiffViewContext();
  const useDiffContextRef = (0, import_react2.useRef)(useDiffContext);
  useDiffContextRef.current = useDiffContext;
  const { enableWrap, onCreateUseWidgetHook } = useDiffContext.useShallowStableSelector((s) => ({
    enableWrap: s.enableWrap,
    onCreateUseWidgetHook: s.onCreateUseWidgetHook
  }));
  const useWidget = (0, import_react2.useMemo)(() => createDiffWidgetStore(useDiffContextRef), []);
  const contextValue = (0, import_react2.useMemo)(() => ({ useWidget }), [useWidget]);
  (0, import_react2.useEffect)(() => {
    const { setWidget } = useWidget.getReadonlyState();
    setWidget({});
  }, [diffFile, useWidget]);
  (0, import_react2.useEffect)(() => {
    onCreateUseWidgetHook === null || onCreateUseWidgetHook === void 0 ? void 0 : onCreateUseWidgetHook(useWidget);
  }, [useWidget, onCreateUseWidgetHook]);
  return React.createElement(DiffWidgetContext.Provider, { value: contextValue }, enableWrap ? React.createElement(DiffSplitViewWrap, { diffFile }) : React.createElement(DiffSplitViewNormal, { diffFile }));
});
DiffSplitView.displayName = "DiffSplitView";
var DiffUnifiedOldLine = ({ index, diffLine, rawLine, plainLine, syntaxLine, lineNumber, diffFile, setWidget, enableWrap, enableAddWidget, enableHighlight, onAddWidgetClick }) => {
  return React.createElement(
    "tr",
    { "data-line": index, "data-state": "diff", className: "diff-line group" },
    React.createElement(
      "td",
      { className: "diff-line-num sticky left-0 z-[1] w-[1%] min-w-[100px] select-none whitespace-nowrap pl-[10px] pr-[10px] text-right align-top", style: {
        color: `var(${plainLineNumberColorName})`,
        backgroundColor: `var(${delLineNumberBGName})`,
        width: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`,
        maxWidth: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`,
        minWidth: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`
      } },
      enableAddWidget && React.createElement(DiffUnifiedAddWidget, { index: index - 1, lineNumber, diffFile, side: SplitSide.old, onWidgetClick: onAddWidgetClick, onOpenAddWidget: (lineNumber2, side) => setWidget({ lineNumber: lineNumber2, side }) }),
      React.createElement(
        "div",
        { className: "flex" },
        React.createElement("span", { "data-line-old-num": lineNumber, className: "inline-block w-[50%]" }, lineNumber),
        React.createElement("span", { className: "w-[10px] shrink-0" }),
        React.createElement("span", { className: "inline-block w-[50%]" })
      )
    ),
    React.createElement(
      "td",
      { className: "diff-line-content pr-[10px] align-top", style: { backgroundColor: `var(${delContentBGName})` } },
      React.createElement(DiffContent, { enableWrap, diffFile, enableHighlight, rawLine, diffLine, plainLine, syntaxLine })
    )
  );
};
var DiffUnifiedNewLine = ({ index, diffLine, rawLine, plainLine, syntaxLine, lineNumber, diffFile, setWidget, enableWrap, enableAddWidget, enableHighlight, onAddWidgetClick }) => {
  return React.createElement(
    "tr",
    { "data-line": index, "data-state": "diff", className: "diff-line group" },
    React.createElement(
      "td",
      { className: "diff-line-num sticky left-0 z-[1] w-[1%] min-w-[100px] select-none whitespace-nowrap pl-[10px] pr-[10px] text-right align-top", style: {
        color: `var(${plainLineNumberColorName})`,
        backgroundColor: `var(${addLineNumberBGName})`,
        width: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`,
        maxWidth: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`,
        minWidth: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`
      } },
      enableAddWidget && React.createElement(DiffUnifiedAddWidget, { index: index - 1, lineNumber, diffFile, side: SplitSide.new, onWidgetClick: onAddWidgetClick, onOpenAddWidget: (lineNumber2, side) => setWidget({ lineNumber: lineNumber2, side }) }),
      React.createElement(
        "div",
        { className: "flex" },
        React.createElement("span", { className: "inline-block w-[50%]" }),
        React.createElement("span", { className: "w-[10px] shrink-0" }),
        React.createElement("span", { "data-line-new-num": lineNumber, className: "inline-block w-[50%]" }, lineNumber)
      )
    ),
    React.createElement(
      "td",
      { className: "diff-line-content pr-[10px] align-top", style: { backgroundColor: `var(${addContentBGName})` } },
      React.createElement(DiffContent, { enableWrap, diffFile, enableHighlight, rawLine, diffLine, plainLine, syntaxLine })
    )
  );
};
var _DiffUnifiedLine = (0, import_react2.memo)(({ index, diffFile, lineNumber, enableWrap, enableAddWidget, enableHighlight }) => {
  const unifiedLine = diffFile.getUnifiedLine(index);
  const { useDiffContext } = useDiffViewContext();
  const onAddWidgetClick = useDiffContext.getReadonlyState().onAddWidgetClick;
  const { useWidget } = useDiffWidgetContext();
  const setWidget = useWidget.getReadonlyState().setWidget;
  const hasDiff = unifiedLine.diff;
  const hasChange = checkDiffLineIncludeChange(unifiedLine.diff);
  const rawLine = unifiedLine.value || "";
  const diffLine = unifiedLine.diff;
  const newLineNumber = unifiedLine.newLineNumber;
  const oldLinenumber = unifiedLine.oldLineNumber;
  const syntaxLine = newLineNumber ? diffFile.getNewSyntaxLine(newLineNumber) : oldLinenumber ? diffFile.getOldSyntaxLine(oldLinenumber) : void 0;
  const plainLine = newLineNumber ? diffFile.getNewPlainLine(newLineNumber) : oldLinenumber ? diffFile.getOldPlainLine(oldLinenumber) : void 0;
  if (hasChange) {
    if (unifiedLine.oldLineNumber) {
      return React.createElement(DiffUnifiedOldLine, { index: lineNumber, enableWrap, diffFile, rawLine, diffLine, setWidget, plainLine, syntaxLine, enableHighlight, enableAddWidget, lineNumber: unifiedLine.oldLineNumber, onAddWidgetClick: (...props) => {
        var _a;
        return (_a = onAddWidgetClick.current) === null || _a === void 0 ? void 0 : _a.call(onAddWidgetClick, ...props);
      } });
    } else {
      return React.createElement(DiffUnifiedNewLine, { index: lineNumber, enableWrap, rawLine, diffLine, diffFile, setWidget, plainLine, syntaxLine, enableHighlight, enableAddWidget, lineNumber: unifiedLine.newLineNumber, onAddWidgetClick: (...props) => {
        var _a;
        return (_a = onAddWidgetClick.current) === null || _a === void 0 ? void 0 : _a.call(onAddWidgetClick, ...props);
      } });
    }
  } else {
    return React.createElement(
      "tr",
      { "data-line": lineNumber, "data-state": unifiedLine.diff ? "diff" : "plain", className: "diff-line group" },
      React.createElement(
        "td",
        { className: "diff-line-num sticky left-0 z-[1] w-[1%] min-w-[100px] select-none whitespace-nowrap pl-[10px] pr-[10px] text-right align-top", style: {
          color: `var(${hasDiff ? plainLineNumberColorName : expandLineNumberColorName})`,
          width: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`,
          maxWidth: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`,
          minWidth: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`,
          backgroundColor: hasDiff ? `var(${plainLineNumberBGName})` : `var(${expandContentBGName})`
        } },
        enableAddWidget && hasDiff && React.createElement(DiffUnifiedAddWidget, { index, diffFile, lineNumber: unifiedLine.newLineNumber, side: SplitSide.new, onWidgetClick: (...props) => {
          var _a;
          return (_a = onAddWidgetClick.current) === null || _a === void 0 ? void 0 : _a.call(onAddWidgetClick, ...props);
        }, onOpenAddWidget: (lineNumber2, side) => setWidget({ lineNumber: lineNumber2, side }) }),
        React.createElement(
          "div",
          { className: "flex opacity-[0.5]" },
          React.createElement("span", { "data-line-old-num": unifiedLine.oldLineNumber, className: "inline-block w-[50%]" }, unifiedLine.oldLineNumber),
          React.createElement("span", { className: "w-[10px] shrink-0" }),
          React.createElement("span", { "data-line-new-num": unifiedLine.newLineNumber, className: "inline-block w-[50%]" }, unifiedLine.newLineNumber)
        )
      ),
      React.createElement(
        "td",
        { className: "diff-line-content pr-[10px] align-top", style: {
          backgroundColor: hasDiff ? `var(${plainContentBGName})` : `var(${expandContentBGName})`
        } },
        React.createElement(DiffContent, { enableWrap, diffFile, enableHighlight, rawLine, diffLine, plainLine, syntaxLine })
      )
    );
  }
});
_DiffUnifiedLine.displayName = "_DiffUnifiedLine";
var DiffUnifiedContentLine = ({ index, diffFile, lineNumber, enableWrap, enableHighlight, enableAddWidget }) => {
  const unifiedLine = diffFile.getUnifiedLine(index);
  if (unifiedLine === null || unifiedLine === void 0 ? void 0 : unifiedLine.isHidden)
    return null;
  return React.createElement(_DiffUnifiedLine, { index, diffFile, lineNumber, enableWrap, enableHighlight, enableAddWidget });
};
var InternalDiffUnifiedExtendLine = ({ index, diffFile, lineNumber, oldLineExtend, newLineExtend }) => {
  const { useDiffContext } = useDiffViewContext();
  const renderExtendLine = useDiffContext.useShallowStableSelector((s) => s.renderExtendLine);
  const unifiedItem = diffFile.getUnifiedLine(index);
  const width = useDomWidth({
    selector: ".unified-diff-table-wrapper",
    enable: typeof renderExtendLine === "function"
  });
  if (!renderExtendLine)
    return null;
  return React.createElement(
    "tr",
    { "data-line": `${lineNumber}-extend`, "data-state": "extend", className: "diff-line diff-line-extend" },
    React.createElement(
      "td",
      { className: "diff-line-extend-content p-0 align-top", colSpan: 2 },
      React.createElement(
        "div",
        { className: "diff-line-extend-wrapper sticky left-0 z-[1]", style: { width } },
        width > 0 && (oldLineExtend === null || oldLineExtend === void 0 ? void 0 : oldLineExtend.data) !== void 0 && (oldLineExtend === null || oldLineExtend === void 0 ? void 0 : oldLineExtend.data) !== null && (renderExtendLine === null || renderExtendLine === void 0 ? void 0 : renderExtendLine({
          diffFile,
          side: SplitSide.old,
          lineNumber: unifiedItem.oldLineNumber,
          data: oldLineExtend.data,
          onUpdate: diffFile.notifyAll
        })),
        width > 0 && (newLineExtend === null || newLineExtend === void 0 ? void 0 : newLineExtend.data) !== void 0 && (newLineExtend === null || newLineExtend === void 0 ? void 0 : newLineExtend.data) !== null && (renderExtendLine === null || renderExtendLine === void 0 ? void 0 : renderExtendLine({
          diffFile,
          side: SplitSide.new,
          lineNumber: unifiedItem.newLineNumber,
          data: newLineExtend.data,
          onUpdate: diffFile.notifyAll
        }))
      )
    )
  );
};
var DiffUnifiedExtendLine = ({ index, diffFile, lineNumber }) => {
  const { useDiffContext } = useDiffViewContext();
  const unifiedItem = diffFile.getUnifiedLine(index);
  const { oldLineExtend, newLineExtend } = useDiffContext((0, import_react2.useCallback)((s) => {
    var _a, _b, _c, _d;
    return {
      oldLineExtend: (_b = (_a = s.extendData) === null || _a === void 0 ? void 0 : _a.oldFile) === null || _b === void 0 ? void 0 : _b[unifiedItem === null || unifiedItem === void 0 ? void 0 : unifiedItem.oldLineNumber],
      newLineExtend: (_d = (_c = s.extendData) === null || _c === void 0 ? void 0 : _c.newFile) === null || _d === void 0 ? void 0 : _d[unifiedItem === null || unifiedItem === void 0 ? void 0 : unifiedItem.newLineNumber]
    };
  }, [unifiedItem.oldLineNumber, unifiedItem.newLineNumber]));
  const hasExtend = (oldLineExtend === null || oldLineExtend === void 0 ? void 0 : oldLineExtend.data) || (newLineExtend === null || newLineExtend === void 0 ? void 0 : newLineExtend.data);
  if (!hasExtend || !unifiedItem || unifiedItem.isHidden)
    return null;
  return React.createElement(InternalDiffUnifiedExtendLine, { index, diffFile, lineNumber, oldLineExtend, newLineExtend });
};
var InternalDiffUnifiedHunkLine = ({ index, diffFile, lineNumber }) => {
  var _a;
  const currentHunk = diffFile.getUnifiedHunkLine(index);
  const expandEnabled = diffFile.getExpandEnabled();
  const { useDiffContext } = useDiffViewContext();
  const enableWrap = useDiffContext.useShallowStableSelector((s) => s.enableWrap);
  const couldExpand = expandEnabled && currentHunk && currentHunk.unifiedInfo;
  const isExpandAll = currentHunk && currentHunk.unifiedInfo && currentHunk.unifiedInfo.endHiddenIndex - currentHunk.unifiedInfo.startHiddenIndex < composeLen;
  const isFirstLine = currentHunk && currentHunk.isFirst;
  const isLastLine = currentHunk && currentHunk.isLast;
  return React.createElement(
    "tr",
    { "data-line": `${lineNumber}-hunk`, "data-state": "hunk", className: "diff-line diff-line-hunk" },
    React.createElement("td", { className: "diff-line-hunk-action sticky left-0 w-[1%] min-w-[100px] select-none p-[1px]", style: {
      backgroundColor: `var(${hunkLineNumberBGName})`,
      color: `var(${plainLineNumberColorName})`,
      width: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`,
      maxWidth: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`,
      minWidth: `calc(calc(var(${diffAsideWidthName}) + 5px) * 2)`
    } }, couldExpand ? isFirstLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onUnifiedHunkExpand("up", index) },
      React.createElement(ExpandUp, { className: "fill-current" })
    ) : isLastLine ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onUnifiedHunkExpand("down", index) },
      React.createElement(ExpandDown, { className: "fill-current" })
    ) : isExpandAll ? React.createElement(
      "button",
      { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[6px]", title: "Expand All", "data-title": "Expand All", onClick: () => diffFile.onUnifiedHunkExpand("all", index) },
      React.createElement(ExpandAll, { className: "fill-current" })
    ) : React.createElement(
      React.Fragment,
      null,
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Down", "data-title": "Expand Down", onClick: () => diffFile.onUnifiedHunkExpand("down", index) },
        React.createElement(ExpandDown, { className: "fill-current" })
      ),
      React.createElement(
        "button",
        { className: "diff-widget-tooltip flex w-full cursor-pointer items-center justify-center rounded-[2px] py-[2px]", title: "Expand Up", "data-title": "Expand Up", onClick: () => diffFile.onUnifiedHunkExpand("up", index) },
        React.createElement(ExpandUp, { className: "fill-current" })
      )
    ) : React.createElement("div", { className: "min-h-[28px]" }, "")),
    React.createElement(
      "td",
      { className: "diff-line-hunk-content pr-[10px] align-middle", style: { backgroundColor: `var(${hunkContentBGName})` } },
      React.createElement("div", { className: "pl-[1.5em]", style: {
        whiteSpace: enableWrap ? "pre-wrap" : "pre",
        wordBreak: enableWrap ? "break-all" : "initial",
        color: `var(${hunkContentColorName})`
      } }, ((_a = currentHunk.unifiedInfo) === null || _a === void 0 ? void 0 : _a.plainText) || currentHunk.text)
    )
  );
};
var DiffUnifiedHunkLine = ({ index, diffFile, lineNumber }) => {
  const currentHunk = diffFile.getUnifiedHunkLine(index);
  const currentIsShow = currentHunk && currentHunk.unifiedInfo && currentHunk.unifiedInfo.startHiddenIndex < currentHunk.unifiedInfo.endHiddenIndex;
  const currentIsPureHunk = currentHunk && diffFile._getIsPureDiffRender() && !currentHunk.unifiedInfo;
  if (!currentIsShow && !currentIsPureHunk)
    return null;
  return React.createElement(InternalDiffUnifiedHunkLine, { index, diffFile, lineNumber });
};
var InternalDiffUnifiedWidgetLine = ({ index, diffFile, lineNumber }) => {
  const { useWidget } = useDiffWidgetContext();
  const setWidget = useWidget.getReadonlyState().setWidget;
  const unifiedItem = diffFile.getUnifiedLine(index);
  const onClose = () => setWidget({});
  const widgetSide = useWidget.getReadonlyState().widgetSide;
  const widgetLineNumber = useWidget.getReadonlyState().widgetLineNumber;
  const oldWidget = unifiedItem.oldLineNumber && widgetSide === SplitSide.old && widgetLineNumber === unifiedItem.oldLineNumber;
  const newWidget = unifiedItem.newLineNumber && widgetSide === SplitSide.new && widgetLineNumber === unifiedItem.newLineNumber;
  const { useDiffContext } = useDiffViewContext();
  const renderWidgetLine = useDiffContext.useShallowStableSelector((s) => s.renderWidgetLine);
  const width = useDomWidth({
    selector: ".unified-diff-table-wrapper",
    enable: typeof renderWidgetLine === "function"
  });
  if (!renderWidgetLine)
    return null;
  return React.createElement(
    "tr",
    { "data-line": `${lineNumber}-widget`, "data-state": "widget", className: "diff-line diff-line-widget" },
    React.createElement(
      "td",
      { className: "diff-line-widget-content p-0", colSpan: 2 },
      React.createElement(
        "div",
        { className: "diff-line-widget-wrapper sticky left-0 z-[1]", style: { width } },
        width > 0 && oldWidget && (renderWidgetLine === null || renderWidgetLine === void 0 ? void 0 : renderWidgetLine({ diffFile, side: SplitSide.old, lineNumber: unifiedItem.oldLineNumber, onClose })),
        width > 0 && newWidget && (renderWidgetLine === null || renderWidgetLine === void 0 ? void 0 : renderWidgetLine({ diffFile, side: SplitSide.new, lineNumber: unifiedItem.newLineNumber, onClose }))
      )
    )
  );
};
var DiffUnifiedWidgetLine = ({ index, diffFile, lineNumber }) => {
  const { useWidget } = useDiffWidgetContext();
  const currentIsShow = useWidget.useShallowSelector(React.useCallback((s) => {
    const widgetLineNumber = s.widgetLineNumber;
    const widgetSide = s.widgetSide;
    const unifiedItem = diffFile.getUnifiedLine(index);
    const oldWidget = unifiedItem.oldLineNumber && widgetSide === SplitSide.old && widgetLineNumber === unifiedItem.oldLineNumber;
    const newWidget = unifiedItem.newLineNumber && widgetSide === SplitSide.new && widgetLineNumber === unifiedItem.newLineNumber;
    const currentIsShow2 = oldWidget || newWidget;
    return currentIsShow2;
  }, [diffFile, index]), (p, c) => p === c);
  if (!currentIsShow)
    return null;
  return React.createElement(InternalDiffUnifiedWidgetLine, { index, diffFile, lineNumber });
};
var DiffUnifiedView = (0, import_react2.memo)(({ diffFile }) => {
  const { useDiffContext } = useDiffViewContext();
  const ref2 = (0, import_react2.useRef)(null);
  const tempRef = (0, import_react2.useRef)();
  const useDiffContextRef = (0, import_react2.useRef)(useDiffContext);
  useDiffContextRef.current = useDiffContext;
  const useWidget = (0, import_react2.useMemo)(() => createDiffWidgetStore(useDiffContextRef), []);
  const contextValue = (0, import_react2.useMemo)(() => ({ useWidget }), [useWidget]);
  const { fontSize, enableWrap, enableHighlight, enableAddWidget, onCreateUseWidgetHook } = useDiffContext.useShallowStableSelector((s) => ({
    fontSize: s.fontSize,
    enableWrap: s.enableWrap,
    enableHighlight: s.enableHighlight,
    enableAddWidget: s.enableAddWidget,
    onCreateUseWidgetHook: s.onCreateUseWidgetHook
  }));
  (0, import_shim2.useSyncExternalStore)(diffFile.subscribe, diffFile.getUpdateCount, diffFile.getUpdateCount);
  (0, import_react2.useEffect)(() => {
    const { setWidget } = useWidget.getReadonlyState();
    setWidget({});
  }, [diffFile, useWidget]);
  (0, import_react2.useEffect)(() => {
    onCreateUseWidgetHook === null || onCreateUseWidgetHook === void 0 ? void 0 : onCreateUseWidgetHook(useWidget);
  }, [useWidget, onCreateUseWidgetHook]);
  const unifiedLineLength = Math.max(diffFile.unifiedLineLength, diffFile.fileLineLength);
  const _width = useTextWidth({
    text: unifiedLineLength.toString(),
    font: (0, import_react2.useMemo)(() => ({ fontSize: fontSize + "px", fontFamily: "Menlo, Consolas, monospace" }), [fontSize])
  });
  const width = Math.max(40, _width + 10);
  const lines = getUnifiedContentLine(diffFile);
  const setStyle = (side) => {
    if (!ref2.current)
      return;
    if (!side) {
      ref2.current.textContent = "";
    } else {
      const id = `diff-root${diffFile.getId()}`;
      ref2.current.textContent = `#${id} [data-state="extend"] {user-select: none} 
#${id} [data-state="hunk"] {user-select: none} 
#${id} [data-state="widget"] {user-select: none}`;
    }
  };
  const onMouseDown = (e) => {
    let ele = e.target;
    if (ele && ele instanceof HTMLElement && ele.nodeName === "BUTTON") {
      removeAllSelection();
      return;
    }
    while (ele && ele instanceof HTMLElement) {
      const state = ele.getAttribute("data-state");
      if (state) {
        if (state === "extend" || state === "hunk" || state === "widget") {
          if (tempRef.current !== void 0) {
            tempRef.current = void 0;
            setStyle(void 0);
            removeAllSelection();
          }
          return;
        } else {
          if (tempRef.current !== SplitSide.new) {
            tempRef.current = SplitSide.new;
            setStyle(SplitSide.new);
            removeAllSelection();
          }
          return;
        }
      }
      ele = ele.parentElement;
    }
  };
  return React.createElement(
    DiffWidgetContext.Provider,
    { value: contextValue },
    React.createElement(
      "div",
      { className: `unified-diff-view ${enableWrap ? "unified-diff-view-wrap" : "unified-diff-view-normal"} w-full` },
      React.createElement("style", { "data-select-style": true, ref: ref2 }),
      React.createElement(
        "div",
        { className: "unified-diff-table-wrapper diff-table-scroll-container w-full overflow-x-auto overflow-y-hidden", style: {
          // @ts-ignore
          [diffAsideWidthName]: `${Math.round(width)}px`,
          fontFamily: "Menlo, Consolas, monospace",
          fontSize: `var(${diffFontSizeName})`
        } },
        React.createElement(
          "table",
          { className: `unified-diff-table w-full border-collapse border-spacing-0 ${enableWrap ? "table-fixed" : ""}` },
          React.createElement(
            "colgroup",
            null,
            React.createElement("col", { className: "unified-diff-table-num-col" }),
            React.createElement("col", { className: "unified-diff-table-content-col" })
          ),
          React.createElement(
            "thead",
            { className: "hidden" },
            React.createElement(
              "tr",
              null,
              React.createElement("th", { scope: "col" }, "line number"),
              React.createElement("th", { scope: "col" }, "line content")
            )
          ),
          React.createElement(
            "tbody",
            { className: "diff-table-body leading-[1.4]", onMouseDownCapture: onMouseDown },
            lines.map((item) => React.createElement(
              import_react2.Fragment,
              { key: item.index },
              React.createElement(DiffUnifiedHunkLine, { index: item.index, lineNumber: item.lineNumber, diffFile }),
              React.createElement(DiffUnifiedContentLine, { index: item.index, lineNumber: item.lineNumber, diffFile, enableWrap, enableHighlight, enableAddWidget }),
              React.createElement(DiffUnifiedWidgetLine, { index: item.index, lineNumber: item.lineNumber, diffFile }),
              React.createElement(DiffUnifiedExtendLine, { index: item.index, lineNumber: item.lineNumber, diffFile })
            )),
            React.createElement(DiffUnifiedHunkLine, { index: diffFile.unifiedLineLength, lineNumber: diffFile.unifiedLineLength, diffFile })
          )
        )
      )
    )
  );
});
DiffUnifiedView.displayName = "DiffUnifiedView";
_cacheMap.name = "@git-diff-view/react";
var InternalDiffView = (props) => {
  const { diffFile, className, style, wrapperRef, diffViewMode, diffViewWrap, diffViewFontSize, diffViewHighlight, renderWidgetLine, renderExtendLine, extendData, diffViewAddWidget, onAddWidgetClick, onCreateUseWidgetHook, isMounted } = props;
  const diffFileId = (0, import_react2.useMemo)(() => diffFile.getId(), [diffFile]);
  const useDiffContext = (0, import_react2.useMemo)(
    () => createDiffConfigStore(props, diffFileId),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  (0, import_react2.useEffect)(() => {
    const { id, setId, mode, setMode, mounted, setMounted, enableAddWidget, setEnableAddWidget, enableHighlight, setEnableHighlight, enableWrap, setEnableWrap, setExtendData, fontSize, setFontSize, onAddWidgetClick: _onAddWidgetClick, setOnAddWidgetClick, renderExtendLine: _renderExtendLine, setRenderExtendLine, renderWidgetLine: _renderWidgetLine, setRenderWidgetLine, onCreateUseWidgetHook: _onCreateUseWidgetHook, setOnCreateUseWidgetHook } = useDiffContext.getReadonlyState();
    if (diffFileId && diffFileId !== id) {
      setId(diffFileId);
    }
    if (diffViewMode && diffViewMode !== mode) {
      setMode(diffViewMode);
    }
    if (mounted !== isMounted) {
      setMounted(isMounted);
    }
    if (diffViewAddWidget !== enableAddWidget) {
      setEnableAddWidget(diffViewAddWidget);
    }
    if (diffViewHighlight !== enableHighlight) {
      setEnableHighlight(diffViewHighlight);
    }
    if (diffViewWrap !== enableWrap) {
      setEnableWrap(diffViewWrap);
    }
    if (extendData) {
      setExtendData(extendData);
    }
    if (diffViewFontSize && diffViewFontSize !== fontSize) {
      setFontSize(diffViewFontSize);
    }
    if (onAddWidgetClick !== _onAddWidgetClick.current) {
      setOnAddWidgetClick({ current: onAddWidgetClick });
    }
    if (onCreateUseWidgetHook !== _onCreateUseWidgetHook) {
      setOnCreateUseWidgetHook(onCreateUseWidgetHook);
    }
    if (renderExtendLine !== _renderExtendLine) {
      setRenderExtendLine(renderExtendLine);
    }
    if (renderWidgetLine !== _renderWidgetLine) {
      setRenderWidgetLine(renderWidgetLine);
    }
  }, [
    useDiffContext,
    diffViewFontSize,
    diffViewHighlight,
    diffViewMode,
    diffViewWrap,
    diffViewAddWidget,
    diffFileId,
    isMounted,
    renderWidgetLine,
    renderExtendLine,
    extendData,
    onAddWidgetClick,
    onCreateUseWidgetHook
  ]);
  const value = (0, import_react2.useMemo)(() => ({ useDiffContext }), [useDiffContext]);
  return React.createElement(
    DiffViewContext.Provider,
    { value },
    React.createElement(
      "div",
      { className: "diff-tailwindcss-wrapper", "data-component": "git-diff-view", "data-theme": diffFile._getTheme() || "light", "data-version": "0.0.30", "data-highlighter": diffFile._getHighlighterName(), ref: wrapperRef },
      React.createElement(
        "div",
        { className: "diff-style-root", style: {
          // @ts-ignore
          [diffFontSizeName]: diffViewFontSize + "px"
        } },
        React.createElement("div", { id: isMounted ? `diff-root${diffFileId}` : void 0, className: "diff-view-wrapper" + (className ? ` ${className}` : ""), style }, diffViewMode & DiffModeEnum.Split ? React.createElement(DiffSplitView, { diffFile }) : React.createElement(DiffUnifiedView, { diffFile }))
      )
    )
  );
};
var MemoedInternalDiffView = (0, import_react2.memo)(InternalDiffView);
var DiffViewWithRef = (props, ref2) => {
  var _a, _b;
  const { registerHighlighter, data, diffViewTheme, diffFile: _diffFile } = props, restProps = __rest(props, ["registerHighlighter", "data", "diffViewTheme", "diffFile"]);
  const diffFile = (0, import_react2.useMemo)(() => {
    var _a2, _b2, _c, _d, _e, _f;
    if (_diffFile) {
      const diffFile2 = DiffFile.createInstance({});
      diffFile2._mergeFullBundle(_diffFile._getFullBundle());
      return diffFile2;
    } else if (data) {
      return new DiffFile(((_a2 = data === null || data === void 0 ? void 0 : data.oldFile) === null || _a2 === void 0 ? void 0 : _a2.fileName) || "", ((_b2 = data === null || data === void 0 ? void 0 : data.oldFile) === null || _b2 === void 0 ? void 0 : _b2.content) || "", ((_c = data === null || data === void 0 ? void 0 : data.newFile) === null || _c === void 0 ? void 0 : _c.fileName) || "", ((_d = data === null || data === void 0 ? void 0 : data.newFile) === null || _d === void 0 ? void 0 : _d.content) || "", (data === null || data === void 0 ? void 0 : data.hunks) || [], ((_e = data === null || data === void 0 ? void 0 : data.oldFile) === null || _e === void 0 ? void 0 : _e.fileLang) || "", ((_f = data === null || data === void 0 ? void 0 : data.newFile) === null || _f === void 0 ? void 0 : _f.fileLang) || "");
    }
    return null;
  }, [data, _diffFile]);
  const diffFileRef = (0, import_react2.useRef)(diffFile);
  const wrapperRef = (0, import_react2.useRef)();
  if (diffFileRef.current && diffFileRef.current !== diffFile) {
    (_b = (_a = diffFileRef.current).clear) === null || _b === void 0 ? void 0 : _b.call(_a);
    diffFileRef.current = diffFile;
  }
  const isMounted = useIsMounted();
  (0, import_react2.useEffect)(() => {
    if (_diffFile && diffFile) {
      _diffFile._addClonedInstance(diffFile);
      return () => {
        _diffFile._delClonedInstance(diffFile);
      };
    }
  }, [diffFile, _diffFile]);
  (0, import_react2.useEffect)(() => {
    if (!diffFile)
      return;
    diffFile.initTheme(diffViewTheme);
    diffFile.initRaw();
    diffFile.buildSplitDiffLines();
    diffFile.buildUnifiedDiffLines();
  }, [diffFile, diffViewTheme]);
  (0, import_react2.useEffect)(() => {
    if (!diffFile)
      return;
    if (props.diffViewHighlight) {
      diffFile.initSyntax({ registerHighlighter });
      diffFile.notifyAll();
    }
  }, [diffFile, props.diffViewHighlight, registerHighlighter]);
  (0, import_react2.useEffect)(() => {
    if (!diffFile)
      return;
    const init = () => {
      var _a2, _b2;
      (_a2 = wrapperRef.current) === null || _a2 === void 0 ? void 0 : _a2.setAttribute("data-theme", diffFile._getTheme() || "light");
      (_b2 = wrapperRef.current) === null || _b2 === void 0 ? void 0 : _b2.setAttribute("data-highlighter", diffFile._getHighlighterName());
    };
    init();
    const cb = diffFile.subscribe(init);
    return cb;
  }, [diffFile, diffViewTheme]);
  useUnmount(() => {
    var _a2, _b2;
    return true ? (_a2 = diffFile === null || diffFile === void 0 ? void 0 : diffFile._destroy) === null || _a2 === void 0 ? void 0 : _a2.call(diffFile) : (_b2 = diffFile === null || diffFile === void 0 ? void 0 : diffFile.clear) === null || _b2 === void 0 ? void 0 : _b2.call(diffFile);
  }, [diffFile]);
  (0, import_react2.useImperativeHandle)(ref2, () => ({ getDiffFileInstance: () => diffFile }), [diffFile]);
  if (!diffFile)
    return null;
  return React.createElement(MemoedInternalDiffView, Object.assign({ key: diffFile.getId() }, restProps, { diffFile, isMounted, wrapperRef, diffViewTheme, diffViewMode: restProps.diffViewMode || DiffModeEnum.SplitGitHub, diffViewFontSize: restProps.diffViewFontSize || 14 }));
};
var InnerDiffView = (0, import_react2.forwardRef)(DiffViewWithRef);
InnerDiffView.displayName = "DiffView";
var DiffView = InnerDiffView;
var version = "0.0.30";
export {
  DefaultDiffExpansionStep,
  DiffFile,
  DiffFileLineType,
  DiffHunk,
  DiffHunkExpansionType,
  DiffHunkHeader,
  DiffLine,
  DiffLineType,
  DiffModeEnum,
  DiffParser,
  DiffView,
  File,
  HiddenBidiCharsRegex,
  SplitSide,
  _cacheMap,
  _getAST,
  assertNever,
  changeDefaultComposeLength,
  checkCurrentLineIsHidden,
  checkDiffLineIncludeChange,
  composeLen,
  diffChanges,
  disableCache,
  escapeHtml,
  getCurrentComposeLength,
  getDiffRange,
  getFile,
  getHunkHeaderExpansionType,
  getLang,
  getLargestLineNumber,
  getPlainDiffTemplate,
  getPlainLineTemplate,
  getSplitContentLines,
  getSplitLines,
  getSyntaxDiffTemplate,
  getSyntaxLineTemplate,
  getUnifiedContentLine,
  getUnifiedLines,
  highlighter,
  isTransformEnabled,
  numIterator,
  parseInstance,
  processAST,
  processTransformForFile,
  processTransformTemplateContent,
  relativeChanges,
  resetDefaultComposeLength,
  resetTransform,
  setTransformForFile,
  setTransformForTemplateContent,
  version,
  versions
};
/*! Bundled license information:

@vue/shared/dist/shared.esm-bundler.js:
  (**
  * @vue/shared v3.5.26
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/reactivity/dist/reactivity.esm-bundler.js:
  (**
  * @vue/reactivity v3.5.26
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=@git-diff-view_react.js.map
