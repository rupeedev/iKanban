import {
  TRANSFORMERS,
  registerMarkdownShortcuts
} from "./chunk-O75QT6JB.js";
import "./chunk-CXAXUUYS.js";
import "./chunk-FBEBASWN.js";
import {
  useLexicalComposerContext
} from "./chunk-3KRADT7E.js";
import "./chunk-4GKSFKSI.js";
import "./chunk-TXWECFHX.js";
import {
  $isHorizontalRuleNode,
  HorizontalRuleNode
} from "./chunk-GYYCZLBE.js";
import {
  addClassNamesToElement,
  mergeRegister,
  removeClassNamesFromElement
} from "./chunk-RBMJ4EHG.js";
import {
  $applyNodeReplacement,
  $createNodeSelection,
  $getNodeByKey,
  $getSelection,
  $isNodeSelection,
  $setSelection,
  CLICK_COMMAND,
  COMMAND_PRIORITY_LOW
} from "./chunk-GDWONKOB.js";
import {
  require_jsx_runtime
} from "./chunk-7BUGFXDR.js";
import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@lexical/react/useLexicalNodeSelection.dev.mjs
var import_react = __toESM(require_react(), 1);
function isNodeSelected(editor, key) {
  return editor.getEditorState().read(() => {
    const node = $getNodeByKey(key);
    if (node === null) {
      return false;
    }
    return node.isSelected();
  });
}
function useLexicalNodeSelection(key) {
  const [editor] = useLexicalComposerContext();
  const [isSelected, setIsSelected] = (0, import_react.useState)(() => isNodeSelected(editor, key));
  (0, import_react.useEffect)(() => {
    let isMounted = true;
    const unregister = editor.registerUpdateListener(() => {
      if (isMounted) {
        setIsSelected(isNodeSelected(editor, key));
      }
    });
    return () => {
      isMounted = false;
      unregister();
    };
  }, [editor, key]);
  const setSelected = (0, import_react.useCallback)((selected) => {
    editor.update(() => {
      let selection = $getSelection();
      if (!$isNodeSelection(selection)) {
        selection = $createNodeSelection();
        $setSelection(selection);
      }
      if ($isNodeSelection(selection)) {
        if (selected) {
          selection.add(key);
        } else {
          selection.delete(key);
        }
      }
    });
  }, [editor, key]);
  const clearSelected = (0, import_react.useCallback)(() => {
    editor.update(() => {
      const selection = $getSelection();
      if ($isNodeSelection(selection)) {
        selection.clear();
      }
    });
  }, [editor]);
  return [isSelected, setSelected, clearSelected];
}

// node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.mjs
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function HorizontalRuleComponent({
  nodeKey
}) {
  const [editor] = useLexicalComposerContext();
  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection(nodeKey);
  (0, import_react2.useEffect)(() => {
    return mergeRegister(editor.registerCommand(CLICK_COMMAND, (event) => {
      const hrElem = editor.getElementByKey(nodeKey);
      if (event.target === hrElem) {
        if (!event.shiftKey) {
          clearSelection();
        }
        setSelected(!isSelected);
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW));
  }, [clearSelection, editor, isSelected, nodeKey, setSelected]);
  (0, import_react2.useEffect)(() => {
    const hrElem = editor.getElementByKey(nodeKey);
    const isSelectedClassName = editor._config.theme.hrSelected ?? "selected";
    if (hrElem !== null) {
      if (isSelected) {
        addClassNamesToElement(hrElem, isSelectedClassName);
      } else {
        removeClassNamesFromElement(hrElem, isSelectedClassName);
      }
    }
  }, [editor, isSelected, nodeKey]);
  return null;
}
var HorizontalRuleNode2 = class _HorizontalRuleNode extends HorizontalRuleNode {
  static getType() {
    return "horizontalrule";
  }
  static clone(node) {
    return new _HorizontalRuleNode(node.__key);
  }
  static importJSON(serializedNode) {
    return $createHorizontalRuleNode().updateFromJSON(serializedNode);
  }
  static importDOM() {
    return {
      hr: () => ({
        conversion: $convertHorizontalRuleElement,
        priority: 0
      })
    };
  }
  decorate() {
    return (0, import_jsx_runtime.jsx)(HorizontalRuleComponent, {
      nodeKey: this.__key
    });
  }
};
function $convertHorizontalRuleElement() {
  return {
    node: $createHorizontalRuleNode()
  };
}
function $createHorizontalRuleNode() {
  return $applyNodeReplacement(new HorizontalRuleNode2());
}

// node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.mjs
var import_react3 = __toESM(require_react(), 1);
var HR = {
  dependencies: [HorizontalRuleNode2],
  export: (node) => {
    return $isHorizontalRuleNode(node) ? "***" : null;
  },
  regExp: /^(---|\*\*\*|___)\s?$/,
  replace: (parentNode, _1, _2, isImport) => {
    const line = $createHorizontalRuleNode();
    if (isImport || parentNode.getNextSibling() != null) {
      parentNode.replace(line);
    } else {
      parentNode.insertBefore(line);
    }
    line.selectNext();
  },
  type: "element"
};
var DEFAULT_TRANSFORMERS = [HR, ...TRANSFORMERS];
function MarkdownShortcutPlugin({
  transformers = DEFAULT_TRANSFORMERS
}) {
  const [editor] = useLexicalComposerContext();
  (0, import_react3.useEffect)(() => {
    return registerMarkdownShortcuts(editor, transformers);
  }, [editor, transformers]);
  return null;
}
export {
  DEFAULT_TRANSFORMERS,
  MarkdownShortcutPlugin
};
//# sourceMappingURL=@lexical_react_LexicalMarkdownShortcutPlugin.js.map
