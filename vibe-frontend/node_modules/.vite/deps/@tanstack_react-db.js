import {
  AggregateFunctionNotInSelectError,
  AggregateNotSupportedError,
  BTreeIndex,
  BaseIndex,
  BaseQueryBuilder,
  CannotCombineEmptyExpressionListError,
  CollectionConfigurationError,
  CollectionImpl,
  CollectionInErrorStateError,
  CollectionInputNotFoundError,
  CollectionIsInErrorStateError,
  CollectionOperationError,
  CollectionRequiresConfigError,
  CollectionRequiresSyncConfigError,
  CollectionStateError,
  DeduplicatedLoadSubset,
  DeleteKeyNotFoundError,
  DistinctRequiresSelectError,
  DuplicateAliasInSubqueryError,
  DuplicateDbInstanceError,
  DuplicateKeyError,
  DuplicateKeySyncError,
  EmptyReferencePathError,
  GroupByError,
  HavingRequiresGroupByError,
  IndexOperation,
  IndexProxy,
  InvalidCollectionStatusTransitionError,
  InvalidJoinCondition,
  InvalidJoinConditionLeftSourceError,
  InvalidJoinConditionRightSourceError,
  InvalidJoinConditionSameSourceError,
  InvalidJoinConditionSourceMismatchError,
  InvalidKeyError,
  InvalidSchemaError,
  InvalidSourceError,
  InvalidSourceTypeError,
  InvalidStorageDataFormatError,
  InvalidStorageObjectFormatError,
  JoinCollectionNotFoundError,
  JoinConditionMustBeEqualityError,
  JoinError,
  KeyUpdateNotAllowedError,
  LazyIndexWrapper,
  LimitOffsetRequireOrderByError,
  LocalStorageCollectionError,
  MissingAliasInputsError,
  MissingDeleteHandlerError,
  MissingHandlerError,
  MissingInsertHandlerError,
  MissingMutationFunctionError,
  MissingUpdateArgumentError,
  MissingUpdateHandlerError,
  NegativeActiveSubscribersError,
  NoKeysPassedToDeleteError,
  NoKeysPassedToUpdateError,
  NoPendingSyncTransactionCommitError,
  NoPendingSyncTransactionWriteError,
  NonAggregateExpressionNotInGroupByError,
  NonRetriableError,
  OnMutateMustBeSynchronousError,
  OnlyOneSourceAllowedError,
  Query,
  QueryBuilderError,
  QueryCompilationError,
  QueryMustHaveFromClauseError,
  QueryOptimizerError,
  SchemaMustBeSynchronousError,
  SchemaValidationError,
  SerializationError,
  SetWindowRequiresOrderByError,
  SortedMap,
  StorageError,
  StorageKeyRequiredError,
  SubQueryMustHaveFromClauseError,
  SubscriptionNotFoundError,
  SyncCleanupError,
  SyncTransactionAlreadyCommittedError,
  SyncTransactionAlreadyCommittedWriteError,
  TanStackDBError,
  TransactionAlreadyCompletedRollbackError,
  TransactionError,
  TransactionNotPendingCommitError,
  TransactionNotPendingMutateError,
  UndefinedKeyError,
  UnknownExpressionTypeError,
  UnknownFunctionError,
  UnknownHavingExpressionTypeError,
  UnsupportedAggregateFunctionError,
  UnsupportedFromTypeError,
  UnsupportedJoinSourceTypeError,
  UnsupportedJoinTypeError,
  UpdateKeyNotFoundError,
  WhereClauseConversionError,
  add,
  and,
  avg,
  coalesce,
  compileQuery,
  concat,
  count,
  createArrayChangeProxy,
  createChangeProxy,
  createCollection,
  createLiveQueryCollection,
  createOptimisticAction,
  createPacedMutations,
  createTransaction,
  debounceStrategy,
  deepEquals,
  eq,
  extractFieldPath,
  extractSimpleComparisons,
  extractValue,
  getActiveTransaction,
  gt,
  gte,
  ilike,
  inArray,
  ir_exports,
  isLimitSubset,
  isNull,
  isOffsetLimitSubset,
  isOrderBySubset,
  isPredicateSubset,
  isUndefined,
  isWhereSubset,
  length,
  like,
  liveQueryCollectionOptions,
  localOnlyCollectionOptions,
  localStorageCollectionOptions,
  lower,
  lt,
  lte,
  max,
  min,
  minusWherePredicates,
  not,
  operators,
  or,
  parseLoadSubsetOptions,
  parseOrderByExpression,
  parseWhereExpression,
  queueStrategy,
  sum,
  throttleStrategy,
  unionWherePredicates,
  upper,
  walkExpression,
  withArrayChangeTracking,
  withChangeTracking
} from "./chunk-F4MVZ6SI.js";
import "./chunk-WOGQ2CNA.js";
import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@tanstack/react-db/dist/esm/useLiveQuery.js
var import_react = __toESM(require_react(), 1);
var DEFAULT_GC_TIME_MS = 1;
function useLiveQuery(configOrQueryOrCollection, deps = []) {
  const isCollection = configOrQueryOrCollection && typeof configOrQueryOrCollection === `object` && typeof configOrQueryOrCollection.subscribeChanges === `function` && typeof configOrQueryOrCollection.startSyncImmediate === `function` && typeof configOrQueryOrCollection.id === `string`;
  const collectionRef = (0, import_react.useRef)(
    null
  );
  const depsRef = (0, import_react.useRef)(null);
  const configRef = (0, import_react.useRef)(null);
  const versionRef = (0, import_react.useRef)(0);
  const snapshotRef = (0, import_react.useRef)(null);
  const needsNewCollection = !collectionRef.current || isCollection && configRef.current !== configOrQueryOrCollection || !isCollection && (depsRef.current === null || depsRef.current.length !== deps.length || depsRef.current.some((dep, i) => dep !== deps[i]));
  if (needsNewCollection) {
    if (isCollection) {
      configOrQueryOrCollection.startSyncImmediate();
      collectionRef.current = configOrQueryOrCollection;
      configRef.current = configOrQueryOrCollection;
    } else {
      if (typeof configOrQueryOrCollection === `function`) {
        const queryBuilder = new BaseQueryBuilder();
        const result = configOrQueryOrCollection(queryBuilder);
        if (result === void 0 || result === null) {
          collectionRef.current = null;
        } else if (result instanceof CollectionImpl) {
          result.startSyncImmediate();
          collectionRef.current = result;
        } else if (result instanceof BaseQueryBuilder) {
          collectionRef.current = createLiveQueryCollection({
            query: configOrQueryOrCollection,
            startSync: true,
            gcTime: DEFAULT_GC_TIME_MS
          });
        } else if (result && typeof result === `object`) {
          collectionRef.current = createLiveQueryCollection({
            startSync: true,
            gcTime: DEFAULT_GC_TIME_MS,
            ...result
          });
        } else {
          throw new Error(
            `useLiveQuery callback must return a QueryBuilder, LiveQueryCollectionConfig, Collection, undefined, or null. Got: ${typeof result}`
          );
        }
        depsRef.current = [...deps];
      } else {
        collectionRef.current = createLiveQueryCollection({
          startSync: true,
          gcTime: DEFAULT_GC_TIME_MS,
          ...configOrQueryOrCollection
        });
        depsRef.current = [...deps];
      }
    }
  }
  if (needsNewCollection) {
    versionRef.current = 0;
    snapshotRef.current = null;
  }
  const subscribeRef = (0, import_react.useRef)(null);
  if (!subscribeRef.current || needsNewCollection) {
    subscribeRef.current = (onStoreChange) => {
      if (!collectionRef.current) {
        return () => {
        };
      }
      const subscription = collectionRef.current.subscribeChanges(() => {
        versionRef.current += 1;
        onStoreChange();
      });
      if (collectionRef.current.status === `ready`) {
        versionRef.current += 1;
        onStoreChange();
      }
      return () => {
        subscription.unsubscribe();
      };
    };
  }
  const getSnapshotRef = (0, import_react.useRef)(null);
  if (!getSnapshotRef.current || needsNewCollection) {
    getSnapshotRef.current = () => {
      const currentVersion = versionRef.current;
      const currentCollection = collectionRef.current;
      if (!snapshotRef.current || snapshotRef.current.version !== currentVersion || snapshotRef.current.collection !== currentCollection) {
        snapshotRef.current = {
          collection: currentCollection,
          version: currentVersion
        };
      }
      return snapshotRef.current;
    };
  }
  const snapshot = (0, import_react.useSyncExternalStore)(
    subscribeRef.current,
    getSnapshotRef.current
  );
  const returnedSnapshotRef = (0, import_react.useRef)(null);
  const returnedRef = (0, import_react.useRef)(null);
  if (!returnedSnapshotRef.current || returnedSnapshotRef.current.version !== snapshot.version || returnedSnapshotRef.current.collection !== snapshot.collection) {
    if (!snapshot.collection) {
      returnedRef.current = {
        state: void 0,
        data: void 0,
        collection: void 0,
        status: `disabled`,
        isLoading: false,
        isReady: true,
        isIdle: false,
        isError: false,
        isCleanedUp: false,
        isEnabled: false
      };
    } else {
      const entries = Array.from(snapshot.collection.entries());
      const config = snapshot.collection.config;
      const singleResult = config.singleResult;
      let stateCache = null;
      let dataCache = null;
      returnedRef.current = {
        get state() {
          if (!stateCache) {
            stateCache = new Map(entries);
          }
          return stateCache;
        },
        get data() {
          if (!dataCache) {
            dataCache = entries.map(([, value]) => value);
          }
          return singleResult ? dataCache[0] : dataCache;
        },
        collection: snapshot.collection,
        status: snapshot.collection.status,
        isLoading: snapshot.collection.status === `loading`,
        isReady: snapshot.collection.status === `ready`,
        isIdle: snapshot.collection.status === `idle`,
        isError: snapshot.collection.status === `error`,
        isCleanedUp: snapshot.collection.status === `cleaned-up`,
        isEnabled: true
      };
    }
    returnedSnapshotRef.current = snapshot;
  }
  return returnedRef.current;
}

// node_modules/@tanstack/react-db/dist/esm/useLiveSuspenseQuery.js
var import_react2 = __toESM(require_react(), 1);
function useLiveSuspenseQuery(configOrQueryOrCollection, deps = []) {
  const promiseRef = (0, import_react2.useRef)(null);
  const collectionRef = (0, import_react2.useRef)(null);
  const hasBeenReadyRef = (0, import_react2.useRef)(false);
  const result = useLiveQuery(configOrQueryOrCollection, deps);
  if (collectionRef.current !== result.collection) {
    promiseRef.current = null;
    collectionRef.current = result.collection;
    hasBeenReadyRef.current = false;
  }
  if (result.status === `ready`) {
    hasBeenReadyRef.current = true;
    promiseRef.current = null;
  }
  if (!result.isEnabled) {
    throw new Error(
      `useLiveSuspenseQuery does not support disabled queries. Use useLiveQuery instead for conditional queries.`
    );
  }
  if (result.status === `error` && !hasBeenReadyRef.current) {
    promiseRef.current = null;
    throw new Error(`Collection "${result.collection.id}" failed to load`);
  }
  if (result.status === `loading` || result.status === `idle`) {
    if (!promiseRef.current) {
      promiseRef.current = result.collection.preload();
    }
    throw promiseRef.current;
  }
  return {
    state: result.state,
    data: result.data,
    collection: result.collection
  };
}

// node_modules/@tanstack/react-db/dist/esm/usePacedMutations.js
var import_react3 = __toESM(require_react(), 1);
function usePacedMutations(config) {
  const onMutateRef = (0, import_react3.useRef)(config.onMutate);
  onMutateRef.current = config.onMutate;
  const mutationFnRef = (0, import_react3.useRef)(config.mutationFn);
  mutationFnRef.current = config.mutationFn;
  const stableOnMutate = (0, import_react3.useCallback)((variables) => {
    return onMutateRef.current(variables);
  }, []);
  const stableMutationFn = (0, import_react3.useCallback)((params) => {
    return mutationFnRef.current(params);
  }, []);
  const mutate = (0, import_react3.useMemo)(() => {
    return createPacedMutations({
      ...config,
      onMutate: stableOnMutate,
      mutationFn: stableMutationFn
    });
  }, [
    stableOnMutate,
    stableMutationFn,
    config.metadata,
    // Serialize strategy to avoid recreating when object reference changes but values are same
    JSON.stringify({
      type: config.strategy._type,
      options: config.strategy.options
    })
  ]);
  const stableMutate = (0, import_react3.useCallback)(mutate, [mutate]);
  return stableMutate;
}

// node_modules/@tanstack/react-db/dist/esm/useLiveInfiniteQuery.js
var import_react4 = __toESM(require_react(), 1);
function isLiveQueryCollectionUtils(utils) {
  return typeof utils.setWindow === `function`;
}
function useLiveInfiniteQuery(queryFnOrCollection, config, deps = []) {
  const pageSize = config.pageSize || 20;
  const initialPageParam = config.initialPageParam ?? 0;
  const isCollection = queryFnOrCollection instanceof CollectionImpl;
  if (!isCollection && typeof queryFnOrCollection !== `function`) {
    throw new Error(
      `useLiveInfiniteQuery: First argument must be either a pre-created live query collection (CollectionImpl) or a query function. Received: ${typeof queryFnOrCollection}`
    );
  }
  const [loadedPageCount, setLoadedPageCount] = (0, import_react4.useState)(1);
  const [isFetchingNextPage, setIsFetchingNextPage] = (0, import_react4.useState)(false);
  const collectionRef = (0, import_react4.useRef)(isCollection ? queryFnOrCollection : null);
  const hasValidatedCollectionRef = (0, import_react4.useRef)(false);
  const depsKey = JSON.stringify(deps);
  const prevDepsKeyRef = (0, import_react4.useRef)(depsKey);
  (0, import_react4.useEffect)(() => {
    let shouldReset = false;
    if (isCollection) {
      if (collectionRef.current !== queryFnOrCollection) {
        collectionRef.current = queryFnOrCollection;
        hasValidatedCollectionRef.current = false;
        shouldReset = true;
      }
    } else {
      if (prevDepsKeyRef.current !== depsKey) {
        prevDepsKeyRef.current = depsKey;
        shouldReset = true;
      }
    }
    if (shouldReset) {
      setLoadedPageCount(1);
    }
  }, [isCollection, queryFnOrCollection, depsKey]);
  const queryResult = isCollection ? useLiveQuery(queryFnOrCollection) : useLiveQuery(
    (q) => queryFnOrCollection(q).limit(pageSize).offset(0),
    deps
  );
  (0, import_react4.useEffect)(() => {
    const utils = queryResult.collection.utils;
    const expectedOffset = 0;
    const expectedLimit = loadedPageCount * pageSize + 1;
    if (!isLiveQueryCollectionUtils(utils)) {
      if (isCollection) {
        throw new Error(
          `useLiveInfiniteQuery: Pre-created live query collection must have an orderBy clause for infinite pagination to work. Please add .orderBy() to your createLiveQueryCollection query.`
        );
      }
      return;
    }
    if (isCollection && !hasValidatedCollectionRef.current) {
      const currentWindow = utils.getWindow();
      if (currentWindow && (currentWindow.offset !== expectedOffset || currentWindow.limit !== expectedLimit)) {
        console.warn(
          `useLiveInfiniteQuery: Pre-created collection has window {offset: ${currentWindow.offset}, limit: ${currentWindow.limit}} but hook expects {offset: ${expectedOffset}, limit: ${expectedLimit}}. Adjusting window now.`
        );
      }
      hasValidatedCollectionRef.current = true;
    }
    if (!isCollection && !queryResult.isReady) return;
    const result = utils.setWindow({
      offset: expectedOffset,
      limit: expectedLimit
    });
    if (result !== true) {
      setIsFetchingNextPage(true);
      result.then(() => {
        setIsFetchingNextPage(false);
      });
    } else {
      setIsFetchingNextPage(false);
    }
  }, [
    isCollection,
    queryResult.collection,
    queryResult.isReady,
    loadedPageCount,
    pageSize
  ]);
  const { pages, pageParams, hasNextPage, flatData } = (0, import_react4.useMemo)(() => {
    const dataArray = Array.isArray(queryResult.data) ? queryResult.data : [];
    const totalItemsRequested = loadedPageCount * pageSize;
    const hasMore = dataArray.length > totalItemsRequested;
    const pagesResult = [];
    const pageParamsResult = [];
    for (let i = 0; i < loadedPageCount; i++) {
      const pageData = dataArray.slice(i * pageSize, (i + 1) * pageSize);
      pagesResult.push(pageData);
      pageParamsResult.push(initialPageParam + i);
    }
    const flatDataResult = dataArray.slice(
      0,
      totalItemsRequested
    );
    return {
      pages: pagesResult,
      pageParams: pageParamsResult,
      hasNextPage: hasMore,
      flatData: flatDataResult
    };
  }, [queryResult.data, loadedPageCount, pageSize, initialPageParam]);
  const fetchNextPage = (0, import_react4.useCallback)(() => {
    if (!hasNextPage || isFetchingNextPage) return;
    setLoadedPageCount((prev) => prev + 1);
  }, [hasNextPage, isFetchingNextPage]);
  return {
    ...queryResult,
    data: flatData,
    pages,
    pageParams,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  };
}
export {
  AggregateFunctionNotInSelectError,
  AggregateNotSupportedError,
  BTreeIndex,
  BaseIndex,
  BaseQueryBuilder,
  CannotCombineEmptyExpressionListError,
  CollectionConfigurationError,
  CollectionImpl,
  CollectionInErrorStateError,
  CollectionInputNotFoundError,
  CollectionIsInErrorStateError,
  CollectionOperationError,
  CollectionRequiresConfigError,
  CollectionRequiresSyncConfigError,
  CollectionStateError,
  DeduplicatedLoadSubset,
  DeleteKeyNotFoundError,
  DistinctRequiresSelectError,
  DuplicateAliasInSubqueryError,
  DuplicateDbInstanceError,
  DuplicateKeyError,
  DuplicateKeySyncError,
  EmptyReferencePathError,
  GroupByError,
  HavingRequiresGroupByError,
  ir_exports as IR,
  IndexOperation,
  IndexProxy,
  InvalidCollectionStatusTransitionError,
  InvalidJoinCondition,
  InvalidJoinConditionLeftSourceError,
  InvalidJoinConditionRightSourceError,
  InvalidJoinConditionSameSourceError,
  InvalidJoinConditionSourceMismatchError,
  InvalidKeyError,
  InvalidSchemaError,
  InvalidSourceError,
  InvalidSourceTypeError,
  InvalidStorageDataFormatError,
  InvalidStorageObjectFormatError,
  JoinCollectionNotFoundError,
  JoinConditionMustBeEqualityError,
  JoinError,
  KeyUpdateNotAllowedError,
  LazyIndexWrapper,
  LimitOffsetRequireOrderByError,
  LocalStorageCollectionError,
  MissingAliasInputsError,
  MissingDeleteHandlerError,
  MissingHandlerError,
  MissingInsertHandlerError,
  MissingMutationFunctionError,
  MissingUpdateArgumentError,
  MissingUpdateHandlerError,
  NegativeActiveSubscribersError,
  NoKeysPassedToDeleteError,
  NoKeysPassedToUpdateError,
  NoPendingSyncTransactionCommitError,
  NoPendingSyncTransactionWriteError,
  NonAggregateExpressionNotInGroupByError,
  NonRetriableError,
  OnMutateMustBeSynchronousError,
  OnlyOneSourceAllowedError,
  Query,
  QueryBuilderError,
  QueryCompilationError,
  QueryMustHaveFromClauseError,
  QueryOptimizerError,
  SchemaMustBeSynchronousError,
  SchemaValidationError,
  SerializationError,
  SetWindowRequiresOrderByError,
  SortedMap,
  StorageError,
  StorageKeyRequiredError,
  SubQueryMustHaveFromClauseError,
  SubscriptionNotFoundError,
  SyncCleanupError,
  SyncTransactionAlreadyCommittedError,
  SyncTransactionAlreadyCommittedWriteError,
  TanStackDBError,
  TransactionAlreadyCompletedRollbackError,
  TransactionError,
  TransactionNotPendingCommitError,
  TransactionNotPendingMutateError,
  UndefinedKeyError,
  UnknownExpressionTypeError,
  UnknownFunctionError,
  UnknownHavingExpressionTypeError,
  UnsupportedAggregateFunctionError,
  UnsupportedFromTypeError,
  UnsupportedJoinSourceTypeError,
  UnsupportedJoinTypeError,
  UpdateKeyNotFoundError,
  WhereClauseConversionError,
  add,
  and,
  avg,
  coalesce,
  compileQuery,
  concat,
  count,
  createArrayChangeProxy,
  createChangeProxy,
  createCollection,
  createLiveQueryCollection,
  createOptimisticAction,
  createPacedMutations,
  createTransaction,
  debounceStrategy,
  deepEquals,
  eq,
  extractFieldPath,
  extractSimpleComparisons,
  extractValue,
  getActiveTransaction,
  gt,
  gte,
  ilike,
  inArray,
  isLimitSubset,
  isNull,
  isOffsetLimitSubset,
  isOrderBySubset,
  isPredicateSubset,
  isUndefined,
  isWhereSubset,
  length,
  like,
  liveQueryCollectionOptions,
  localOnlyCollectionOptions,
  localStorageCollectionOptions,
  lower,
  lt,
  lte,
  max,
  min,
  minusWherePredicates,
  not,
  operators,
  or,
  parseLoadSubsetOptions,
  parseOrderByExpression,
  parseWhereExpression,
  queueStrategy,
  sum,
  throttleStrategy,
  unionWherePredicates,
  upper,
  useLiveInfiniteQuery,
  useLiveQuery,
  useLiveSuspenseQuery,
  usePacedMutations,
  walkExpression,
  withArrayChangeTracking,
  withChangeTracking
};
//# sourceMappingURL=@tanstack_react-db.js.map
