{
  "version": 3,
  "sources": ["../../@lexical/markdown/LexicalMarkdown.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isParagraphNode, $isTextNode, $getRoot, $isElementNode, $isDecoratorNode, $isLineBreakNode, $getSelection, $createTextNode, $createParagraphNode, $createLineBreakNode, COLLABORATION_TAG, HISTORIC_TAG, $isRangeSelection, $isRootOrShadowRoot, $createRangeSelection, $setSelection } from 'lexical';\nimport { $isListNode, $isListItemNode, ListNode, ListItemNode, $createListItemNode, $createListNode } from '@lexical/list';\nimport { $isQuoteNode, HeadingNode, QuoteNode, $createHeadingNode, $isHeadingNode, $createQuoteNode } from '@lexical/rich-text';\nimport { $findMatchingParent } from '@lexical/utils';\nimport { CodeNode, $createCodeNode, $isCodeNode } from '@lexical/code';\nimport { LinkNode, $createLinkNode, $isLinkNode, $isAutoLinkNode } from '@lexical/link';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (!key) {\n      continue;\n    }\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    multilineElement: byType['multiline-element'] || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nfunction isEmptyParagraph(node) {\n  if (!$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && $isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction createMarkdownExport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const elementTransformers = [...byType.multilineElement, ...byType.element];\n  const isNewlineDelimited = !shouldPreserveNewLines;\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1)\n  // Make sure all text transformers that contain 'code' in their format are at the end of the array. Otherwise, formatted code like\n  // <strong><code>code</code></strong> will be exported as `**Bold Code**`, as the code format will be applied first, and the bold format\n  // will be applied second and thus skipped entirely, as the code format will prevent any further formatting.\n  .sort((a, b) => {\n    return Number(a.format.includes('code')) - Number(b.format.includes('code'));\n  });\n  return node => {\n    const output = [];\n    const children = (node || $getRoot()).getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const result = exportTopLevelElements(child, elementTransformers, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(\n        // separate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n        isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? '\\n'.concat(result) : result);\n      }\n    }\n    // Ensure consecutive groups of texts are at least \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    if (!transformer.export) {\n      continue;\n    }\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if ($isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if ($isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags) {\n  const output = [];\n  const children = node.getChildren();\n  // keep track of unclosed tags from the very beginning\n  if (!unclosedTags) {\n    unclosedTags = [];\n  }\n  if (!unclosableTags) {\n    unclosableTags = [];\n  }\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      if (!transformer.export) {\n        continue;\n      }\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers, unclosedTags,\n      // Add current unclosed tags to the list of unclosable tags - we don't want nested tags from\n      // textmatch transformers to close the outer ones, as that may result in invalid markdown.\n      // E.g. **text [text**](https://lexical.io)\n      // is invalid markdown, as the closing ** is inside the link.\n      //\n      [...unclosableTags, ...unclosedTags]), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex, unclosedTags, unclosableTags));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if ($isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if ($isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex, unclosedTags, unclosableTags));\n    } else if ($isElementNode(child)) {\n      // empty paragraph returns \"\"\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags));\n    } else if ($isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers,\n// unclosed tags include the markdown tags that haven't been closed yet, and their associated formats\nunclosedTags, unclosableTags) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // If the node has no format, we use the original text.\n  // Otherwise, we escape leading and trailing whitespaces to their corresponding code points,\n  // ensuring the returned string maintains its original formatting, e.g., \"**&#32;&#32;&#32;foo&#32;&#32;&#32;**\".\n  let output = node.getFormat() === 0 ? textContent : escapeLeadingAndTrailingWhitespaces(textContent);\n  if (!node.hasFormat('code')) {\n    // Escape any markdown characters in the text content\n    output = output.replace(/([*_`~\\\\])/g, '\\\\$1');\n  }\n\n  // the opening tags to be added to the result\n  let openingTags = '';\n  // the closing tags to be added to the result\n  let closingTagsBefore = '';\n  let closingTagsAfter = '';\n  const prevNode = getTextSibling(node, true);\n  const nextNode = getTextSibling(node, false);\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    // dedup applied formats\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n\n      // append the tag to openingTags, if it's not applied to the previous nodes,\n      // or the nodes before that (which would result in an unclosed tag)\n      if (!hasFormat(prevNode, format) || !unclosedTags.find(element => element.tag === tag)) {\n        unclosedTags.push({\n          format,\n          tag\n        });\n        openingTags += tag;\n      }\n    }\n  }\n\n  // close any tags in the same order they were applied, if necessary\n  for (let i = 0; i < unclosedTags.length; i++) {\n    const nodeHasFormat = hasFormat(node, unclosedTags[i].format);\n    const nextNodeHasFormat = hasFormat(nextNode, unclosedTags[i].format);\n\n    // prevent adding closing tag if next sibling will do it\n    if (nodeHasFormat && nextNodeHasFormat) {\n      continue;\n    }\n    const unhandledUnclosedTags = [...unclosedTags]; // Shallow copy to avoid modifying the original array\n\n    while (unhandledUnclosedTags.length > i) {\n      const unclosedTag = unhandledUnclosedTags.pop();\n\n      // If tag is unclosable, don't close it and leave it in the original array,\n      // So that it can be closed when it's no longer unclosable\n      if (unclosableTags && unclosedTag && unclosableTags.find(element => element.tag === unclosedTag.tag)) {\n        continue;\n      }\n      if (unclosedTag && typeof unclosedTag.tag === 'string') {\n        if (!nodeHasFormat) {\n          // Handles cases where the tag has not been closed before, e.g. if the previous node\n          // was a text match transformer that did not account for closing tags of the next node (e.g. a link)\n          closingTagsBefore += unclosedTag.tag;\n        } else if (!nextNodeHasFormat) {\n          closingTagsAfter += unclosedTag.tag;\n        }\n      }\n      // Mutate the original array to remove the closed tag\n      unclosedTags.pop();\n    }\n    break;\n  }\n  output = openingTags + output + closingTagsAfter;\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return closingTagsBefore + output;\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if ($isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if ($isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if ($isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return $isTextNode(node) && node.hasFormat(format);\n}\nfunction escapeLeadingAndTrailingWhitespaces(textContent) {\n  return textContent.replace(/^\\s+|\\s+$/g, match => {\n    return [...match].map(char => '&#' + char.codePointAt(0) + ';').join('');\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    return null;\n  }\n  const textFormatMatchStart = match.index || 0;\n  const textFormatMatchEnd = textFormatMatchStart + match[0].length;\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  return {\n    endIndex: textFormatMatchEnd,\n    match,\n    startIndex: textFormatMatchStart,\n    transformer\n  };\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction importTextFormatTransformer(textNode, startIndex, endIndex, transformer, match) {\n  const textContent = textNode.getTextContent();\n\n  // No text matches - we can safely process the text format match\n  let transformedNode, nodeAfter, nodeBefore;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    transformedNode = textNode;\n  } else {\n    if (startIndex === 0) {\n      [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n    } else {\n      [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  transformedNode.setTextContent(match[2]);\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!transformedNode.hasFormat(format)) {\n        transformedNode.toggleFormat(format);\n      }\n    }\n  }\n  return {\n    nodeAfter: nodeAfter,\n    nodeBefore: nodeBefore,\n    transformedNode: transformedNode\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextMatchTransformer(textNode_, textMatchTransformers) {\n  const textNode = textNode_;\n  let foundMatchStartIndex = undefined;\n  let foundMatchEndIndex = undefined;\n  let foundMatchTransformer = undefined;\n  let foundMatch = undefined;\n  for (const transformer of textMatchTransformers) {\n    if (!transformer.replace || !transformer.importRegExp) {\n      continue;\n    }\n    const match = textNode.getTextContent().match(transformer.importRegExp);\n    if (!match) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = transformer.getEndIndex ? transformer.getEndIndex(textNode, match) : startIndex + match[0].length;\n    if (endIndex === false) {\n      continue;\n    }\n    if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined ||\n    // Wraps previous match or is strictly before it.\n    startIndex < foundMatchStartIndex && (endIndex > foundMatchEndIndex || endIndex <= foundMatchStartIndex)) {\n      foundMatchStartIndex = startIndex;\n      foundMatchEndIndex = endIndex;\n      foundMatchTransformer = transformer;\n      foundMatch = match;\n    }\n  }\n  if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined || foundMatchTransformer === undefined || foundMatch === undefined) {\n    return null;\n  }\n  return {\n    endIndex: foundMatchEndIndex,\n    match: foundMatch,\n    startIndex: foundMatchStartIndex,\n    transformer: foundMatchTransformer\n  };\n}\nfunction importFoundTextMatchTransformer(textNode, startIndex, endIndex, transformer, match) {\n  let transformedNode, nodeAfter, nodeBefore;\n  if (startIndex === 0) {\n    [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n  } else {\n    [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n  }\n  if (!transformer.replace) {\n    return null;\n  }\n  const potentialTransformedNode = transformer.replace(transformedNode, match);\n  return {\n    nodeAfter,\n    nodeBefore,\n    transformedNode: potentialTransformedNode || undefined\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Returns true if the node can contain transformable markdown.\n * Code nodes cannot contain transformable markdown.\n * For example, `code **bold**` should not be transformed to\n * <code>code <strong>bold</strong></code>.\n */\nfunction canContainTransformableMarkdown(node) {\n  return $isTextNode(node) && !node.hasFormat('code');\n}\n\n/**\n * Handles applying both text format and text match transformers.\n * It finds the outermost text format or text match and applies it,\n * then recursively calls itself to apply the next outermost transformer,\n * until there are no more transformers to apply.\n */\nfunction importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  let foundTextFormat = findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex);\n  let foundTextMatch = findOutermostTextMatchTransformer(textNode, textMatchTransformers);\n  if (foundTextFormat && foundTextMatch) {\n    // Find the outermost transformer\n    if (foundTextFormat.startIndex <= foundTextMatch.startIndex && foundTextFormat.endIndex >= foundTextMatch.endIndex ||\n    // foundTextMatch is not contained within foundTextFormat\n    foundTextMatch.startIndex > foundTextFormat.endIndex) {\n      // foundTextFormat wraps foundTextMatch - apply foundTextFormat by setting foundTextMatch to null\n      foundTextMatch = null;\n    } else {\n      // foundTextMatch wraps foundTextFormat - apply foundTextMatch by setting foundTextFormat to null\n      foundTextFormat = null;\n    }\n  }\n  if (foundTextFormat) {\n    const result = importTextFormatTransformer(textNode, foundTextFormat.startIndex, foundTextFormat.endIndex, foundTextFormat.transformer, foundTextFormat.match);\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  } else if (foundTextMatch) {\n    const result = importFoundTextMatchTransformer(textNode, foundTextMatch.startIndex, foundTextMatch.endIndex, foundTextMatch.transformer, foundTextMatch.match);\n    if (!result) {\n      return;\n    }\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  }\n\n  // Handle escape characters\n  const textContent = textNode.getTextContent();\n  const escapedText = textContent.replace(/\\\\([*_`~\\\\])/g, '$1').replace(/&#(\\d+);/g, (_, codePoint) => {\n    return String.fromCodePoint(codePoint);\n  });\n  textNode.setTextContent(escapedText);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction createMarkdownImport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || $getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      const [imported, shiftedIndex] = $importMultiline(lines, i, byType.multilineElement, root);\n      if (imported) {\n        // If a multiline markdown element was imported, we don't want to process the lines that were part of it anymore.\n        // There could be other sub-markdown elements (both multiline and normal ones) matching within this matched multiline element's children.\n        // However, it would be the responsibility of the matched multiline transformer to decide how it wants to handle them.\n        // We cannot handle those, as there is no way for us to know how to maintain the correct order of generated lexical nodes for possible children.\n        i = shiftedIndex; // Next loop will start from the line after the last line of the multiline element\n        continue;\n      }\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch, shouldPreserveNewLines);\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren();\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove();\n      }\n    }\n    if ($getSelection() !== null) {\n      root.selectStart();\n    }\n  };\n}\n\n/**\n *\n * @returns first element of the returned tuple is a boolean indicating if a multiline element was imported. The second element is the index of the last line that was processed.\n */\nfunction $importMultiline(lines, startLineIndex, multilineElementTransformers, rootNode) {\n  for (const transformer of multilineElementTransformers) {\n    const {\n      handleImportAfterStartMatch,\n      regExpEnd,\n      regExpStart,\n      replace\n    } = transformer;\n    const startMatch = lines[startLineIndex].match(regExpStart);\n    if (!startMatch) {\n      continue; // Try next transformer\n    }\n    if (handleImportAfterStartMatch) {\n      const result = handleImportAfterStartMatch({\n        lines,\n        rootNode,\n        startLineIndex,\n        startMatch,\n        transformer\n      });\n      if (result === null) {\n        continue;\n      } else if (result) {\n        return result;\n      }\n    }\n    const regexpEndRegex = typeof regExpEnd === 'object' && 'regExp' in regExpEnd ? regExpEnd.regExp : regExpEnd;\n    const isEndOptional = regExpEnd && typeof regExpEnd === 'object' && 'optional' in regExpEnd ? regExpEnd.optional : !regExpEnd;\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    // check every single line for the closing match. It could also be on the same line as the opening match.\n    while (endLineIndex < linesLength) {\n      const endMatch = regexpEndRegex ? lines[endLineIndex].match(regexpEndRegex) : null;\n      if (!endMatch) {\n        if (!isEndOptional || isEndOptional && endLineIndex < linesLength - 1 // Optional end, but didn't reach the end of the document yet => continue searching for potential closing match\n        ) {\n          endLineIndex++;\n          continue; // Search next line for closing match\n        }\n      }\n\n      // Now, check if the closing match matched is the same as the opening match.\n      // If it is, we need to continue searching for the actual closing match.\n      if (endMatch && startLineIndex === endLineIndex && endMatch.index === startMatch.index) {\n        endLineIndex++;\n        continue; // Search next line for closing match\n      }\n\n      // At this point, we have found the closing match. Next: calculate the lines in between open and closing match\n      // This should not include the matches themselves, and be split up by lines\n      const linesInBetween = [];\n      if (endMatch && startLineIndex === endLineIndex) {\n        linesInBetween.push(lines[startLineIndex].slice(startMatch[0].length, -endMatch[0].length));\n      } else {\n        for (let i = startLineIndex; i <= endLineIndex; i++) {\n          if (i === startLineIndex) {\n            const text = lines[i].slice(startMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else if (i === endLineIndex && endMatch) {\n            const text = lines[i].slice(0, -endMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else {\n            linesInBetween.push(lines[i]);\n          }\n        }\n      }\n      if (replace(rootNode, null, startMatch, endMatch, linesInBetween, true) !== false) {\n        // Return here. This $importMultiline function is run line by line and should only process a single multiline element at a time.\n        return [true, endLineIndex];\n      }\n\n      // The replace function returned false, despite finding the matching open and close tags => this transformer does not want to handle it.\n      // Thus, we continue letting the remaining transformers handle the passed lines of text from the beginning\n      break;\n    }\n  }\n\n  // No multiline transformer handled this line successfully\n  return [false, startLineIndex];\n}\nfunction $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers, shouldPreserveNewLines) {\n  const textNode = $createTextNode(lineText);\n  const elementNode = $createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      if (replace(elementNode, [textNode], match, true) !== false) {\n        break;\n      }\n    }\n  }\n  importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineText.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if (!shouldPreserveNewLines && (\n    // Only append if we're not preserving newlines\n    $isParagraphNode(previousNode) || $isQuoteNode(previousNode) || $isListNode(previousNode))) {\n      let targetNode = previousNode;\n      if ($isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = $findMatchingParent(lastDescendant, $isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    // Single-char tag (e.g. \"*\"),\n    if (tag.length === 1) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    } else {\n      // Multiâ€char tags (e.g. \"**\")\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<!\\\\\\\\)(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?!\\\\\\\\)`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Regexp to locate *any* potential opening tag (longest first).\n    openTagsRegExp: new RegExp(`${escapeRegExp}(${openTagsRegExp.join('|')})`, 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ORDERED_LIST_REGEX = /^(\\s*)(\\d{1,})\\.\\s/;\nconst UNORDERED_LIST_REGEX = /^(\\s*)[-*+]\\s/;\nconst CHECK_LIST_REGEX = /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i;\nconst HEADING_REGEX = /^(#{1,6})\\s/;\nconst QUOTE_REGEX = /^>\\s/;\nconst CODE_START_REGEX = /^[ \\t]*```([\\w-]+)?/;\nconst CODE_END_REGEX = /[ \\t]*```$/;\nconst CODE_SINGLE_LINE_REGEX = /^[ \\t]*```[^`]+(?:(?:`{1,2}|`{4,})[^`]+)*```(?:[^`]|$)/;\nconst TABLE_ROW_REG_EXP = /^(?:\\|)(.+)(?:\\|)\\s?$/;\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/;\nconst createBlockNode = createNode => {\n  return (parentNode, children, match, isImport) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nfunction getIndent(whitespaces) {\n  const tabs = whitespaces.match(/\\t/g);\n  const spaces = whitespaces.match(/ /g);\n  let indent = 0;\n  if (tabs) {\n    indent += tabs.length;\n  }\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);\n  }\n  return indent;\n}\nconst listReplace = listType => {\n  return (parentNode, children, match, isImport) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list.append(listItem);\n      parentNode.replace(list);\n    }\n    listItem.append(...children);\n    if (!isImport) {\n      listItem.select(0, 0);\n    }\n    const indent = getIndent(match[1]);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [HeadingNode],\n  export: (node, exportChildren) => {\n    if (!$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: HEADING_REGEX,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return $createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: QUOTE_REGEX,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [$createLineBreakNode(), ...children]);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = $createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [CodeNode],\n  export: node => {\n    if (!$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExpEnd: {\n    optional: true,\n    regExp: CODE_END_REGEX\n  },\n  regExpStart: CODE_START_REGEX,\n  replace: (rootNode, children, startMatch, endMatch, linesInBetween, isImport) => {\n    let codeBlockNode;\n    let code;\n    if (!children && linesInBetween) {\n      if (linesInBetween.length === 1) {\n        // Single-line code blocks\n        if (endMatch) {\n          // End match on same line. Example: ```markdown hello```. markdown should not be considered the language here.\n          codeBlockNode = $createCodeNode();\n          code = startMatch[1] + linesInBetween[0];\n        } else {\n          // No end match. We should assume the language is next to the backticks and that code will be typed on the next line in the future\n          codeBlockNode = $createCodeNode(startMatch[1]);\n          code = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n      } else {\n        // Treat multi-line code blocks as if they always have an end match\n        codeBlockNode = $createCodeNode(startMatch[1]);\n        if (linesInBetween[0].trim().length === 0) {\n          // Filter out all start and end lines that are length 0 until we find the first line with content\n          while (linesInBetween.length > 0 && !linesInBetween[0].length) {\n            linesInBetween.shift();\n          }\n        } else {\n          // The first line already has content => Remove the first space of the line if it exists\n          linesInBetween[0] = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n\n        // Filter out all end lines that are length 0 until we find the last line with content\n        while (linesInBetween.length > 0 && !linesInBetween[linesInBetween.length - 1].length) {\n          linesInBetween.pop();\n        }\n        code = linesInBetween.join('\\n');\n      }\n      const textNode = $createTextNode(code);\n      codeBlockNode.append(textNode);\n      rootNode.append(codeBlockNode);\n    } else if (children) {\n      createBlockNode(match => {\n        return $createCodeNode(match ? match[1] : undefined);\n      })(rootNode, children, startMatch, isImport);\n    }\n  },\n  type: 'multiline-element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: UNORDERED_LIST_REGEX,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: CHECK_LIST_REGEX,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: ORDERED_LIST_REGEX,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!$isLinkNode(node) || $isAutoLinkNode(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const textContent = exportChildren(node);\n    const linkContent = title ? `[${textContent}](${node.getURL()} \"${title}\")` : `[${textContent}](${node.getURL()})`;\n    return linkContent;\n  },\n  importRegExp: /(?:\\[(.*?)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[(.*?)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = $createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const openBracketAmount = linkText.split('[').length - 1;\n    const closeBracketAmount = linkText.split(']').length - 1;\n    let parsedLinkText = linkText;\n    let outsideLinkText = '';\n    if (openBracketAmount < closeBracketAmount) {\n      return;\n    } else if (openBracketAmount > closeBracketAmount) {\n      const linkTextParts = linkText.split('[');\n      outsideLinkText = '[' + linkTextParts[0];\n      parsedLinkText = linkTextParts.slice(1).join('[');\n    }\n    const linkTextNode = $createTextNode(parsedLinkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n    if (outsideLinkText) {\n      linkNode.insertBefore($createTextNode(outsideLinkText));\n    }\n    return linkTextNode;\n  },\n  trigger: ')',\n  type: 'text-match'\n};\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, UNORDERED_LIST, ORDERED_LIST];\nconst MULTILINE_ELEMENT_TRANSFORMERS = [CODE];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...MULTILINE_ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\nfunction normalizeMarkdown(input, shouldMergeAdjacentLines = false) {\n  const lines = input.split('\\n');\n  let inCodeBlock = false;\n  const sanitizedLines = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lastLine = sanitizedLines[sanitizedLines.length - 1];\n\n    // Code blocks of ```single line``` don't toggle the inCodeBlock flag\n    if (CODE_SINGLE_LINE_REGEX.test(line)) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // Detect the start or end of a code block\n    if (CODE_START_REGEX.test(line) || CODE_END_REGEX.test(line)) {\n      inCodeBlock = !inCodeBlock;\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // If we are inside a code block, keep the line unchanged\n    if (inCodeBlock) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // In markdown the concept of \"empty paragraphs\" does not exist.\n    // Blocks must be separated by an empty line. Non-empty adjacent lines must be merged.\n    if (line === '' || lastLine === '' || !lastLine || HEADING_REGEX.test(lastLine) || HEADING_REGEX.test(line) || QUOTE_REGEX.test(line) || ORDERED_LIST_REGEX.test(line) || UNORDERED_LIST_REGEX.test(line) || CHECK_LIST_REGEX.test(line) || TABLE_ROW_REG_EXP.test(line) || TABLE_ROW_DIVIDER_REG_EXP.test(line) || !shouldMergeAdjacentLines) {\n      sanitizedLines.push(line);\n    } else {\n      sanitizedLines[sanitizedLines.length - 1] = lastLine + line;\n    }\n  }\n  return sanitizedLines.join('\\n');\n}\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExpStart,\n    replace,\n    regExpEnd\n  } of elementTransformers) {\n    if (regExpEnd && !('optional' in regExpEnd) || regExpEnd && 'optional' in regExpEnd && !regExpEnd.optional) {\n      continue;\n    }\n    const match = textContent.match(regExpStart);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, null, null, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    if (!transformer.replace || !transformer.regExp) {\n      continue;\n    }\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if ($isLineBreakNode(sibling)) {\n        break;\n      }\n      if ($isTextNode(sibling)) {\n        if (sibling.hasFormat('code')) {\n          continue;\n        }\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = $getSelection();\n    const nextSelection = $createRangeSelection();\n    $setSelection(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersByTrigger = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match' || type === 'multiline-element') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            formatDevErrorMessage(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const $transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {\n      return;\n    }\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has(COLLABORATION_TAG) || tags.has(HISTORIC_TAG)) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read($getSelection);\n    const prevSelection = prevEditorState.read($getSelection);\n\n    // We expect selection to be a collapsed range and not match previous one (as we want\n    // to trigger transforms only as user types)\n    if (!$isRangeSelection(prevSelection) || !$isRangeSelection(selection) || !selection.isCollapsed() || selection.is(prevSelection)) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      if (!canContainTransformableMarkdown(anchorNode)) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || $isCodeNode(parentNode)) {\n        return;\n      }\n      $transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n *\n *  @param {boolean} [shouldPreserveNewLines] By setting this to true, new lines will be preserved between conversions\n *  @param {boolean} [shouldMergeAdjacentLines] By setting this to true, adjacent non empty lines will be merged according to commonmark spec: https://spec.commonmark.org/0.24/#example-177. Not applicable if shouldPreserveNewLines = true.\n */\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false, shouldMergeAdjacentLines = false) {\n  const sanitizedMarkdown = shouldPreserveNewLines ? markdown : normalizeMarkdown(markdown, shouldMergeAdjacentLines);\n  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);\n  return importMarkdown(sanitizedMarkdown, node);\n}\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);\n  return exportMarkdown(node);\n}\n\nexport { $convertFromMarkdownString, $convertToMarkdownString, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, CHECK_LIST, CODE, ELEMENT_TRANSFORMERS, HEADING, HIGHLIGHT, INLINE_CODE, ITALIC_STAR, ITALIC_UNDERSCORE, LINK, MULTILINE_ELEMENT_TRANSFORMERS, ORDERED_LIST, QUOTE, STRIKETHROUGH, TEXT_FORMAT_TRANSFORMERS, TEXT_MATCH_TRANSFORMERS, TRANSFORMERS, UNORDERED_LIST, registerMarkdownShortcuts };\n"],
  "mappings": "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",
  "names": ["exportChildren"]
}
