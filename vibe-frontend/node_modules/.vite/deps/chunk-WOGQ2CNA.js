// node_modules/@tanstack/pacer-lite/dist/lite-debouncer.js
var LiteDebouncer = class {
  constructor(fn, options) {
    this.fn = fn;
    this.options = options;
    this.canLeadingExecute = true;
    this.maybeExecute = (...args) => {
      var _a, _b;
      let didLeadingExecute = false;
      if (this.options.leading && this.canLeadingExecute) {
        this.canLeadingExecute = false;
        didLeadingExecute = true;
        this.fn(...args);
        (_b = (_a = this.options).onExecute) == null ? void 0 : _b.call(_a, args, this);
      }
      this.lastArgs = args;
      if (this.timeoutId) clearTimeout(this.timeoutId);
      this.timeoutId = setTimeout(() => {
        var _a2, _b2;
        this.canLeadingExecute = true;
        if (this.options.trailing && !didLeadingExecute && this.lastArgs) {
          this.fn(...this.lastArgs);
          (_b2 = (_a2 = this.options).onExecute) == null ? void 0 : _b2.call(_a2, this.lastArgs, this);
        }
        this.lastArgs = void 0;
      }, this.options.wait);
    };
    this.flush = () => {
      var _a, _b;
      if (this.timeoutId && this.lastArgs) {
        clearTimeout(this.timeoutId);
        this.timeoutId = void 0;
        const args = this.lastArgs;
        this.fn(...args);
        (_b = (_a = this.options).onExecute) == null ? void 0 : _b.call(_a, args, this);
        this.lastArgs = void 0;
        this.canLeadingExecute = true;
      }
    };
    this.cancel = () => {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = void 0;
      }
      this.lastArgs = void 0;
      this.canLeadingExecute = true;
    };
    if (this.options.leading === void 0 && this.options.trailing === void 0) this.options.trailing = true;
  }
};

// node_modules/@tanstack/pacer-lite/dist/lite-queuer.js
var LiteQueuer = class {
  constructor(fn, options = {}) {
    this.fn = fn;
    this.options = options;
    this.items = [];
    this.timeoutId = null;
    this.isRunning = true;
    this.pendingTick = false;
    this.addItem = (item, position = this.options.addItemsTo, startProcessing = true) => {
      if (this.items.length >= this.options.maxSize) return false;
      if (this.options.getPriority) {
        const priority = this.options.getPriority(item);
        if (priority !== void 0) {
          const insertIndex = this.items.findIndex((existing) => {
            return (this.options.getPriority(existing) ?? -Infinity) < priority;
          });
          if (insertIndex === -1) this.items.push(item);
          else this.items.splice(insertIndex, 0, item);
        } else this.insertAtPosition(item, position);
      } else this.insertAtPosition(item, position);
      if (startProcessing && this.isRunning && !this.pendingTick) this.tick();
      return true;
    };
    this.insertAtPosition = (item, position) => {
      if (position === "front") this.items.unshift(item);
      else this.items.push(item);
    };
    this.getNextItem = (position = this.options.getItemsFrom) => {
      if (this.items.length === 0) return;
      let item;
      if (this.options.getPriority || position === "front") item = this.items.shift();
      else item = this.items.pop();
      return item;
    };
    this.execute = (position) => {
      const item = this.getNextItem(position);
      if (item !== void 0) this.fn(item);
      return item;
    };
    this.tick = () => {
      if (!this.isRunning) {
        this.pendingTick = false;
        return;
      }
      this.pendingTick = true;
      while (this.items.length > 0) {
        if (this.execute(this.options.getItemsFrom) === void 0) break;
        const wait = this.options.wait;
        if (wait > 0) {
          this.timeoutId = setTimeout(() => this.tick(), wait);
          return;
        }
      }
      this.pendingTick = false;
    };
    this.start = () => {
      this.isRunning = true;
      if (!this.pendingTick && this.items.length > 0) this.tick();
    };
    this.stop = () => {
      this.clearTimeout();
      this.isRunning = false;
      this.pendingTick = false;
    };
    this.clearTimeout = () => {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    };
    this.peekNextItem = (position = "front") => {
      if (this.items.length === 0) return;
      if (this.options.getPriority || position === "front") return this.items[0];
      else return this.items[this.items.length - 1];
    };
    this.peekAllItems = () => {
      return [...this.items];
    };
    this.flush = (numberOfItems = this.items.length, position) => {
      this.clearTimeout();
      for (let i = 0; i < numberOfItems && this.items.length > 0; i++) this.execute(position);
      if (this.isRunning && this.items.length > 0 && !this.pendingTick) this.tick();
    };
    this.flushAsBatch = (batchFunction) => {
      const items = this.peekAllItems();
      this.clear();
      batchFunction(items);
    };
    this.clear = () => {
      this.items = [];
    };
    this.options.addItemsTo = this.options.addItemsTo ?? "back";
    this.options.getItemsFrom = this.options.getItemsFrom ?? "front";
    this.options.maxSize = this.options.maxSize ?? Infinity;
    this.options.started = this.options.started ?? true;
    this.options.wait = this.options.wait ?? 0;
    this.isRunning = this.options.started;
    if (this.options.initialItems) for (const item of this.options.initialItems) this.addItem(item, this.options.addItemsTo, false);
    if (this.isRunning && this.items.length > 0) this.tick();
  }
  /**
  * Number of items currently in the queue
  */
  get size() {
    return this.items.length;
  }
  /**
  * Whether the queue is empty
  */
  get isEmpty() {
    return this.items.length === 0;
  }
  /**
  * Whether the queue is currently running (auto-processing items)
  */
  get isQueueRunning() {
    return this.isRunning;
  }
};

// node_modules/@tanstack/pacer-lite/dist/lite-throttler.js
var LiteThrottler = class {
  constructor(fn, options) {
    this.fn = fn;
    this.options = options;
    this.lastExecutionTime = 0;
    this.isPending = false;
    this.maybeExecute = (...args) => {
      const timeSinceLastExecution = Date.now() - this.lastExecutionTime;
      if (this.options.leading && timeSinceLastExecution >= this.options.wait) this.execute(...args);
      else {
        this.lastArgs = args;
        if (!this.timeoutId && this.options.trailing) {
          const timeoutDuration = this.options.wait - timeSinceLastExecution;
          this.isPending = true;
          this.timeoutId = setTimeout(() => {
            if (this.lastArgs !== void 0) this.execute(...this.lastArgs);
          }, timeoutDuration);
        }
      }
    };
    this.execute = (...args) => {
      var _a, _b;
      this.fn(...args);
      (_b = (_a = this.options).onExecute) == null ? void 0 : _b.call(_a, args, this);
      this.lastExecutionTime = Date.now();
      this.clearTimeout();
      this.lastArgs = void 0;
      this.isPending = false;
    };
    this.flush = () => {
      if (this.isPending && this.lastArgs) this.execute(...this.lastArgs);
    };
    this.cancel = () => {
      this.clearTimeout();
      this.lastArgs = void 0;
      this.isPending = false;
    };
    this.clearTimeout = () => {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = void 0;
      }
    };
    if (this.options.leading === void 0 && this.options.trailing === void 0) {
      this.options.leading = true;
      this.options.trailing = true;
    }
  }
};
function liteThrottle(fn, options) {
  return new LiteThrottler(fn, options).maybeExecute;
}

export {
  LiteDebouncer,
  LiteQueuer,
  LiteThrottler,
  liteThrottle
};
//# sourceMappingURL=chunk-WOGQ2CNA.js.map
