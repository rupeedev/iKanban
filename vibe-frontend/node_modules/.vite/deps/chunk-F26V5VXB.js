import {
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper
} from "./chunk-OL46QLBJ.js";

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/ir.js
var ir_exports = {};
__export(ir_exports, {
  Aggregate: () => Aggregate,
  CollectionRef: () => CollectionRef,
  Func: () => Func,
  PropRef: () => PropRef,
  QueryRef: () => QueryRef,
  Value: () => Value,
  createResidualWhere: () => createResidualWhere,
  followRef: () => followRef,
  getHavingExpression: () => getHavingExpression,
  getWhereExpression: () => getWhereExpression,
  isExpressionLike: () => isExpressionLike,
  isResidualWhere: () => isResidualWhere
});
var BaseExpression = class {
};
var CollectionRef = class extends BaseExpression {
  constructor(collection, alias) {
    super();
    this.collection = collection;
    this.alias = alias;
    this.type = `collectionRef`;
  }
};
var QueryRef = class extends BaseExpression {
  constructor(query, alias) {
    super();
    this.query = query;
    this.alias = alias;
    this.type = `queryRef`;
  }
};
var PropRef = class extends BaseExpression {
  constructor(path) {
    super();
    this.path = path;
    this.type = `ref`;
  }
};
var Value = class extends BaseExpression {
  constructor(value) {
    super();
    this.value = value;
    this.type = `val`;
  }
};
var Func = class extends BaseExpression {
  constructor(name, args) {
    super();
    this.name = name;
    this.args = args;
    this.type = `func`;
  }
};
var Aggregate = class extends BaseExpression {
  constructor(name, args) {
    super();
    this.name = name;
    this.args = args;
    this.type = `agg`;
  }
};
function isExpressionLike(value) {
  return value instanceof Aggregate || value instanceof Func || value instanceof PropRef || value instanceof Value;
}
function getWhereExpression(where) {
  return typeof where === `object` && `expression` in where ? where.expression : where;
}
function getHavingExpression(having) {
  return typeof having === `object` && `expression` in having ? having.expression : having;
}
function isResidualWhere(where) {
  return typeof where === `object` && `expression` in where && where.residual === true;
}
function createResidualWhere(expression) {
  return { expression, residual: true };
}
function getRefFromAlias(query, alias) {
  if (query.from.alias === alias) {
    return query.from;
  }
  for (const join2 of query.join || []) {
    if (join2.from.alias === alias) {
      return join2.from;
    }
  }
}
function followRef(query, ref, collection) {
  if (ref.path.length === 0) {
    return;
  }
  if (ref.path.length === 1) {
    const field = ref.path[0];
    if (query.select) {
      const selectedField = query.select[field];
      if (selectedField && selectedField.type === `ref`) {
        return followRef(query, selectedField, collection);
      }
    }
    return { collection, path: [field] };
  }
  if (ref.path.length > 1) {
    const [alias, ...rest] = ref.path;
    const aliasRef = getRefFromAlias(query, alias);
    if (!aliasRef) {
      return;
    }
    if (aliasRef.type === `queryRef`) {
      return followRef(aliasRef.query, new PropRef(rest), collection);
    } else {
      return { collection: aliasRef.collection, path: rest };
    }
  }
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/errors.js
var TanStackDBError = class extends Error {
  constructor(message) {
    super(message);
    this.name = `TanStackDBError`;
  }
};
var NonRetriableError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `NonRetriableError`;
  }
};
var SchemaValidationError = class extends TanStackDBError {
  constructor(type, issues, message) {
    const defaultMessage = `${type === `insert` ? `Insert` : `Update`} validation failed: ${issues.map((issue) => `
- ${issue.message} - path: ${issue.path}`).join(``)}`;
    super(message || defaultMessage);
    this.name = `SchemaValidationError`;
    this.type = type;
    this.issues = issues;
  }
};
var DuplicateDbInstanceError = class extends TanStackDBError {
  constructor() {
    super(
      `Multiple instances of @tanstack/db detected!

This causes transaction context to be lost because each instance maintains its own transaction stack.

Common causes:
1. Different versions of @tanstack/db installed
2. Incompatible peer dependency versions in packages
3. Module resolution issues in bundler configuration

To fix:
1. Check installed versions: npm list @tanstack/db (or pnpm/yarn list)
2. Force a single version using package manager overrides:
   - npm: "overrides" in package.json
   - pnpm: "pnpm.overrides" in package.json
   - yarn: "resolutions" in package.json
3. Clear node_modules and lockfile, then reinstall

To temporarily disable this check (not recommended):
Set environment variable: TANSTACK_DB_DISABLE_DUP_CHECK=1

See: https://tanstack.com/db/latest/docs/troubleshooting#duplicate-instances`
    );
    this.name = `DuplicateDbInstanceError`;
  }
};
var CollectionConfigurationError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `CollectionConfigurationError`;
  }
};
var CollectionRequiresConfigError = class extends CollectionConfigurationError {
  constructor() {
    super(`Collection requires a config`);
  }
};
var CollectionRequiresSyncConfigError = class extends CollectionConfigurationError {
  constructor() {
    super(`Collection requires a sync config`);
  }
};
var InvalidSchemaError = class extends CollectionConfigurationError {
  constructor() {
    super(`Schema must implement the standard-schema interface`);
  }
};
var SchemaMustBeSynchronousError = class extends CollectionConfigurationError {
  constructor() {
    super(`Schema validation must be synchronous`);
  }
};
var CollectionStateError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `CollectionStateError`;
  }
};
var CollectionInErrorStateError = class extends CollectionStateError {
  constructor(operation, collectionId) {
    super(
      `Cannot perform ${operation} on collection "${collectionId}" - collection is in error state. Try calling cleanup() and restarting the collection.`
    );
  }
};
var InvalidCollectionStatusTransitionError = class extends CollectionStateError {
  constructor(from, to, collectionId) {
    super(
      `Invalid collection status transition from "${from}" to "${to}" for collection "${collectionId}"`
    );
  }
};
var CollectionIsInErrorStateError = class extends CollectionStateError {
  constructor() {
    super(`Collection is in error state`);
  }
};
var NegativeActiveSubscribersError = class extends CollectionStateError {
  constructor() {
    super(`Active subscribers count is negative - this should never happen`);
  }
};
var CollectionOperationError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `CollectionOperationError`;
  }
};
var UndefinedKeyError = class extends CollectionOperationError {
  constructor(item) {
    super(
      `An object was created without a defined key: ${JSON.stringify(item)}`
    );
  }
};
var DuplicateKeyError = class extends CollectionOperationError {
  constructor(key) {
    super(
      `Cannot insert document with ID "${key}" because it already exists in the collection`
    );
  }
};
var DuplicateKeySyncError = class extends CollectionOperationError {
  constructor(key, collectionId, options) {
    const baseMessage = `Cannot insert document with key "${key}" from sync because it already exists in the collection "${collectionId}"`;
    if ((options == null ? void 0 : options.hasCustomGetKey) && options.hasJoins) {
      super(
        `${baseMessage}. This collection uses a custom getKey with joined queries. Joined queries can produce multiple rows with the same key when relationships are not 1:1. Consider: (1) using a composite key in your getKey function (e.g., \`\${item.key1}-\${item.key2}\`), (2) ensuring your join produces unique rows per key, or (3) removing the custom getKey to use the default composite key behavior.`
      );
    } else {
      super(baseMessage);
    }
  }
};
var MissingUpdateArgumentError = class extends CollectionOperationError {
  constructor() {
    super(`The first argument to update is missing`);
  }
};
var NoKeysPassedToUpdateError = class extends CollectionOperationError {
  constructor() {
    super(`No keys were passed to update`);
  }
};
var UpdateKeyNotFoundError = class extends CollectionOperationError {
  constructor(key) {
    super(
      `The key "${key}" was passed to update but an object for this key was not found in the collection`
    );
  }
};
var KeyUpdateNotAllowedError = class extends CollectionOperationError {
  constructor(originalKey, newKey) {
    super(
      `Updating the key of an item is not allowed. Original key: "${originalKey}", Attempted new key: "${newKey}". Please delete the old item and create a new one if a key change is necessary.`
    );
  }
};
var NoKeysPassedToDeleteError = class extends CollectionOperationError {
  constructor() {
    super(`No keys were passed to delete`);
  }
};
var DeleteKeyNotFoundError = class extends CollectionOperationError {
  constructor(key) {
    super(
      `Collection.delete was called with key '${key}' but there is no item in the collection with this key`
    );
  }
};
var MissingHandlerError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `MissingHandlerError`;
  }
};
var MissingInsertHandlerError = class extends MissingHandlerError {
  constructor() {
    super(
      `Collection.insert called directly (not within an explicit transaction) but no 'onInsert' handler is configured.`
    );
  }
};
var MissingUpdateHandlerError = class extends MissingHandlerError {
  constructor() {
    super(
      `Collection.update called directly (not within an explicit transaction) but no 'onUpdate' handler is configured.`
    );
  }
};
var MissingDeleteHandlerError = class extends MissingHandlerError {
  constructor() {
    super(
      `Collection.delete called directly (not within an explicit transaction) but no 'onDelete' handler is configured.`
    );
  }
};
var TransactionError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `TransactionError`;
  }
};
var MissingMutationFunctionError = class extends TransactionError {
  constructor() {
    super(`mutationFn is required when creating a transaction`);
  }
};
var OnMutateMustBeSynchronousError = class extends TransactionError {
  constructor() {
    super(
      `onMutate must be synchronous and cannot return a promise. Remove async/await or returned promises from onMutate.`
    );
    this.name = `OnMutateMustBeSynchronousError`;
  }
};
var TransactionNotPendingMutateError = class extends TransactionError {
  constructor() {
    super(
      `You can no longer call .mutate() as the transaction is no longer pending`
    );
  }
};
var TransactionAlreadyCompletedRollbackError = class extends TransactionError {
  constructor() {
    super(
      `You can no longer call .rollback() as the transaction is already completed`
    );
  }
};
var TransactionNotPendingCommitError = class extends TransactionError {
  constructor() {
    super(
      `You can no longer call .commit() as the transaction is no longer pending`
    );
  }
};
var NoPendingSyncTransactionWriteError = class extends TransactionError {
  constructor() {
    super(`No pending sync transaction to write to`);
  }
};
var SyncTransactionAlreadyCommittedWriteError = class extends TransactionError {
  constructor() {
    super(
      `The pending sync transaction is already committed, you can't still write to it.`
    );
  }
};
var NoPendingSyncTransactionCommitError = class extends TransactionError {
  constructor() {
    super(`No pending sync transaction to commit`);
  }
};
var SyncTransactionAlreadyCommittedError = class extends TransactionError {
  constructor() {
    super(
      `The pending sync transaction is already committed, you can't commit it again.`
    );
  }
};
var QueryBuilderError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `QueryBuilderError`;
  }
};
var OnlyOneSourceAllowedError = class extends QueryBuilderError {
  constructor(context) {
    super(`Only one source is allowed in the ${context}`);
  }
};
var SubQueryMustHaveFromClauseError = class extends QueryBuilderError {
  constructor(context) {
    super(`A sub query passed to a ${context} must have a from clause itself`);
  }
};
var InvalidSourceError = class extends QueryBuilderError {
  constructor(alias) {
    super(
      `Invalid source for live query: The value provided for alias "${alias}" is not a Collection or subquery. Live queries only accept Collection instances or subqueries. Please ensure you're passing a valid Collection or QueryBuilder, not a plain array or other data type.`
    );
  }
};
var InvalidSourceTypeError = class extends QueryBuilderError {
  constructor(context, type) {
    super(
      `Invalid source for ${context}: Expected an object with a single key-value pair like { alias: collection }. For example: .from({ todos: todosCollection }). Got: ${type}`
    );
  }
};
var JoinConditionMustBeEqualityError = class extends QueryBuilderError {
  constructor() {
    super(`Join condition must be an equality expression`);
  }
};
var QueryMustHaveFromClauseError = class extends QueryBuilderError {
  constructor() {
    super(`Query must have a from clause`);
  }
};
var QueryCompilationError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `QueryCompilationError`;
  }
};
var DistinctRequiresSelectError = class extends QueryCompilationError {
  constructor() {
    super(`DISTINCT requires a SELECT clause.`);
  }
};
var HavingRequiresGroupByError = class extends QueryCompilationError {
  constructor() {
    super(`HAVING clause requires GROUP BY clause`);
  }
};
var LimitOffsetRequireOrderByError = class extends QueryCompilationError {
  constructor() {
    super(
      `LIMIT and OFFSET require an ORDER BY clause to ensure deterministic results`
    );
  }
};
var CollectionInputNotFoundError = class extends QueryCompilationError {
  constructor(alias, collectionId, availableKeys) {
    const details = collectionId ? `alias "${alias}" (collection "${collectionId}")` : `collection "${alias}"`;
    const availableKeysMsg = (availableKeys == null ? void 0 : availableKeys.length) ? `. Available keys: ${availableKeys.join(`, `)}` : ``;
    super(`Input for ${details} not found in inputs map${availableKeysMsg}`);
  }
};
var DuplicateAliasInSubqueryError = class extends QueryCompilationError {
  constructor(alias, parentAliases) {
    super(
      `Subquery uses alias "${alias}" which is already used in the parent query. Each alias must be unique across parent and subquery contexts. Parent query aliases: ${parentAliases.join(`, `)}. Please rename "${alias}" in either the parent query or subquery to avoid conflicts.`
    );
  }
};
var UnsupportedFromTypeError = class extends QueryCompilationError {
  constructor(type) {
    super(`Unsupported FROM type: ${type}`);
  }
};
var UnknownExpressionTypeError = class extends QueryCompilationError {
  constructor(type) {
    super(`Unknown expression type: ${type}`);
  }
};
var EmptyReferencePathError = class extends QueryCompilationError {
  constructor() {
    super(`Reference path cannot be empty`);
  }
};
var UnknownFunctionError = class extends QueryCompilationError {
  constructor(functionName) {
    super(`Unknown function: ${functionName}`);
  }
};
var JoinCollectionNotFoundError = class extends QueryCompilationError {
  constructor(collectionId) {
    super(`Collection "${collectionId}" not found during compilation of join`);
  }
};
var JoinError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `JoinError`;
  }
};
var UnsupportedJoinTypeError = class extends JoinError {
  constructor(joinType) {
    super(`Unsupported join type: ${joinType}`);
  }
};
var InvalidJoinConditionSameSourceError = class extends JoinError {
  constructor(sourceAlias) {
    super(
      `Invalid join condition: both expressions refer to the same source "${sourceAlias}"`
    );
  }
};
var InvalidJoinConditionSourceMismatchError = class extends JoinError {
  constructor() {
    super(`Invalid join condition: expressions must reference source aliases`);
  }
};
var InvalidJoinConditionLeftSourceError = class extends JoinError {
  constructor(sourceAlias) {
    super(
      `Invalid join condition: left expression refers to an unavailable source "${sourceAlias}"`
    );
  }
};
var InvalidJoinConditionRightSourceError = class extends JoinError {
  constructor(sourceAlias) {
    super(
      `Invalid join condition: right expression does not refer to the joined source "${sourceAlias}"`
    );
  }
};
var InvalidJoinCondition = class extends JoinError {
  constructor() {
    super(`Invalid join condition`);
  }
};
var UnsupportedJoinSourceTypeError = class extends JoinError {
  constructor(type) {
    super(`Unsupported join source type: ${type}`);
  }
};
var GroupByError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `GroupByError`;
  }
};
var NonAggregateExpressionNotInGroupByError = class extends GroupByError {
  constructor(alias) {
    super(
      `Non-aggregate expression '${alias}' in SELECT must also appear in GROUP BY clause`
    );
  }
};
var UnsupportedAggregateFunctionError = class extends GroupByError {
  constructor(functionName) {
    super(`Unsupported aggregate function: ${functionName}`);
  }
};
var AggregateFunctionNotInSelectError = class extends GroupByError {
  constructor(functionName) {
    super(
      `Aggregate function in HAVING clause must also be in SELECT clause: ${functionName}`
    );
  }
};
var UnknownHavingExpressionTypeError = class extends GroupByError {
  constructor(type) {
    super(`Unknown expression type in HAVING clause: ${type}`);
  }
};
var StorageError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `StorageError`;
  }
};
var SerializationError = class extends StorageError {
  constructor(operation, originalError) {
    super(
      `Cannot ${operation} item because it cannot be JSON serialized: ${originalError}`
    );
  }
};
var LocalStorageCollectionError = class extends StorageError {
  constructor(message) {
    super(message);
    this.name = `LocalStorageCollectionError`;
  }
};
var StorageKeyRequiredError = class extends LocalStorageCollectionError {
  constructor() {
    super(`[LocalStorageCollection] storageKey must be provided.`);
  }
};
var InvalidStorageDataFormatError = class extends LocalStorageCollectionError {
  constructor(storageKey, key) {
    super(
      `[LocalStorageCollection] Invalid data format in storage key "${storageKey}" for key "${key}".`
    );
  }
};
var InvalidStorageObjectFormatError = class extends LocalStorageCollectionError {
  constructor(storageKey) {
    super(
      `[LocalStorageCollection] Invalid data format in storage key "${storageKey}". Expected object format.`
    );
  }
};
var SyncCleanupError = class extends TanStackDBError {
  constructor(collectionId, error) {
    const message = error instanceof Error ? error.message : String(error);
    super(
      `Collection "${collectionId}" sync cleanup function threw an error: ${message}`
    );
    this.name = `SyncCleanupError`;
  }
};
var QueryOptimizerError = class extends TanStackDBError {
  constructor(message) {
    super(message);
    this.name = `QueryOptimizerError`;
  }
};
var CannotCombineEmptyExpressionListError = class extends QueryOptimizerError {
  constructor() {
    super(`Cannot combine empty expression list`);
  }
};
var WhereClauseConversionError = class extends QueryOptimizerError {
  constructor(collectionId, alias) {
    super(
      `Failed to convert WHERE clause to collection filter for collection '${collectionId}' alias '${alias}'. This indicates a bug in the query optimization logic.`
    );
  }
};
var SubscriptionNotFoundError = class extends QueryCompilationError {
  constructor(resolvedAlias, originalAlias, collectionId, availableAliases) {
    super(
      `Internal error: subscription for alias '${resolvedAlias}' (remapped from '${originalAlias}', collection '${collectionId}') is missing in join pipeline. Available aliases: ${availableAliases.join(`, `)}. This indicates a bug in alias tracking.`
    );
  }
};
var AggregateNotSupportedError = class extends QueryCompilationError {
  constructor() {
    super(
      `Aggregate expressions are not supported in this context. Use GROUP BY clause for aggregates.`
    );
  }
};
var MissingAliasInputsError = class extends QueryCompilationError {
  constructor(missingAliases) {
    super(
      `Internal error: compiler returned aliases without inputs: ${missingAliases.join(`, `)}. This indicates a bug in query compilation. Please report this issue.`
    );
  }
};
var SetWindowRequiresOrderByError = class extends QueryCompilationError {
  constructor() {
    super(
      `setWindow() can only be called on collections with an ORDER BY clause. Add .orderBy() to your query to enable window movement.`
    );
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/builder/ref-proxy.js
function createSingleRowRefProxy() {
  const cache = /* @__PURE__ */ new Map();
  function createProxy(path) {
    const pathKey = path.join(`.`);
    if (cache.has(pathKey)) {
      return cache.get(pathKey);
    }
    const proxy = new Proxy({}, {
      get(target, prop, receiver) {
        if (prop === `__refProxy`) return true;
        if (prop === `__path`) return path;
        if (prop === `__type`) return void 0;
        if (typeof prop === `symbol`) return Reflect.get(target, prop, receiver);
        const newPath = [...path, String(prop)];
        return createProxy(newPath);
      },
      has(target, prop) {
        if (prop === `__refProxy` || prop === `__path` || prop === `__type`)
          return true;
        return Reflect.has(target, prop);
      },
      ownKeys(target) {
        return Reflect.ownKeys(target);
      },
      getOwnPropertyDescriptor(target, prop) {
        if (prop === `__refProxy` || prop === `__path` || prop === `__type`) {
          return { enumerable: false, configurable: true };
        }
        return Reflect.getOwnPropertyDescriptor(target, prop);
      }
    });
    cache.set(pathKey, proxy);
    return proxy;
  }
  return createProxy([]);
}
function createRefProxy(aliases) {
  const cache = /* @__PURE__ */ new Map();
  let accessId = 0;
  function createProxy(path) {
    const pathKey = path.join(`.`);
    if (cache.has(pathKey)) {
      return cache.get(pathKey);
    }
    const proxy = new Proxy({}, {
      get(target, prop, receiver) {
        if (prop === `__refProxy`) return true;
        if (prop === `__path`) return path;
        if (prop === `__type`) return void 0;
        if (typeof prop === `symbol`) return Reflect.get(target, prop, receiver);
        const newPath = [...path, String(prop)];
        return createProxy(newPath);
      },
      has(target, prop) {
        if (prop === `__refProxy` || prop === `__path` || prop === `__type`)
          return true;
        return Reflect.has(target, prop);
      },
      ownKeys(target) {
        const id = ++accessId;
        const sentinelKey = `__SPREAD_SENTINEL__${path.join(`.`)}__${id}`;
        if (!Object.prototype.hasOwnProperty.call(target, sentinelKey)) {
          Object.defineProperty(target, sentinelKey, {
            enumerable: true,
            configurable: true,
            value: true
          });
        }
        return Reflect.ownKeys(target);
      },
      getOwnPropertyDescriptor(target, prop) {
        if (prop === `__refProxy` || prop === `__path` || prop === `__type`) {
          return { enumerable: false, configurable: true };
        }
        return Reflect.getOwnPropertyDescriptor(target, prop);
      }
    });
    cache.set(pathKey, proxy);
    return proxy;
  }
  const rootProxy = new Proxy({}, {
    get(target, prop, receiver) {
      if (prop === `__refProxy`) return true;
      if (prop === `__path`) return [];
      if (prop === `__type`) return void 0;
      if (typeof prop === `symbol`) return Reflect.get(target, prop, receiver);
      const propStr = String(prop);
      if (aliases.includes(propStr)) {
        return createProxy([propStr]);
      }
      return void 0;
    },
    has(target, prop) {
      if (prop === `__refProxy` || prop === `__path` || prop === `__type`)
        return true;
      if (typeof prop === `string` && aliases.includes(prop)) return true;
      return Reflect.has(target, prop);
    },
    ownKeys(_target) {
      return [...aliases, `__refProxy`, `__path`, `__type`];
    },
    getOwnPropertyDescriptor(target, prop) {
      if (prop === `__refProxy` || prop === `__path` || prop === `__type`) {
        return { enumerable: false, configurable: true };
      }
      if (typeof prop === `string` && aliases.includes(prop)) {
        return { enumerable: true, configurable: true };
      }
      return void 0;
    }
  });
  return rootProxy;
}
function toExpression(value) {
  if (isRefProxy(value)) {
    return new PropRef(value.__path);
  }
  if (value && typeof value === `object` && `type` in value && (value.type === `func` || value.type === `ref` || value.type === `val` || value.type === `agg`)) {
    return value;
  }
  return new Value(value);
}
function isRefProxy(value) {
  return value && typeof value === `object` && value.__refProxy === true;
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/builder/functions.js
function eq(left, right) {
  return new Func(`eq`, [toExpression(left), toExpression(right)]);
}
function gt(left, right) {
  return new Func(`gt`, [toExpression(left), toExpression(right)]);
}
function gte(left, right) {
  return new Func(`gte`, [toExpression(left), toExpression(right)]);
}
function lt(left, right) {
  return new Func(`lt`, [toExpression(left), toExpression(right)]);
}
function lte(left, right) {
  return new Func(`lte`, [toExpression(left), toExpression(right)]);
}
function and(left, right, ...rest) {
  const allArgs = [left, right, ...rest];
  return new Func(
    `and`,
    allArgs.map((arg) => toExpression(arg))
  );
}
function or(left, right, ...rest) {
  const allArgs = [left, right, ...rest];
  return new Func(
    `or`,
    allArgs.map((arg) => toExpression(arg))
  );
}
function not(value) {
  return new Func(`not`, [toExpression(value)]);
}
function isUndefined(value) {
  return new Func(`isUndefined`, [toExpression(value)]);
}
function isNull(value) {
  return new Func(`isNull`, [toExpression(value)]);
}
function inArray(value, array) {
  return new Func(`in`, [toExpression(value), toExpression(array)]);
}
function like(left, right) {
  return new Func(`like`, [toExpression(left), toExpression(right)]);
}
function ilike(left, right) {
  return new Func(`ilike`, [toExpression(left), toExpression(right)]);
}
function upper(arg) {
  return new Func(`upper`, [toExpression(arg)]);
}
function lower(arg) {
  return new Func(`lower`, [toExpression(arg)]);
}
function length(arg) {
  return new Func(`length`, [toExpression(arg)]);
}
function concat(...args) {
  return new Func(
    `concat`,
    args.map((arg) => toExpression(arg))
  );
}
function coalesce(...args) {
  return new Func(
    `coalesce`,
    args.map((arg) => toExpression(arg))
  );
}
function add(left, right) {
  return new Func(`add`, [
    toExpression(left),
    toExpression(right)
  ]);
}
function count(arg) {
  return new Aggregate(`count`, [toExpression(arg)]);
}
function avg(arg) {
  return new Aggregate(`avg`, [toExpression(arg)]);
}
function sum(arg) {
  return new Aggregate(`sum`, [toExpression(arg)]);
}
function min(arg) {
  return new Aggregate(`min`, [toExpression(arg)]);
}
function max(arg) {
  return new Aggregate(`max`, [toExpression(arg)]);
}
var comparisonFunctions = [
  `eq`,
  `gt`,
  `gte`,
  `lt`,
  `lte`,
  `in`,
  `like`,
  `ilike`
];
var operators = [
  // Comparison operators
  `eq`,
  `gt`,
  `gte`,
  `lt`,
  `lte`,
  `in`,
  `like`,
  `ilike`,
  // Logical operators
  `and`,
  `or`,
  `not`,
  // Null checking
  `isNull`,
  `isUndefined`,
  // String functions
  `upper`,
  `lower`,
  `length`,
  `concat`,
  // Numeric functions
  `add`,
  // Utility functions
  `coalesce`,
  // Aggregate functions
  `count`,
  `avg`,
  `sum`,
  `min`,
  `max`
];

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/utils/comparison.js
var objectIds = /* @__PURE__ */ new WeakMap();
var nextObjectId = 1;
function getObjectId(obj) {
  if (objectIds.has(obj)) {
    return objectIds.get(obj);
  }
  const id = nextObjectId++;
  objectIds.set(obj, id);
  return id;
}
var ascComparator = (a, b, opts) => {
  const { nulls } = opts;
  if (a == null && b == null) return 0;
  if (a == null) return nulls === `first` ? -1 : 1;
  if (b == null) return nulls === `first` ? 1 : -1;
  if (typeof a === `string` && typeof b === `string`) {
    if (opts.stringSort === `locale`) {
      return a.localeCompare(b, opts.locale, opts.localeOptions);
    }
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    for (let i = 0; i < Math.min(a.length, b.length); i++) {
      const result = ascComparator(a[i], b[i], opts);
      if (result !== 0) {
        return result;
      }
    }
    return a.length - b.length;
  }
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() - b.getTime();
  }
  const aIsObject = typeof a === `object`;
  const bIsObject = typeof b === `object`;
  if (aIsObject || bIsObject) {
    if (aIsObject && bIsObject) {
      const aId = getObjectId(a);
      const bId = getObjectId(b);
      return aId - bId;
    }
    if (aIsObject) return 1;
    if (bIsObject) return -1;
  }
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
};
var descComparator = (a, b, opts) => {
  return ascComparator(b, a, {
    ...opts,
    nulls: opts.nulls === `first` ? `last` : `first`
  });
};
function makeComparator(opts) {
  return (a, b) => {
    if (opts.direction === `asc`) {
      return ascComparator(a, b, opts);
    } else {
      return descComparator(a, b, opts);
    }
  };
}
var defaultComparator = makeComparator({
  direction: `asc`,
  nulls: `first`,
  stringSort: `locale`
});
function areUint8ArraysEqual(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
var UINT8ARRAY_NORMALIZE_THRESHOLD = 128;
function normalizeValue(value) {
  if (value instanceof Date) {
    return value.getTime();
  }
  const isUint8Array = typeof Buffer !== `undefined` && value instanceof Buffer || value instanceof Uint8Array;
  if (isUint8Array) {
    if (value.byteLength <= UINT8ARRAY_NORMALIZE_THRESHOLD) {
      return `__u8__${Array.from(value).join(`,`)}`;
    }
  }
  return value;
}
function areValuesEqual(a, b) {
  if (a === b) {
    return true;
  }
  const aIsUint8Array = typeof Buffer !== `undefined` && a instanceof Buffer || a instanceof Uint8Array;
  const bIsUint8Array = typeof Buffer !== `undefined` && b instanceof Buffer || b instanceof Uint8Array;
  if (aIsUint8Array && bIsUint8Array) {
    return areUint8ArraysEqual(a, b);
  }
  return false;
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/compiler/evaluators.js
function isUnknown(value) {
  return value === null || value === void 0;
}
function toBooleanPredicate(result) {
  return result === true;
}
function compileExpression(expr, isSingleRow = false) {
  const compiledFn = compileExpressionInternal(expr, isSingleRow);
  return compiledFn;
}
function compileSingleRowExpression(expr) {
  const compiledFn = compileExpressionInternal(expr, true);
  return compiledFn;
}
function compileExpressionInternal(expr, isSingleRow) {
  switch (expr.type) {
    case `val`: {
      const value = expr.value;
      return () => value;
    }
    case `ref`: {
      return isSingleRow ? compileSingleRowRef(expr) : compileRef(expr);
    }
    case `func`: {
      return compileFunction(expr, isSingleRow);
    }
    default:
      throw new UnknownExpressionTypeError(expr.type);
  }
}
function compileRef(ref) {
  const [tableAlias, ...propertyPath] = ref.path;
  if (!tableAlias) {
    throw new EmptyReferencePathError();
  }
  if (propertyPath.length === 0) {
    return (namespacedRow) => namespacedRow[tableAlias];
  } else if (propertyPath.length === 1) {
    const prop = propertyPath[0];
    return (namespacedRow) => {
      const tableData = namespacedRow[tableAlias];
      return tableData == null ? void 0 : tableData[prop];
    };
  } else {
    return (namespacedRow) => {
      const tableData = namespacedRow[tableAlias];
      if (tableData === void 0) {
        return void 0;
      }
      let value = tableData;
      for (const prop of propertyPath) {
        if (value == null) {
          return value;
        }
        value = value[prop];
      }
      return value;
    };
  }
}
function compileSingleRowRef(ref) {
  const propertyPath = ref.path;
  return (item) => {
    let value = item;
    for (const prop of propertyPath) {
      if (value == null) {
        return value;
      }
      value = value[prop];
    }
    return value;
  };
}
function compileFunction(func, isSingleRow) {
  const compiledArgs = func.args.map(
    (arg) => compileExpressionInternal(arg, isSingleRow)
  );
  switch (func.name) {
    case `eq`: {
      const argA = compiledArgs[0];
      const argB = compiledArgs[1];
      return (data) => {
        const a = normalizeValue(argA(data));
        const b = normalizeValue(argB(data));
        if (isUnknown(a) || isUnknown(b)) {
          return null;
        }
        return areValuesEqual(a, b);
      };
    }
    case `gt`: {
      const argA = compiledArgs[0];
      const argB = compiledArgs[1];
      return (data) => {
        const a = argA(data);
        const b = argB(data);
        if (isUnknown(a) || isUnknown(b)) {
          return null;
        }
        return a > b;
      };
    }
    case `gte`: {
      const argA = compiledArgs[0];
      const argB = compiledArgs[1];
      return (data) => {
        const a = argA(data);
        const b = argB(data);
        if (isUnknown(a) || isUnknown(b)) {
          return null;
        }
        return a >= b;
      };
    }
    case `lt`: {
      const argA = compiledArgs[0];
      const argB = compiledArgs[1];
      return (data) => {
        const a = argA(data);
        const b = argB(data);
        if (isUnknown(a) || isUnknown(b)) {
          return null;
        }
        return a < b;
      };
    }
    case `lte`: {
      const argA = compiledArgs[0];
      const argB = compiledArgs[1];
      return (data) => {
        const a = argA(data);
        const b = argB(data);
        if (isUnknown(a) || isUnknown(b)) {
          return null;
        }
        return a <= b;
      };
    }
    case `and`:
      return (data) => {
        let hasUnknown = false;
        for (const compiledArg of compiledArgs) {
          const result = compiledArg(data);
          if (result === false) {
            return false;
          }
          if (isUnknown(result)) {
            hasUnknown = true;
          }
        }
        if (hasUnknown) {
          return null;
        }
        return true;
      };
    case `or`:
      return (data) => {
        let hasUnknown = false;
        for (const compiledArg of compiledArgs) {
          const result = compiledArg(data);
          if (result === true) {
            return true;
          }
          if (isUnknown(result)) {
            hasUnknown = true;
          }
        }
        if (hasUnknown) {
          return null;
        }
        return false;
      };
    case `not`: {
      const arg = compiledArgs[0];
      return (data) => {
        const result = arg(data);
        if (isUnknown(result)) {
          return null;
        }
        return !result;
      };
    }
    case `in`: {
      const valueEvaluator = compiledArgs[0];
      const arrayEvaluator = compiledArgs[1];
      return (data) => {
        const value = valueEvaluator(data);
        const array = arrayEvaluator(data);
        if (isUnknown(value)) {
          return null;
        }
        if (!Array.isArray(array)) {
          return false;
        }
        return array.includes(value);
      };
    }
    case `like`: {
      const valueEvaluator = compiledArgs[0];
      const patternEvaluator = compiledArgs[1];
      return (data) => {
        const value = valueEvaluator(data);
        const pattern = patternEvaluator(data);
        if (isUnknown(value) || isUnknown(pattern)) {
          return null;
        }
        return evaluateLike(value, pattern, false);
      };
    }
    case `ilike`: {
      const valueEvaluator = compiledArgs[0];
      const patternEvaluator = compiledArgs[1];
      return (data) => {
        const value = valueEvaluator(data);
        const pattern = patternEvaluator(data);
        if (isUnknown(value) || isUnknown(pattern)) {
          return null;
        }
        return evaluateLike(value, pattern, true);
      };
    }
    case `upper`: {
      const arg = compiledArgs[0];
      return (data) => {
        const value = arg(data);
        return typeof value === `string` ? value.toUpperCase() : value;
      };
    }
    case `lower`: {
      const arg = compiledArgs[0];
      return (data) => {
        const value = arg(data);
        return typeof value === `string` ? value.toLowerCase() : value;
      };
    }
    case `length`: {
      const arg = compiledArgs[0];
      return (data) => {
        const value = arg(data);
        if (typeof value === `string`) {
          return value.length;
        }
        if (Array.isArray(value)) {
          return value.length;
        }
        return 0;
      };
    }
    case `concat`:
      return (data) => {
        return compiledArgs.map((evaluator) => {
          const arg = evaluator(data);
          try {
            return String(arg ?? ``);
          } catch {
            try {
              return JSON.stringify(arg) || ``;
            } catch {
              return `[object]`;
            }
          }
        }).join(``);
      };
    case `coalesce`:
      return (data) => {
        for (const evaluator of compiledArgs) {
          const value = evaluator(data);
          if (value !== null && value !== void 0) {
            return value;
          }
        }
        return null;
      };
    case `add`: {
      const argA = compiledArgs[0];
      const argB = compiledArgs[1];
      return (data) => {
        const a = argA(data);
        const b = argB(data);
        return (a ?? 0) + (b ?? 0);
      };
    }
    case `subtract`: {
      const argA = compiledArgs[0];
      const argB = compiledArgs[1];
      return (data) => {
        const a = argA(data);
        const b = argB(data);
        return (a ?? 0) - (b ?? 0);
      };
    }
    case `multiply`: {
      const argA = compiledArgs[0];
      const argB = compiledArgs[1];
      return (data) => {
        const a = argA(data);
        const b = argB(data);
        return (a ?? 0) * (b ?? 0);
      };
    }
    case `divide`: {
      const argA = compiledArgs[0];
      const argB = compiledArgs[1];
      return (data) => {
        const a = argA(data);
        const b = argB(data);
        const divisor = b ?? 0;
        return divisor !== 0 ? (a ?? 0) / divisor : null;
      };
    }
    case `isUndefined`: {
      const arg = compiledArgs[0];
      return (data) => {
        const value = arg(data);
        return value === void 0;
      };
    }
    case `isNull`: {
      const arg = compiledArgs[0];
      return (data) => {
        const value = arg(data);
        return value === null;
      };
    }
    default:
      throw new UnknownFunctionError(func.name);
  }
}
function evaluateLike(value, pattern, caseInsensitive) {
  if (typeof value !== `string` || typeof pattern !== `string`) {
    return false;
  }
  const searchValue = caseInsensitive ? value.toLowerCase() : value;
  const searchPattern = caseInsensitive ? pattern.toLowerCase() : pattern;
  let regexPattern = searchPattern.replace(/[.*+?^${}()|[\]\\]/g, `\\$&`);
  regexPattern = regexPattern.replace(/%/g, `.*`);
  regexPattern = regexPattern.replace(/_/g, `.`);
  const regex = new RegExp(`^${regexPattern}$`);
  return regex.test(searchValue);
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/utils.js
function deepEquals(a, b) {
  return deepEqualsInternal(a, b, /* @__PURE__ */ new Map());
}
function deepEqualsInternal(a, b, visited) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (typeof a !== typeof b) return false;
  if (a instanceof Date) {
    if (!(b instanceof Date)) return false;
    return a.getTime() === b.getTime();
  }
  if (a instanceof RegExp) {
    if (!(b instanceof RegExp)) return false;
    return a.source === b.source && a.flags === b.flags;
  }
  if (a instanceof Map) {
    if (!(b instanceof Map)) return false;
    if (a.size !== b.size) return false;
    if (visited.has(a)) {
      return visited.get(a) === b;
    }
    visited.set(a, b);
    const entries = Array.from(a.entries());
    const result = entries.every(([key, val]) => {
      return b.has(key) && deepEqualsInternal(val, b.get(key), visited);
    });
    visited.delete(a);
    return result;
  }
  if (a instanceof Set) {
    if (!(b instanceof Set)) return false;
    if (a.size !== b.size) return false;
    if (visited.has(a)) {
      return visited.get(a) === b;
    }
    visited.set(a, b);
    const aValues = Array.from(a);
    const bValues = Array.from(b);
    if (aValues.every((val) => typeof val !== `object`)) {
      visited.delete(a);
      return aValues.every((val) => b.has(val));
    }
    const result = aValues.length === bValues.length;
    visited.delete(a);
    return result;
  }
  if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b) && !(a instanceof DataView) && !(b instanceof DataView)) {
    const typedA = a;
    const typedB = b;
    if (typedA.length !== typedB.length) return false;
    for (let i = 0; i < typedA.length; i++) {
      if (typedA[i] !== typedB[i]) return false;
    }
    return true;
  }
  if (isTemporal(a) && isTemporal(b)) {
    const aTag = getStringTag(a);
    const bTag = getStringTag(b);
    if (aTag !== bTag) return false;
    if (typeof a.equals === `function`) {
      return a.equals(b);
    }
    return a.toString() === b.toString();
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) return false;
    if (visited.has(a)) {
      return visited.get(a) === b;
    }
    visited.set(a, b);
    const result = a.every(
      (item, index) => deepEqualsInternal(item, b[index], visited)
    );
    visited.delete(a);
    return result;
  }
  if (typeof a === `object`) {
    if (visited.has(a)) {
      return visited.get(a) === b;
    }
    visited.set(a, b);
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) {
      visited.delete(a);
      return false;
    }
    const result = keysA.every(
      (key) => key in b && deepEqualsInternal(a[key], b[key], visited)
    );
    visited.delete(a);
    return result;
  }
  return false;
}
var temporalTypes = [
  `Temporal.Duration`,
  `Temporal.Instant`,
  `Temporal.PlainDate`,
  `Temporal.PlainDateTime`,
  `Temporal.PlainMonthDay`,
  `Temporal.PlainTime`,
  `Temporal.PlainYearMonth`,
  `Temporal.ZonedDateTime`
];
function getStringTag(a) {
  return a[Symbol.toStringTag];
}
function isTemporal(a) {
  const tag = getStringTag(a);
  return typeof tag === `string` && temporalTypes.includes(tag);
}
var DEFAULT_COMPARE_OPTIONS = {
  direction: `asc`,
  nulls: `first`,
  stringSort: `locale`
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/indexes/base-index.js
var IndexOperation = comparisonFunctions;
var BaseIndex = class {
  constructor(id, expression, name, options) {
    this.lookupCount = 0;
    this.totalLookupTime = 0;
    this.lastUpdated = /* @__PURE__ */ new Date();
    this.id = id;
    this.expression = expression;
    this.compareOptions = DEFAULT_COMPARE_OPTIONS;
    this.name = name;
    this.initialize(options);
  }
  // Common methods
  supports(operation) {
    return this.supportedOperations.has(operation);
  }
  matchesField(fieldPath) {
    return this.expression.type === `ref` && this.expression.path.length === fieldPath.length && this.expression.path.every((part, i) => part === fieldPath[i]);
  }
  /**
   * Checks if the compare options match the index's compare options.
   * The direction is ignored because the index can be reversed if the direction is different.
   */
  matchesCompareOptions(compareOptions) {
    const thisCompareOptionsWithoutDirection = {
      ...this.compareOptions,
      direction: void 0
    };
    const compareOptionsWithoutDirection = {
      ...compareOptions,
      direction: void 0
    };
    return deepEquals(
      thisCompareOptionsWithoutDirection,
      compareOptionsWithoutDirection
    );
  }
  /**
   * Checks if the index matches the provided direction.
   */
  matchesDirection(direction) {
    return this.compareOptions.direction === direction;
  }
  getStats() {
    return {
      entryCount: this.keyCount,
      lookupCount: this.lookupCount,
      averageLookupTime: this.lookupCount > 0 ? this.totalLookupTime / this.lookupCount : 0,
      lastUpdated: this.lastUpdated
    };
  }
  evaluateIndexExpression(item) {
    const evaluator = compileSingleRowExpression(this.expression);
    return evaluator(item);
  }
  trackLookup(startTime) {
    const duration = performance.now() - startTime;
    this.lookupCount++;
    this.totalLookupTime += duration;
  }
  updateTimestamp() {
    this.lastUpdated = /* @__PURE__ */ new Date();
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/utils/btree.js
var BTree = class {
  /**
   * Initializes an empty B+ tree.
   * @param compare Custom function to compare pairs of elements in the tree.
   *   If not specified, defaultComparator will be used which is valid as long as K extends DefaultComparable.
   * @param entries A set of key-value pairs to initialize the tree
   * @param maxNodeSize Branching factor (maximum items or children per node)
   *   Must be in range 4..256. If undefined or <4 then default is used; if >256 then 256.
   */
  constructor(compare, entries, maxNodeSize) {
    this._root = EmptyLeaf;
    this._size = 0;
    this._maxNodeSize = maxNodeSize >= 4 ? Math.min(maxNodeSize, 256) : 32;
    this._compare = compare;
    if (entries) this.setPairs(entries);
  }
  // ///////////////////////////////////////////////////////////////////////////
  // ES6 Map<K,V> methods /////////////////////////////////////////////////////
  /** Gets the number of key-value pairs in the tree. */
  get size() {
    return this._size;
  }
  /** Gets the number of key-value pairs in the tree. */
  get length() {
    return this._size;
  }
  /** Returns true iff the tree contains no key-value pairs. */
  get isEmpty() {
    return this._size === 0;
  }
  /** Releases the tree so that its size is 0. */
  clear() {
    this._root = EmptyLeaf;
    this._size = 0;
  }
  /**
   * Finds a pair in the tree and returns the associated value.
   * @param defaultValue a value to return if the key was not found.
   * @returns the value, or defaultValue if the key was not found.
   * @description Computational complexity: O(log size)
   */
  get(key, defaultValue) {
    return this._root.get(key, defaultValue, this);
  }
  /**
   * Adds or overwrites a key-value pair in the B+ tree.
   * @param key the key is used to determine the sort order of
   *        data in the tree.
   * @param value data to associate with the key (optional)
   * @param overwrite Whether to overwrite an existing key-value pair
   *        (default: true). If this is false and there is an existing
   *        key-value pair then this method has no effect.
   * @returns true if a new key-value pair was added.
   * @description Computational complexity: O(log size)
   * Note: when overwriting a previous entry, the key is updated
   * as well as the value. This has no effect unless the new key
   * has data that does not affect its sort order.
   */
  set(key, value, overwrite) {
    if (this._root.isShared) this._root = this._root.clone();
    const result = this._root.set(key, value, overwrite, this);
    if (result === true || result === false) return result;
    this._root = new BNodeInternal([this._root, result]);
    return true;
  }
  /**
   * Returns true if the key exists in the B+ tree, false if not.
   * Use get() for best performance; use has() if you need to
   * distinguish between "undefined value" and "key not present".
   * @param key Key to detect
   * @description Computational complexity: O(log size)
   */
  has(key) {
    return this.forRange(key, key, true, void 0) !== 0;
  }
  /**
   * Removes a single key-value pair from the B+ tree.
   * @param key Key to find
   * @returns true if a pair was found and removed, false otherwise.
   * @description Computational complexity: O(log size)
   */
  delete(key) {
    return this.editRange(key, key, true, DeleteRange) !== 0;
  }
  // ///////////////////////////////////////////////////////////////////////////
  // Additional methods ///////////////////////////////////////////////////////
  /** Returns the maximum number of children/values before nodes will split. */
  get maxNodeSize() {
    return this._maxNodeSize;
  }
  /** Gets the lowest key in the tree. Complexity: O(log size) */
  minKey() {
    return this._root.minKey();
  }
  /** Gets the highest key in the tree. Complexity: O(1) */
  maxKey() {
    return this._root.maxKey();
  }
  /** Gets an array of all keys, sorted */
  keysArray() {
    const results = [];
    this._root.forRange(
      this.minKey(),
      this.maxKey(),
      true,
      false,
      this,
      0,
      (k, _v) => {
        results.push(k);
      }
    );
    return results;
  }
  /** Returns the next pair whose key is larger than the specified key (or undefined if there is none).
   * If key === undefined, this function returns the lowest pair.
   * @param key The key to search for.
   * @param reusedArray Optional array used repeatedly to store key-value pairs, to
   * avoid creating a new array on every iteration.
   */
  nextHigherPair(key, reusedArray) {
    reusedArray = reusedArray || [];
    if (key === void 0) {
      return this._root.minPair(reusedArray);
    }
    return this._root.getPairOrNextHigher(
      key,
      this._compare,
      false,
      reusedArray
    );
  }
  /** Returns the next key larger than the specified key, or undefined if there is none.
   *  Also, nextHigherKey(undefined) returns the lowest key.
   */
  nextHigherKey(key) {
    const p = this.nextHigherPair(key, ReusedArray);
    return p && p[0];
  }
  /** Returns the next pair whose key is smaller than the specified key (or undefined if there is none).
   *  If key === undefined, this function returns the highest pair.
   * @param key The key to search for.
   * @param reusedArray Optional array used repeatedly to store key-value pairs, to
   *        avoid creating a new array each time you call this method.
   */
  nextLowerPair(key, reusedArray) {
    reusedArray = reusedArray || [];
    if (key === void 0) {
      return this._root.maxPair(reusedArray);
    }
    return this._root.getPairOrNextLower(key, this._compare, false, reusedArray);
  }
  /** Returns the next key smaller than the specified key, or undefined if there is none.
   *  Also, nextLowerKey(undefined) returns the highest key.
   */
  nextLowerKey(key) {
    const p = this.nextLowerPair(key, ReusedArray);
    return p && p[0];
  }
  /** Adds all pairs from a list of key-value pairs.
   * @param pairs Pairs to add to this tree. If there are duplicate keys,
   *        later pairs currently overwrite earlier ones (e.g. [[0,1],[0,7]]
   *        associates 0 with 7.)
   * @param overwrite Whether to overwrite pairs that already exist (if false,
   *        pairs[i] is ignored when the key pairs[i][0] already exists.)
   * @returns The number of pairs added to the collection.
   * @description Computational complexity: O(pairs.length * log(size + pairs.length))
   */
  setPairs(pairs, overwrite) {
    let added = 0;
    for (const pair of pairs) {
      if (this.set(pair[0], pair[1], overwrite)) added++;
    }
    return added;
  }
  /**
   * Scans the specified range of keys, in ascending order by key.
   * Note: the callback `onFound` must not insert or remove items in the
   * collection. Doing so may cause incorrect data to be sent to the
   * callback afterward.
   * @param low The first key scanned will be greater than or equal to `low`.
   * @param high Scanning stops when a key larger than this is reached.
   * @param includeHigh If the `high` key is present, `onFound` is called for
   *        that final pair if and only if this parameter is true.
   * @param onFound A function that is called for each key-value pair. This
   *        function can return {break:R} to stop early with result R.
   * @param initialCounter Initial third argument of onFound. This value
   *        increases by one each time `onFound` is called. Default: 0
   * @returns The number of values found, or R if the callback returned
   *        `{break:R}` to stop early.
   * @description Computational complexity: O(number of items scanned + log size)
   */
  forRange(low, high, includeHigh, onFound, initialCounter) {
    const r = this._root.forRange(
      low,
      high,
      includeHigh,
      false,
      this,
      initialCounter || 0,
      onFound
    );
    return typeof r === `number` ? r : r.break;
  }
  /**
   * Scans and potentially modifies values for a subsequence of keys.
   * Note: the callback `onFound` should ideally be a pure function.
   *   Specfically, it must not insert items, call clone(), or change
   *   the collection except via return value; out-of-band editing may
   *   cause an exception or may cause incorrect data to be sent to
   *   the callback (duplicate or missed items). It must not cause a
   *   clone() of the collection, otherwise the clone could be modified
   *   by changes requested by the callback.
   * @param low The first key scanned will be greater than or equal to `low`.
   * @param high Scanning stops when a key larger than this is reached.
   * @param includeHigh If the `high` key is present, `onFound` is called for
   *        that final pair if and only if this parameter is true.
   * @param onFound A function that is called for each key-value pair. This
   *        function can return `{value:v}` to change the value associated
   *        with the current key, `{delete:true}` to delete the current pair,
   *        `{break:R}` to stop early with result R, or it can return nothing
   *        (undefined or {}) to cause no effect and continue iterating.
   *        `{break:R}` can be combined with one of the other two commands.
   *        The third argument `counter` is the number of items iterated
   *        previously; it equals 0 when `onFound` is called the first time.
   * @returns The number of values scanned, or R if the callback returned
   *        `{break:R}` to stop early.
   * @description
   *   Computational complexity: O(number of items scanned + log size)
   *   Note: if the tree has been cloned with clone(), any shared
   *   nodes are copied before `onFound` is called. This takes O(n) time
   *   where n is proportional to the amount of shared data scanned.
   */
  editRange(low, high, includeHigh, onFound, initialCounter) {
    let root = this._root;
    if (root.isShared) this._root = root = root.clone();
    try {
      const r = root.forRange(
        low,
        high,
        includeHigh,
        true,
        this,
        initialCounter || 0,
        onFound
      );
      return typeof r === `number` ? r : r.break;
    } finally {
      let isShared;
      while (root.keys.length <= 1 && !root.isLeaf) {
        isShared || (isShared = root.isShared);
        this._root = root = root.keys.length === 0 ? EmptyLeaf : root.children[0];
      }
      if (isShared) {
        root.isShared = true;
      }
    }
  }
};
var BNode = class _BNode {
  get isLeaf() {
    return this.children === void 0;
  }
  constructor(keys = [], values) {
    this.keys = keys;
    this.values = values || undefVals;
    this.isShared = void 0;
  }
  // /////////////////////////////////////////////////////////////////////////
  // Shared methods /////////////////////////////////////////////////////////
  maxKey() {
    return this.keys[this.keys.length - 1];
  }
  // If key not found, returns i^failXor where i is the insertion index.
  // Callers that don't care whether there was a match will set failXor=0.
  indexOf(key, failXor, cmp) {
    const keys = this.keys;
    let lo = 0, hi = keys.length, mid = hi >> 1;
    while (lo < hi) {
      const c = cmp(keys[mid], key);
      if (c < 0) lo = mid + 1;
      else if (c > 0)
        hi = mid;
      else if (c === 0) return mid;
      else {
        if (key === key)
          return keys.length;
        else throw new Error(`BTree: NaN was used as a key`);
      }
      mid = lo + hi >> 1;
    }
    return mid ^ failXor;
  }
  // ///////////////////////////////////////////////////////////////////////////
  // Leaf Node: misc //////////////////////////////////////////////////////////
  minKey() {
    return this.keys[0];
  }
  minPair(reusedArray) {
    if (this.keys.length === 0) return void 0;
    reusedArray[0] = this.keys[0];
    reusedArray[1] = this.values[0];
    return reusedArray;
  }
  maxPair(reusedArray) {
    if (this.keys.length === 0) return void 0;
    const lastIndex = this.keys.length - 1;
    reusedArray[0] = this.keys[lastIndex];
    reusedArray[1] = this.values[lastIndex];
    return reusedArray;
  }
  clone() {
    const v = this.values;
    return new _BNode(this.keys.slice(0), v === undefVals ? v : v.slice(0));
  }
  get(key, defaultValue, tree) {
    const i = this.indexOf(key, -1, tree._compare);
    return i < 0 ? defaultValue : this.values[i];
  }
  getPairOrNextLower(key, compare, inclusive, reusedArray) {
    const i = this.indexOf(key, -1, compare);
    const indexOrLower = i < 0 ? ~i - 1 : inclusive ? i : i - 1;
    if (indexOrLower >= 0) {
      reusedArray[0] = this.keys[indexOrLower];
      reusedArray[1] = this.values[indexOrLower];
      return reusedArray;
    }
    return void 0;
  }
  getPairOrNextHigher(key, compare, inclusive, reusedArray) {
    const i = this.indexOf(key, -1, compare);
    const indexOrLower = i < 0 ? ~i : inclusive ? i : i + 1;
    const keys = this.keys;
    if (indexOrLower < keys.length) {
      reusedArray[0] = keys[indexOrLower];
      reusedArray[1] = this.values[indexOrLower];
      return reusedArray;
    }
    return void 0;
  }
  // ///////////////////////////////////////////////////////////////////////////
  // Leaf Node: set & node splitting //////////////////////////////////////////
  set(key, value, overwrite, tree) {
    let i = this.indexOf(key, -1, tree._compare);
    if (i < 0) {
      i = ~i;
      tree._size++;
      if (this.keys.length < tree._maxNodeSize) {
        return this.insertInLeaf(i, key, value, tree);
      } else {
        const newRightSibling = this.splitOffRightSide();
        let target = this;
        if (i > this.keys.length) {
          i -= this.keys.length;
          target = newRightSibling;
        }
        target.insertInLeaf(i, key, value, tree);
        return newRightSibling;
      }
    } else {
      if (overwrite !== false) {
        if (value !== void 0) this.reifyValues();
        this.keys[i] = key;
        this.values[i] = value;
      }
      return false;
    }
  }
  reifyValues() {
    if (this.values === undefVals)
      return this.values = this.values.slice(0, this.keys.length);
    return this.values;
  }
  insertInLeaf(i, key, value, tree) {
    this.keys.splice(i, 0, key);
    if (this.values === undefVals) {
      while (undefVals.length < tree._maxNodeSize) undefVals.push(void 0);
      if (value === void 0) {
        return true;
      } else {
        this.values = undefVals.slice(0, this.keys.length - 1);
      }
    }
    this.values.splice(i, 0, value);
    return true;
  }
  takeFromRight(rhs) {
    let v = this.values;
    if (rhs.values === undefVals) {
      if (v !== undefVals) v.push(void 0);
    } else {
      v = this.reifyValues();
      v.push(rhs.values.shift());
    }
    this.keys.push(rhs.keys.shift());
  }
  takeFromLeft(lhs) {
    let v = this.values;
    if (lhs.values === undefVals) {
      if (v !== undefVals) v.unshift(void 0);
    } else {
      v = this.reifyValues();
      v.unshift(lhs.values.pop());
    }
    this.keys.unshift(lhs.keys.pop());
  }
  splitOffRightSide() {
    const half = this.keys.length >> 1, keys = this.keys.splice(half);
    const values = this.values === undefVals ? undefVals : this.values.splice(half);
    return new _BNode(keys, values);
  }
  // ///////////////////////////////////////////////////////////////////////////
  // Leaf Node: scanning & deletions //////////////////////////////////////////
  forRange(low, high, includeHigh, editMode, tree, count6, onFound) {
    const cmp = tree._compare;
    let iLow, iHigh;
    if (high === low) {
      if (!includeHigh) return count6;
      iHigh = (iLow = this.indexOf(low, -1, cmp)) + 1;
      if (iLow < 0) return count6;
    } else {
      iLow = this.indexOf(low, 0, cmp);
      iHigh = this.indexOf(high, -1, cmp);
      if (iHigh < 0) iHigh = ~iHigh;
      else if (includeHigh === true) iHigh++;
    }
    const keys = this.keys, values = this.values;
    if (onFound !== void 0) {
      for (let i = iLow; i < iHigh; i++) {
        const key = keys[i];
        const result = onFound(key, values[i], count6++);
        if (result !== void 0) {
          if (editMode === true) {
            if (key !== keys[i] || this.isShared === true)
              throw new Error(`BTree illegally changed or cloned in editRange`);
            if (result.delete) {
              this.keys.splice(i, 1);
              if (this.values !== undefVals) this.values.splice(i, 1);
              tree._size--;
              i--;
              iHigh--;
            } else if (result.hasOwnProperty(`value`)) {
              values[i] = result.value;
            }
          }
          if (result.break !== void 0) return result;
        }
      }
    } else count6 += iHigh - iLow;
    return count6;
  }
  /** Adds entire contents of right-hand sibling (rhs is left unchanged) */
  mergeSibling(rhs, _) {
    this.keys.push.apply(this.keys, rhs.keys);
    if (this.values === undefVals) {
      if (rhs.values === undefVals) return;
      this.values = this.values.slice(0, this.keys.length);
    }
    this.values.push.apply(this.values, rhs.reifyValues());
  }
};
var BNodeInternal = class _BNodeInternal extends BNode {
  /**
   * This does not mark `children` as shared, so it is the responsibility of the caller
   * to ensure children are either marked shared, or aren't included in another tree.
   */
  constructor(children, keys) {
    if (!keys) {
      keys = [];
      for (let i = 0; i < children.length; i++) keys[i] = children[i].maxKey();
    }
    super(keys);
    this.children = children;
  }
  minKey() {
    return this.children[0].minKey();
  }
  minPair(reusedArray) {
    return this.children[0].minPair(reusedArray);
  }
  maxPair(reusedArray) {
    return this.children[this.children.length - 1].maxPair(reusedArray);
  }
  get(key, defaultValue, tree) {
    const i = this.indexOf(key, 0, tree._compare), children = this.children;
    return i < children.length ? children[i].get(key, defaultValue, tree) : void 0;
  }
  getPairOrNextLower(key, compare, inclusive, reusedArray) {
    const i = this.indexOf(key, 0, compare), children = this.children;
    if (i >= children.length) return this.maxPair(reusedArray);
    const result = children[i].getPairOrNextLower(
      key,
      compare,
      inclusive,
      reusedArray
    );
    if (result === void 0 && i > 0) {
      return children[i - 1].maxPair(reusedArray);
    }
    return result;
  }
  getPairOrNextHigher(key, compare, inclusive, reusedArray) {
    const i = this.indexOf(key, 0, compare), children = this.children, length2 = children.length;
    if (i >= length2) return void 0;
    const result = children[i].getPairOrNextHigher(
      key,
      compare,
      inclusive,
      reusedArray
    );
    if (result === void 0 && i < length2 - 1) {
      return children[i + 1].minPair(reusedArray);
    }
    return result;
  }
  // ///////////////////////////////////////////////////////////////////////////
  // Internal Node: set & node splitting //////////////////////////////////////
  set(key, value, overwrite, tree) {
    const c = this.children, max4 = tree._maxNodeSize, cmp = tree._compare;
    let i = Math.min(this.indexOf(key, 0, cmp), c.length - 1), child = c[i];
    if (child.isShared) c[i] = child = child.clone();
    if (child.keys.length >= max4) {
      let other;
      if (i > 0 && (other = c[i - 1]).keys.length < max4 && cmp(child.keys[0], key) < 0) {
        if (other.isShared) c[i - 1] = other = other.clone();
        other.takeFromRight(child);
        this.keys[i - 1] = other.maxKey();
      } else if ((other = c[i + 1]) !== void 0 && other.keys.length < max4 && cmp(child.maxKey(), key) < 0) {
        if (other.isShared) c[i + 1] = other = other.clone();
        other.takeFromLeft(child);
        this.keys[i] = c[i].maxKey();
      }
    }
    const result = child.set(key, value, overwrite, tree);
    if (result === false) return false;
    this.keys[i] = child.maxKey();
    if (result === true) return true;
    if (this.keys.length < max4) {
      this.insert(i + 1, result);
      return true;
    } else {
      const newRightSibling = this.splitOffRightSide();
      let target = this;
      if (cmp(result.maxKey(), this.maxKey()) > 0) {
        target = newRightSibling;
        i -= this.keys.length;
      }
      target.insert(i + 1, result);
      return newRightSibling;
    }
  }
  /**
   * Inserts `child` at index `i`.
   * This does not mark `child` as shared, so it is the responsibility of the caller
   * to ensure that either child is marked shared, or it is not included in another tree.
   */
  insert(i, child) {
    this.children.splice(i, 0, child);
    this.keys.splice(i, 0, child.maxKey());
  }
  /**
   * Split this node.
   * Modifies this to remove the second half of the items, returning a separate node containing them.
   */
  splitOffRightSide() {
    const half = this.children.length >> 1;
    return new _BNodeInternal(
      this.children.splice(half),
      this.keys.splice(half)
    );
  }
  takeFromRight(rhs) {
    this.keys.push(rhs.keys.shift());
    this.children.push(rhs.children.shift());
  }
  takeFromLeft(lhs) {
    this.keys.unshift(lhs.keys.pop());
    this.children.unshift(lhs.children.pop());
  }
  // ///////////////////////////////////////////////////////////////////////////
  // Internal Node: scanning & deletions //////////////////////////////////////
  // Note: `count` is the next value of the third argument to `onFound`.
  //       A leaf node's `forRange` function returns a new value for this counter,
  //       unless the operation is to stop early.
  forRange(low, high, includeHigh, editMode, tree, count6, onFound) {
    const cmp = tree._compare;
    const keys = this.keys, children = this.children;
    let iLow = this.indexOf(low, 0, cmp), i = iLow;
    const iHigh = Math.min(
      high === low ? iLow : this.indexOf(high, 0, cmp),
      keys.length - 1
    );
    if (!editMode) {
      for (; i <= iHigh; i++) {
        const result = children[i].forRange(
          low,
          high,
          includeHigh,
          editMode,
          tree,
          count6,
          onFound
        );
        if (typeof result !== `number`) return result;
        count6 = result;
      }
    } else if (i <= iHigh) {
      try {
        for (; i <= iHigh; i++) {
          if (children[i].isShared) children[i] = children[i].clone();
          const result = children[i].forRange(
            low,
            high,
            includeHigh,
            editMode,
            tree,
            count6,
            onFound
          );
          keys[i] = children[i].maxKey();
          if (typeof result !== `number`) return result;
          count6 = result;
        }
      } finally {
        const half = tree._maxNodeSize >> 1;
        if (iLow > 0) iLow--;
        for (i = iHigh; i >= iLow; i--) {
          if (children[i].keys.length <= half) {
            if (children[i].keys.length !== 0) {
              this.tryMerge(i, tree._maxNodeSize);
            } else {
              keys.splice(i, 1);
              children.splice(i, 1);
            }
          }
        }
        if (children.length !== 0 && children[0].keys.length === 0)
          check(false, `emptiness bug`);
      }
    }
    return count6;
  }
  /** Merges child i with child i+1 if their combined size is not too large */
  tryMerge(i, maxSize) {
    const children = this.children;
    if (i >= 0 && i + 1 < children.length) {
      if (children[i].keys.length + children[i + 1].keys.length <= maxSize) {
        if (children[i].isShared)
          children[i] = children[i].clone();
        children[i].mergeSibling(children[i + 1], maxSize);
        children.splice(i + 1, 1);
        this.keys.splice(i + 1, 1);
        this.keys[i] = children[i].maxKey();
        return true;
      }
    }
    return false;
  }
  /**
   * Move children from `rhs` into this.
   * `rhs` must be part of this tree, and be removed from it after this call
   * (otherwise isShared for its children could be incorrect).
   */
  mergeSibling(rhs, maxNodeSize) {
    const oldLength = this.keys.length;
    this.keys.push.apply(this.keys, rhs.keys);
    const rhsChildren = rhs.children;
    this.children.push.apply(this.children, rhsChildren);
    if (rhs.isShared && !this.isShared) {
      for (const child of rhsChildren) child.isShared = true;
    }
    this.tryMerge(oldLength - 1, maxNodeSize);
  }
};
var undefVals = [];
var Delete = { delete: true };
var DeleteRange = () => Delete;
var EmptyLeaf = function() {
  const n = new BNode();
  n.isShared = true;
  return n;
}();
var ReusedArray = [];
function check(fact, ...args) {
  {
    args.unshift(`B+ tree`);
    throw new Error(args.join(` `));
  }
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/indexes/btree-index.js
var BTreeIndex = class extends BaseIndex {
  constructor(id, expression, name, options) {
    super(id, expression, name, options);
    this.supportedOperations = /* @__PURE__ */ new Set([
      `eq`,
      `gt`,
      `gte`,
      `lt`,
      `lte`,
      `in`
    ]);
    this.valueMap = /* @__PURE__ */ new Map();
    this.indexedKeys = /* @__PURE__ */ new Set();
    this.compareFn = defaultComparator;
    this.compareFn = (options == null ? void 0 : options.compareFn) ?? defaultComparator;
    if (options == null ? void 0 : options.compareOptions) {
      this.compareOptions = options.compareOptions;
    }
    this.orderedEntries = new BTree(this.compareFn);
  }
  initialize(_options) {
  }
  /**
   * Adds a value to the index
   */
  add(key, item) {
    let indexedValue2;
    try {
      indexedValue2 = this.evaluateIndexExpression(item);
    } catch (error) {
      throw new Error(
        `Failed to evaluate index expression for key ${key}: ${error}`
      );
    }
    const normalizedValue = normalizeValue(indexedValue2);
    if (this.valueMap.has(normalizedValue)) {
      this.valueMap.get(normalizedValue).add(key);
    } else {
      const keySet = /* @__PURE__ */ new Set([key]);
      this.valueMap.set(normalizedValue, keySet);
      this.orderedEntries.set(normalizedValue, void 0);
    }
    this.indexedKeys.add(key);
    this.updateTimestamp();
  }
  /**
   * Removes a value from the index
   */
  remove(key, item) {
    let indexedValue2;
    try {
      indexedValue2 = this.evaluateIndexExpression(item);
    } catch (error) {
      console.warn(
        `Failed to evaluate index expression for key ${key} during removal:`,
        error
      );
      return;
    }
    const normalizedValue = normalizeValue(indexedValue2);
    if (this.valueMap.has(normalizedValue)) {
      const keySet = this.valueMap.get(normalizedValue);
      keySet.delete(key);
      if (keySet.size === 0) {
        this.valueMap.delete(normalizedValue);
        this.orderedEntries.delete(normalizedValue);
      }
    }
    this.indexedKeys.delete(key);
    this.updateTimestamp();
  }
  /**
   * Updates a value in the index
   */
  update(key, oldItem, newItem) {
    this.remove(key, oldItem);
    this.add(key, newItem);
  }
  /**
   * Builds the index from a collection of entries
   */
  build(entries) {
    this.clear();
    for (const [key, item] of entries) {
      this.add(key, item);
    }
  }
  /**
   * Clears all data from the index
   */
  clear() {
    this.orderedEntries.clear();
    this.valueMap.clear();
    this.indexedKeys.clear();
    this.updateTimestamp();
  }
  /**
   * Performs a lookup operation
   */
  lookup(operation, value) {
    const startTime = performance.now();
    let result;
    switch (operation) {
      case `eq`:
        result = this.equalityLookup(value);
        break;
      case `gt`:
        result = this.rangeQuery({ from: value, fromInclusive: false });
        break;
      case `gte`:
        result = this.rangeQuery({ from: value, fromInclusive: true });
        break;
      case `lt`:
        result = this.rangeQuery({ to: value, toInclusive: false });
        break;
      case `lte`:
        result = this.rangeQuery({ to: value, toInclusive: true });
        break;
      case `in`:
        result = this.inArrayLookup(value);
        break;
      default:
        throw new Error(`Operation ${operation} not supported by BTreeIndex`);
    }
    this.trackLookup(startTime);
    return result;
  }
  /**
   * Gets the number of indexed keys
   */
  get keyCount() {
    return this.indexedKeys.size;
  }
  // Public methods for backward compatibility (used by tests)
  /**
   * Performs an equality lookup
   */
  equalityLookup(value) {
    const normalizedValue = normalizeValue(value);
    return new Set(this.valueMap.get(normalizedValue) ?? []);
  }
  /**
   * Performs a range query with options
   * This is more efficient for compound queries like "WHERE a > 5 AND a < 10"
   */
  rangeQuery(options = {}) {
    const { from, to, fromInclusive = true, toInclusive = true } = options;
    const result = /* @__PURE__ */ new Set();
    const normalizedFrom = normalizeValue(from);
    const normalizedTo = normalizeValue(to);
    const fromKey = normalizedFrom ?? this.orderedEntries.minKey();
    const toKey = normalizedTo ?? this.orderedEntries.maxKey();
    this.orderedEntries.forRange(
      fromKey,
      toKey,
      toInclusive,
      (indexedValue2, _) => {
        if (!fromInclusive && this.compareFn(indexedValue2, from) === 0) {
          return;
        }
        const keys = this.valueMap.get(indexedValue2);
        if (keys) {
          keys.forEach((key) => result.add(key));
        }
      }
    );
    return result;
  }
  /**
   * Performs a reversed range query
   */
  rangeQueryReversed(options = {}) {
    const { from, to, fromInclusive = true, toInclusive = true } = options;
    return this.rangeQuery({
      from: to ?? this.orderedEntries.maxKey(),
      to: from ?? this.orderedEntries.minKey(),
      fromInclusive: toInclusive,
      toInclusive: fromInclusive
    });
  }
  takeInternal(n, nextPair, from, filterFn) {
    const keysInResult = /* @__PURE__ */ new Set();
    const result = [];
    let pair;
    let key = normalizeValue(from);
    while ((pair = nextPair(key)) !== void 0 && result.length < n) {
      key = pair[0];
      const keys = this.valueMap.get(key);
      if (keys) {
        const it = keys.values();
        let ks;
        while (result.length < n && (ks = it.next().value)) {
          if (!keysInResult.has(ks) && ((filterFn == null ? void 0 : filterFn(ks)) ?? true)) {
            result.push(ks);
            keysInResult.add(ks);
          }
        }
      }
    }
    return result;
  }
  /**
   * Returns the next n items after the provided item or the first n items if no from item is provided.
   * @param n - The number of items to return
   * @param from - The item to start from (exclusive). Starts from the smallest item (inclusive) if not provided.
   * @returns The next n items after the provided key. Returns the first n items if no from item is provided.
   */
  take(n, from, filterFn) {
    const nextPair = (k) => this.orderedEntries.nextHigherPair(k);
    return this.takeInternal(n, nextPair, from, filterFn);
  }
  /**
   * Returns the next n items **before** the provided item (in descending order) or the last n items if no from item is provided.
   * @param n - The number of items to return
   * @param from - The item to start from (exclusive). Starts from the largest item (inclusive) if not provided.
   * @returns The next n items **before** the provided key. Returns the last n items if no from item is provided.
   */
  takeReversed(n, from, filterFn) {
    const nextPair = (k) => this.orderedEntries.nextLowerPair(k);
    return this.takeInternal(n, nextPair, from, filterFn);
  }
  /**
   * Performs an IN array lookup
   */
  inArrayLookup(values) {
    const result = /* @__PURE__ */ new Set();
    for (const value of values) {
      const normalizedValue = normalizeValue(value);
      const keys = this.valueMap.get(normalizedValue);
      if (keys) {
        keys.forEach((key) => result.add(key));
      }
    }
    return result;
  }
  // Getter methods for testing compatibility
  get indexedKeysSet() {
    return this.indexedKeys;
  }
  get orderedEntriesArray() {
    return this.orderedEntries.keysArray().map((key) => [key, this.valueMap.get(key) ?? /* @__PURE__ */ new Set()]);
  }
  get orderedEntriesArrayReversed() {
    return this.takeReversed(this.orderedEntries.size).map((key) => [
      key,
      this.valueMap.get(key) ?? /* @__PURE__ */ new Set()
    ]);
  }
  get valueMapData() {
    return this.valueMap;
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/SortedMap.js
var SortedMap = class {
  /**
   * Creates a new SortedMap instance
   *
   * @param comparator - Optional function to compare values for sorting
   */
  constructor(comparator) {
    this.map = /* @__PURE__ */ new Map();
    this.sortedKeys = [];
    this.comparator = comparator || this.defaultComparator;
  }
  /**
   * Default comparator function used when none is provided
   *
   * @param a - First value to compare
   * @param b - Second value to compare
   * @returns -1 if a < b, 1 if a > b, 0 if equal
   */
  defaultComparator(a, b) {
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  }
  /**
   * Finds the index where a key-value pair should be inserted to maintain sort order.
   * Uses binary search to find the correct position based on the value.
   * Hence, it is in O(log n) time.
   *
   * @param key - The key to find position for
   * @param value - The value to compare against
   * @returns The index where the key should be inserted
   */
  indexOf(value) {
    let left = 0;
    let right = this.sortedKeys.length;
    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      const midKey = this.sortedKeys[mid];
      const midValue = this.map.get(midKey);
      const comparison = this.comparator(value, midValue);
      if (comparison < 0) {
        right = mid;
      } else if (comparison > 0) {
        left = mid + 1;
      } else {
        return mid;
      }
    }
    return left;
  }
  /**
   * Sets a key-value pair in the map and maintains sort order
   *
   * @param key - The key to set
   * @param value - The value to associate with the key
   * @returns This SortedMap instance for chaining
   */
  set(key, value) {
    if (this.map.has(key)) {
      const oldValue = this.map.get(key);
      const oldIndex = this.indexOf(oldValue);
      this.sortedKeys.splice(oldIndex, 1);
    }
    const index = this.indexOf(value);
    this.sortedKeys.splice(index, 0, key);
    this.map.set(key, value);
    return this;
  }
  /**
   * Gets a value by its key
   *
   * @param key - The key to look up
   * @returns The value associated with the key, or undefined if not found
   */
  get(key) {
    return this.map.get(key);
  }
  /**
   * Removes a key-value pair from the map
   *
   * @param key - The key to remove
   * @returns True if the key was found and removed, false otherwise
   */
  delete(key) {
    if (this.map.has(key)) {
      const oldValue = this.map.get(key);
      const index = this.indexOf(oldValue);
      this.sortedKeys.splice(index, 1);
      return this.map.delete(key);
    }
    return false;
  }
  /**
   * Checks if a key exists in the map
   *
   * @param key - The key to check
   * @returns True if the key exists, false otherwise
   */
  has(key) {
    return this.map.has(key);
  }
  /**
   * Removes all key-value pairs from the map
   */
  clear() {
    this.map.clear();
    this.sortedKeys = [];
  }
  /**
   * Gets the number of key-value pairs in the map
   */
  get size() {
    return this.map.size;
  }
  /**
   * Default iterator that returns entries in sorted order
   *
   * @returns An iterator for the map's entries
   */
  *[Symbol.iterator]() {
    for (const key of this.sortedKeys) {
      yield [key, this.map.get(key)];
    }
  }
  /**
   * Returns an iterator for the map's entries in sorted order
   *
   * @returns An iterator for the map's entries
   */
  entries() {
    return this[Symbol.iterator]();
  }
  /**
   * Returns an iterator for the map's keys in sorted order
   *
   * @returns An iterator for the map's keys
   */
  keys() {
    return this.sortedKeys[Symbol.iterator]();
  }
  /**
   * Returns an iterator for the map's values in sorted order
   *
   * @returns An iterator for the map's values
   */
  values() {
    return (function* () {
      for (const key of this.sortedKeys) {
        yield this.map.get(key);
      }
    }).call(this);
  }
  /**
   * Executes a callback function for each key-value pair in the map in sorted order
   *
   * @param callbackfn - Function to execute for each entry
   */
  forEach(callbackfn) {
    for (const key of this.sortedKeys) {
      callbackfn(this.map.get(key), key, this.map);
    }
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/indexes/lazy-index.js
function isConstructor(resolver) {
  return typeof resolver === `function` && resolver.prototype !== void 0 && resolver.prototype.constructor === resolver;
}
async function resolveIndexConstructor(resolver) {
  if (isConstructor(resolver)) {
    return resolver;
  } else {
    return await resolver();
  }
}
var LazyIndexWrapper = class {
  constructor(id, expression, name, resolver, options, collectionEntries) {
    this.id = id;
    this.expression = expression;
    this.name = name;
    this.resolver = resolver;
    this.options = options;
    this.collectionEntries = collectionEntries;
    this.indexPromise = null;
    this.resolvedIndex = null;
    if (isConstructor(this.resolver)) {
      this.resolvedIndex = new this.resolver(
        this.id,
        this.expression,
        this.name,
        this.options
      );
      if (this.collectionEntries) {
        this.resolvedIndex.build(this.collectionEntries);
      }
    }
  }
  /**
   * Resolve the actual index
   */
  async resolve() {
    if (this.resolvedIndex) {
      return this.resolvedIndex;
    }
    if (!this.indexPromise) {
      this.indexPromise = this.createIndex();
    }
    this.resolvedIndex = await this.indexPromise;
    return this.resolvedIndex;
  }
  /**
   * Check if already resolved
   */
  isResolved() {
    return this.resolvedIndex !== null;
  }
  /**
   * Get resolved index (throws if not ready)
   */
  getResolved() {
    if (!this.resolvedIndex) {
      throw new Error(
        `Index ${this.id} has not been resolved yet. Ensure collection is synced.`
      );
    }
    return this.resolvedIndex;
  }
  /**
   * Get the index ID
   */
  getId() {
    return this.id;
  }
  /**
   * Get the index name
   */
  getName() {
    return this.name;
  }
  /**
   * Get the index expression
   */
  getExpression() {
    return this.expression;
  }
  async createIndex() {
    const IndexClass = await resolveIndexConstructor(this.resolver);
    return new IndexClass(this.id, this.expression, this.name, this.options);
  }
};
var IndexProxy = class {
  constructor(indexId, lazyIndex) {
    this.indexId = indexId;
    this.lazyIndex = lazyIndex;
  }
  /**
   * Get the resolved index (throws if not ready)
   */
  get index() {
    return this.lazyIndex.getResolved();
  }
  /**
   * Check if index is ready
   */
  get isReady() {
    return this.lazyIndex.isResolved();
  }
  /**
   * Wait for index to be ready
   */
  async whenReady() {
    return await this.lazyIndex.resolve();
  }
  /**
   * Get the index ID
   */
  get id() {
    return this.indexId;
  }
  /**
   * Get the index name (throws if not ready)
   */
  get name() {
    if (this.isReady) {
      return this.index.name;
    }
    return this.lazyIndex.getName();
  }
  /**
   * Get the index expression (available immediately)
   */
  get expression() {
    return this.lazyIndex.getExpression();
  }
  /**
   * Check if index supports an operation (throws if not ready)
   */
  supports(operation) {
    return this.index.supports(operation);
  }
  /**
   * Get index statistics (throws if not ready)
   */
  getStats() {
    return this.index.getStats();
  }
  /**
   * Check if index matches a field path (available immediately)
   */
  matchesField(fieldPath) {
    const expr = this.expression;
    return expr.type === `ref` && expr.path.length === fieldPath.length && expr.path.every((part, i) => part === fieldPath[i]);
  }
  /**
   * Get the key count (throws if not ready)
   */
  get keyCount() {
    return this.index.keyCount;
  }
  // Test compatibility properties - delegate to resolved index
  get indexedKeysSet() {
    const resolved = this.index;
    return resolved.indexedKeysSet;
  }
  get orderedEntriesArray() {
    const resolved = this.index;
    return resolved.orderedEntriesArray;
  }
  get valueMapData() {
    const resolved = this.index;
    return resolved.valueMapData;
  }
  // BTreeIndex compatibility methods
  equalityLookup(value) {
    var _a;
    const resolved = this.index;
    return ((_a = resolved.equalityLookup) == null ? void 0 : _a.call(resolved, value)) ?? /* @__PURE__ */ new Set();
  }
  rangeQuery(options) {
    var _a;
    const resolved = this.index;
    return ((_a = resolved.rangeQuery) == null ? void 0 : _a.call(resolved, options)) ?? /* @__PURE__ */ new Set();
  }
  inArrayLookup(values) {
    var _a;
    const resolved = this.index;
    return ((_a = resolved.inArrayLookup) == null ? void 0 : _a.call(resolved, values)) ?? /* @__PURE__ */ new Set();
  }
  // Internal method for the collection to get the lazy wrapper
  _getLazyWrapper() {
    return this.lazyIndex;
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/proxy.js
function debugLog(...args) {
  const isBrowser = typeof window !== `undefined` && typeof localStorage !== `undefined`;
  if (isBrowser && localStorage.getItem(`DEBUG`) === `true`) {
    console.log(`[proxy]`, ...args);
  } else if (
    // true
    !isBrowser && typeof process !== `undefined` && process.env.DEBUG === `true`
  ) {
    console.log(`[proxy]`, ...args);
  }
}
function deepClone(obj, visited = /* @__PURE__ */ new WeakMap()) {
  if (obj === null || obj === void 0) {
    return obj;
  }
  if (typeof obj !== `object`) {
    return obj;
  }
  if (visited.has(obj)) {
    return visited.get(obj);
  }
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags);
  }
  if (Array.isArray(obj)) {
    const arrayClone = [];
    visited.set(obj, arrayClone);
    obj.forEach((item, index) => {
      arrayClone[index] = deepClone(item, visited);
    });
    return arrayClone;
  }
  if (ArrayBuffer.isView(obj) && !(obj instanceof DataView)) {
    const TypedArrayConstructor = Object.getPrototypeOf(obj).constructor;
    const clone2 = new TypedArrayConstructor(
      obj.length
    );
    visited.set(obj, clone2);
    for (let i = 0; i < obj.length; i++) {
      clone2[i] = obj[i];
    }
    return clone2;
  }
  if (obj instanceof Map) {
    const clone2 = /* @__PURE__ */ new Map();
    visited.set(obj, clone2);
    obj.forEach((value, key) => {
      clone2.set(key, deepClone(value, visited));
    });
    return clone2;
  }
  if (obj instanceof Set) {
    const clone2 = /* @__PURE__ */ new Set();
    visited.set(obj, clone2);
    obj.forEach((value) => {
      clone2.add(deepClone(value, visited));
    });
    return clone2;
  }
  if (isTemporal(obj)) {
    return obj;
  }
  const clone = {};
  visited.set(obj, clone);
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      clone[key] = deepClone(
        obj[key],
        visited
      );
    }
  }
  const symbolProps = Object.getOwnPropertySymbols(obj);
  for (const sym of symbolProps) {
    clone[sym] = deepClone(
      obj[sym],
      visited
    );
  }
  return clone;
}
var count2 = 0;
function getProxyCount() {
  count2 += 1;
  return count2;
}
function createChangeProxy(target, parent) {
  const changeProxyCache = /* @__PURE__ */ new Map();
  function memoizedCreateChangeProxy(innerTarget, innerParent) {
    debugLog(`Object ID:`, innerTarget.constructor.name);
    if (changeProxyCache.has(innerTarget)) {
      return changeProxyCache.get(innerTarget);
    } else {
      const changeProxy = createChangeProxy(innerTarget, innerParent);
      changeProxyCache.set(innerTarget, changeProxy);
      return changeProxy;
    }
  }
  const proxyCache = /* @__PURE__ */ new Map();
  const changeTracker = {
    copy_: deepClone(target),
    originalObject: deepClone(target),
    proxyCount: getProxyCount(),
    modified: false,
    assigned_: {},
    parent,
    target
    // Store reference to the target object
  };
  debugLog(
    `createChangeProxy called for target`,
    target,
    changeTracker.proxyCount
  );
  function markChanged(state) {
    if (!state.modified) {
      state.modified = true;
    }
    if (state.parent) {
      debugLog(`propagating change to parent`);
      if (`updateMap` in state.parent) {
        state.parent.updateMap(state.copy_);
      } else if (`updateSet` in state.parent) {
        state.parent.updateSet(state.copy_);
      } else {
        state.parent.tracker.copy_[state.parent.prop] = state.copy_;
        state.parent.tracker.assigned_[state.parent.prop] = true;
      }
      markChanged(state.parent.tracker);
    }
  }
  function checkIfReverted(state) {
    debugLog(
      `checkIfReverted called with assigned keys:`,
      Object.keys(state.assigned_)
    );
    if (Object.keys(state.assigned_).length === 0 && Object.getOwnPropertySymbols(state.assigned_).length === 0) {
      debugLog(`No assigned properties, returning true`);
      return true;
    }
    for (const prop in state.assigned_) {
      if (state.assigned_[prop] === true) {
        const currentValue = state.copy_[prop];
        const originalValue = state.originalObject[prop];
        debugLog(
          `Checking property ${String(prop)}, current:`,
          currentValue,
          `original:`,
          originalValue
        );
        if (!deepEquals(currentValue, originalValue)) {
          debugLog(`Property ${String(prop)} is different, returning false`);
          return false;
        }
      } else if (state.assigned_[prop] === false) {
        debugLog(`Property ${String(prop)} was deleted, returning false`);
        return false;
      }
    }
    const symbolProps = Object.getOwnPropertySymbols(state.assigned_);
    for (const sym of symbolProps) {
      if (state.assigned_[sym] === true) {
        const currentValue = state.copy_[sym];
        const originalValue = state.originalObject[sym];
        if (!deepEquals(currentValue, originalValue)) {
          debugLog(`Symbol property is different, returning false`);
          return false;
        }
      } else if (state.assigned_[sym] === false) {
        debugLog(`Symbol property was deleted, returning false`);
        return false;
      }
    }
    debugLog(`All properties match original values, returning true`);
    return true;
  }
  function checkParentStatus(parentState, childProp) {
    debugLog(`checkParentStatus called for child prop:`, childProp);
    const isReverted = checkIfReverted(parentState);
    debugLog(`Parent checkIfReverted returned:`, isReverted);
    if (isReverted) {
      debugLog(`Parent is fully reverted, clearing tracking`);
      parentState.modified = false;
      parentState.assigned_ = {};
      if (parentState.parent) {
        debugLog(`Continuing up the parent chain`);
        checkParentStatus(parentState.parent.tracker, parentState.parent.prop);
      }
    }
  }
  function createObjectProxy(obj) {
    debugLog(`createObjectProxy`, obj);
    if (proxyCache.has(obj)) {
      debugLog(`proxyCache found match`);
      return proxyCache.get(obj);
    }
    const proxy2 = new Proxy(obj, {
      get(ptarget, prop) {
        debugLog(`get`, ptarget, prop);
        const value = changeTracker.copy_[prop] ?? changeTracker.originalObject[prop];
        const originalValue = changeTracker.originalObject[prop];
        debugLog(`value (at top of proxy get)`, value);
        const desc = Object.getOwnPropertyDescriptor(ptarget, prop);
        if (desc == null ? void 0 : desc.get) {
          return value;
        }
        if (typeof value === `function`) {
          if (Array.isArray(ptarget)) {
            const methodName = prop.toString();
            const modifyingMethods = /* @__PURE__ */ new Set([
              `pop`,
              `push`,
              `shift`,
              `unshift`,
              `splice`,
              `sort`,
              `reverse`,
              `fill`,
              `copyWithin`
            ]);
            if (modifyingMethods.has(methodName)) {
              return function(...args) {
                const result = value.apply(changeTracker.copy_, args);
                markChanged(changeTracker);
                return result;
              };
            }
          }
          if (ptarget instanceof Map || ptarget instanceof Set) {
            const methodName = prop.toString();
            const modifyingMethods = /* @__PURE__ */ new Set([
              `set`,
              `delete`,
              `clear`,
              `add`,
              `pop`,
              `push`,
              `shift`,
              `unshift`,
              `splice`,
              `sort`,
              `reverse`
            ]);
            if (modifyingMethods.has(methodName)) {
              return function(...args) {
                const result = value.apply(changeTracker.copy_, args);
                markChanged(changeTracker);
                return result;
              };
            }
            const iteratorMethods = /* @__PURE__ */ new Set([
              `entries`,
              `keys`,
              `values`,
              `forEach`,
              Symbol.iterator
            ]);
            if (iteratorMethods.has(methodName) || prop === Symbol.iterator) {
              return function(...args) {
                const result = value.apply(changeTracker.copy_, args);
                if (methodName === `forEach`) {
                  const callback = args[0];
                  if (typeof callback === `function`) {
                    const wrappedCallback = function(value2, key, collection) {
                      const cbresult = callback.call(
                        this,
                        value2,
                        key,
                        collection
                      );
                      markChanged(changeTracker);
                      return cbresult;
                    };
                    return value.apply(ptarget, [
                      wrappedCallback,
                      ...args.slice(1)
                    ]);
                  }
                }
                if (methodName === `entries` || methodName === `values` || methodName === Symbol.iterator.toString() || prop === Symbol.iterator) {
                  const originalIterator = result;
                  const valueToKeyMap = /* @__PURE__ */ new Map();
                  if (methodName === `values` && ptarget instanceof Map) {
                    for (const [
                      key,
                      mapValue
                    ] of changeTracker.copy_.entries()) {
                      valueToKeyMap.set(mapValue, key);
                    }
                  }
                  const originalToModifiedMap = /* @__PURE__ */ new Map();
                  if (ptarget instanceof Set) {
                    for (const setValue of changeTracker.copy_.values()) {
                      originalToModifiedMap.set(setValue, setValue);
                    }
                  }
                  return {
                    next() {
                      const nextResult = originalIterator.next();
                      if (!nextResult.done && nextResult.value && typeof nextResult.value === `object`) {
                        if (methodName === `entries` && Array.isArray(nextResult.value) && nextResult.value.length === 2) {
                          if (nextResult.value[1] && typeof nextResult.value[1] === `object`) {
                            const mapKey = nextResult.value[0];
                            const mapParent = {
                              tracker: changeTracker,
                              prop: mapKey,
                              updateMap: (newValue) => {
                                if (changeTracker.copy_ instanceof Map) {
                                  changeTracker.copy_.set(mapKey, newValue);
                                }
                              }
                            };
                            const { proxy: valueProxy } = memoizedCreateChangeProxy(
                              nextResult.value[1],
                              mapParent
                            );
                            nextResult.value[1] = valueProxy;
                          }
                        } else if (methodName === `values` || methodName === Symbol.iterator.toString() || prop === Symbol.iterator) {
                          if (typeof nextResult.value === `object` && nextResult.value !== null) {
                            if (methodName === `values` && ptarget instanceof Map) {
                              const mapKey = valueToKeyMap.get(nextResult.value);
                              if (mapKey !== void 0) {
                                const mapParent = {
                                  tracker: changeTracker,
                                  prop: mapKey,
                                  updateMap: (newValue) => {
                                    if (changeTracker.copy_ instanceof Map) {
                                      changeTracker.copy_.set(mapKey, newValue);
                                    }
                                  }
                                };
                                const { proxy: valueProxy } = memoizedCreateChangeProxy(
                                  nextResult.value,
                                  mapParent
                                );
                                nextResult.value = valueProxy;
                              }
                            } else if (ptarget instanceof Set) {
                              const setOriginalValue = nextResult.value;
                              const setParent = {
                                tracker: changeTracker,
                                prop: setOriginalValue,
                                // Use the original value as the prop
                                updateSet: (newValue) => {
                                  if (changeTracker.copy_ instanceof Set) {
                                    changeTracker.copy_.delete(setOriginalValue);
                                    changeTracker.copy_.add(newValue);
                                    originalToModifiedMap.set(
                                      setOriginalValue,
                                      newValue
                                    );
                                  }
                                }
                              };
                              const { proxy: valueProxy } = memoizedCreateChangeProxy(
                                nextResult.value,
                                setParent
                              );
                              nextResult.value = valueProxy;
                            } else {
                              const tempKey = Symbol(`iterator-value`);
                              const { proxy: valueProxy } = memoizedCreateChangeProxy(nextResult.value, {
                                tracker: changeTracker,
                                prop: tempKey
                              });
                              nextResult.value = valueProxy;
                            }
                          }
                        }
                      }
                      return nextResult;
                    },
                    [Symbol.iterator]() {
                      return this;
                    }
                  };
                }
                return result;
              };
            }
          }
          return value.bind(ptarget);
        }
        if (value && typeof value === `object` && !(value instanceof Date) && !(value instanceof RegExp) && !isTemporal(value)) {
          const nestedParent = {
            tracker: changeTracker,
            prop: String(prop)
          };
          const { proxy: nestedProxy } = memoizedCreateChangeProxy(
            originalValue,
            nestedParent
          );
          proxyCache.set(value, nestedProxy);
          return nestedProxy;
        }
        return value;
      },
      set(_sobj, prop, value) {
        const currentValue = changeTracker.copy_[prop];
        debugLog(
          `set called for property ${String(prop)}, current:`,
          currentValue,
          `new:`,
          value
        );
        if (!deepEquals(currentValue, value)) {
          const originalValue = changeTracker.originalObject[prop];
          const isRevertToOriginal = deepEquals(value, originalValue);
          debugLog(
            `value:`,
            value,
            `original:`,
            originalValue,
            `isRevertToOriginal:`,
            isRevertToOriginal
          );
          if (isRevertToOriginal) {
            debugLog(`Reverting property ${String(prop)} to original value`);
            delete changeTracker.assigned_[prop.toString()];
            debugLog(`Updating copy with original value for ${String(prop)}`);
            changeTracker.copy_[prop] = deepClone(originalValue);
            debugLog(`Checking if all properties reverted`);
            const allReverted = checkIfReverted(changeTracker);
            debugLog(`All reverted:`, allReverted);
            if (allReverted) {
              debugLog(`All properties reverted, clearing tracking`);
              changeTracker.modified = false;
              changeTracker.assigned_ = {};
              if (parent) {
                debugLog(`Updating parent for property:`, parent.prop);
                checkParentStatus(parent.tracker, parent.prop);
              }
            } else {
              debugLog(`Some properties still changed, keeping modified flag`);
              changeTracker.modified = true;
            }
          } else {
            debugLog(`Setting new value for property ${String(prop)}`);
            changeTracker.copy_[prop] = value;
            changeTracker.assigned_[prop.toString()] = true;
            debugLog(`Marking object and ancestors as modified`, changeTracker);
            markChanged(changeTracker);
          }
        } else {
          debugLog(`Value unchanged, not tracking`);
        }
        return true;
      },
      defineProperty(_ptarget, prop, descriptor) {
        if (`value` in descriptor) {
          changeTracker.copy_[prop] = deepClone(descriptor.value);
          changeTracker.assigned_[prop.toString()] = true;
          markChanged(changeTracker);
        }
        return true;
      },
      deleteProperty(dobj, prop) {
        debugLog(`deleteProperty`, dobj, prop);
        const stringProp = typeof prop === `symbol` ? prop.toString() : prop;
        if (stringProp in dobj) {
          const hadPropertyInOriginal = stringProp in changeTracker.originalObject;
          delete changeTracker.copy_[prop];
          if (!hadPropertyInOriginal) {
            delete changeTracker.copy_[stringProp];
            delete changeTracker.assigned_[stringProp];
            if (Object.keys(changeTracker.assigned_).length === 0 && Object.getOwnPropertySymbols(changeTracker.assigned_).length === 0) {
              changeTracker.modified = false;
            } else {
              changeTracker.modified = true;
            }
          } else {
            changeTracker.assigned_[stringProp] = false;
            changeTracker.copy_[stringProp] = void 0;
            markChanged(changeTracker);
          }
        }
        return true;
      }
    });
    proxyCache.set(obj, proxy2);
    return proxy2;
  }
  const proxy = createObjectProxy(target);
  return {
    proxy,
    getChanges: () => {
      debugLog(`getChanges called, modified:`, changeTracker.modified);
      debugLog(changeTracker);
      if (!changeTracker.modified) {
        debugLog(`Object not modified, returning empty object`);
        return {};
      }
      if (typeof changeTracker.copy_ !== `object` || Array.isArray(changeTracker.copy_)) {
        return changeTracker.copy_;
      }
      if (Object.keys(changeTracker.assigned_).length === 0) {
        return changeTracker.copy_;
      }
      const result = {};
      for (const key in changeTracker.copy_) {
        if (changeTracker.assigned_[key] === true && key in changeTracker.copy_) {
          result[key] = changeTracker.copy_[key];
        }
      }
      debugLog(`Returning copy:`, result);
      return result;
    }
  };
}
function createArrayChangeProxy(targets) {
  const proxiesWithChanges = targets.map((target) => createChangeProxy(target));
  return {
    proxies: proxiesWithChanges.map((p) => p.proxy),
    getChanges: () => proxiesWithChanges.map((p) => p.getChanges())
  };
}
function withChangeTracking(target, callback) {
  const { proxy, getChanges } = createChangeProxy(target);
  callback(proxy);
  return getChanges();
}
function withArrayChangeTracking(targets, callback) {
  const { proxies, getChanges } = createArrayChangeProxy(targets);
  callback(proxies);
  return getChanges();
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/deferred.js
function createDeferred() {
  let resolve;
  let reject;
  let isPending = true;
  const promise = new Promise((res, rej) => {
    resolve = (value) => {
      isPending = false;
      res(value);
    };
    reject = (reason) => {
      isPending = false;
      rej(reason);
    };
  });
  return {
    promise,
    resolve,
    reject,
    isPending: () => isPending
  };
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/scheduler.js
function isPendingAwareJob(dep) {
  return typeof dep === `object` && dep !== null && typeof dep.hasPendingGraphRun === `function`;
}
var Scheduler = class {
  constructor() {
    this.contexts = /* @__PURE__ */ new Map();
    this.clearListeners = /* @__PURE__ */ new Set();
  }
  /**
   * Get or create the state bucket for a context.
   */
  getOrCreateContext(contextId) {
    let context = this.contexts.get(contextId);
    if (!context) {
      context = {
        queue: [],
        jobs: /* @__PURE__ */ new Map(),
        dependencies: /* @__PURE__ */ new Map(),
        completed: /* @__PURE__ */ new Set()
      };
      this.contexts.set(contextId, context);
    }
    return context;
  }
  /**
   * Schedule work. Without a context id, executes immediately.
   * Otherwise queues the job to be flushed once dependencies are satisfied.
   * Scheduling the same jobId again replaces the previous run function.
   */
  schedule({ contextId, jobId, dependencies, run }) {
    if (typeof contextId === `undefined`) {
      run();
      return;
    }
    const context = this.getOrCreateContext(contextId);
    if (!context.jobs.has(jobId)) {
      context.queue.push(jobId);
    }
    context.jobs.set(jobId, run);
    if (dependencies) {
      const depSet = new Set(dependencies);
      depSet.delete(jobId);
      context.dependencies.set(jobId, depSet);
    } else if (!context.dependencies.has(jobId)) {
      context.dependencies.set(jobId, /* @__PURE__ */ new Set());
    }
    context.completed.delete(jobId);
  }
  /**
   * Flush all queued work for a context. Jobs with unmet dependencies are retried.
   * Throws if a pass completes without running any job (dependency cycle).
   */
  flush(contextId) {
    const context = this.contexts.get(contextId);
    if (!context) return;
    const { queue, jobs, dependencies, completed } = context;
    while (queue.length > 0) {
      let ranThisPass = false;
      const jobsThisPass = queue.length;
      for (let i = 0; i < jobsThisPass; i++) {
        const jobId = queue.shift();
        const run = jobs.get(jobId);
        if (!run) {
          dependencies.delete(jobId);
          completed.delete(jobId);
          continue;
        }
        const deps = dependencies.get(jobId);
        let ready = !deps;
        if (deps) {
          ready = true;
          for (const dep of deps) {
            if (dep === jobId) continue;
            const depHasPending = isPendingAwareJob(dep) && dep.hasPendingGraphRun(contextId);
            if (jobs.has(dep) && !completed.has(dep) || !jobs.has(dep) && depHasPending) {
              ready = false;
              break;
            }
          }
        }
        if (ready) {
          jobs.delete(jobId);
          dependencies.delete(jobId);
          run();
          completed.add(jobId);
          ranThisPass = true;
        } else {
          queue.push(jobId);
        }
      }
      if (!ranThisPass) {
        throw new Error(
          `Scheduler detected unresolved dependencies for context ${String(
            contextId
          )}.`
        );
      }
    }
    this.contexts.delete(contextId);
  }
  /**
   * Flush all contexts with pending work. Useful during tear-down.
   */
  flushAll() {
    for (const contextId of Array.from(this.contexts.keys())) {
      this.flush(contextId);
    }
  }
  /** Clear all scheduled jobs for a context. */
  clear(contextId) {
    this.contexts.delete(contextId);
    this.clearListeners.forEach((listener) => listener(contextId));
  }
  /** Register a listener to be notified when a context is cleared. */
  onClear(listener) {
    this.clearListeners.add(listener);
    return () => this.clearListeners.delete(listener);
  }
  /** Check if a context has pending jobs. */
  hasPendingJobs(contextId) {
    const context = this.contexts.get(contextId);
    return !!context && context.jobs.size > 0;
  }
  /** Remove a single job from a context and clean up its dependencies. */
  clearJob(contextId, jobId) {
    const context = this.contexts.get(contextId);
    if (!context) return;
    context.jobs.delete(jobId);
    context.dependencies.delete(jobId);
    context.completed.delete(jobId);
    context.queue = context.queue.filter((id) => id !== jobId);
    if (context.jobs.size === 0) {
      this.contexts.delete(contextId);
    }
  }
};
var transactionScopedScheduler = new Scheduler();

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/transactions.js
var transactions = [];
var transactionStack = [];
var sequenceNumber = 0;
function mergePendingMutations(existing, incoming) {
  switch (`${existing.type}-${incoming.type}`) {
    case `insert-update`: {
      return {
        ...existing,
        type: `insert`,
        original: {},
        modified: incoming.modified,
        changes: { ...existing.changes, ...incoming.changes },
        // Keep existing keys (key changes not allowed in updates)
        key: existing.key,
        globalKey: existing.globalKey,
        // Merge metadata (last-write-wins)
        metadata: incoming.metadata ?? existing.metadata,
        syncMetadata: { ...existing.syncMetadata, ...incoming.syncMetadata },
        // Update tracking info
        mutationId: incoming.mutationId,
        updatedAt: incoming.updatedAt
      };
    }
    case `insert-delete`:
      return null;
    case `update-delete`:
      return incoming;
    case `update-update`: {
      return {
        ...incoming,
        // Keep original from first update
        original: existing.original,
        // Union the changes from both updates
        changes: { ...existing.changes, ...incoming.changes },
        // Merge metadata
        metadata: incoming.metadata ?? existing.metadata,
        syncMetadata: { ...existing.syncMetadata, ...incoming.syncMetadata }
      };
    }
    case `delete-delete`:
    case `insert-insert`:
      return incoming;
    default: {
      const _exhaustive = `${existing.type}-${incoming.type}`;
      throw new Error(`Unhandled mutation combination: ${_exhaustive}`);
    }
  }
}
function createTransaction(config) {
  const newTransaction = new Transaction(config);
  transactions.push(newTransaction);
  return newTransaction;
}
function getActiveTransaction() {
  if (transactionStack.length > 0) {
    return transactionStack.slice(-1)[0];
  } else {
    return void 0;
  }
}
function registerTransaction(tx) {
  transactionScopedScheduler.clear(tx.id);
  transactionStack.push(tx);
}
function unregisterTransaction(tx) {
  try {
    transactionScopedScheduler.flush(tx.id);
  } finally {
    transactionStack = transactionStack.filter((t) => t.id !== tx.id);
  }
}
function removeFromPendingList(tx) {
  const index = transactions.findIndex((t) => t.id === tx.id);
  if (index !== -1) {
    transactions.splice(index, 1);
  }
}
var Transaction = class {
  constructor(config) {
    if (typeof config.mutationFn === `undefined`) {
      throw new MissingMutationFunctionError();
    }
    this.id = config.id ?? crypto.randomUUID();
    this.mutationFn = config.mutationFn;
    this.state = `pending`;
    this.mutations = [];
    this.isPersisted = createDeferred();
    this.autoCommit = config.autoCommit ?? true;
    this.createdAt = /* @__PURE__ */ new Date();
    this.sequenceNumber = sequenceNumber++;
    this.metadata = config.metadata ?? {};
  }
  setState(newState) {
    this.state = newState;
    if (newState === `completed` || newState === `failed`) {
      removeFromPendingList(this);
    }
  }
  /**
   * Execute collection operations within this transaction
   * @param callback - Function containing collection operations to group together. If the
   * callback returns a Promise, the transaction context will remain active until the promise
   * settles, allowing optimistic writes after `await` boundaries.
   * @returns This transaction for chaining
   * @example
   * // Group multiple operations
   * const tx = createTransaction({ mutationFn: async () => {
   *   // Send to API
   * }})
   *
   * tx.mutate(() => {
   *   collection.insert({ id: "1", text: "Buy milk" })
   *   collection.update("2", draft => { draft.completed = true })
   *   collection.delete("3")
   * })
   *
   * await tx.isPersisted.promise
   *
   * @example
   * // Handle mutate errors
   * try {
   *   tx.mutate(() => {
   *     collection.insert({ id: "invalid" }) // This might throw
   *   })
   * } catch (error) {
   *   console.log('Mutation failed:', error)
   * }
   *
   * @example
   * // Manual commit control
   * const tx = createTransaction({ autoCommit: false, mutationFn: async () => {} })
   *
   * tx.mutate(() => {
   *   collection.insert({ id: "1", text: "Item" })
   * })
   *
   * // Commit later when ready
   * await tx.commit()
   */
  mutate(callback) {
    if (this.state !== `pending`) {
      throw new TransactionNotPendingMutateError();
    }
    registerTransaction(this);
    try {
      callback();
    } finally {
      unregisterTransaction(this);
    }
    if (this.autoCommit) {
      this.commit().catch(() => {
      });
    }
    return this;
  }
  /**
   * Apply new mutations to this transaction, intelligently merging with existing mutations
   *
   * When mutations operate on the same item (same globalKey), they are merged according to
   * the following rules:
   *
   * - **insert + update**  insert (merge changes, keep empty original)
   * - **insert + delete**  removed (mutations cancel each other out)
   * - **update + delete**  delete (delete dominates)
   * - **update + update**  update (union changes, keep first original)
   * - **same type**  replace with latest
   *
   * This merging reduces over-the-wire churn and keeps the optimistic local view
   * aligned with user intent.
   *
   * @param mutations - Array of new mutations to apply
   */
  applyMutations(mutations) {
    for (const newMutation of mutations) {
      const existingIndex = this.mutations.findIndex(
        (m) => m.globalKey === newMutation.globalKey
      );
      if (existingIndex >= 0) {
        const existingMutation = this.mutations[existingIndex];
        const mergeResult = mergePendingMutations(existingMutation, newMutation);
        if (mergeResult === null) {
          this.mutations.splice(existingIndex, 1);
        } else {
          this.mutations[existingIndex] = mergeResult;
        }
      } else {
        this.mutations.push(newMutation);
      }
    }
  }
  /**
   * Rollback the transaction and any conflicting transactions
   * @param config - Configuration for rollback behavior
   * @returns This transaction for chaining
   * @example
   * // Manual rollback
   * const tx = createTransaction({ mutationFn: async () => {
   *   // Send to API
   * }})
   *
   * tx.mutate(() => {
   *   collection.insert({ id: "1", text: "Buy milk" })
   * })
   *
   * // Rollback if needed
   * if (shouldCancel) {
   *   tx.rollback()
   * }
   *
   * @example
   * // Handle rollback cascade (automatic)
   * const tx1 = createTransaction({ mutationFn: async () => {} })
   * const tx2 = createTransaction({ mutationFn: async () => {} })
   *
   * tx1.mutate(() => collection.update("1", draft => { draft.value = "A" }))
   * tx2.mutate(() => collection.update("1", draft => { draft.value = "B" })) // Same item
   *
   * tx1.rollback() // This will also rollback tx2 due to conflict
   *
   * @example
   * // Handle rollback in error scenarios
   * try {
   *   await tx.isPersisted.promise
   * } catch (error) {
   *   console.log('Transaction was rolled back:', error)
   *   // Transaction automatically rolled back on mutation function failure
   * }
   */
  rollback(config) {
    var _a;
    const isSecondaryRollback = (config == null ? void 0 : config.isSecondaryRollback) ?? false;
    if (this.state === `completed`) {
      throw new TransactionAlreadyCompletedRollbackError();
    }
    this.setState(`failed`);
    if (!isSecondaryRollback) {
      const mutationIds = /* @__PURE__ */ new Set();
      this.mutations.forEach((m) => mutationIds.add(m.globalKey));
      for (const t of transactions) {
        t.state === `pending` && t.mutations.some((m) => mutationIds.has(m.globalKey)) && t.rollback({ isSecondaryRollback: true });
      }
    }
    this.isPersisted.reject((_a = this.error) == null ? void 0 : _a.error);
    this.touchCollection();
    return this;
  }
  // Tell collection that something has changed with the transaction
  touchCollection() {
    const hasCalled = /* @__PURE__ */ new Set();
    for (const mutation of this.mutations) {
      if (!hasCalled.has(mutation.collection.id)) {
        mutation.collection._state.onTransactionStateChange();
        if (mutation.collection._state.pendingSyncedTransactions.length > 0) {
          mutation.collection._state.commitPendingTransactions();
        }
        hasCalled.add(mutation.collection.id);
      }
    }
  }
  /**
   * Commit the transaction and execute the mutation function
   * @returns Promise that resolves to this transaction when complete
   * @example
   * // Manual commit (when autoCommit is false)
   * const tx = createTransaction({
   *   autoCommit: false,
   *   mutationFn: async ({ transaction }) => {
   *     await api.saveChanges(transaction.mutations)
   *   }
   * })
   *
   * tx.mutate(() => {
   *   collection.insert({ id: "1", text: "Buy milk" })
   * })
   *
   * await tx.commit() // Manually commit
   *
   * @example
   * // Handle commit errors
   * try {
   *   const tx = createTransaction({
   *     mutationFn: async () => { throw new Error("API failed") }
   *   })
   *
   *   tx.mutate(() => {
   *     collection.insert({ id: "1", text: "Item" })
   *   })
   *
   *   await tx.commit()
   * } catch (error) {
   *   console.log('Commit failed, transaction rolled back:', error)
   * }
   *
   * @example
   * // Check transaction state after commit
   * await tx.commit()
   * console.log(tx.state) // "completed" or "failed"
   */
  async commit() {
    if (this.state !== `pending`) {
      throw new TransactionNotPendingCommitError();
    }
    this.setState(`persisting`);
    if (this.mutations.length === 0) {
      this.setState(`completed`);
      this.isPersisted.resolve(this);
      return this;
    }
    try {
      await this.mutationFn({
        transaction: this
      });
      this.setState(`completed`);
      this.touchCollection();
      this.isPersisted.resolve(this);
    } catch (error) {
      const originalError = error instanceof Error ? error : new Error(String(error));
      this.error = {
        message: originalError.message,
        error: originalError
      };
      this.rollback();
      throw originalError;
    }
    return this;
  }
  /**
   * Compare two transactions by their createdAt time and sequence number in order
   * to sort them in the order they were created.
   * @param other - The other transaction to compare to
   * @returns -1 if this transaction was created before the other, 1 if it was created after, 0 if they were created at the same time
   */
  compareCreatedAt(other) {
    const createdAtComparison = this.createdAt.getTime() - other.createdAt.getTime();
    if (createdAtComparison !== 0) {
      return createdAtComparison;
    }
    return this.sequenceNumber - other.sequenceNumber;
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/indexes/reverse-index.js
var ReverseIndex = class {
  constructor(index) {
    this.originalIndex = index;
  }
  // Define the reversed operations
  lookup(operation, value) {
    const reverseOperation = operation === `gt` ? `lt` : operation === `gte` ? `lte` : operation === `lt` ? `gt` : operation === `lte` ? `gte` : operation;
    return this.originalIndex.lookup(reverseOperation, value);
  }
  rangeQuery(options = {}) {
    return this.originalIndex.rangeQueryReversed(options);
  }
  rangeQueryReversed(options = {}) {
    return this.originalIndex.rangeQuery(options);
  }
  take(n, from, filterFn) {
    return this.originalIndex.takeReversed(n, from, filterFn);
  }
  takeReversed(n, from, filterFn) {
    return this.originalIndex.take(n, from, filterFn);
  }
  get orderedEntriesArray() {
    return this.originalIndex.orderedEntriesArrayReversed;
  }
  get orderedEntriesArrayReversed() {
    return this.originalIndex.orderedEntriesArray;
  }
  // All operations below delegate to the original index
  supports(operation) {
    return this.originalIndex.supports(operation);
  }
  matchesField(fieldPath) {
    return this.originalIndex.matchesField(fieldPath);
  }
  matchesCompareOptions(compareOptions) {
    return this.originalIndex.matchesCompareOptions(compareOptions);
  }
  matchesDirection(direction) {
    return this.originalIndex.matchesDirection(direction);
  }
  getStats() {
    return this.originalIndex.getStats();
  }
  add(key, item) {
    this.originalIndex.add(key, item);
  }
  remove(key, item) {
    this.originalIndex.remove(key, item);
  }
  update(key, oldItem, newItem) {
    this.originalIndex.update(key, oldItem, newItem);
  }
  build(entries) {
    this.originalIndex.build(entries);
  }
  clear() {
    this.originalIndex.clear();
  }
  get keyCount() {
    return this.originalIndex.keyCount;
  }
  equalityLookup(value) {
    return this.originalIndex.equalityLookup(value);
  }
  inArrayLookup(values) {
    return this.originalIndex.inArrayLookup(values);
  }
  get indexedKeysSet() {
    return this.originalIndex.indexedKeysSet;
  }
  get valueMapData() {
    return this.originalIndex.valueMapData;
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/utils/index-optimization.js
function findIndexForField(collection, fieldPath, compareOptions) {
  const compareOpts = compareOptions ?? {
    ...DEFAULT_COMPARE_OPTIONS,
    ...collection.compareOptions
  };
  for (const index of collection.indexes.values()) {
    if (index.matchesField(fieldPath) && index.matchesCompareOptions(compareOpts)) {
      if (!index.matchesDirection(compareOpts.direction)) {
        return new ReverseIndex(index);
      }
      return index;
    }
  }
  return void 0;
}
function intersectSets(sets) {
  if (sets.length === 0) return /* @__PURE__ */ new Set();
  if (sets.length === 1) return new Set(sets[0]);
  let result = new Set(sets[0]);
  for (let i = 1; i < sets.length; i++) {
    const newResult = /* @__PURE__ */ new Set();
    for (const item of result) {
      if (sets[i].has(item)) {
        newResult.add(item);
      }
    }
    result = newResult;
  }
  return result;
}
function unionSets(sets) {
  const result = /* @__PURE__ */ new Set();
  for (const set of sets) {
    for (const item of set) {
      result.add(item);
    }
  }
  return result;
}
function optimizeExpressionWithIndexes(expression, collection) {
  return optimizeQueryRecursive(expression, collection);
}
function optimizeQueryRecursive(expression, collection) {
  if (expression.type === `func`) {
    switch (expression.name) {
      case `eq`:
      case `gt`:
      case `gte`:
      case `lt`:
      case `lte`:
        return optimizeSimpleComparison(expression, collection);
      case `and`:
        return optimizeAndExpression(expression, collection);
      case `or`:
        return optimizeOrExpression(expression, collection);
      case `in`:
        return optimizeInArrayExpression(expression, collection);
    }
  }
  return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
}
function optimizeCompoundRangeQuery(expression, collection) {
  if (expression.type !== `func` || expression.args.length < 2) {
    return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
  }
  const fieldOperations = /* @__PURE__ */ new Map();
  for (const arg of expression.args) {
    if (arg.type === `func` && [`gt`, `gte`, `lt`, `lte`].includes(arg.name)) {
      const rangeOp = arg;
      if (rangeOp.args.length === 2) {
        const leftArg = rangeOp.args[0];
        const rightArg = rangeOp.args[1];
        let fieldArg = null;
        let valueArg = null;
        let operation = rangeOp.name;
        if (leftArg.type === `ref` && rightArg.type === `val`) {
          fieldArg = leftArg;
          valueArg = rightArg;
        } else if (leftArg.type === `val` && rightArg.type === `ref`) {
          fieldArg = rightArg;
          valueArg = leftArg;
          switch (operation) {
            case `gt`:
              operation = `lt`;
              break;
            case `gte`:
              operation = `lte`;
              break;
            case `lt`:
              operation = `gt`;
              break;
            case `lte`:
              operation = `gte`;
              break;
          }
        }
        if (fieldArg && valueArg) {
          const fieldPath = fieldArg.path;
          const fieldKey = fieldPath.join(`.`);
          const value = valueArg.value;
          if (!fieldOperations.has(fieldKey)) {
            fieldOperations.set(fieldKey, []);
          }
          fieldOperations.get(fieldKey).push({ operation, value });
        }
      }
    }
  }
  for (const [fieldKey, operations] of fieldOperations) {
    if (operations.length >= 2) {
      const fieldPath = fieldKey.split(`.`);
      const index = findIndexForField(collection, fieldPath);
      if (index && index.supports(`gt`) && index.supports(`lt`)) {
        let from = void 0;
        let to = void 0;
        let fromInclusive = true;
        let toInclusive = true;
        for (const { operation, value } of operations) {
          switch (operation) {
            case `gt`:
              if (from === void 0 || value > from) {
                from = value;
                fromInclusive = false;
              }
              break;
            case `gte`:
              if (from === void 0 || value > from) {
                from = value;
                fromInclusive = true;
              }
              break;
            case `lt`:
              if (to === void 0 || value < to) {
                to = value;
                toInclusive = false;
              }
              break;
            case `lte`:
              if (to === void 0 || value < to) {
                to = value;
                toInclusive = true;
              }
              break;
          }
        }
        const matchingKeys = index.rangeQuery({
          from,
          to,
          fromInclusive,
          toInclusive
        });
        return { canOptimize: true, matchingKeys };
      }
    }
  }
  return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
}
function optimizeSimpleComparison(expression, collection) {
  if (expression.type !== `func` || expression.args.length !== 2) {
    return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
  }
  const leftArg = expression.args[0];
  const rightArg = expression.args[1];
  let fieldArg = null;
  let valueArg = null;
  let operation = expression.name;
  if (leftArg.type === `ref` && rightArg.type === `val`) {
    fieldArg = leftArg;
    valueArg = rightArg;
  } else if (leftArg.type === `val` && rightArg.type === `ref`) {
    fieldArg = rightArg;
    valueArg = leftArg;
    switch (operation) {
      case `gt`:
        operation = `lt`;
        break;
      case `gte`:
        operation = `lte`;
        break;
      case `lt`:
        operation = `gt`;
        break;
      case `lte`:
        operation = `gte`;
        break;
    }
  }
  if (fieldArg && valueArg) {
    const fieldPath = fieldArg.path;
    const index = findIndexForField(collection, fieldPath);
    if (index) {
      const queryValue = valueArg.value;
      const indexOperation = operation;
      if (!index.supports(indexOperation)) {
        return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
      }
      const matchingKeys = index.lookup(indexOperation, queryValue);
      return { canOptimize: true, matchingKeys };
    }
  }
  return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
}
function optimizeAndExpression(expression, collection) {
  if (expression.type !== `func` || expression.args.length < 2) {
    return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
  }
  const compoundRangeResult = optimizeCompoundRangeQuery(expression, collection);
  if (compoundRangeResult.canOptimize) {
    return compoundRangeResult;
  }
  const results = [];
  for (const arg of expression.args) {
    const result = optimizeQueryRecursive(arg, collection);
    if (result.canOptimize) {
      results.push(result);
    }
  }
  if (results.length > 0) {
    const allMatchingSets = results.map((r) => r.matchingKeys);
    const intersectedKeys = intersectSets(allMatchingSets);
    return { canOptimize: true, matchingKeys: intersectedKeys };
  }
  return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
}
function optimizeOrExpression(expression, collection) {
  if (expression.type !== `func` || expression.args.length < 2) {
    return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
  }
  const results = [];
  for (const arg of expression.args) {
    const result = optimizeQueryRecursive(arg, collection);
    if (result.canOptimize) {
      results.push(result);
    }
  }
  if (results.length > 0) {
    const allMatchingSets = results.map((r) => r.matchingKeys);
    const unionedKeys = unionSets(allMatchingSets);
    return { canOptimize: true, matchingKeys: unionedKeys };
  }
  return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
}
function optimizeInArrayExpression(expression, collection) {
  if (expression.type !== `func` || expression.args.length !== 2) {
    return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
  }
  const fieldArg = expression.args[0];
  const arrayArg = expression.args[1];
  if (fieldArg.type === `ref` && arrayArg.type === `val` && Array.isArray(arrayArg.value)) {
    const fieldPath = fieldArg.path;
    const values = arrayArg.value;
    const index = findIndexForField(collection, fieldPath);
    if (index) {
      if (index.supports(`in`)) {
        const matchingKeys = index.lookup(`in`, values);
        return { canOptimize: true, matchingKeys };
      } else if (index.supports(`eq`)) {
        const matchingKeys = /* @__PURE__ */ new Set();
        for (const value of values) {
          const keysForValue = index.lookup(`eq`, value);
          for (const key of keysForValue) {
            matchingKeys.add(key);
          }
        }
        return { canOptimize: true, matchingKeys };
      }
    }
  }
  return { canOptimize: false, matchingKeys: /* @__PURE__ */ new Set() };
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/indexes/auto-index.js
function shouldAutoIndex(collection) {
  if (collection.config.autoIndex !== `eager`) {
    return false;
  }
  return true;
}
function ensureIndexForField(fieldName, fieldPath, collection, compareOptions, compareFn) {
  if (!shouldAutoIndex(collection)) {
    return;
  }
  const compareOpts = compareOptions ?? {
    ...DEFAULT_COMPARE_OPTIONS,
    ...collection.compareOptions
  };
  const existingIndex = Array.from(collection.indexes.values()).find(
    (index) => index.matchesField(fieldPath) && index.matchesCompareOptions(compareOpts)
  );
  if (existingIndex) {
    return;
  }
  try {
    collection.createIndex(
      (row) => {
        let current = row;
        for (const part of fieldPath) {
          current = current[part];
        }
        return current;
      },
      {
        name: `auto:${fieldPath.join(`.`)}`,
        indexType: BTreeIndex,
        options: compareFn ? { compareFn, compareOptions: compareOpts } : {}
      }
    );
  } catch (error) {
    console.warn(
      `${collection.id ? `[${collection.id}] ` : ``}Failed to create auto-index for field path "${fieldPath.join(`.`)}":`,
      error
    );
  }
}
function ensureIndexForExpression(expression, collection) {
  if (!shouldAutoIndex(collection)) {
    return;
  }
  const indexableExpressions = extractIndexableExpressions(expression);
  for (const { fieldName, fieldPath } of indexableExpressions) {
    ensureIndexForField(fieldName, fieldPath, collection);
  }
}
function extractIndexableExpressions(expression) {
  const results = [];
  function extractFromExpression(expr) {
    if (expr.type !== `func`) {
      return;
    }
    const func = expr;
    if (func.name === `and`) {
      for (const arg of func.args) {
        extractFromExpression(arg);
      }
      return;
    }
    const supportedOperations = [`eq`, `gt`, `gte`, `lt`, `lte`, `in`];
    if (!supportedOperations.includes(func.name)) {
      return;
    }
    if (func.args.length < 1 || func.args[0].type !== `ref`) {
      return;
    }
    const fieldRef = func.args[0];
    const fieldPath = fieldRef.path;
    if (fieldPath.length === 0) {
      return;
    }
    const fieldName = fieldPath.join(`_`);
    results.push({ fieldName, fieldPath });
  }
  extractFromExpression(expression);
  return results;
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/utils.js
var DefaultMap = class extends Map {
  constructor(defaultValue, entries) {
    super(entries);
    this.defaultValue = defaultValue;
  }
  get(key) {
    if (!this.has(key)) {
      return this.defaultValue();
    }
    return super.get(key);
  }
  /**
   * Update the value for a key using a function.
   */
  update(key, updater) {
    const value = this.get(key);
    const newValue = updater(value);
    this.set(key, newValue);
    return newValue;
  }
};
var chunkSize = 3e4;
function chunkedArrayPush(array, other) {
  if (other.length <= chunkSize) {
    array.push(...other);
  } else {
    for (let i = 0; i < other.length; i += chunkSize) {
      const chunk = other.slice(i, i + chunkSize);
      array.push(...chunk);
    }
  }
}
function binarySearch(array, value, comparator) {
  let low = 0;
  let high = array.length;
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    const comparison = comparator(array[mid], value);
    if (comparison < 0) {
      low = mid + 1;
    } else if (comparison > 0) {
      high = mid;
    } else {
      return mid;
    }
  }
  return low;
}
var ObjectIdGenerator = class {
  constructor() {
    this.objectIds = /* @__PURE__ */ new WeakMap();
    this.nextId = 0;
  }
  /**
   * Get a unique identifier for any value.
   * - Objects: Uses WeakMap for reference-based identity
   * - Primitives: Uses consistent string-based hashing
   */
  getId(value) {
    if (typeof value !== `object` || value === null) {
      const str = String(value);
      let hashValue = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hashValue = (hashValue << 5) - hashValue + char;
        hashValue = hashValue & hashValue;
      }
      return hashValue;
    }
    if (!this.objectIds.has(value)) {
      this.objectIds.set(value, this.nextId++);
    }
    return this.objectIds.get(value);
  }
  /**
   * Get a string representation of the ID for use in composite keys.
   */
  getStringId(value) {
    if (value === null) return `null`;
    if (value === void 0) return `undefined`;
    if (typeof value !== `object`) return `str_${String(value)}`;
    return `obj_${this.getId(value)}`;
  }
};
var globalObjectIdGenerator = new ObjectIdGenerator();
function diffHalfOpen(a, b) {
  const [a1, a2] = a;
  const [b1, b2] = b;
  const onlyInA = [
    ...range(a1, Math.min(a2, b1)),
    // left side of A outside B
    ...range(Math.max(a1, b2), a2)
    // right side of A outside B
  ];
  const onlyInB = [
    ...range(b1, Math.min(b2, a1)),
    ...range(Math.max(b1, a2), b2)
  ];
  return { onlyInA, onlyInB };
}
function range(start, end) {
  const out = [];
  for (let i = start; i < end; i++) out.push(i);
  return out;
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/hashing/murmur.js
var RANDOM_SEED = randomHash();
var STRING_MARKER = randomHash();
var BIG_INT_MARKER = randomHash();
var NEG_BIG_INT_MARKER = randomHash();
var SYMBOL_MARKER = randomHash();
function randomHash() {
  return Math.random() * (2 ** 31 - 1) >>> 0;
}
var buf = new ArrayBuffer(8);
var dv = new DataView(buf);
var u8 = new Uint8Array(buf);
var MurmurHashStream = class {
  constructor() {
    this.hash = RANDOM_SEED;
    this.length = 0;
    this.carry = 0;
    this.carryBytes = 0;
  }
  _mix(k1) {
    k1 = Math.imul(k1, 3432918353);
    k1 = k1 << 15 | k1 >>> 17;
    k1 = Math.imul(k1, 461845907);
    this.hash ^= k1;
    this.hash = this.hash << 13 | this.hash >>> 19;
    this.hash = Math.imul(this.hash, 5) + 3864292196;
  }
  writeByte(byte) {
    this.carry |= (byte & 255) << 8 * this.carryBytes;
    this.carryBytes++;
    this.length++;
    if (this.carryBytes === 4) {
      this._mix(this.carry >>> 0);
      this.carry = 0;
      this.carryBytes = 0;
    }
  }
  update(chunk) {
    switch (typeof chunk) {
      case `symbol`: {
        this.update(SYMBOL_MARKER);
        const description = chunk.description;
        if (!description) {
          return;
        }
        for (let i = 0; i < description.length; i++) {
          const code = description.charCodeAt(i);
          this.writeByte(code & 255);
          this.writeByte(code >>> 8 & 255);
        }
        return;
      }
      case `string`:
        this.update(STRING_MARKER);
        for (let i = 0; i < chunk.length; i++) {
          const code = chunk.charCodeAt(i);
          this.writeByte(code & 255);
          this.writeByte(code >>> 8 & 255);
        }
        return;
      case `number`:
        dv.setFloat64(0, chunk, true);
        this.writeByte(u8[0]);
        this.writeByte(u8[1]);
        this.writeByte(u8[2]);
        this.writeByte(u8[3]);
        this.writeByte(u8[4]);
        this.writeByte(u8[5]);
        this.writeByte(u8[6]);
        this.writeByte(u8[7]);
        return;
      case `bigint`: {
        let value = chunk;
        if (value < 0n) {
          value = -value;
          this.update(NEG_BIG_INT_MARKER);
        } else {
          this.update(BIG_INT_MARKER);
        }
        while (value > 0n) {
          this.writeByte(Number(value & 0xffn));
          value >>= 8n;
        }
        if (chunk === 0n) this.writeByte(0);
        return;
      }
      default:
        throw new TypeError(`Unsupported input type: ${typeof chunk}`);
    }
  }
  digest() {
    if (this.carryBytes > 0) {
      let k1 = this.carry >>> 0;
      k1 = Math.imul(k1, 3432918353);
      k1 = k1 << 15 | k1 >>> 17;
      k1 = Math.imul(k1, 461845907);
      this.hash ^= k1;
    }
    this.hash ^= this.length;
    this.hash ^= this.hash >>> 16;
    this.hash = Math.imul(this.hash, 2246822507);
    this.hash ^= this.hash >>> 13;
    this.hash = Math.imul(this.hash, 3266489909);
    this.hash ^= this.hash >>> 16;
    return this.hash >>> 0;
  }
};

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/hashing/hash.js
var TRUE = randomHash();
var FALSE = randomHash();
var NULL = randomHash();
var UNDEFINED = randomHash();
var KEY = randomHash();
var FUNCTIONS = randomHash();
var DATE_MARKER = randomHash();
var OBJECT_MARKER = randomHash();
var ARRAY_MARKER = randomHash();
var MAP_MARKER = randomHash();
var SET_MARKER = randomHash();
var UINT8ARRAY_MARKER = randomHash();
var UINT8ARRAY_CONTENT_HASH_THRESHOLD = 128;
var hashCache = /* @__PURE__ */ new WeakMap();
function hash(input) {
  const hasher = new MurmurHashStream();
  updateHasher(hasher, input);
  return hasher.digest();
}
function hashObject(input) {
  const cachedHash = hashCache.get(input);
  if (cachedHash !== void 0) {
    return cachedHash;
  }
  let valueHash;
  if (input instanceof Date) {
    valueHash = hashDate(input);
  } else if (
    // Check if input is a Uint8Array or Buffer
    typeof Buffer !== `undefined` && input instanceof Buffer || input instanceof Uint8Array
  ) {
    if (input.byteLength <= UINT8ARRAY_CONTENT_HASH_THRESHOLD) {
      valueHash = hashUint8Array(input);
    } else {
      return cachedReferenceHash(input);
    }
  } else if (input instanceof File) {
    return cachedReferenceHash(input);
  } else {
    let plainObjectInput = input;
    let marker = OBJECT_MARKER;
    if (input instanceof Array) {
      marker = ARRAY_MARKER;
    }
    if (input instanceof Map) {
      marker = MAP_MARKER;
      plainObjectInput = [...input.entries()];
    }
    if (input instanceof Set) {
      marker = SET_MARKER;
      plainObjectInput = [...input.entries()];
    }
    valueHash = hashPlainObject(plainObjectInput, marker);
  }
  hashCache.set(input, valueHash);
  return valueHash;
}
function hashDate(input) {
  const hasher = new MurmurHashStream();
  hasher.update(DATE_MARKER);
  hasher.update(input.getTime());
  return hasher.digest();
}
function hashUint8Array(input) {
  const hasher = new MurmurHashStream();
  hasher.update(UINT8ARRAY_MARKER);
  hasher.update(input.byteLength);
  for (let i = 0; i < input.byteLength; i++) {
    hasher.writeByte(input[i]);
  }
  return hasher.digest();
}
function hashPlainObject(input, marker) {
  const hasher = new MurmurHashStream();
  hasher.update(marker);
  const keys = Object.keys(input);
  keys.sort(keySort);
  for (const key of keys) {
    hasher.update(KEY);
    hasher.update(key);
    updateHasher(hasher, input[key]);
  }
  return hasher.digest();
}
function updateHasher(hasher, input) {
  if (input === null) {
    hasher.update(NULL);
    return;
  }
  switch (typeof input) {
    case `undefined`:
      hasher.update(UNDEFINED);
      return;
    case `boolean`:
      hasher.update(input ? TRUE : FALSE);
      return;
    case `number`:
      hasher.update(isNaN(input) ? NaN : input === 0 ? 0 : input);
      return;
    case `bigint`:
    case `string`:
    case `symbol`:
      hasher.update(input);
      return;
    case `object`:
      hasher.update(getCachedHash(input));
      return;
    case `function`:
      hasher.update(cachedReferenceHash(input));
      return;
    default:
      console.warn(
        `Ignored input during hashing because it is of type ${typeof input} which is not supported`
      );
  }
}
function getCachedHash(input) {
  let valueHash = hashCache.get(input);
  if (valueHash === void 0) {
    valueHash = hashObject(input);
  }
  return valueHash;
}
var nextRefId = 1;
function cachedReferenceHash(fn) {
  let valueHash = hashCache.get(fn);
  if (valueHash === void 0) {
    valueHash = nextRefId ^ FUNCTIONS;
    nextRefId++;
    hashCache.set(fn, valueHash);
  }
  return valueHash;
}
function keySort(a, b) {
  return a.localeCompare(b);
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/multiset.js
var _inner, _MultiSet_instances, consolidateKeyed_fn, consolidateUnkeyed_fn;
var _MultiSet = class _MultiSet {
  constructor(data = []) {
    __privateAdd(this, _MultiSet_instances);
    __privateAdd(this, _inner);
    __privateSet(this, _inner, data);
  }
  toString(indent = false) {
    return `MultiSet(${JSON.stringify(__privateGet(this, _inner), null, indent ? 2 : void 0)})`;
  }
  toJSON() {
    return JSON.stringify(Array.from(this.getInner()));
  }
  static fromJSON(json) {
    return new _MultiSet(JSON.parse(json));
  }
  /**
   * Apply a function to all records in the collection.
   */
  map(f) {
    return new _MultiSet(
      __privateGet(this, _inner).map(([data, multiplicity]) => [f(data), multiplicity])
    );
  }
  /**
   * Filter out records for which a function f(record) evaluates to False.
   */
  filter(f) {
    return new _MultiSet(__privateGet(this, _inner).filter(([data, _]) => f(data)));
  }
  /**
   * Negate all multiplicities in the collection.
   */
  negate() {
    return new _MultiSet(
      __privateGet(this, _inner).map(([data, multiplicity]) => [data, -multiplicity])
    );
  }
  /**
   * Concatenate two collections together.
   */
  concat(other) {
    const out = [];
    chunkedArrayPush(out, __privateGet(this, _inner));
    chunkedArrayPush(out, other.getInner());
    return new _MultiSet(out);
  }
  /**
   * Produce as output a collection that is logically equivalent to the input
   * but which combines identical instances of the same record into one
   * (record, multiplicity) pair.
   */
  consolidate() {
    var _a;
    if (__privateGet(this, _inner).length > 0) {
      const firstItem = (_a = __privateGet(this, _inner)[0]) == null ? void 0 : _a[0];
      if (Array.isArray(firstItem) && firstItem.length === 2) {
        return __privateMethod(this, _MultiSet_instances, consolidateKeyed_fn).call(this);
      }
    }
    return __privateMethod(this, _MultiSet_instances, consolidateUnkeyed_fn).call(this);
  }
  extend(other) {
    const otherArray = other instanceof _MultiSet ? other.getInner() : other;
    chunkedArrayPush(__privateGet(this, _inner), otherArray);
  }
  add(item, multiplicity) {
    if (multiplicity !== 0) {
      __privateGet(this, _inner).push([item, multiplicity]);
    }
  }
  getInner() {
    return __privateGet(this, _inner);
  }
};
_inner = new WeakMap();
_MultiSet_instances = new WeakSet();
/**
 * Private method for consolidating keyed multisets where keys are strings/numbers
 * and values are compared by reference equality.
 *
 * This method provides significant performance improvements over the hash-based approach
 * by using WeakMap for object reference tracking and avoiding expensive serialization.
 *
 * Special handling for join operations: When values are tuples of length 2 (common in joins),
 * we unpack them and compare each element individually to maintain proper equality semantics.
 */
consolidateKeyed_fn = function() {
  const consolidated = /* @__PURE__ */ new Map();
  const values = /* @__PURE__ */ new Map();
  const getTupleId = (tuple) => {
    if (tuple.length !== 2) {
      throw new Error(`Expected tuple of length 2`);
    }
    const [first, second] = tuple;
    return `${globalObjectIdGenerator.getStringId(first)}|${globalObjectIdGenerator.getStringId(second)}`;
  };
  for (const [data, multiplicity] of __privateGet(this, _inner)) {
    if (!Array.isArray(data) || data.length !== 2) {
      return __privateMethod(this, _MultiSet_instances, consolidateUnkeyed_fn).call(this);
    }
    const [key, value] = data;
    if (typeof key !== `string` && typeof key !== `number`) {
      return __privateMethod(this, _MultiSet_instances, consolidateUnkeyed_fn).call(this);
    }
    let valueId;
    if (Array.isArray(value) && value.length === 2) {
      valueId = getTupleId(value);
    } else {
      valueId = globalObjectIdGenerator.getStringId(value);
    }
    const compositeKey = key + `|` + valueId;
    consolidated.set(
      compositeKey,
      (consolidated.get(compositeKey) || 0) + multiplicity
    );
    if (!values.has(compositeKey)) {
      values.set(compositeKey, data);
    }
  }
  const result = [];
  for (const [compositeKey, multiplicity] of consolidated) {
    if (multiplicity !== 0) {
      result.push([values.get(compositeKey), multiplicity]);
    }
  }
  return new _MultiSet(result);
};
/**
 * Private method for consolidating unkeyed multisets using the original approach.
 */
consolidateUnkeyed_fn = function() {
  const consolidated = new DefaultMap(() => 0);
  const values = /* @__PURE__ */ new Map();
  let hasString = false;
  let hasNumber = false;
  let hasOther = false;
  for (const [data, _] of __privateGet(this, _inner)) {
    if (typeof data === `string`) {
      hasString = true;
    } else if (typeof data === `number`) {
      hasNumber = true;
    } else {
      hasOther = true;
      break;
    }
  }
  const requireJson = hasOther || hasString && hasNumber;
  for (const [data, multiplicity] of __privateGet(this, _inner)) {
    const key = requireJson ? hash(data) : data;
    if (requireJson && !values.has(key)) {
      values.set(key, data);
    }
    consolidated.update(key, (count6) => count6 + multiplicity);
  }
  const result = [];
  for (const [key, multiplicity] of consolidated.entries()) {
    if (multiplicity !== 0) {
      const parsedKey = requireJson ? values.get(key) : key;
      result.push([parsedKey, multiplicity]);
    }
  }
  return new _MultiSet(result);
};
var MultiSet = _MultiSet;

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/graph.js
var _queue;
var DifferenceStreamReader = class {
  constructor(queue) {
    __privateAdd(this, _queue);
    __privateSet(this, _queue, queue);
  }
  drain() {
    const out = [...__privateGet(this, _queue)].reverse();
    __privateGet(this, _queue).length = 0;
    return out;
  }
  isEmpty() {
    return __privateGet(this, _queue).length === 0;
  }
};
_queue = new WeakMap();
var _queues;
var DifferenceStreamWriter = class {
  constructor() {
    __privateAdd(this, _queues, []);
  }
  sendData(collection) {
    if (!(collection instanceof MultiSet)) {
      collection = new MultiSet(collection);
    }
    for (const q of __privateGet(this, _queues)) {
      q.unshift(collection);
    }
  }
  newReader() {
    const q = [];
    __privateGet(this, _queues).push(q);
    return new DifferenceStreamReader(q);
  }
};
_queues = new WeakMap();
var Operator = class {
  constructor(id, inputs, output2) {
    this.id = id;
    this.inputs = inputs;
    this.output = output2;
  }
  hasPendingWork() {
    return this.inputs.some((input) => !input.isEmpty());
  }
};
var UnaryOperator = class extends Operator {
  constructor(id, inputA, output2) {
    super(id, [inputA], output2);
    this.id = id;
  }
  inputMessages() {
    return this.inputs[0].drain();
  }
};
var BinaryOperator = class extends Operator {
  constructor(id, inputA, inputB, output2) {
    super(id, [inputA, inputB], output2);
    this.id = id;
  }
  inputAMessages() {
    return this.inputs[0].drain();
  }
  inputBMessages() {
    return this.inputs[1].drain();
  }
};
var LinearUnaryOperator = class extends UnaryOperator {
  run() {
    for (const message of this.inputMessages()) {
      this.output.sendData(this.inner(message));
    }
  }
};

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/d2.js
var _operators, _nextOperatorId, _finalized, _D2_instances, checkNotFinalized_fn;
var D2 = class {
  constructor() {
    __privateAdd(this, _D2_instances);
    __privateAdd(this, _operators, []);
    __privateAdd(this, _nextOperatorId, 0);
    __privateAdd(this, _finalized, false);
  }
  getNextOperatorId() {
    __privateMethod(this, _D2_instances, checkNotFinalized_fn).call(this);
    return __privateWrapper(this, _nextOperatorId)._++;
  }
  newInput() {
    __privateMethod(this, _D2_instances, checkNotFinalized_fn).call(this);
    const writer = new DifferenceStreamWriter();
    const streamBuilder = new RootStreamBuilder(this, writer);
    return streamBuilder;
  }
  addOperator(operator) {
    __privateMethod(this, _D2_instances, checkNotFinalized_fn).call(this);
    __privateGet(this, _operators).push(operator);
  }
  finalize() {
    __privateMethod(this, _D2_instances, checkNotFinalized_fn).call(this);
    __privateSet(this, _finalized, true);
  }
  step() {
    if (!__privateGet(this, _finalized)) {
      throw new Error(`Graph not finalized`);
    }
    for (const op of __privateGet(this, _operators)) {
      op.run();
    }
  }
  pendingWork() {
    return __privateGet(this, _operators).some((op) => op.hasPendingWork());
  }
  run() {
    while (this.pendingWork()) {
      this.step();
    }
  }
};
_operators = new WeakMap();
_nextOperatorId = new WeakMap();
_finalized = new WeakMap();
_D2_instances = new WeakSet();
checkNotFinalized_fn = function() {
  if (__privateGet(this, _finalized)) {
    throw new Error(`Graph already finalized`);
  }
};
var _graph, _writer;
var StreamBuilder = class {
  constructor(graph, writer) {
    __privateAdd(this, _graph);
    __privateAdd(this, _writer);
    __privateSet(this, _graph, graph);
    __privateSet(this, _writer, writer);
  }
  connectReader() {
    return __privateGet(this, _writer).newReader();
  }
  get writer() {
    return __privateGet(this, _writer);
  }
  get graph() {
    return __privateGet(this, _graph);
  }
  pipe(...operators2) {
    return operators2.reduce((stream, operator) => {
      return operator(stream);
    }, this);
  }
};
_graph = new WeakMap();
_writer = new WeakMap();
var RootStreamBuilder = class extends StreamBuilder {
  sendData(collection) {
    this.writer.sendData(collection);
  }
};

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/map.js
var _f;
var MapOperator = class extends LinearUnaryOperator {
  constructor(id, inputA, output2, f) {
    super(id, inputA, output2);
    __privateAdd(this, _f);
    __privateSet(this, _f, f);
  }
  inner(collection) {
    return collection.map(__privateGet(this, _f));
  }
};
_f = new WeakMap();
function map(f) {
  return (stream) => {
    const output2 = new StreamBuilder(
      stream.graph,
      new DifferenceStreamWriter()
    );
    const operator = new MapOperator(
      stream.graph.getNextOperatorId(),
      stream.connectReader(),
      output2.writer,
      f
    );
    stream.graph.addOperator(operator);
    return output2;
  };
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/indexes.js
var NO_PREFIX = Symbol(`NO_PREFIX`);
var PrefixMap = class extends Map {
  /**
   * Add a value to the PrefixMap. Returns true if the map becomes empty after the operation.
   */
  addValue(value, multiplicity) {
    if (multiplicity === 0) return this.size === 0;
    const prefix = getPrefix(value);
    const valueMapOrSingleValue = this.get(prefix);
    if (isSingleValue(valueMapOrSingleValue)) {
      const [currentValue, currentMultiplicity] = valueMapOrSingleValue;
      const currentPrefix = getPrefix(currentValue);
      if (currentPrefix !== prefix) {
        throw new Error(`Mismatching prefixes, this should never happen`);
      }
      if (currentValue === value || hash(currentValue) === hash(value)) {
        const newMultiplicity = currentMultiplicity + multiplicity;
        if (newMultiplicity === 0) {
          this.delete(prefix);
        } else {
          this.set(prefix, [value, newMultiplicity]);
        }
      } else {
        const valueMap = new ValueMap();
        valueMap.set(hash(currentValue), valueMapOrSingleValue);
        valueMap.set(hash(value), [value, multiplicity]);
        this.set(prefix, valueMap);
      }
    } else if (valueMapOrSingleValue === void 0) {
      this.set(prefix, [value, multiplicity]);
    } else {
      const isEmpty = valueMapOrSingleValue.addValue(value, multiplicity);
      if (isEmpty) {
        this.delete(prefix);
      }
    }
    return this.size === 0;
  }
};
var ValueMap = class extends Map {
  /**
   * Add a value to the ValueMap. Returns true if the map becomes empty after the operation.
   * @param value - The full value to store
   * @param multiplicity - The multiplicity to add
   * @param hashKey - Optional hash key to use instead of hashing the full value (used when in PrefixMap context)
   */
  addValue(value, multiplicity) {
    if (multiplicity === 0) return this.size === 0;
    const key = hash(value);
    const currentValue = this.get(key);
    if (currentValue) {
      const [, currentMultiplicity] = currentValue;
      const newMultiplicity = currentMultiplicity + multiplicity;
      if (newMultiplicity === 0) {
        this.delete(key);
      } else {
        this.set(key, [value, newMultiplicity]);
      }
    } else {
      this.set(key, [value, multiplicity]);
    }
    return this.size === 0;
  }
};
var _inner2, _consolidatedMultiplicity, _Index_instances, handleSingleValueTransition_fn;
var _Index = class _Index {
  // sum of multiplicities per key
  constructor() {
    __privateAdd(this, _Index_instances);
    /*
     * This index maintains a nested map of keys -> (value, multiplicities), where:
     * - initially the values are stored against the key as a single value tuple
     * - when a key gets additional values, the values are stored against the key in a
     *   prefix map
     * - the prefix is extract where possible from values that are structured as
     *   [rowPrimaryKey, rowValue], as they are in the Tanstack DB query pipeline.
     * - only when there are multiple values for a given prefix do we fall back to a
     *   hash to identify identical values, storing them in a third level value map.
     */
    __privateAdd(this, _inner2);
    __privateAdd(this, _consolidatedMultiplicity, /* @__PURE__ */ new Map());
    __privateSet(this, _inner2, /* @__PURE__ */ new Map());
  }
  /**
   * Create an Index from multiple MultiSet messages.
   * @param messages - Array of MultiSet messages to build the index from.
   * @returns A new Index containing all the data from the messages.
   */
  static fromMultiSets(messages) {
    const index = new _Index();
    for (const message of messages) {
      for (const [item, multiplicity] of message.getInner()) {
        const [key, value] = item;
        index.addValue(key, [value, multiplicity]);
      }
    }
    return index;
  }
  /**
   * This method returns a string representation of the index.
   * @param indent - Whether to indent the string representation.
   * @returns A string representation of the index.
   */
  toString(indent = false) {
    return `Index(${JSON.stringify(
      [...this.entries()],
      void 0,
      indent ? 2 : void 0
    )})`;
  }
  /**
   * The size of the index.
   */
  get size() {
    return __privateGet(this, _inner2).size;
  }
  /**
   * This method checks if the index has a given key.
   * @param key - The key to check.
   * @returns True if the index has the key, false otherwise.
   */
  has(key) {
    return __privateGet(this, _inner2).has(key);
  }
  /**
   * Check if a key has presence (non-zero consolidated multiplicity).
   * @param key - The key to check.
   * @returns True if the key has non-zero consolidated multiplicity, false otherwise.
   */
  hasPresence(key) {
    return (__privateGet(this, _consolidatedMultiplicity).get(key) || 0) !== 0;
  }
  /**
   * Get the consolidated multiplicity (sum of multiplicities) for a key.
   * @param key - The key to get the consolidated multiplicity for.
   * @returns The consolidated multiplicity for the key.
   */
  getConsolidatedMultiplicity(key) {
    return __privateGet(this, _consolidatedMultiplicity).get(key) || 0;
  }
  /**
   * Get all keys that have presence (non-zero consolidated multiplicity).
   * @returns An iterator of keys with non-zero consolidated multiplicity.
   */
  getPresenceKeys() {
    return __privateGet(this, _consolidatedMultiplicity).keys();
  }
  /**
   * This method returns all values for a given key.
   * @param key - The key to get the values for.
   * @returns An array of value tuples [value, multiplicity].
   */
  get(key) {
    return [...this.getIterator(key)];
  }
  /**
   * This method returns an iterator over all values for a given key.
   * @param key - The key to get the values for.
   * @returns An iterator of value tuples [value, multiplicity].
   */
  *getIterator(key) {
    const mapOrSingleValue = __privateGet(this, _inner2).get(key);
    if (isSingleValue(mapOrSingleValue)) {
      yield mapOrSingleValue;
    } else if (mapOrSingleValue === void 0) {
      return;
    } else if (mapOrSingleValue instanceof ValueMap) {
      for (const valueTuple of mapOrSingleValue.values()) {
        yield valueTuple;
      }
    } else {
      for (const singleValueOrValueMap of mapOrSingleValue.values()) {
        if (isSingleValue(singleValueOrValueMap)) {
          yield singleValueOrValueMap;
        } else {
          for (const valueTuple of singleValueOrValueMap.values()) {
            yield valueTuple;
          }
        }
      }
    }
  }
  /**
   * This returns an iterator that iterates over all key-value pairs.
   * @returns An iterable of all key-value pairs (and their multiplicities) in the index.
   */
  *entries() {
    for (const key of __privateGet(this, _inner2).keys()) {
      for (const valueTuple of this.getIterator(key)) {
        yield [key, valueTuple];
      }
    }
  }
  /**
   * This method only iterates over the keys and not over the values.
   * Hence, it is more efficient than the `#entries` method.
   * It returns an iterator that you can use if you need to iterate over the values for a given key.
   * @returns An iterator of all *keys* in the index and their corresponding value iterator.
   */
  *entriesIterators() {
    for (const key of __privateGet(this, _inner2).keys()) {
      yield [key, this.getIterator(key)];
    }
  }
  /**
   * This method adds a value to the index.
   * @param key - The key to add the value to.
   * @param valueTuple - The value tuple [value, multiplicity] to add to the index.
   */
  addValue(key, valueTuple) {
    const [value, multiplicity] = valueTuple;
    if (multiplicity === 0) return;
    const newConsolidatedMultiplicity = (__privateGet(this, _consolidatedMultiplicity).get(key) || 0) + multiplicity;
    if (newConsolidatedMultiplicity === 0) {
      __privateGet(this, _consolidatedMultiplicity).delete(key);
    } else {
      __privateGet(this, _consolidatedMultiplicity).set(key, newConsolidatedMultiplicity);
    }
    const mapOrSingleValue = __privateGet(this, _inner2).get(key);
    if (mapOrSingleValue === void 0) {
      __privateGet(this, _inner2).set(key, valueTuple);
      return;
    }
    if (isSingleValue(mapOrSingleValue)) {
      __privateMethod(this, _Index_instances, handleSingleValueTransition_fn).call(this, key, mapOrSingleValue, value, multiplicity);
      return;
    }
    if (mapOrSingleValue instanceof ValueMap) {
      const prefix = getPrefix(value);
      if (prefix !== NO_PREFIX) {
        const prefixMap = new PrefixMap();
        prefixMap.set(NO_PREFIX, mapOrSingleValue);
        prefixMap.set(prefix, valueTuple);
        __privateGet(this, _inner2).set(key, prefixMap);
      } else {
        const isEmpty = mapOrSingleValue.addValue(value, multiplicity);
        if (isEmpty) {
          __privateGet(this, _inner2).delete(key);
        }
      }
    } else {
      const isEmpty = mapOrSingleValue.addValue(value, multiplicity);
      if (isEmpty) {
        __privateGet(this, _inner2).delete(key);
      }
    }
  }
  /**
   * This method appends another index to the current index.
   * @param other - The index to append to the current index.
   */
  append(other) {
    for (const [key, value] of other.entries()) {
      this.addValue(key, value);
    }
  }
  /**
   * This method joins two indexes.
   * @param other - The index to join with the current index.
   * @returns A multiset of the joined values.
   */
  join(other) {
    const result = [];
    if (this.size <= other.size) {
      for (const [key, valueIt] of this.entriesIterators()) {
        if (!other.has(key)) continue;
        const otherValues = other.get(key);
        for (const [val1, mul1] of valueIt) {
          for (const [val2, mul2] of otherValues) {
            if (mul1 !== 0 && mul2 !== 0) {
              result.push([[key, [val1, val2]], mul1 * mul2]);
            }
          }
        }
      }
    } else {
      for (const [key, otherValueIt] of other.entriesIterators()) {
        if (!this.has(key)) continue;
        const values = this.get(key);
        for (const [val2, mul2] of otherValueIt) {
          for (const [val1, mul1] of values) {
            if (mul1 !== 0 && mul2 !== 0) {
              result.push([[key, [val1, val2]], mul1 * mul2]);
            }
          }
        }
      }
    }
    return new MultiSet(result);
  }
};
_inner2 = new WeakMap();
_consolidatedMultiplicity = new WeakMap();
_Index_instances = new WeakSet();
/**
 * Handle the transition from a single value to either a ValueMap or PrefixMap
 */
handleSingleValueTransition_fn = function(key, currentSingleValue, newValue, multiplicity) {
  const [currentValue, currentMultiplicity] = currentSingleValue;
  if (currentValue === newValue) {
    const newMultiplicity = currentMultiplicity + multiplicity;
    if (newMultiplicity === 0) {
      __privateGet(this, _inner2).delete(key);
    } else {
      __privateGet(this, _inner2).set(key, [newValue, newMultiplicity]);
    }
    return;
  }
  const newPrefix = getPrefix(newValue);
  const currentPrefix = getPrefix(currentValue);
  if (currentPrefix === newPrefix && (currentValue === newValue || hash(currentValue) === hash(newValue))) {
    const newMultiplicity = currentMultiplicity + multiplicity;
    if (newMultiplicity === 0) {
      __privateGet(this, _inner2).delete(key);
    } else {
      __privateGet(this, _inner2).set(key, [newValue, newMultiplicity]);
    }
    return;
  }
  if (currentPrefix === NO_PREFIX && newPrefix === NO_PREFIX) {
    const valueMap = new ValueMap();
    valueMap.set(hash(currentValue), currentSingleValue);
    valueMap.set(hash(newValue), [newValue, multiplicity]);
    __privateGet(this, _inner2).set(key, valueMap);
  } else {
    const prefixMap = new PrefixMap();
    if (currentPrefix === newPrefix) {
      const valueMap = new ValueMap();
      valueMap.set(hash(currentValue), currentSingleValue);
      valueMap.set(hash(newValue), [newValue, multiplicity]);
      prefixMap.set(currentPrefix, valueMap);
    } else {
      prefixMap.set(currentPrefix, currentSingleValue);
      prefixMap.set(newPrefix, [newValue, multiplicity]);
    }
    __privateGet(this, _inner2).set(key, prefixMap);
  }
};
var Index = _Index;
function getPrefix(value) {
  if (Array.isArray(value) && (typeof value[0] === `string` || typeof value[0] === `number` || typeof value[0] === `bigint`)) {
    return value[0];
  }
  return NO_PREFIX;
}
function isSingleValue(value) {
  return Array.isArray(value);
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/reduce.js
var _index, _indexOut, _f2;
var ReduceOperator = class extends UnaryOperator {
  constructor(id, inputA, output2, f) {
    super(id, inputA, output2);
    __privateAdd(this, _index, new Index());
    __privateAdd(this, _indexOut, new Index());
    __privateAdd(this, _f2);
    __privateSet(this, _f2, f);
  }
  run() {
    const keysTodo = /* @__PURE__ */ new Set();
    for (const message of this.inputMessages()) {
      for (const [item, multiplicity] of message.getInner()) {
        const [key, value] = item;
        __privateGet(this, _index).addValue(key, [value, multiplicity]);
        keysTodo.add(key);
      }
    }
    const result = [];
    for (const key of keysTodo) {
      const curr = __privateGet(this, _index).get(key);
      const currOut = __privateGet(this, _indexOut).get(key);
      const out = __privateGet(this, _f2).call(this, curr);
      const newOutputMap = /* @__PURE__ */ new Map();
      const oldOutputMap = /* @__PURE__ */ new Map();
      for (const [value, multiplicity] of out) {
        const existing = newOutputMap.get(value) ?? 0;
        newOutputMap.set(value, existing + multiplicity);
      }
      for (const [value, multiplicity] of currOut) {
        const existing = oldOutputMap.get(value) ?? 0;
        oldOutputMap.set(value, existing + multiplicity);
      }
      for (const [value, multiplicity] of oldOutputMap) {
        if (!newOutputMap.has(value)) {
          result.push([[key, value], -multiplicity]);
          __privateGet(this, _indexOut).addValue(key, [value, -multiplicity]);
        }
      }
      for (const [value, multiplicity] of newOutputMap) {
        if (!oldOutputMap.has(value)) {
          if (multiplicity !== 0) {
            result.push([[key, value], multiplicity]);
            __privateGet(this, _indexOut).addValue(key, [value, multiplicity]);
          }
        }
      }
      for (const [value, newMultiplicity] of newOutputMap) {
        const oldMultiplicity = oldOutputMap.get(value);
        if (oldMultiplicity !== void 0) {
          const delta = newMultiplicity - oldMultiplicity;
          if (delta !== 0) {
            result.push([[key, value], delta]);
            __privateGet(this, _indexOut).addValue(key, [value, delta]);
          }
        }
      }
    }
    if (result.length > 0) {
      this.output.sendData(new MultiSet(result));
    }
  }
};
_index = new WeakMap();
_indexOut = new WeakMap();
_f2 = new WeakMap();
function reduce(f) {
  return (stream) => {
    const output2 = new StreamBuilder(
      stream.graph,
      new DifferenceStreamWriter()
    );
    const operator = new ReduceOperator(
      stream.graph.getNextOperatorId(),
      stream.connectReader(),
      output2.writer,
      f
    );
    stream.graph.addOperator(operator);
    return output2;
  };
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/groupBy.js
function isPipedAggregateFunction(aggregate) {
  return `pipe` in aggregate;
}
function groupBy(keyExtractor, aggregates = {}) {
  const basicAggregates = Object.fromEntries(
    Object.entries(aggregates).filter(
      ([_, aggregate]) => !isPipedAggregateFunction(aggregate)
    )
  );
  Object.fromEntries(
    Object.entries(aggregates).filter(
      ([_, aggregate]) => isPipedAggregateFunction(aggregate)
    )
  );
  return (stream) => {
    const KEY_SENTINEL = `__original_key__`;
    const withKeysAndValues = stream.pipe(
      map((data) => {
        const key = keyExtractor(data);
        const keyString = JSON.stringify(key);
        const values = {};
        values[KEY_SENTINEL] = key;
        for (const [name, aggregate] of Object.entries(basicAggregates)) {
          values[name] = aggregate.preMap(data);
        }
        return [keyString, values];
      })
    );
    const reduced = withKeysAndValues.pipe(
      reduce((values) => {
        var _a, _b;
        let totalMultiplicity = 0;
        for (const [_, multiplicity] of values) {
          totalMultiplicity += multiplicity;
        }
        if (totalMultiplicity <= 0) {
          return [];
        }
        const result = {};
        const originalKey = (_b = (_a = values[0]) == null ? void 0 : _a[0]) == null ? void 0 : _b[KEY_SENTINEL];
        result[KEY_SENTINEL] = originalKey;
        for (const [name, aggregate] of Object.entries(basicAggregates)) {
          const preValues = values.map(
            ([v, m]) => [v[name], m]
          );
          result[name] = aggregate.reduce(preValues);
        }
        return [[result, 1]];
      })
    );
    return reduced.pipe(
      map(([keyString, values]) => {
        const key = values[KEY_SENTINEL];
        const result = {};
        Object.assign(result, key);
        for (const [name, aggregate] of Object.entries(basicAggregates)) {
          if (aggregate.postMap) {
            result[name] = aggregate.postMap(values[name]);
          } else {
            result[name] = values[name];
          }
        }
        return [keyString, result];
      })
    );
  };
}
function sum2(valueExtractor = (v) => v) {
  return {
    preMap: (data) => valueExtractor(data),
    reduce: (values) => {
      let total = 0;
      for (const [value, multiplicity] of values) {
        total += value * multiplicity;
      }
      return total;
    }
  };
}
function count3(valueExtractor = (v) => v) {
  return {
    // Count only not-null values (the `== null` comparison gives true for both null and undefined)
    preMap: (data) => valueExtractor(data) == null ? 0 : 1,
    reduce: (values) => {
      let totalCount = 0;
      for (const [nullMultiplier, multiplicity] of values) {
        totalCount += nullMultiplier * multiplicity;
      }
      return totalCount;
    }
  };
}
function avg2(valueExtractor = (v) => v) {
  return {
    preMap: (data) => ({
      sum: valueExtractor(data),
      count: 0
    }),
    reduce: (values) => {
      let totalSum = 0;
      let totalCount = 0;
      for (const [value, multiplicity] of values) {
        totalSum += value.sum * multiplicity;
        totalCount += multiplicity;
      }
      return {
        sum: totalSum,
        count: totalCount
      };
    },
    postMap: (result) => {
      return result.sum / result.count;
    }
  };
}
function min2(valueExtractor) {
  const extractor = valueExtractor ?? ((v) => v);
  return {
    preMap: (data) => extractor(data),
    reduce: (values) => {
      let minValue2;
      for (const [value, _multiplicity] of values) {
        if (!minValue2 || value && value < minValue2) {
          minValue2 = value;
        }
      }
      return minValue2;
    }
  };
}
function max2(valueExtractor) {
  const extractor = valueExtractor ?? ((v) => v);
  return {
    preMap: (data) => extractor(data),
    reduce: (values) => {
      let maxValue2;
      for (const [value, _multiplicity] of values) {
        if (!maxValue2 || value && value > maxValue2) {
          maxValue2 = value;
        }
      }
      return maxValue2;
    }
  };
}
function median(valueExtractor = (v) => v) {
  return {
    preMap: (data) => [valueExtractor(data)],
    reduce: (values) => {
      const allValues = [];
      for (const [valueArray, multiplicity] of values) {
        for (const value of valueArray) {
          for (let i = 0; i < multiplicity; i++) {
            allValues.push(value);
          }
        }
      }
      if (allValues.length === 0) {
        return [];
      }
      allValues.sort((a, b) => a - b);
      return allValues;
    },
    postMap: (result) => {
      if (result.length === 0) return 0;
      const mid = Math.floor(result.length / 2);
      if (result.length % 2 === 0) {
        return (result[mid - 1] + result[mid]) / 2;
      }
      return result[mid];
    }
  };
}
function mode(valueExtractor = (v) => v) {
  return {
    preMap: (data) => {
      const value = valueExtractor(data);
      const frequencyMap = /* @__PURE__ */ new Map();
      frequencyMap.set(value, 1);
      return frequencyMap;
    },
    reduce: (values) => {
      const combinedMap = /* @__PURE__ */ new Map();
      for (const [frequencyMap, multiplicity] of values) {
        for (const [value, frequencyCount] of frequencyMap.entries()) {
          const currentCount = combinedMap.get(value) || 0;
          combinedMap.set(value, currentCount + frequencyCount * multiplicity);
        }
      }
      return combinedMap;
    },
    postMap: (result) => {
      if (result.size === 0) return 0;
      let modeValue = 0;
      let maxFrequency = 0;
      for (const [value, frequency] of result.entries()) {
        if (frequency > maxFrequency) {
          maxFrequency = frequency;
          modeValue = value;
        }
      }
      return modeValue;
    }
  };
}
var groupByOperators = {
  sum: sum2,
  count: count3,
  avg: avg2,
  min: min2,
  max: max2,
  median,
  mode
};

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/tap.js
var _f3;
var TapOperator = class extends LinearUnaryOperator {
  constructor(id, inputA, output2, f) {
    super(id, inputA, output2);
    __privateAdd(this, _f3);
    __privateSet(this, _f3, f);
  }
  inner(collection) {
    __privateGet(this, _f3).call(this, collection);
    return collection;
  }
};
_f3 = new WeakMap();
function tap(f) {
  return (stream) => {
    const output2 = new StreamBuilder(
      stream.graph,
      new DifferenceStreamWriter()
    );
    const operator = new TapOperator(
      stream.graph.getNextOperatorId(),
      stream.connectReader(),
      output2.writer,
      f
    );
    stream.graph.addOperator(operator);
    return output2;
  };
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/filter.js
var _f4;
var FilterOperator = class extends LinearUnaryOperator {
  constructor(id, inputA, output2, f) {
    super(id, inputA, output2);
    __privateAdd(this, _f4);
    __privateSet(this, _f4, f);
  }
  inner(collection) {
    return collection.filter(__privateGet(this, _f4));
  }
};
_f4 = new WeakMap();
function filter(f) {
  return (stream) => {
    const output2 = new StreamBuilder(
      stream.graph,
      new DifferenceStreamWriter()
    );
    const operator = new FilterOperator(
      stream.graph.getNextOperatorId(),
      stream.connectReader(),
      output2.writer,
      f
    );
    stream.graph.addOperator(operator);
    return output2;
  };
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/output.js
var _fn;
var OutputOperator = class extends UnaryOperator {
  constructor(id, inputA, outputWriter, fn) {
    super(id, inputA, outputWriter);
    __privateAdd(this, _fn);
    __privateSet(this, _fn, fn);
  }
  run() {
    for (const message of this.inputMessages()) {
      __privateGet(this, _fn).call(this, message);
      this.output.sendData(message);
    }
  }
};
_fn = new WeakMap();
function output(fn) {
  return (stream) => {
    const outputStream = new StreamBuilder(
      stream.graph,
      new DifferenceStreamWriter()
    );
    const operator = new OutputOperator(
      stream.graph.getNextOperatorId(),
      stream.connectReader(),
      outputStream.writer,
      fn
    );
    stream.graph.addOperator(operator);
    return outputStream;
  };
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/consolidate.js
var ConsolidateOperator = class extends UnaryOperator {
  run() {
    const messages = this.inputMessages();
    if (messages.length === 0) {
      return;
    }
    const combined = new MultiSet();
    for (const message of messages) {
      combined.extend(message);
    }
    const consolidated = combined.consolidate();
    if (consolidated.getInner().length > 0) {
      this.output.sendData(consolidated);
    }
  }
};
function consolidate() {
  return (stream) => {
    const output2 = new StreamBuilder(
      stream.graph,
      new DifferenceStreamWriter()
    );
    const operator = new ConsolidateOperator(
      stream.graph.getNextOperatorId(),
      stream.connectReader(),
      output2.writer
    );
    stream.graph.addOperator(operator);
    return output2;
  };
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/join.js
var _indexA, _indexB, _mode;
var JoinOperator = class extends BinaryOperator {
  constructor(id, inputA, inputB, output2, mode2 = `inner`) {
    super(id, inputA, inputB, output2);
    __privateAdd(this, _indexA, new Index());
    __privateAdd(this, _indexB, new Index());
    __privateAdd(this, _mode);
    __privateSet(this, _mode, mode2);
  }
  run() {
    const deltaA = Index.fromMultiSets(
      this.inputAMessages()
    );
    const deltaB = Index.fromMultiSets(
      this.inputBMessages()
    );
    if (deltaA.size === 0 && deltaB.size === 0) return;
    const results = new MultiSet();
    if (__privateGet(this, _mode) !== `anti`) {
      this.emitInnerResults(deltaA, deltaB, results);
    }
    if (__privateGet(this, _mode) === `left` || __privateGet(this, _mode) === `full` || __privateGet(this, _mode) === `anti`) {
      this.emitLeftOuterResults(deltaA, deltaB, results);
    }
    if (__privateGet(this, _mode) === `right` || __privateGet(this, _mode) === `full`) {
      this.emitRightOuterResults(deltaA, deltaB, results);
    }
    __privateGet(this, _indexA).append(deltaA);
    __privateGet(this, _indexB).append(deltaB);
    if (results.getInner().length > 0) {
      this.output.sendData(results);
    }
  }
  emitInnerResults(deltaA, deltaB, results) {
    if (deltaA.size > 0) results.extend(deltaA.join(__privateGet(this, _indexB)));
    if (deltaB.size > 0) results.extend(__privateGet(this, _indexA).join(deltaB));
    if (deltaA.size > 0 && deltaB.size > 0) results.extend(deltaA.join(deltaB));
  }
  emitLeftOuterResults(deltaA, deltaB, results) {
    if (deltaA.size > 0) {
      for (const [key, valueIterator] of deltaA.entriesIterators()) {
        const currentMultiplicityB = __privateGet(this, _indexB).getConsolidatedMultiplicity(key);
        const deltaMultiplicityB = deltaB.getConsolidatedMultiplicity(key);
        const finalMultiplicityB = currentMultiplicityB + deltaMultiplicityB;
        if (finalMultiplicityB === 0) {
          for (const [value, multiplicity] of valueIterator) {
            if (multiplicity !== 0) {
              results.add([key, [value, null]], multiplicity);
            }
          }
        }
      }
    }
    if (deltaB.size > 0) {
      for (const key of deltaB.getPresenceKeys()) {
        const before = __privateGet(this, _indexB).getConsolidatedMultiplicity(key);
        const deltaMult = deltaB.getConsolidatedMultiplicity(key);
        if (deltaMult === 0) continue;
        const after = before + deltaMult;
        if (before === 0 === (after === 0)) continue;
        const transitioningToMatched = before === 0;
        for (const [value, multiplicity] of __privateGet(this, _indexA).getIterator(key)) {
          if (multiplicity !== 0) {
            results.add(
              [key, [value, null]],
              transitioningToMatched ? -multiplicity : +multiplicity
            );
          }
        }
      }
    }
  }
  emitRightOuterResults(deltaA, deltaB, results) {
    if (deltaB.size > 0) {
      for (const [key, valueIterator] of deltaB.entriesIterators()) {
        const currentMultiplicityA = __privateGet(this, _indexA).getConsolidatedMultiplicity(key);
        const deltaMultiplicityA = deltaA.getConsolidatedMultiplicity(key);
        const finalMultiplicityA = currentMultiplicityA + deltaMultiplicityA;
        if (finalMultiplicityA === 0) {
          for (const [value, multiplicity] of valueIterator) {
            if (multiplicity !== 0) {
              results.add([key, [null, value]], multiplicity);
            }
          }
        }
      }
    }
    if (deltaA.size > 0) {
      for (const key of deltaA.getPresenceKeys()) {
        const before = __privateGet(this, _indexA).getConsolidatedMultiplicity(key);
        const deltaMult = deltaA.getConsolidatedMultiplicity(key);
        if (deltaMult === 0) continue;
        const after = before + deltaMult;
        if (before === 0 === (after === 0)) continue;
        const transitioningToMatched = before === 0;
        for (const [value, multiplicity] of __privateGet(this, _indexB).getIterator(key)) {
          if (multiplicity !== 0) {
            results.add(
              [key, [null, value]],
              transitioningToMatched ? -multiplicity : +multiplicity
            );
          }
        }
      }
    }
  }
};
_indexA = new WeakMap();
_indexB = new WeakMap();
_mode = new WeakMap();
function join(other, type = `inner`) {
  return (stream) => {
    if (stream.graph !== other.graph) {
      throw new Error(`Cannot join streams from different graphs`);
    }
    const output2 = new StreamBuilder(
      stream.graph,
      new DifferenceStreamWriter()
    );
    const operator = new JoinOperator(
      stream.graph.getNextOperatorId(),
      stream.connectReader(),
      other.connectReader(),
      output2.writer,
      type
    );
    stream.graph.addOperator(operator);
    return output2;
  };
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/distinct.js
var _by, _values;
var DistinctOperator = class extends UnaryOperator {
  // keeps track of the number of times each value has been seen
  constructor(id, input, output2, by = (value) => value) {
    super(id, input, output2);
    __privateAdd(this, _by);
    __privateAdd(this, _values);
    __privateSet(this, _by, by);
    __privateSet(this, _values, /* @__PURE__ */ new Map());
  }
  run() {
    var _a;
    const updatedValues = /* @__PURE__ */ new Map();
    for (const message of this.inputMessages()) {
      for (const [value, diff] of message.getInner()) {
        const hashedValue = hash(__privateGet(this, _by).call(this, value));
        const oldMultiplicity = ((_a = updatedValues.get(hashedValue)) == null ? void 0 : _a[0]) ?? __privateGet(this, _values).get(hashedValue) ?? 0;
        const newMultiplicity = oldMultiplicity + diff;
        updatedValues.set(hashedValue, [newMultiplicity, value]);
      }
    }
    const result = [];
    for (const [
      hashedValue,
      [newMultiplicity, value]
    ] of updatedValues.entries()) {
      const oldMultiplicity = __privateGet(this, _values).get(hashedValue) ?? 0;
      if (newMultiplicity === 0) {
        __privateGet(this, _values).delete(hashedValue);
      } else {
        __privateGet(this, _values).set(hashedValue, newMultiplicity);
      }
      if (oldMultiplicity <= 0 && newMultiplicity > 0) {
        result.push([[hash(__privateGet(this, _by).call(this, value)), value[1]], 1]);
      } else if (oldMultiplicity > 0 && newMultiplicity <= 0) {
        result.push([[hash(__privateGet(this, _by).call(this, value)), value[1]], -1]);
      }
    }
    if (result.length > 0) {
      this.output.sendData(new MultiSet(result));
    }
  }
};
_by = new WeakMap();
_values = new WeakMap();
function distinct(by = (value) => value) {
  return (stream) => {
    const output2 = new StreamBuilder(
      stream.graph,
      new DifferenceStreamWriter()
    );
    const operator = new DistinctOperator(
      stream.graph.getNextOperatorId(),
      stream.connectReader(),
      output2.writer,
      by
    );
    stream.graph.addOperator(operator);
    return output2;
  };
}

// ../node_modules/.pnpm/fractional-indexing@3.2.0/node_modules/fractional-indexing/src/index.js
var BASE_62_DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
function midpoint(a, b, digits) {
  const zero = digits[0];
  if (b != null && a >= b) {
    throw new Error(a + " >= " + b);
  }
  if (a.slice(-1) === zero || b && b.slice(-1) === zero) {
    throw new Error("trailing zero");
  }
  if (b) {
    let n = 0;
    while ((a[n] || zero) === b[n]) {
      n++;
    }
    if (n > 0) {
      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);
    }
  }
  const digitA = a ? digits.indexOf(a[0]) : 0;
  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;
  if (digitB - digitA > 1) {
    const midDigit = Math.round(0.5 * (digitA + digitB));
    return digits[midDigit];
  } else {
    if (b && b.length > 1) {
      return b.slice(0, 1);
    } else {
      return digits[digitA] + midpoint(a.slice(1), null, digits);
    }
  }
}
function validateInteger(int) {
  if (int.length !== getIntegerLength(int[0])) {
    throw new Error("invalid integer part of order key: " + int);
  }
}
function getIntegerLength(head) {
  if (head >= "a" && head <= "z") {
    return head.charCodeAt(0) - "a".charCodeAt(0) + 2;
  } else if (head >= "A" && head <= "Z") {
    return "Z".charCodeAt(0) - head.charCodeAt(0) + 2;
  } else {
    throw new Error("invalid order key head: " + head);
  }
}
function getIntegerPart(key) {
  const integerPartLength = getIntegerLength(key[0]);
  if (integerPartLength > key.length) {
    throw new Error("invalid order key: " + key);
  }
  return key.slice(0, integerPartLength);
}
function validateOrderKey(key, digits) {
  if (key === "A" + digits[0].repeat(26)) {
    throw new Error("invalid order key: " + key);
  }
  const i = getIntegerPart(key);
  const f = key.slice(i.length);
  if (f.slice(-1) === digits[0]) {
    throw new Error("invalid order key: " + key);
  }
}
function incrementInteger(x, digits) {
  validateInteger(x);
  const [head, ...digs] = x.split("");
  let carry = true;
  for (let i = digs.length - 1; carry && i >= 0; i--) {
    const d = digits.indexOf(digs[i]) + 1;
    if (d === digits.length) {
      digs[i] = digits[0];
    } else {
      digs[i] = digits[d];
      carry = false;
    }
  }
  if (carry) {
    if (head === "Z") {
      return "a" + digits[0];
    }
    if (head === "z") {
      return null;
    }
    const h = String.fromCharCode(head.charCodeAt(0) + 1);
    if (h > "a") {
      digs.push(digits[0]);
    } else {
      digs.pop();
    }
    return h + digs.join("");
  } else {
    return head + digs.join("");
  }
}
function decrementInteger(x, digits) {
  validateInteger(x);
  const [head, ...digs] = x.split("");
  let borrow = true;
  for (let i = digs.length - 1; borrow && i >= 0; i--) {
    const d = digits.indexOf(digs[i]) - 1;
    if (d === -1) {
      digs[i] = digits.slice(-1);
    } else {
      digs[i] = digits[d];
      borrow = false;
    }
  }
  if (borrow) {
    if (head === "a") {
      return "Z" + digits.slice(-1);
    }
    if (head === "A") {
      return null;
    }
    const h = String.fromCharCode(head.charCodeAt(0) - 1);
    if (h < "Z") {
      digs.push(digits.slice(-1));
    } else {
      digs.pop();
    }
    return h + digs.join("");
  } else {
    return head + digs.join("");
  }
}
function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {
  if (a != null) {
    validateOrderKey(a, digits);
  }
  if (b != null) {
    validateOrderKey(b, digits);
  }
  if (a != null && b != null && a >= b) {
    throw new Error(a + " >= " + b);
  }
  if (a == null) {
    if (b == null) {
      return "a" + digits[0];
    }
    const ib2 = getIntegerPart(b);
    const fb2 = b.slice(ib2.length);
    if (ib2 === "A" + digits[0].repeat(26)) {
      return ib2 + midpoint("", fb2, digits);
    }
    if (ib2 < b) {
      return ib2;
    }
    const res = decrementInteger(ib2, digits);
    if (res == null) {
      throw new Error("cannot decrement any more");
    }
    return res;
  }
  if (b == null) {
    const ia2 = getIntegerPart(a);
    const fa2 = a.slice(ia2.length);
    const i2 = incrementInteger(ia2, digits);
    return i2 == null ? ia2 + midpoint(fa2, null, digits) : i2;
  }
  const ia = getIntegerPart(a);
  const fa = a.slice(ia.length);
  const ib = getIntegerPart(b);
  const fb = b.slice(ib.length);
  if (ia === ib) {
    return ia + midpoint(fa, fb, digits);
  }
  const i = incrementInteger(ia, digits);
  if (i == null) {
    throw new Error("cannot increment any more");
  }
  if (i < b) {
    return i;
  }
  return ia + midpoint(fa, null, digits);
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/topKWithFractionalIndex.js
var _sortedValues, _comparator, _topKStart, _topKEnd, _TopKArray_instances, findIndex_fn;
var TopKArray = class {
  constructor(offset, limit, comparator) {
    __privateAdd(this, _TopKArray_instances);
    __privateAdd(this, _sortedValues, []);
    __privateAdd(this, _comparator);
    __privateAdd(this, _topKStart);
    __privateAdd(this, _topKEnd);
    __privateSet(this, _topKStart, offset);
    __privateSet(this, _topKEnd, offset + limit);
    __privateSet(this, _comparator, comparator);
  }
  get size() {
    const offset = __privateGet(this, _topKStart);
    const limit = __privateGet(this, _topKEnd) - __privateGet(this, _topKStart);
    const available = __privateGet(this, _sortedValues).length - offset;
    return Math.max(0, Math.min(limit, available));
  }
  /**
   * Moves the topK window
   */
  move({
    offset,
    limit
  }) {
    const oldOffset = __privateGet(this, _topKStart);
    const oldLimit = __privateGet(this, _topKEnd) - __privateGet(this, _topKStart);
    const oldRange = [
      __privateGet(this, _topKStart),
      __privateGet(this, _topKEnd) === Infinity ? __privateGet(this, _topKStart) + this.size : __privateGet(this, _topKEnd)
    ];
    __privateSet(this, _topKStart, offset ?? oldOffset);
    __privateSet(this, _topKEnd, __privateGet(this, _topKStart) + (limit ?? oldLimit));
    const newRange = [
      __privateGet(this, _topKStart),
      __privateGet(this, _topKEnd) === Infinity ? Math.max(__privateGet(this, _topKStart) + this.size, oldRange[1]) : __privateGet(this, _topKEnd)
    ];
    const { onlyInA, onlyInB } = diffHalfOpen(oldRange, newRange);
    const moveIns = [];
    onlyInB.forEach((index) => {
      const value = __privateGet(this, _sortedValues)[index];
      if (value) {
        moveIns.push(value);
      }
    });
    const moveOuts = [];
    onlyInA.forEach((index) => {
      const value = __privateGet(this, _sortedValues)[index];
      if (value) {
        moveOuts.push(value);
      }
    });
    return { moveIns, moveOuts, changes: onlyInA.length + onlyInB.length > 0 };
  }
  insert(value) {
    const result = { moveIn: null, moveOut: null };
    const index = __privateMethod(this, _TopKArray_instances, findIndex_fn).call(this, value);
    const indexBefore = index === 0 ? null : getIndex(__privateGet(this, _sortedValues)[index - 1]);
    const indexAfter = index === __privateGet(this, _sortedValues).length ? null : getIndex(__privateGet(this, _sortedValues)[index]);
    const fractionalIndex = generateKeyBetween(indexBefore, indexAfter);
    const val = indexedValue(value, fractionalIndex);
    __privateGet(this, _sortedValues).splice(index, 0, val);
    if (index < __privateGet(this, _topKEnd)) {
      const moveInIndex = Math.max(index, __privateGet(this, _topKStart));
      if (moveInIndex < __privateGet(this, _sortedValues).length) {
        result.moveIn = __privateGet(this, _sortedValues)[moveInIndex];
        if (__privateGet(this, _topKEnd) < __privateGet(this, _sortedValues).length) {
          result.moveOut = __privateGet(this, _sortedValues)[__privateGet(this, _topKEnd)];
        }
      }
    }
    return result;
  }
  /**
   * Deletes a value that may or may not be in the topK.
   * IMPORTANT: this assumes that the value is present in the collection
   *            if it's not the case it will remove the element
   *            that is on the position where the provided `value` would be.
   */
  delete(value) {
    const result = { moveIn: null, moveOut: null };
    const index = __privateMethod(this, _TopKArray_instances, findIndex_fn).call(this, value);
    const [removedElem] = __privateGet(this, _sortedValues).splice(index, 1);
    if (index < __privateGet(this, _topKEnd)) {
      result.moveOut = removedElem;
      if (index < __privateGet(this, _topKStart)) {
        const moveOutIndex = __privateGet(this, _topKStart) - 1;
        if (moveOutIndex < __privateGet(this, _sortedValues).length) {
          result.moveOut = __privateGet(this, _sortedValues)[moveOutIndex];
        } else {
          result.moveOut = null;
        }
      }
      const moveInIndex = __privateGet(this, _topKEnd) - 1;
      if (moveInIndex < __privateGet(this, _sortedValues).length) {
        result.moveIn = __privateGet(this, _sortedValues)[moveInIndex];
      }
    }
    return result;
  }
};
_sortedValues = new WeakMap();
_comparator = new WeakMap();
_topKStart = new WeakMap();
_topKEnd = new WeakMap();
_TopKArray_instances = new WeakSet();
// TODO: see if there is a way to refactor the code for insert and delete in the topK above
//       because they are very similar, one is shifting the topK window to the left and the other is shifting it to the right
//       so i have the feeling there is a common pattern here and we can implement both cases using that pattern
findIndex_fn = function(value) {
  return binarySearch(
    __privateGet(this, _sortedValues),
    indexedValue(value, ``),
    (a, b) => __privateGet(this, _comparator).call(this, getValue(a), getValue(b))
  );
};
var _index2, _topK;
var TopKWithFractionalIndexOperator = class extends UnaryOperator {
  constructor(id, inputA, output2, comparator, options) {
    var _a, _b;
    super(id, inputA, output2);
    __privateAdd(this, _index2, /* @__PURE__ */ new Map());
    // maps keys to their multiplicity
    /**
     * topK data structure that supports insertions and deletions
     * and returns changes to the topK.
     */
    __privateAdd(this, _topK);
    const limit = options.limit ?? Infinity;
    const offset = options.offset ?? 0;
    const compareTaggedValues = (a, b) => {
      const valueComparison = comparator(getVal(a), getVal(b));
      if (valueComparison !== 0) {
        return valueComparison;
      }
      const tieBreakerA = getTag(a);
      const tieBreakerB = getTag(b);
      return tieBreakerA - tieBreakerB;
    };
    __privateSet(this, _topK, this.createTopK(offset, limit, compareTaggedValues));
    (_a = options.setSizeCallback) == null ? void 0 : _a.call(options, () => __privateGet(this, _topK).size);
    (_b = options.setWindowFn) == null ? void 0 : _b.call(options, this.moveTopK.bind(this));
  }
  createTopK(offset, limit, comparator) {
    return new TopKArray(offset, limit, comparator);
  }
  /**
   * Moves the topK window based on the provided offset and limit.
   * Any changes to the topK are sent to the output.
   */
  moveTopK({ offset, limit }) {
    if (!(__privateGet(this, _topK) instanceof TopKArray)) {
      throw new Error(
        `Cannot move B+-tree implementation of TopK with fractional index`
      );
    }
    const result = [];
    const diff = __privateGet(this, _topK).move({ offset, limit });
    diff.moveIns.forEach((moveIn) => this.handleMoveIn(moveIn, result));
    diff.moveOuts.forEach((moveOut) => this.handleMoveOut(moveOut, result));
    if (diff.changes) {
      this.output.sendData(new MultiSet(result));
    }
  }
  run() {
    const result = [];
    for (const message of this.inputMessages()) {
      for (const [item, multiplicity] of message.getInner()) {
        const [key, value] = item;
        this.processElement(key, value, multiplicity, result);
      }
    }
    if (result.length > 0) {
      this.output.sendData(new MultiSet(result));
    }
  }
  processElement(key, value, multiplicity, result) {
    const { oldMultiplicity, newMultiplicity } = this.addKey(key, multiplicity);
    let res = {
      moveIn: null,
      moveOut: null
    };
    if (oldMultiplicity <= 0 && newMultiplicity > 0) {
      const taggedValue = tagValue(key, value);
      res = __privateGet(this, _topK).insert(taggedValue);
    } else if (oldMultiplicity > 0 && newMultiplicity <= 0) {
      const taggedValue = tagValue(key, value);
      res = __privateGet(this, _topK).delete(taggedValue);
    } else ;
    this.handleMoveIn(res.moveIn, result);
    this.handleMoveOut(res.moveOut, result);
    return;
  }
  handleMoveIn(moveIn, result) {
    if (moveIn) {
      const index = getIndex(moveIn);
      const taggedValue = getValue(moveIn);
      const k = getKey(taggedValue);
      const val = getVal(taggedValue);
      result.push([[k, [val, index]], 1]);
    }
  }
  handleMoveOut(moveOut, result) {
    if (moveOut) {
      const index = getIndex(moveOut);
      const taggedValue = getValue(moveOut);
      const k = getKey(taggedValue);
      const val = getVal(taggedValue);
      result.push([[k, [val, index]], -1]);
    }
  }
  getMultiplicity(key) {
    return __privateGet(this, _index2).get(key) ?? 0;
  }
  addKey(key, multiplicity) {
    const oldMultiplicity = this.getMultiplicity(key);
    const newMultiplicity = oldMultiplicity + multiplicity;
    if (newMultiplicity === 0) {
      __privateGet(this, _index2).delete(key);
    } else {
      __privateGet(this, _index2).set(key, newMultiplicity);
    }
    return { oldMultiplicity, newMultiplicity };
  }
};
_index2 = new WeakMap();
_topK = new WeakMap();
function topKWithFractionalIndex(comparator, options) {
  const opts = options || {};
  return (stream) => {
    const output2 = new StreamBuilder(
      stream.graph,
      new DifferenceStreamWriter()
    );
    const operator = new TopKWithFractionalIndexOperator(
      stream.graph.getNextOperatorId(),
      stream.connectReader(),
      output2.writer,
      comparator,
      opts
    );
    stream.graph.addOperator(operator);
    return output2;
  };
}
function indexedValue(value, index) {
  return [value, index];
}
function getValue(indexedVal) {
  return indexedVal[0];
}
function getIndex(indexedVal) {
  return indexedVal[1];
}
function tagValue(key, value) {
  return [key, value, globalObjectIdGenerator.getId(key)];
}
function getKey(tieBreakerTaggedValue) {
  return tieBreakerTaggedValue[0];
}
function getVal(tieBreakerTaggedValue) {
  return tieBreakerTaggedValue[1];
}
function getTag(tieBreakerTaggedValue) {
  return tieBreakerTaggedValue[2];
}

// ../node_modules/.pnpm/@tanstack+db-ivm@0.1.13_typescript@5.9.2/node_modules/@tanstack/db-ivm/dist/esm/operators/orderBy.js
function orderByWithFractionalIndexBase(topKFunction, valueExtractor, options) {
  const limit = (options == null ? void 0 : options.limit) ?? Infinity;
  const offset = (options == null ? void 0 : options.offset) ?? 0;
  const setSizeCallback = options == null ? void 0 : options.setSizeCallback;
  const setWindowFn = options == null ? void 0 : options.setWindowFn;
  const comparator = (options == null ? void 0 : options.comparator) ?? ((a, b) => {
    if (a === b) return 0;
    if (a < b) return -1;
    return 1;
  });
  return (stream) => {
    return stream.pipe(
      topKFunction(
        (a, b) => comparator(valueExtractor(a), valueExtractor(b)),
        {
          limit,
          offset,
          setSizeCallback,
          setWindowFn
        }
      ),
      consolidate()
    );
  };
}
function orderByWithFractionalIndex(valueExtractor, options) {
  return orderByWithFractionalIndexBase(
    topKWithFractionalIndex,
    valueExtractor,
    options
  );
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/compiler/group-by.js
var { sum: sum3, count: count5, avg: avg3, min: min3, max: max3 } = groupByOperators;
function validateAndCreateMapping(groupByClause, selectClause) {
  const selectToGroupByIndex = /* @__PURE__ */ new Map();
  const groupByExpressions = [...groupByClause];
  if (!selectClause) {
    return { selectToGroupByIndex, groupByExpressions };
  }
  for (const [alias, expr] of Object.entries(selectClause)) {
    if (expr.type === `agg`) {
      continue;
    }
    const groupIndex = groupByExpressions.findIndex(
      (groupExpr) => expressionsEqual(expr, groupExpr)
    );
    if (groupIndex === -1) {
      throw new NonAggregateExpressionNotInGroupByError(alias);
    }
    selectToGroupByIndex.set(alias, groupIndex);
  }
  return { selectToGroupByIndex, groupByExpressions };
}
function processGroupBy(pipeline, groupByClause, havingClauses, selectClause, fnHavingClauses) {
  if (groupByClause.length === 0) {
    const aggregates2 = {};
    if (selectClause) {
      for (const [alias, expr] of Object.entries(selectClause)) {
        if (expr.type === `agg`) {
          const aggExpr = expr;
          aggregates2[alias] = getAggregateFunction(aggExpr);
        }
      }
    }
    const keyExtractor2 = () => ({ __singleGroup: true });
    pipeline = pipeline.pipe(
      groupBy(keyExtractor2, aggregates2)
    );
    pipeline = pipeline.pipe(
      map(([, aggregatedRow]) => {
        const selectResults = aggregatedRow.__select_results || {};
        const finalResults = { ...selectResults };
        if (selectClause) {
          for (const [alias, expr] of Object.entries(selectClause)) {
            if (expr.type === `agg`) {
              finalResults[alias] = aggregatedRow[alias];
            }
          }
        }
        return [
          `single_group`,
          {
            ...aggregatedRow,
            __select_results: finalResults
          }
        ];
      })
    );
    if (havingClauses && havingClauses.length > 0) {
      for (const havingClause of havingClauses) {
        const havingExpression = getHavingExpression(havingClause);
        const transformedHavingClause = replaceAggregatesByRefs(
          havingExpression,
          selectClause || {}
        );
        const compiledHaving = compileExpression(transformedHavingClause);
        pipeline = pipeline.pipe(
          filter(([, row]) => {
            const namespacedRow = { result: row.__select_results };
            return toBooleanPredicate(compiledHaving(namespacedRow));
          })
        );
      }
    }
    if (fnHavingClauses && fnHavingClauses.length > 0) {
      for (const fnHaving of fnHavingClauses) {
        pipeline = pipeline.pipe(
          filter(([, row]) => {
            const namespacedRow = { result: row.__select_results };
            return toBooleanPredicate(fnHaving(namespacedRow));
          })
        );
      }
    }
    return pipeline;
  }
  const mapping = validateAndCreateMapping(groupByClause, selectClause);
  const compiledGroupByExpressions = groupByClause.map(
    (e) => compileExpression(e)
  );
  const keyExtractor = ([, row]) => {
    const namespacedRow = { ...row };
    delete namespacedRow.__select_results;
    const key = {};
    for (let i = 0; i < groupByClause.length; i++) {
      const compiledExpr = compiledGroupByExpressions[i];
      const value = compiledExpr(namespacedRow);
      key[`__key_${i}`] = value;
    }
    return key;
  };
  const aggregates = {};
  if (selectClause) {
    for (const [alias, expr] of Object.entries(selectClause)) {
      if (expr.type === `agg`) {
        const aggExpr = expr;
        aggregates[alias] = getAggregateFunction(aggExpr);
      }
    }
  }
  pipeline = pipeline.pipe(groupBy(keyExtractor, aggregates));
  pipeline = pipeline.pipe(
    map(([, aggregatedRow]) => {
      const selectResults = aggregatedRow.__select_results || {};
      const finalResults = {};
      if (selectClause) {
        for (const [alias, expr] of Object.entries(selectClause)) {
          if (expr.type !== `agg`) {
            const groupIndex = mapping.selectToGroupByIndex.get(alias);
            if (groupIndex !== void 0) {
              finalResults[alias] = aggregatedRow[`__key_${groupIndex}`];
            } else {
              finalResults[alias] = selectResults[alias];
            }
          } else {
            finalResults[alias] = aggregatedRow[alias];
          }
        }
      } else {
        for (let i = 0; i < groupByClause.length; i++) {
          finalResults[`__key_${i}`] = aggregatedRow[`__key_${i}`];
        }
      }
      let finalKey;
      if (groupByClause.length === 1) {
        finalKey = aggregatedRow[`__key_0`];
      } else {
        const keyParts = [];
        for (let i = 0; i < groupByClause.length; i++) {
          keyParts.push(aggregatedRow[`__key_${i}`]);
        }
        finalKey = JSON.stringify(keyParts);
      }
      return [
        finalKey,
        {
          ...aggregatedRow,
          __select_results: finalResults
        }
      ];
    })
  );
  if (havingClauses && havingClauses.length > 0) {
    for (const havingClause of havingClauses) {
      const havingExpression = getHavingExpression(havingClause);
      const transformedHavingClause = replaceAggregatesByRefs(
        havingExpression,
        selectClause || {}
      );
      const compiledHaving = compileExpression(transformedHavingClause);
      pipeline = pipeline.pipe(
        filter(([, row]) => {
          const namespacedRow = { result: row.__select_results };
          return compiledHaving(namespacedRow);
        })
      );
    }
  }
  if (fnHavingClauses && fnHavingClauses.length > 0) {
    for (const fnHaving of fnHavingClauses) {
      pipeline = pipeline.pipe(
        filter(([, row]) => {
          const namespacedRow = { result: row.__select_results };
          return toBooleanPredicate(fnHaving(namespacedRow));
        })
      );
    }
  }
  return pipeline;
}
function expressionsEqual(expr1, expr2) {
  var _a, _b, _c, _d;
  if (!expr1 || !expr2) return false;
  if (expr1.type !== expr2.type) return false;
  switch (expr1.type) {
    case `ref`:
      if (!expr1.path || !expr2.path) return false;
      if (expr1.path.length !== expr2.path.length) return false;
      return expr1.path.every(
        (segment, i) => segment === expr2.path[i]
      );
    case `val`:
      return expr1.value === expr2.value;
    case `func`:
      return expr1.name === expr2.name && ((_a = expr1.args) == null ? void 0 : _a.length) === ((_b = expr2.args) == null ? void 0 : _b.length) && (expr1.args || []).every(
        (arg, i) => expressionsEqual(arg, expr2.args[i])
      );
    case `agg`:
      return expr1.name === expr2.name && ((_c = expr1.args) == null ? void 0 : _c.length) === ((_d = expr2.args) == null ? void 0 : _d.length) && (expr1.args || []).every(
        (arg, i) => expressionsEqual(arg, expr2.args[i])
      );
    default:
      return false;
  }
}
function getAggregateFunction(aggExpr) {
  const compiledExpr = compileExpression(aggExpr.args[0]);
  const valueExtractor = ([, namespacedRow]) => {
    const value = compiledExpr(namespacedRow);
    return typeof value === `number` ? value : value != null ? Number(value) : 0;
  };
  const valueExtractorWithDate = ([, namespacedRow]) => {
    const value = compiledExpr(namespacedRow);
    return typeof value === `number` || value instanceof Date ? value : value != null ? Number(value) : 0;
  };
  const rawValueExtractor = ([, namespacedRow]) => {
    return compiledExpr(namespacedRow);
  };
  switch (aggExpr.name.toLowerCase()) {
    case `sum`:
      return sum3(valueExtractor);
    case `count`:
      return count5(rawValueExtractor);
    case `avg`:
      return avg3(valueExtractor);
    case `min`:
      return min3(valueExtractorWithDate);
    case `max`:
      return max3(valueExtractorWithDate);
    default:
      throw new UnsupportedAggregateFunctionError(aggExpr.name);
  }
}
function replaceAggregatesByRefs(havingExpr, selectClause, resultAlias = `result`) {
  switch (havingExpr.type) {
    case `agg`: {
      const aggExpr = havingExpr;
      for (const [alias, selectExpr] of Object.entries(selectClause)) {
        if (selectExpr.type === `agg` && aggregatesEqual(aggExpr, selectExpr)) {
          return new PropRef([resultAlias, alias]);
        }
      }
      throw new AggregateFunctionNotInSelectError(aggExpr.name);
    }
    case `func`: {
      const funcExpr = havingExpr;
      const transformedArgs = funcExpr.args.map(
        (arg) => replaceAggregatesByRefs(arg, selectClause)
      );
      return new Func(funcExpr.name, transformedArgs);
    }
    case `ref`: {
      return havingExpr;
    }
    case `val`:
      return havingExpr;
    default:
      throw new UnknownHavingExpressionTypeError(havingExpr.type);
  }
}
function aggregatesEqual(agg1, agg2) {
  return agg1.name === agg2.name && agg1.args.length === agg2.args.length && agg1.args.every((arg, i) => expressionsEqual(arg, agg2.args[i]));
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/compiler/order-by.js
function processOrderBy(rawQuery, pipeline, orderByClause, selectClause, collection, optimizableOrderByCollections, setWindowFn, limit, offset) {
  const compiledOrderBy = orderByClause.map((clause) => {
    const clauseWithoutAggregates = replaceAggregatesByRefs(
      clause.expression,
      selectClause,
      `__select_results`
    );
    return {
      compiledExpression: compileExpression(clauseWithoutAggregates),
      compareOptions: buildCompareOptions(clause, collection)
    };
  });
  const valueExtractor = (row) => {
    const orderByContext = row;
    if (orderByClause.length > 1) {
      return compiledOrderBy.map(
        (compiled) => compiled.compiledExpression(orderByContext)
      );
    } else if (orderByClause.length === 1) {
      const compiled = compiledOrderBy[0];
      return compiled.compiledExpression(orderByContext);
    }
    return null;
  };
  const compare = (a, b) => {
    if (orderByClause.length > 1) {
      const arrayA = a;
      const arrayB = b;
      for (let i = 0; i < orderByClause.length; i++) {
        const clause = compiledOrderBy[i];
        const compareFn = makeComparator(clause.compareOptions);
        const result = compareFn(arrayA[i], arrayB[i]);
        if (result !== 0) {
          return result;
        }
      }
      return arrayA.length - arrayB.length;
    }
    if (orderByClause.length === 1) {
      const clause = compiledOrderBy[0];
      const compareFn = makeComparator(clause.compareOptions);
      return compareFn(a, b);
    }
    return defaultComparator(a, b);
  };
  let setSizeCallback;
  let orderByOptimizationInfo;
  if (limit && orderByClause.length === 1) {
    const clause = orderByClause[0];
    const orderByExpression = clause.expression;
    if (orderByExpression.type === `ref`) {
      const followRefResult = followRef(
        rawQuery,
        orderByExpression,
        collection
      );
      const followRefCollection = followRefResult.collection;
      const fieldName = followRefResult.path[0];
      const compareOpts = buildCompareOptions(clause, followRefCollection);
      if (fieldName) {
        ensureIndexForField(
          fieldName,
          followRefResult.path,
          followRefCollection,
          compareOpts,
          compare
        );
      }
      const valueExtractorForRawRow = compileExpression(
        new PropRef(followRefResult.path),
        true
      );
      const comparator = (a, b) => {
        const extractedA = a ? valueExtractorForRawRow(a) : a;
        const extractedB = b ? valueExtractorForRawRow(b) : b;
        return compare(extractedA, extractedB);
      };
      const index = findIndexForField(
        followRefCollection,
        followRefResult.path,
        compareOpts
      );
      if (index && index.supports(`gt`)) {
        const orderByAlias = orderByExpression.path.length > 1 ? String(orderByExpression.path[0]) : rawQuery.from.alias;
        orderByOptimizationInfo = {
          alias: orderByAlias,
          offset: offset ?? 0,
          limit,
          comparator,
          valueExtractorForRawRow,
          index,
          orderBy: orderByClause
        };
        optimizableOrderByCollections[followRefCollection.id] = orderByOptimizationInfo;
        setSizeCallback = (getSize) => {
          optimizableOrderByCollections[followRefCollection.id][`dataNeeded`] = () => {
            const size = getSize();
            return Math.max(0, orderByOptimizationInfo.limit - size);
          };
        };
      }
    }
  }
  return pipeline.pipe(
    orderByWithFractionalIndex(valueExtractor, {
      limit,
      offset,
      comparator: compare,
      setSizeCallback,
      setWindowFn: (windowFn) => {
        setWindowFn(
          // We wrap the move function such that we update the orderByOptimizationInfo
          // because that is used by the `dataNeeded` callback to determine if we need to load more data
          (options) => {
            windowFn(options);
            if (orderByOptimizationInfo) {
              orderByOptimizationInfo.offset = options.offset ?? orderByOptimizationInfo.offset;
              orderByOptimizationInfo.limit = options.limit ?? orderByOptimizationInfo.limit;
            }
          }
        );
      }
    })
    // orderByWithFractionalIndex returns [key, [value, index]] - we keep this format
  );
}
function buildCompareOptions(clause, collection) {
  if (clause.compareOptions.stringSort !== void 0) {
    return clause.compareOptions;
  }
  return {
    ...collection.compareOptions,
    direction: clause.compareOptions.direction,
    nulls: clause.compareOptions.nulls
  };
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/change-events.js
function currentStateAsChanges(collection, options = {}) {
  const collectFilteredResults = (filterFn) => {
    const result = [];
    for (const [key, value] of collection.entries()) {
      if ((filterFn == null ? void 0 : filterFn(value)) ?? true) {
        result.push({
          type: `insert`,
          key,
          value
        });
      }
    }
    return result;
  };
  if (options.limit !== void 0 && !options.orderBy) {
    throw new Error(`limit cannot be used without orderBy`);
  }
  if (options.orderBy) {
    const whereFilter = options.where ? createFilterFunctionFromExpression(options.where) : void 0;
    const orderedKeys = getOrderedKeys(
      collection,
      options.orderBy,
      options.limit,
      whereFilter,
      options.optimizedOnly
    );
    if (orderedKeys === void 0) {
      return;
    }
    const result = [];
    for (const key of orderedKeys) {
      const value = collection.get(key);
      if (value !== void 0) {
        result.push({
          type: `insert`,
          key,
          value
        });
      }
    }
    return result;
  }
  if (!options.where) {
    return collectFilteredResults();
  }
  try {
    const expression = options.where;
    const optimizationResult = optimizeExpressionWithIndexes(
      expression,
      collection
    );
    if (optimizationResult.canOptimize) {
      const result = [];
      for (const key of optimizationResult.matchingKeys) {
        const value = collection.get(key);
        if (value !== void 0) {
          result.push({
            type: `insert`,
            key,
            value
          });
        }
      }
      return result;
    } else {
      if (options.optimizedOnly) {
        return;
      }
      const filterFn = createFilterFunctionFromExpression(expression);
      return collectFilteredResults(filterFn);
    }
  } catch (error) {
    console.warn(
      `${collection.id ? `[${collection.id}] ` : ``}Error processing where clause, falling back to full scan:`,
      error
    );
    const filterFn = createFilterFunctionFromExpression(options.where);
    if (options.optimizedOnly) {
      return;
    }
    return collectFilteredResults(filterFn);
  }
}
function createFilterFunctionFromExpression(expression) {
  return (item) => {
    try {
      const evaluator = compileSingleRowExpression(expression);
      const result = evaluator(item);
      return toBooleanPredicate(result);
    } catch {
      return false;
    }
  };
}
function createFilteredCallback(originalCallback, options) {
  const filterFn = createFilterFunctionFromExpression(options.whereExpression);
  return (changes) => {
    const filteredChanges = [];
    for (const change of changes) {
      if (change.type === `insert`) {
        if (filterFn(change.value)) {
          filteredChanges.push(change);
        }
      } else if (change.type === `update`) {
        const newValueMatches = filterFn(change.value);
        const oldValueMatches = change.previousValue ? filterFn(change.previousValue) : false;
        if (newValueMatches && oldValueMatches) {
          filteredChanges.push(change);
        } else if (newValueMatches && !oldValueMatches) {
          filteredChanges.push({
            ...change,
            type: `insert`
          });
        } else if (!newValueMatches && oldValueMatches) {
          filteredChanges.push({
            ...change,
            type: `delete`,
            value: change.previousValue
            // Use the previous value for the delete
          });
        }
      } else {
        if (filterFn(change.value)) {
          filteredChanges.push(change);
        }
      }
    }
    if (filteredChanges.length > 0 || changes.length === 0) {
      originalCallback(filteredChanges);
    }
  };
}
function getOrderedKeys(collection, orderBy2, limit, whereFilter, optimizedOnly) {
  if (orderBy2.length === 1) {
    const clause = orderBy2[0];
    const orderByExpression = clause.expression;
    if (orderByExpression.type === `ref`) {
      const propRef = orderByExpression;
      const fieldPath = propRef.path;
      const compareOpts = buildCompareOptions(clause, collection);
      ensureIndexForField(
        fieldPath[0],
        fieldPath,
        collection,
        compareOpts
      );
      const index = findIndexForField(collection, fieldPath, compareOpts);
      if (index && index.supports(`gt`)) {
        const filterFn = (key) => {
          const value = collection.get(key);
          if (value === void 0) {
            return false;
          }
          return (whereFilter == null ? void 0 : whereFilter(value)) ?? true;
        };
        return index.take(limit ?? index.keyCount, void 0, filterFn);
      }
    }
  }
  if (optimizedOnly) {
    return;
  }
  const allItems = [];
  for (const [key, value] of collection.entries()) {
    if ((whereFilter == null ? void 0 : whereFilter(value)) ?? true) {
      allItems.push({ key, value });
    }
  }
  const compare = (a, b) => {
    for (const clause of orderBy2) {
      const compareFn = makeComparator(clause.compareOptions);
      const aValue = extractValueFromItem(a.value, clause.expression);
      const bValue = extractValueFromItem(b.value, clause.expression);
      const result = compareFn(aValue, bValue);
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  };
  allItems.sort(compare);
  const sortedKeys = allItems.map((item) => item.key);
  if (limit !== void 0) {
    return sortedKeys.slice(0, limit);
  }
  return sortedKeys;
}
function extractValueFromItem(item, expression) {
  if (expression.type === `ref`) {
    const propRef = expression;
    let value = item;
    for (const pathPart of propRef.path) {
      value = value == null ? void 0 : value[pathPart];
    }
    return value;
  } else if (expression.type === `val`) {
    return expression.value;
  } else {
    const evaluator = compileSingleRowExpression(expression);
    return evaluator(item);
  }
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/state.js
var CollectionStateManager = class {
  /**
   * Creates a new CollectionState manager
   */
  constructor(config) {
    this.pendingSyncedTransactions = [];
    this.syncedMetadata = /* @__PURE__ */ new Map();
    this.optimisticUpserts = /* @__PURE__ */ new Map();
    this.optimisticDeletes = /* @__PURE__ */ new Set();
    this.size = 0;
    this.syncedKeys = /* @__PURE__ */ new Set();
    this.preSyncVisibleState = /* @__PURE__ */ new Map();
    this.recentlySyncedKeys = /* @__PURE__ */ new Set();
    this.hasReceivedFirstCommit = false;
    this.isCommittingSyncTransactions = false;
    this.commitPendingTransactions = () => {
      var _a;
      let hasPersistingTransaction = false;
      for (const transaction of this.transactions.values()) {
        if (transaction.state === `persisting`) {
          hasPersistingTransaction = true;
          break;
        }
      }
      const {
        committedSyncedTransactions,
        uncommittedSyncedTransactions,
        hasTruncateSync
      } = this.pendingSyncedTransactions.reduce(
        (acc, t) => {
          if (t.committed) {
            acc.committedSyncedTransactions.push(t);
            if (t.truncate === true) {
              acc.hasTruncateSync = true;
            }
          } else {
            acc.uncommittedSyncedTransactions.push(t);
          }
          return acc;
        },
        {
          committedSyncedTransactions: [],
          uncommittedSyncedTransactions: [],
          hasTruncateSync: false
        }
      );
      if (!hasPersistingTransaction || hasTruncateSync) {
        this.isCommittingSyncTransactions = true;
        const truncateOptimisticSnapshot = hasTruncateSync ? (_a = committedSyncedTransactions.find((t) => t.truncate)) == null ? void 0 : _a.optimisticSnapshot : null;
        const changedKeys = /* @__PURE__ */ new Set();
        for (const transaction of committedSyncedTransactions) {
          for (const operation of transaction.operations) {
            changedKeys.add(operation.key);
          }
        }
        let currentVisibleState = this.preSyncVisibleState;
        if (currentVisibleState.size === 0) {
          currentVisibleState = /* @__PURE__ */ new Map();
          for (const key of changedKeys) {
            const currentValue = this.get(key);
            if (currentValue !== void 0) {
              currentVisibleState.set(key, currentValue);
            }
          }
        }
        const events = [];
        const rowUpdateMode = this.config.sync.rowUpdateMode || `partial`;
        for (const transaction of committedSyncedTransactions) {
          if (transaction.truncate) {
            const visibleKeys = /* @__PURE__ */ new Set([
              ...this.syncedData.keys(),
              ...(truncateOptimisticSnapshot == null ? void 0 : truncateOptimisticSnapshot.upserts.keys()) || []
            ]);
            for (const key of visibleKeys) {
              if (truncateOptimisticSnapshot == null ? void 0 : truncateOptimisticSnapshot.deletes.has(key)) continue;
              const previousValue = (truncateOptimisticSnapshot == null ? void 0 : truncateOptimisticSnapshot.upserts.get(key)) || this.syncedData.get(key);
              if (previousValue !== void 0) {
                events.push({ type: `delete`, key, value: previousValue });
              }
            }
            this.syncedData.clear();
            this.syncedMetadata.clear();
            this.syncedKeys.clear();
            for (const key of changedKeys) {
              currentVisibleState.delete(key);
            }
          }
          for (const operation of transaction.operations) {
            const key = operation.key;
            this.syncedKeys.add(key);
            switch (operation.type) {
              case `insert`:
                this.syncedMetadata.set(key, operation.metadata);
                break;
              case `update`:
                this.syncedMetadata.set(
                  key,
                  Object.assign(
                    {},
                    this.syncedMetadata.get(key),
                    operation.metadata
                  )
                );
                break;
              case `delete`:
                this.syncedMetadata.delete(key);
                break;
            }
            switch (operation.type) {
              case `insert`:
                this.syncedData.set(key, operation.value);
                break;
              case `update`: {
                if (rowUpdateMode === `partial`) {
                  const updatedValue = Object.assign(
                    {},
                    this.syncedData.get(key),
                    operation.value
                  );
                  this.syncedData.set(key, updatedValue);
                } else {
                  this.syncedData.set(key, operation.value);
                }
                break;
              }
              case `delete`:
                this.syncedData.delete(key);
                break;
            }
          }
        }
        if (hasTruncateSync) {
          const syncedInsertedOrUpdatedKeys = /* @__PURE__ */ new Set();
          for (const t of committedSyncedTransactions) {
            for (const op of t.operations) {
              if (op.type === `insert` || op.type === `update`) {
                syncedInsertedOrUpdatedKeys.add(op.key);
              }
            }
          }
          const reapplyUpserts = new Map(
            truncateOptimisticSnapshot.upserts
          );
          const reapplyDeletes = new Set(
            truncateOptimisticSnapshot.deletes
          );
          for (const [key, value] of reapplyUpserts) {
            if (reapplyDeletes.has(key)) continue;
            if (syncedInsertedOrUpdatedKeys.has(key)) {
              let foundInsert = false;
              for (let i = events.length - 1; i >= 0; i--) {
                const evt = events[i];
                if (evt.key === key && evt.type === `insert`) {
                  evt.value = value;
                  foundInsert = true;
                  break;
                }
              }
              if (!foundInsert) {
                events.push({ type: `insert`, key, value });
              }
            } else {
              events.push({ type: `insert`, key, value });
            }
          }
          if (events.length > 0 && reapplyDeletes.size > 0) {
            const filtered = [];
            for (const evt of events) {
              if (evt.type === `insert` && reapplyDeletes.has(evt.key)) {
                continue;
              }
              filtered.push(evt);
            }
            events.length = 0;
            events.push(...filtered);
          }
          if (this.lifecycle.status !== `ready`) {
            this.lifecycle.markReady();
          }
        }
        this.optimisticUpserts.clear();
        this.optimisticDeletes.clear();
        this.isCommittingSyncTransactions = false;
        if (hasTruncateSync && truncateOptimisticSnapshot) {
          for (const [key, value] of truncateOptimisticSnapshot.upserts) {
            this.optimisticUpserts.set(key, value);
          }
          for (const key of truncateOptimisticSnapshot.deletes) {
            this.optimisticDeletes.add(key);
          }
        }
        for (const transaction of this.transactions.values()) {
          if (![`completed`, `failed`].includes(transaction.state)) {
            for (const mutation of transaction.mutations) {
              if (this.isThisCollection(mutation.collection) && mutation.optimistic) {
                switch (mutation.type) {
                  case `insert`:
                  case `update`:
                    this.optimisticUpserts.set(
                      mutation.key,
                      mutation.modified
                    );
                    this.optimisticDeletes.delete(mutation.key);
                    break;
                  case `delete`:
                    this.optimisticUpserts.delete(mutation.key);
                    this.optimisticDeletes.add(mutation.key);
                    break;
                }
              }
            }
          }
        }
        const completedOptimisticOps = /* @__PURE__ */ new Map();
        for (const transaction of this.transactions.values()) {
          if (transaction.state === `completed`) {
            for (const mutation of transaction.mutations) {
              if (mutation.optimistic && this.isThisCollection(mutation.collection) && changedKeys.has(mutation.key)) {
                completedOptimisticOps.set(mutation.key, {
                  type: mutation.type,
                  value: mutation.modified
                });
              }
            }
          }
        }
        for (const key of changedKeys) {
          const previousVisibleValue = currentVisibleState.get(key);
          const newVisibleValue = this.get(key);
          const completedOp = completedOptimisticOps.get(key);
          let isRedundantSync = false;
          if (completedOp) {
            if (completedOp.type === `delete` && previousVisibleValue !== void 0 && newVisibleValue === void 0 && deepEquals(completedOp.value, previousVisibleValue)) {
              isRedundantSync = true;
            } else if (newVisibleValue !== void 0 && deepEquals(completedOp.value, newVisibleValue)) {
              isRedundantSync = true;
            }
          }
          if (!isRedundantSync) {
            if (previousVisibleValue === void 0 && newVisibleValue !== void 0) {
              events.push({
                type: `insert`,
                key,
                value: newVisibleValue
              });
            } else if (previousVisibleValue !== void 0 && newVisibleValue === void 0) {
              events.push({
                type: `delete`,
                key,
                value: previousVisibleValue
              });
            } else if (previousVisibleValue !== void 0 && newVisibleValue !== void 0 && !deepEquals(previousVisibleValue, newVisibleValue)) {
              events.push({
                type: `update`,
                key,
                value: newVisibleValue,
                previousValue: previousVisibleValue
              });
            }
          }
        }
        this.size = this.calculateSize();
        if (events.length > 0) {
          this.indexes.updateIndexes(events);
        }
        this.changes.emitEvents(events, true);
        this.pendingSyncedTransactions = uncommittedSyncedTransactions;
        this.preSyncVisibleState.clear();
        Promise.resolve().then(() => {
          this.recentlySyncedKeys.clear();
        });
        if (!this.hasReceivedFirstCommit) {
          this.hasReceivedFirstCommit = true;
        }
      }
    };
    this.config = config;
    this.transactions = new SortedMap(
      (a, b) => a.compareCreatedAt(b)
    );
    if (config.compare) {
      this.syncedData = new SortedMap(config.compare);
    } else {
      this.syncedData = /* @__PURE__ */ new Map();
    }
  }
  setDeps(deps) {
    this.collection = deps.collection;
    this.lifecycle = deps.lifecycle;
    this.changes = deps.changes;
    this.indexes = deps.indexes;
  }
  /**
   * Get the current value for a key (virtual derived state)
   */
  get(key) {
    const { optimisticDeletes, optimisticUpserts, syncedData } = this;
    if (optimisticDeletes.has(key)) {
      return void 0;
    }
    if (optimisticUpserts.has(key)) {
      return optimisticUpserts.get(key);
    }
    return syncedData.get(key);
  }
  /**
   * Check if a key exists in the collection (virtual derived state)
   */
  has(key) {
    const { optimisticDeletes, optimisticUpserts, syncedData } = this;
    if (optimisticDeletes.has(key)) {
      return false;
    }
    if (optimisticUpserts.has(key)) {
      return true;
    }
    return syncedData.has(key);
  }
  /**
   * Get all keys (virtual derived state)
   */
  *keys() {
    const { syncedData, optimisticDeletes, optimisticUpserts } = this;
    for (const key of syncedData.keys()) {
      if (!optimisticDeletes.has(key)) {
        yield key;
      }
    }
    for (const key of optimisticUpserts.keys()) {
      if (!syncedData.has(key) && !optimisticDeletes.has(key)) {
        yield key;
      }
    }
  }
  /**
   * Get all values (virtual derived state)
   */
  *values() {
    for (const key of this.keys()) {
      const value = this.get(key);
      if (value !== void 0) {
        yield value;
      }
    }
  }
  /**
   * Get all entries (virtual derived state)
   */
  *entries() {
    for (const key of this.keys()) {
      const value = this.get(key);
      if (value !== void 0) {
        yield [key, value];
      }
    }
  }
  /**
   * Get all entries (virtual derived state)
   */
  *[Symbol.iterator]() {
    for (const [key, value] of this.entries()) {
      yield [key, value];
    }
  }
  /**
   * Execute a callback for each entry in the collection
   */
  forEach(callbackfn) {
    let index = 0;
    for (const [key, value] of this.entries()) {
      callbackfn(value, key, index++);
    }
  }
  /**
   * Create a new array with the results of calling a function for each entry in the collection
   */
  map(callbackfn) {
    const result = [];
    let index = 0;
    for (const [key, value] of this.entries()) {
      result.push(callbackfn(value, key, index++));
    }
    return result;
  }
  /**
   * Check if the given collection is this collection
   * @param collection The collection to check
   * @returns True if the given collection is this collection, false otherwise
   */
  isThisCollection(collection) {
    return collection === this.collection;
  }
  /**
   * Recompute optimistic state from active transactions
   */
  recomputeOptimisticState(triggeredByUserAction = false) {
    if (this.isCommittingSyncTransactions && !triggeredByUserAction) {
      return;
    }
    const previousState = new Map(this.optimisticUpserts);
    const previousDeletes = new Set(this.optimisticDeletes);
    this.optimisticUpserts.clear();
    this.optimisticDeletes.clear();
    const activeTransactions = [];
    for (const transaction of this.transactions.values()) {
      if (![`completed`, `failed`].includes(transaction.state)) {
        activeTransactions.push(transaction);
      }
    }
    for (const transaction of activeTransactions) {
      for (const mutation of transaction.mutations) {
        if (this.isThisCollection(mutation.collection) && mutation.optimistic) {
          switch (mutation.type) {
            case `insert`:
            case `update`:
              this.optimisticUpserts.set(
                mutation.key,
                mutation.modified
              );
              this.optimisticDeletes.delete(mutation.key);
              break;
            case `delete`:
              this.optimisticUpserts.delete(mutation.key);
              this.optimisticDeletes.add(mutation.key);
              break;
          }
        }
      }
    }
    this.size = this.calculateSize();
    const events = [];
    this.collectOptimisticChanges(previousState, previousDeletes, events);
    const filteredEventsBySyncStatus = events.filter((event) => {
      if (!this.recentlySyncedKeys.has(event.key)) {
        return true;
      }
      if (triggeredByUserAction) {
        return true;
      }
      return false;
    });
    if (this.pendingSyncedTransactions.length > 0 && !triggeredByUserAction) {
      const pendingSyncKeys = /* @__PURE__ */ new Set();
      for (const transaction of this.pendingSyncedTransactions) {
        for (const operation of transaction.operations) {
          pendingSyncKeys.add(operation.key);
        }
      }
      const filteredEvents = filteredEventsBySyncStatus.filter((event) => {
        if (event.type === `delete` && pendingSyncKeys.has(event.key)) {
          const hasActiveOptimisticMutation = activeTransactions.some(
            (tx) => tx.mutations.some(
              (m) => this.isThisCollection(m.collection) && m.key === event.key
            )
          );
          if (!hasActiveOptimisticMutation) {
            return false;
          }
        }
        return true;
      });
      if (filteredEvents.length > 0) {
        this.indexes.updateIndexes(filteredEvents);
      }
      this.changes.emitEvents(filteredEvents, triggeredByUserAction);
    } else {
      if (filteredEventsBySyncStatus.length > 0) {
        this.indexes.updateIndexes(filteredEventsBySyncStatus);
      }
      this.changes.emitEvents(filteredEventsBySyncStatus, triggeredByUserAction);
    }
  }
  /**
   * Calculate the current size based on synced data and optimistic changes
   */
  calculateSize() {
    const syncedSize = this.syncedData.size;
    const deletesFromSynced = Array.from(this.optimisticDeletes).filter(
      (key) => this.syncedData.has(key) && !this.optimisticUpserts.has(key)
    ).length;
    const upsertsNotInSynced = Array.from(this.optimisticUpserts.keys()).filter(
      (key) => !this.syncedData.has(key)
    ).length;
    return syncedSize - deletesFromSynced + upsertsNotInSynced;
  }
  /**
   * Collect events for optimistic changes
   */
  collectOptimisticChanges(previousUpserts, previousDeletes, events) {
    const allKeys = /* @__PURE__ */ new Set([
      ...previousUpserts.keys(),
      ...this.optimisticUpserts.keys(),
      ...previousDeletes,
      ...this.optimisticDeletes
    ]);
    for (const key of allKeys) {
      const currentValue = this.get(key);
      const previousValue = this.getPreviousValue(
        key,
        previousUpserts,
        previousDeletes
      );
      if (previousValue !== void 0 && currentValue === void 0) {
        events.push({ type: `delete`, key, value: previousValue });
      } else if (previousValue === void 0 && currentValue !== void 0) {
        events.push({ type: `insert`, key, value: currentValue });
      } else if (previousValue !== void 0 && currentValue !== void 0 && previousValue !== currentValue) {
        events.push({
          type: `update`,
          key,
          value: currentValue,
          previousValue
        });
      }
    }
  }
  /**
   * Get the previous value for a key given previous optimistic state
   */
  getPreviousValue(key, previousUpserts, previousDeletes) {
    if (previousDeletes.has(key)) {
      return void 0;
    }
    if (previousUpserts.has(key)) {
      return previousUpserts.get(key);
    }
    return this.syncedData.get(key);
  }
  /**
   * Schedule cleanup of a transaction when it completes
   */
  scheduleTransactionCleanup(transaction) {
    if (transaction.state === `completed`) {
      this.transactions.delete(transaction.id);
      return;
    }
    transaction.isPersisted.promise.then(() => {
      this.transactions.delete(transaction.id);
    }).catch(() => {
    });
  }
  /**
   * Capture visible state for keys that will be affected by pending sync operations
   * This must be called BEFORE onTransactionStateChange clears optimistic state
   */
  capturePreSyncVisibleState() {
    if (this.pendingSyncedTransactions.length === 0) return;
    const syncedKeys = /* @__PURE__ */ new Set();
    for (const transaction of this.pendingSyncedTransactions) {
      for (const operation of transaction.operations) {
        syncedKeys.add(operation.key);
      }
    }
    for (const key of syncedKeys) {
      this.recentlySyncedKeys.add(key);
    }
    for (const key of syncedKeys) {
      if (!this.preSyncVisibleState.has(key)) {
        const currentValue = this.get(key);
        if (currentValue !== void 0) {
          this.preSyncVisibleState.set(key, currentValue);
        }
      }
    }
  }
  /**
   * Trigger a recomputation when transactions change
   * This method should be called by the Transaction class when state changes
   */
  onTransactionStateChange() {
    this.changes.shouldBatchEvents = this.pendingSyncedTransactions.length > 0;
    this.capturePreSyncVisibleState();
    this.recomputeOptimisticState(false);
  }
  /**
   * Clean up the collection by stopping sync and clearing data
   * This can be called manually or automatically by garbage collection
   */
  cleanup() {
    this.syncedData.clear();
    this.syncedMetadata.clear();
    this.optimisticUpserts.clear();
    this.optimisticDeletes.clear();
    this.size = 0;
    this.pendingSyncedTransactions = [];
    this.syncedKeys.clear();
    this.hasReceivedFirstCommit = false;
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/event-emitter.js
var EventEmitter = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  /**
   * Subscribe to an event
   * @param event - Event name to listen for
   * @param callback - Function to call when event is emitted
   * @returns Unsubscribe function
   */
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, /* @__PURE__ */ new Set());
    }
    this.listeners.get(event).add(callback);
    return () => {
      var _a;
      (_a = this.listeners.get(event)) == null ? void 0 : _a.delete(callback);
    };
  }
  /**
   * Subscribe to an event once (automatically unsubscribes after first emission)
   * @param event - Event name to listen for
   * @param callback - Function to call when event is emitted
   * @returns Unsubscribe function
   */
  once(event, callback) {
    const unsubscribe = this.on(event, (eventPayload) => {
      callback(eventPayload);
      unsubscribe();
    });
    return unsubscribe;
  }
  /**
   * Unsubscribe from an event
   * @param event - Event name to stop listening for
   * @param callback - Function to remove
   */
  off(event, callback) {
    var _a;
    (_a = this.listeners.get(event)) == null ? void 0 : _a.delete(callback);
  }
  /**
   * Wait for an event to be emitted
   * @param event - Event name to wait for
   * @param timeout - Optional timeout in milliseconds
   * @returns Promise that resolves with the event payload
   */
  waitFor(event, timeout) {
    return new Promise((resolve, reject) => {
      let timeoutId;
      const unsubscribe = this.on(event, (eventPayload) => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = void 0;
        }
        resolve(eventPayload);
        unsubscribe();
      });
      if (timeout) {
        timeoutId = setTimeout(() => {
          timeoutId = void 0;
          unsubscribe();
          reject(new Error(`Timeout waiting for event ${String(event)}`));
        }, timeout);
      }
    });
  }
  /**
   * Emit an event to all listeners
   * @param event - Event name to emit
   * @param eventPayload - Event payload
   * @internal For use by subclasses - subclasses should wrap this with a public emit if needed
   */
  emitInner(event, eventPayload) {
    var _a;
    (_a = this.listeners.get(event)) == null ? void 0 : _a.forEach((listener) => {
      try {
        listener(eventPayload);
      } catch (error) {
        queueMicrotask(() => {
          throw error;
        });
      }
    });
  }
  /**
   * Clear all listeners
   */
  clearListeners() {
    this.listeners.clear();
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/subscription.js
var CollectionSubscription = class extends EventEmitter {
  constructor(collection, callback, options) {
    super();
    this.collection = collection;
    this.callback = callback;
    this.options = options;
    this.loadedInitialState = false;
    this.snapshotSent = false;
    this.loadedSubsets = [];
    this.sentKeys = /* @__PURE__ */ new Set();
    this._status = `ready`;
    this.pendingLoadSubsetPromises = /* @__PURE__ */ new Set();
    if (options.onUnsubscribe) {
      this.on(`unsubscribed`, (event) => options.onUnsubscribe(event));
    }
    if (options.whereExpression) {
      ensureIndexForExpression(options.whereExpression, this.collection);
    }
    const callbackWithSentKeysTracking = (changes) => {
      callback(changes);
      this.trackSentKeys(changes);
    };
    this.callback = callbackWithSentKeysTracking;
    this.filteredCallback = options.whereExpression ? createFilteredCallback(this.callback, options) : this.callback;
  }
  get status() {
    return this._status;
  }
  setOrderByIndex(index) {
    this.orderByIndex = index;
  }
  /**
   * Set subscription status and emit events if changed
   */
  setStatus(newStatus) {
    if (this._status === newStatus) {
      return;
    }
    const previousStatus = this._status;
    this._status = newStatus;
    this.emitInner(`status:change`, {
      type: `status:change`,
      subscription: this,
      previousStatus,
      status: newStatus
    });
    const eventKey = `status:${newStatus}`;
    this.emitInner(eventKey, {
      type: eventKey,
      subscription: this,
      previousStatus,
      status: newStatus
    });
  }
  /**
   * Track a loadSubset promise and manage loading status
   */
  trackLoadSubsetPromise(syncResult) {
    if (syncResult instanceof Promise) {
      this.pendingLoadSubsetPromises.add(syncResult);
      this.setStatus(`loadingSubset`);
      syncResult.finally(() => {
        this.pendingLoadSubsetPromises.delete(syncResult);
        if (this.pendingLoadSubsetPromises.size === 0) {
          this.setStatus(`ready`);
        }
      });
    }
  }
  hasLoadedInitialState() {
    return this.loadedInitialState;
  }
  hasSentAtLeastOneSnapshot() {
    return this.snapshotSent;
  }
  emitEvents(changes) {
    const newChanges = this.filterAndFlipChanges(changes);
    this.filteredCallback(newChanges);
  }
  /**
   * Sends the snapshot to the callback.
   * Returns a boolean indicating if it succeeded.
   * It can only fail if there is no index to fulfill the request
   * and the optimizedOnly option is set to true,
   * or, the entire state was already loaded.
   */
  requestSnapshot(opts) {
    if (this.loadedInitialState) {
      return false;
    }
    const stateOpts = {
      where: this.options.whereExpression,
      optimizedOnly: (opts == null ? void 0 : opts.optimizedOnly) ?? false
    };
    if (opts) {
      if (`where` in opts) {
        const snapshotWhereExp = opts.where;
        if (stateOpts.where) {
          const subWhereExp = stateOpts.where;
          const combinedWhereExp = and(subWhereExp, snapshotWhereExp);
          stateOpts.where = combinedWhereExp;
        } else {
          stateOpts.where = snapshotWhereExp;
        }
      }
    } else {
      this.loadedInitialState = true;
    }
    const loadOptions = {
      where: stateOpts.where,
      subscription: this
    };
    const syncResult = this.collection._sync.loadSubset(loadOptions);
    this.loadedSubsets.push(loadOptions);
    const trackLoadSubsetPromise = (opts == null ? void 0 : opts.trackLoadSubsetPromise) ?? true;
    if (trackLoadSubsetPromise) {
      this.trackLoadSubsetPromise(syncResult);
    }
    const snapshot = this.collection.currentStateAsChanges(stateOpts);
    if (snapshot === void 0) {
      return false;
    }
    const filteredSnapshot = snapshot.filter(
      (change) => !this.sentKeys.has(change.key)
    );
    this.snapshotSent = true;
    this.callback(filteredSnapshot);
    return true;
  }
  /**
   * Sends a snapshot that fulfills the `where` clause and all rows are bigger or equal to `minValue`.
   * Requires a range index to be set with `setOrderByIndex` prior to calling this method.
   * It uses that range index to load the items in the order of the index.
   * Note 1: it may load more rows than the provided LIMIT because it loads all values equal to `minValue` + limit values greater than `minValue`.
   *         This is needed to ensure that it does not accidentally skip duplicate values when the limit falls in the middle of some duplicated values.
   * Note 2: it does not send keys that have already been sent before.
   */
  requestLimitedSnapshot({
    orderBy: orderBy2,
    limit,
    minValue: minValue2
  }) {
    if (!limit) throw new Error(`limit is required`);
    if (!this.orderByIndex) {
      throw new Error(
        `Ordered snapshot was requested but no index was found. You have to call setOrderByIndex before requesting an ordered snapshot.`
      );
    }
    const index = this.orderByIndex;
    const where = this.options.whereExpression;
    const whereFilterFn = where ? createFilterFunctionFromExpression(where) : void 0;
    const filterFn = (key) => {
      if (this.sentKeys.has(key)) {
        return false;
      }
      const value = this.collection.get(key);
      if (value === void 0) {
        return false;
      }
      return (whereFilterFn == null ? void 0 : whereFilterFn(value)) ?? true;
    };
    let biggestObservedValue = minValue2;
    const changes = [];
    let keys = [];
    if (minValue2 !== void 0) {
      const { expression } = orderBy2[0];
      const allRowsWithMinValue = this.collection.currentStateAsChanges({
        where: eq(expression, new Value(minValue2))
      });
      if (allRowsWithMinValue) {
        const keysWithMinValue = allRowsWithMinValue.map((change) => change.key).filter((key) => !this.sentKeys.has(key) && filterFn(key));
        keys.push(...keysWithMinValue);
        const keysGreaterThanMin = index.take(
          limit - keys.length,
          minValue2,
          filterFn
        );
        keys.push(...keysGreaterThanMin);
      } else {
        keys = index.take(limit, minValue2, filterFn);
      }
    } else {
      keys = index.take(limit, minValue2, filterFn);
    }
    const valuesNeeded = () => Math.max(limit - changes.length, 0);
    const collectionExhausted = () => keys.length === 0;
    while (valuesNeeded() > 0 && !collectionExhausted()) {
      const insertedKeys = /* @__PURE__ */ new Set();
      for (const key of keys) {
        const value = this.collection.get(key);
        changes.push({
          type: `insert`,
          key,
          value
        });
        biggestObservedValue = value;
        insertedKeys.add(key);
      }
      keys = index.take(valuesNeeded(), biggestObservedValue, filterFn);
    }
    this.callback(changes);
    let whereWithValueFilter = where;
    if (typeof minValue2 !== `undefined`) {
      const { expression, compareOptions } = orderBy2[0];
      const operator = compareOptions.direction === `asc` ? gt : lt;
      const valueFilter = operator(expression, new Value(minValue2));
      whereWithValueFilter = where ? and(where, valueFilter) : valueFilter;
    }
    const loadOptions1 = {
      where: whereWithValueFilter,
      limit,
      orderBy: orderBy2,
      subscription: this
    };
    const syncResult = this.collection._sync.loadSubset(loadOptions1);
    this.loadedSubsets.push(loadOptions1);
    const promises = [];
    if (typeof minValue2 !== `undefined`) {
      const { expression } = orderBy2[0];
      const exactValueFilter = eq(expression, new Value(minValue2));
      const loadOptions2 = {
        where: exactValueFilter,
        subscription: this
      };
      const equalValueResult = this.collection._sync.loadSubset(loadOptions2);
      this.loadedSubsets.push(loadOptions2);
      if (equalValueResult instanceof Promise) {
        promises.push(equalValueResult);
      }
    }
    if (syncResult instanceof Promise) {
      promises.push(syncResult);
    }
    if (promises.length > 0) {
      const combinedPromise = Promise.all(promises).then(() => {
      });
      this.trackLoadSubsetPromise(combinedPromise);
    } else {
      this.trackLoadSubsetPromise(syncResult);
    }
  }
  // TODO: also add similar test but that checks that it can also load it from the collection's loadSubset function
  //       and that that also works properly (i.e. does not skip duplicate values)
  /**
   * Filters and flips changes for keys that have not been sent yet.
   * Deletes are filtered out for keys that have not been sent yet.
   * Updates are flipped into inserts for keys that have not been sent yet.
   */
  filterAndFlipChanges(changes) {
    if (this.loadedInitialState) {
      return changes;
    }
    const newChanges = [];
    for (const change of changes) {
      let newChange = change;
      if (!this.sentKeys.has(change.key)) {
        if (change.type === `update`) {
          newChange = { ...change, type: `insert`, previousValue: void 0 };
        } else if (change.type === `delete`) {
          continue;
        }
        this.sentKeys.add(change.key);
      }
      newChanges.push(newChange);
    }
    return newChanges;
  }
  trackSentKeys(changes) {
    if (this.loadedInitialState) {
      return;
    }
    for (const change of changes) {
      this.sentKeys.add(change.key);
    }
  }
  unsubscribe() {
    for (const options of this.loadedSubsets) {
      this.collection._sync.unloadSubset(options);
    }
    this.loadedSubsets = [];
    this.emitInner(`unsubscribed`, {
      type: `unsubscribed`,
      subscription: this
    });
    this.clearListeners();
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/changes.js
var CollectionChangesManager = class {
  /**
   * Creates a new CollectionChangesManager instance
   */
  constructor() {
    this.activeSubscribersCount = 0;
    this.changeSubscriptions = /* @__PURE__ */ new Set();
    this.batchedEvents = [];
    this.shouldBatchEvents = false;
  }
  setDeps(deps) {
    this.lifecycle = deps.lifecycle;
    this.sync = deps.sync;
    this.events = deps.events;
    this.collection = deps.collection;
  }
  /**
   * Emit an empty ready event to notify subscribers that the collection is ready
   * This bypasses the normal empty array check in emitEvents
   */
  emitEmptyReadyEvent() {
    for (const subscription of this.changeSubscriptions) {
      subscription.emitEvents([]);
    }
  }
  /**
   * Emit events either immediately or batch them for later emission
   */
  emitEvents(changes, forceEmit = false) {
    if (this.shouldBatchEvents && !forceEmit) {
      this.batchedEvents.push(...changes);
      return;
    }
    let eventsToEmit = changes;
    if (forceEmit) {
      if (this.batchedEvents.length > 0) {
        eventsToEmit = [...this.batchedEvents, ...changes];
      }
      this.batchedEvents = [];
      this.shouldBatchEvents = false;
    }
    if (eventsToEmit.length === 0) {
      return;
    }
    for (const subscription of this.changeSubscriptions) {
      subscription.emitEvents(eventsToEmit);
    }
  }
  /**
   * Subscribe to changes in the collection
   */
  subscribeChanges(callback, options = {}) {
    this.addSubscriber();
    const subscription = new CollectionSubscription(this.collection, callback, {
      ...options,
      onUnsubscribe: () => {
        this.removeSubscriber();
        this.changeSubscriptions.delete(subscription);
      }
    });
    if (options.includeInitialState) {
      subscription.requestSnapshot({ trackLoadSubsetPromise: false });
    }
    this.changeSubscriptions.add(subscription);
    return subscription;
  }
  /**
   * Increment the active subscribers count and start sync if needed
   */
  addSubscriber() {
    const previousSubscriberCount = this.activeSubscribersCount;
    this.activeSubscribersCount++;
    this.lifecycle.cancelGCTimer();
    if (this.lifecycle.status === `cleaned-up` || this.lifecycle.status === `idle`) {
      this.sync.startSync();
    }
    this.events.emitSubscribersChange(
      this.activeSubscribersCount,
      previousSubscriberCount
    );
  }
  /**
   * Decrement the active subscribers count and start GC timer if needed
   */
  removeSubscriber() {
    const previousSubscriberCount = this.activeSubscribersCount;
    this.activeSubscribersCount--;
    if (this.activeSubscribersCount === 0) {
      this.lifecycle.startGCTimer();
    } else if (this.activeSubscribersCount < 0) {
      throw new NegativeActiveSubscribersError();
    }
    this.events.emitSubscribersChange(
      this.activeSubscribersCount,
      previousSubscriberCount
    );
  }
  /**
   * Clean up the collection by stopping sync and clearing data
   * This can be called manually or automatically by garbage collection
   */
  cleanup() {
    this.batchedEvents = [];
    this.shouldBatchEvents = false;
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/utils/browser-polyfills.js
var requestIdleCallbackPolyfill = (callback) => {
  const timeout = 0;
  const timeoutId = setTimeout(() => {
    callback({
      didTimeout: true,
      // Always indicate timeout for the polyfill
      timeRemaining: () => 50
      // Return some time remaining for polyfill
    });
  }, timeout);
  return timeoutId;
};
var cancelIdleCallbackPolyfill = (id) => {
  clearTimeout(id);
};
var safeRequestIdleCallback = typeof window !== `undefined` && `requestIdleCallback` in window ? (callback, options) => window.requestIdleCallback(callback, options) : (callback, _options) => requestIdleCallbackPolyfill(callback);
var safeCancelIdleCallback = typeof window !== `undefined` && `cancelIdleCallback` in window ? (id) => window.cancelIdleCallback(id) : cancelIdleCallbackPolyfill;

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/lifecycle.js
var CollectionLifecycleManager = class {
  /**
   * Creates a new CollectionLifecycleManager instance
   */
  constructor(config, id) {
    this.status = `idle`;
    this.hasBeenReady = false;
    this.hasReceivedFirstCommit = false;
    this.onFirstReadyCallbacks = [];
    this.gcTimeoutId = null;
    this.idleCallbackId = null;
    this.config = config;
    this.id = id;
  }
  setDeps(deps) {
    this.indexes = deps.indexes;
    this.events = deps.events;
    this.changes = deps.changes;
    this.sync = deps.sync;
    this.state = deps.state;
  }
  /**
   * Validates state transitions to prevent invalid status changes
   */
  validateStatusTransition(from, to) {
    if (from === to) {
      return;
    }
    const validTransitions = {
      idle: [`loading`, `error`, `cleaned-up`],
      loading: [`ready`, `error`, `cleaned-up`],
      ready: [`cleaned-up`, `error`],
      error: [`cleaned-up`, `idle`],
      "cleaned-up": [`loading`, `error`]
    };
    if (!validTransitions[from].includes(to)) {
      throw new InvalidCollectionStatusTransitionError(from, to, this.id);
    }
  }
  /**
   * Safely update the collection status with validation
   * @private
   */
  setStatus(newStatus, allowReady = false) {
    if (newStatus === `ready` && !allowReady) {
      throw new CollectionStateError(
        `You can't directly call "setStatus('ready'). You must use markReady instead.`
      );
    }
    this.validateStatusTransition(this.status, newStatus);
    const previousStatus = this.status;
    this.status = newStatus;
    if (newStatus === `ready` && !this.indexes.isIndexesResolved) {
      this.indexes.resolveAllIndexes().catch((error) => {
        console.warn(
          `${this.config.id ? `[${this.config.id}] ` : ``}Failed to resolve indexes:`,
          error
        );
      });
    }
    this.events.emitStatusChange(newStatus, previousStatus);
  }
  /**
   * Validates that the collection is in a usable state for data operations
   * @private
   */
  validateCollectionUsable(operation) {
    switch (this.status) {
      case `error`:
        throw new CollectionInErrorStateError(operation, this.id);
      case `cleaned-up`:
        this.sync.startSync();
        break;
    }
  }
  /**
   * Mark the collection as ready for use
   * This is called by sync implementations to explicitly signal that the collection is ready,
   * providing a more intuitive alternative to using commits for readiness signaling
   * @private - Should only be called by sync implementations
   */
  markReady() {
    this.validateStatusTransition(this.status, `ready`);
    if (this.status === `loading`) {
      this.setStatus(`ready`, true);
      if (!this.hasBeenReady) {
        this.hasBeenReady = true;
        if (!this.hasReceivedFirstCommit) {
          this.hasReceivedFirstCommit = true;
        }
        const callbacks = [...this.onFirstReadyCallbacks];
        this.onFirstReadyCallbacks = [];
        callbacks.forEach((callback) => callback());
      }
      if (this.changes.changeSubscriptions.size > 0) {
        this.changes.emitEmptyReadyEvent();
      }
    }
  }
  /**
   * Start the garbage collection timer
   * Called when the collection becomes inactive (no subscribers)
   */
  startGCTimer() {
    if (this.gcTimeoutId) {
      clearTimeout(this.gcTimeoutId);
    }
    const gcTime = this.config.gcTime ?? 3e5;
    if (gcTime === 0) {
      return;
    }
    this.gcTimeoutId = setTimeout(() => {
      if (this.changes.activeSubscribersCount === 0) {
        this.scheduleIdleCleanup();
      }
    }, gcTime);
  }
  /**
   * Cancel the garbage collection timer
   * Called when the collection becomes active again
   */
  cancelGCTimer() {
    if (this.gcTimeoutId) {
      clearTimeout(this.gcTimeoutId);
      this.gcTimeoutId = null;
    }
    if (this.idleCallbackId !== null) {
      safeCancelIdleCallback(this.idleCallbackId);
      this.idleCallbackId = null;
    }
  }
  /**
   * Schedule cleanup to run during browser idle time
   * This prevents blocking the UI thread during cleanup operations
   */
  scheduleIdleCleanup() {
    if (this.idleCallbackId !== null) {
      safeCancelIdleCallback(this.idleCallbackId);
    }
    this.idleCallbackId = safeRequestIdleCallback(
      (deadline) => {
        if (this.changes.activeSubscribersCount === 0) {
          const cleanupCompleted = this.performCleanup(deadline);
          if (cleanupCompleted) {
            this.idleCallbackId = null;
          }
        } else {
          this.idleCallbackId = null;
        }
      },
      { timeout: 1e3 }
    );
  }
  /**
   * Perform cleanup operations, optionally in chunks during idle time
   * @returns true if cleanup was completed, false if it was rescheduled
   */
  performCleanup(deadline) {
    const hasTime = !deadline || deadline.timeRemaining() > 0 || deadline.didTimeout;
    if (hasTime) {
      this.sync.cleanup();
      this.state.cleanup();
      this.changes.cleanup();
      this.indexes.cleanup();
      if (this.gcTimeoutId) {
        clearTimeout(this.gcTimeoutId);
        this.gcTimeoutId = null;
      }
      this.hasBeenReady = false;
      this.onFirstReadyCallbacks = [];
      this.setStatus(`cleaned-up`);
      this.events.cleanup();
      return true;
    } else {
      this.scheduleIdleCleanup();
      return false;
    }
  }
  /**
   * Register a callback to be executed when the collection first becomes ready
   * Useful for preloading collections
   * @param callback Function to call when the collection first becomes ready
   */
  onFirstReady(callback) {
    if (this.hasBeenReady) {
      callback();
      return;
    }
    this.onFirstReadyCallbacks.push(callback);
  }
  cleanup() {
    if (this.idleCallbackId !== null) {
      safeCancelIdleCallback(this.idleCallbackId);
      this.idleCallbackId = null;
    }
    this.performCleanup();
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/live/internal.js
var LIVE_QUERY_INTERNAL = Symbol(`liveQueryInternal`);

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/sync.js
var CollectionSyncManager = class {
  /**
   * Creates a new CollectionSyncManager instance
   */
  constructor(config, id) {
    this.preloadPromise = null;
    this.syncCleanupFn = null;
    this.syncLoadSubsetFn = null;
    this.syncUnloadSubsetFn = null;
    this.pendingLoadSubsetPromises = /* @__PURE__ */ new Set();
    this.config = config;
    this.id = id;
    this.syncMode = config.syncMode ?? `eager`;
  }
  setDeps(deps) {
    this.collection = deps.collection;
    this.state = deps.state;
    this.lifecycle = deps.lifecycle;
    this._events = deps.events;
  }
  /**
   * Start the sync process for this collection
   * This is called when the collection is first accessed or preloaded
   */
  startSync() {
    if (this.lifecycle.status !== `idle` && this.lifecycle.status !== `cleaned-up`) {
      return;
    }
    this.lifecycle.setStatus(`loading`);
    try {
      const syncRes = normalizeSyncFnResult(
        this.config.sync.sync({
          collection: this.collection,
          begin: () => {
            this.state.pendingSyncedTransactions.push({
              committed: false,
              operations: [],
              deletedKeys: /* @__PURE__ */ new Set()
            });
          },
          write: (messageWithoutKey) => {
            const pendingTransaction = this.state.pendingSyncedTransactions[this.state.pendingSyncedTransactions.length - 1];
            if (!pendingTransaction) {
              throw new NoPendingSyncTransactionWriteError();
            }
            if (pendingTransaction.committed) {
              throw new SyncTransactionAlreadyCommittedWriteError();
            }
            const key = this.config.getKey(messageWithoutKey.value);
            let messageType = messageWithoutKey.type;
            if (messageWithoutKey.type === `insert`) {
              const insertingIntoExistingSynced = this.state.syncedData.has(key);
              const hasPendingDeleteForKey = pendingTransaction.deletedKeys.has(key);
              const isTruncateTransaction = pendingTransaction.truncate === true;
              if (insertingIntoExistingSynced && !hasPendingDeleteForKey && !isTruncateTransaction) {
                const existingValue = this.state.syncedData.get(key);
                if (existingValue !== void 0 && deepEquals(existingValue, messageWithoutKey.value)) {
                  messageType = `update`;
                } else {
                  const utils = this.config.utils;
                  const internal = utils[LIVE_QUERY_INTERNAL];
                  throw new DuplicateKeySyncError(key, this.id, {
                    hasCustomGetKey: (internal == null ? void 0 : internal.hasCustomGetKey) ?? false,
                    hasJoins: (internal == null ? void 0 : internal.hasJoins) ?? false
                  });
                }
              }
            }
            const message = {
              ...messageWithoutKey,
              type: messageType,
              key
            };
            pendingTransaction.operations.push(message);
            if (messageType === `delete`) {
              pendingTransaction.deletedKeys.add(key);
            }
          },
          commit: () => {
            const pendingTransaction = this.state.pendingSyncedTransactions[this.state.pendingSyncedTransactions.length - 1];
            if (!pendingTransaction) {
              throw new NoPendingSyncTransactionCommitError();
            }
            if (pendingTransaction.committed) {
              throw new SyncTransactionAlreadyCommittedError();
            }
            pendingTransaction.committed = true;
            this.state.commitPendingTransactions();
          },
          markReady: () => {
            this.lifecycle.markReady();
          },
          truncate: () => {
            const pendingTransaction = this.state.pendingSyncedTransactions[this.state.pendingSyncedTransactions.length - 1];
            if (!pendingTransaction) {
              throw new NoPendingSyncTransactionWriteError();
            }
            if (pendingTransaction.committed) {
              throw new SyncTransactionAlreadyCommittedWriteError();
            }
            pendingTransaction.operations = [];
            pendingTransaction.deletedKeys.clear();
            pendingTransaction.truncate = true;
            pendingTransaction.optimisticSnapshot = {
              upserts: new Map(this.state.optimisticUpserts),
              deletes: new Set(this.state.optimisticDeletes)
            };
          }
        })
      );
      this.syncCleanupFn = (syncRes == null ? void 0 : syncRes.cleanup) ?? null;
      this.syncLoadSubsetFn = (syncRes == null ? void 0 : syncRes.loadSubset) ?? null;
      this.syncUnloadSubsetFn = (syncRes == null ? void 0 : syncRes.unloadSubset) ?? null;
      if (this.syncMode === `on-demand` && !this.syncLoadSubsetFn) {
        throw new CollectionConfigurationError(
          `Collection "${this.id}" is configured with syncMode "on-demand" but the sync function did not return a loadSubset handler. Either provide a loadSubset handler or use syncMode "eager".`
        );
      }
    } catch (error) {
      this.lifecycle.setStatus(`error`);
      throw error;
    }
  }
  /**
   * Preload the collection data by starting sync if not already started
   * Multiple concurrent calls will share the same promise
   */
  preload() {
    if (this.preloadPromise) {
      return this.preloadPromise;
    }
    if (this.syncMode === `on-demand`) {
      console.warn(
        `${this.id ? `[${this.id}] ` : ``}Calling .preload() on a collection with syncMode "on-demand" is a no-op. In on-demand mode, data is only loaded when queries request it. Instead, create a live query and call .preload() on that to load the specific data you need. See https://tanstack.com/blog/tanstack-db-0.5-query-driven-sync for more details.`
      );
    }
    this.preloadPromise = new Promise((resolve, reject) => {
      if (this.lifecycle.status === `ready`) {
        resolve();
        return;
      }
      if (this.lifecycle.status === `error`) {
        reject(new CollectionIsInErrorStateError());
        return;
      }
      this.lifecycle.onFirstReady(() => {
        resolve();
      });
      if (this.lifecycle.status === `idle` || this.lifecycle.status === `cleaned-up`) {
        try {
          this.startSync();
        } catch (error) {
          reject(error);
          return;
        }
      }
    });
    return this.preloadPromise;
  }
  /**
   * Gets whether the collection is currently loading more data
   */
  get isLoadingSubset() {
    return this.pendingLoadSubsetPromises.size > 0;
  }
  /**
   * Tracks a load promise for isLoadingSubset state.
   * @internal This is for internal coordination (e.g., live-query glue code), not for general use.
   */
  trackLoadPromise(promise) {
    const loadingStarting = !this.isLoadingSubset;
    this.pendingLoadSubsetPromises.add(promise);
    if (loadingStarting) {
      this._events.emit(`loadingSubset:change`, {
        type: `loadingSubset:change`,
        collection: this.collection,
        isLoadingSubset: true,
        previousIsLoadingSubset: false,
        loadingSubsetTransition: `start`
      });
    }
    promise.finally(() => {
      const loadingEnding = this.pendingLoadSubsetPromises.size === 1 && this.pendingLoadSubsetPromises.has(promise);
      this.pendingLoadSubsetPromises.delete(promise);
      if (loadingEnding) {
        this._events.emit(`loadingSubset:change`, {
          type: `loadingSubset:change`,
          collection: this.collection,
          isLoadingSubset: false,
          previousIsLoadingSubset: true,
          loadingSubsetTransition: `end`
        });
      }
    });
  }
  /**
   * Requests the sync layer to load more data.
   * @param options Options to control what data is being loaded
   * @returns If data loading is asynchronous, this method returns a promise that resolves when the data is loaded.
   *          Returns true if no sync function is configured, if syncMode is 'eager', or if there is no work to do.
   */
  loadSubset(options) {
    if (this.syncMode === `eager`) {
      return true;
    }
    if (this.syncLoadSubsetFn) {
      const result = this.syncLoadSubsetFn(options);
      if (result instanceof Promise) {
        this.trackLoadPromise(result);
        return result;
      }
    }
    return true;
  }
  /**
   * Notifies the sync layer that a subset is no longer needed.
   * @param options Options that identify what data is being unloaded
   */
  unloadSubset(options) {
    if (this.syncUnloadSubsetFn) {
      this.syncUnloadSubsetFn(options);
    }
  }
  cleanup() {
    try {
      if (this.syncCleanupFn) {
        this.syncCleanupFn();
        this.syncCleanupFn = null;
      }
    } catch (error) {
      queueMicrotask(() => {
        if (error instanceof Error) {
          const wrappedError = new SyncCleanupError(this.id, error);
          wrappedError.cause = error;
          wrappedError.stack = error.stack;
          throw wrappedError;
        } else {
          throw new SyncCleanupError(this.id, error);
        }
      });
    }
    this.preloadPromise = null;
  }
};
function normalizeSyncFnResult(result) {
  if (typeof result === `function`) {
    return { cleanup: result };
  }
  if (typeof result === `object`) {
    return result;
  }
  return void 0;
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/indexes.js
var CollectionIndexesManager = class {
  constructor() {
    this.lazyIndexes = /* @__PURE__ */ new Map();
    this.resolvedIndexes = /* @__PURE__ */ new Map();
    this.isIndexesResolved = false;
    this.indexCounter = 0;
  }
  setDeps(deps) {
    this.state = deps.state;
    this.lifecycle = deps.lifecycle;
  }
  /**
   * Creates an index on a collection for faster queries.
   */
  createIndex(indexCallback, config = {}) {
    this.lifecycle.validateCollectionUsable(`createIndex`);
    const indexId = ++this.indexCounter;
    const singleRowRefProxy = createSingleRowRefProxy();
    const indexExpression = indexCallback(singleRowRefProxy);
    const expression = toExpression(indexExpression);
    const resolver = config.indexType ?? BTreeIndex;
    const lazyIndex = new LazyIndexWrapper(
      indexId,
      expression,
      config.name,
      resolver,
      config.options,
      this.state.entries()
    );
    this.lazyIndexes.set(indexId, lazyIndex);
    if (resolver === BTreeIndex) {
      try {
        const resolvedIndex = lazyIndex.getResolved();
        this.resolvedIndexes.set(indexId, resolvedIndex);
      } catch (error) {
        console.warn(`Failed to resolve BTreeIndex:`, error);
      }
    } else if (typeof resolver === `function` && resolver.prototype) {
      try {
        const resolvedIndex = lazyIndex.getResolved();
        this.resolvedIndexes.set(indexId, resolvedIndex);
      } catch {
        this.resolveSingleIndex(indexId, lazyIndex).catch((error) => {
          console.warn(`Failed to resolve single index:`, error);
        });
      }
    } else if (this.isIndexesResolved) {
      this.resolveSingleIndex(indexId, lazyIndex).catch((error) => {
        console.warn(`Failed to resolve single index:`, error);
      });
    }
    return new IndexProxy(indexId, lazyIndex);
  }
  /**
   * Resolve all lazy indexes (called when collection first syncs)
   */
  async resolveAllIndexes() {
    if (this.isIndexesResolved) return;
    const resolutionPromises = Array.from(this.lazyIndexes.entries()).map(
      async ([indexId, lazyIndex]) => {
        const resolvedIndex = await lazyIndex.resolve();
        resolvedIndex.build(this.state.entries());
        this.resolvedIndexes.set(indexId, resolvedIndex);
        return { indexId, resolvedIndex };
      }
    );
    await Promise.all(resolutionPromises);
    this.isIndexesResolved = true;
  }
  /**
   * Resolve a single index immediately
   */
  async resolveSingleIndex(indexId, lazyIndex) {
    const resolvedIndex = await lazyIndex.resolve();
    resolvedIndex.build(this.state.entries());
    this.resolvedIndexes.set(indexId, resolvedIndex);
    return resolvedIndex;
  }
  /**
   * Get resolved indexes for query optimization
   */
  get indexes() {
    return this.resolvedIndexes;
  }
  /**
   * Updates all indexes when the collection changes
   */
  updateIndexes(changes) {
    for (const index of this.resolvedIndexes.values()) {
      for (const change of changes) {
        switch (change.type) {
          case `insert`:
            index.add(change.key, change.value);
            break;
          case `update`:
            if (change.previousValue) {
              index.update(change.key, change.previousValue, change.value);
            } else {
              index.add(change.key, change.value);
            }
            break;
          case `delete`:
            index.remove(change.key, change.value);
            break;
        }
      }
    }
  }
  /**
   * Clean up the collection by stopping sync and clearing data
   * This can be called manually or automatically by garbage collection
   */
  cleanup() {
    this.lazyIndexes.clear();
    this.resolvedIndexes.clear();
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/mutations.js
var CollectionMutationsManager = class {
  constructor(config, id) {
    this.insert = (data, config2) => {
      this.lifecycle.validateCollectionUsable(`insert`);
      const state = this.state;
      const ambientTransaction = getActiveTransaction();
      if (!ambientTransaction && !this.config.onInsert) {
        throw new MissingInsertHandlerError();
      }
      const items = Array.isArray(data) ? data : [data];
      const mutations = [];
      items.forEach((item) => {
        var _a, _b;
        const validatedData = this.validateData(item, `insert`);
        const key = this.config.getKey(validatedData);
        if (this.state.has(key)) {
          throw new DuplicateKeyError(key);
        }
        const globalKey = this.generateGlobalKey(key, item);
        const mutation = {
          mutationId: crypto.randomUUID(),
          original: {},
          modified: validatedData,
          // Pick the values from validatedData based on what's passed in - this is for cases
          // where a schema has default values. The validated data has the extra default
          // values but for changes, we just want to show the data that was actually passed in.
          changes: Object.fromEntries(
            Object.keys(item).map((k) => [
              k,
              validatedData[k]
            ])
          ),
          globalKey,
          key,
          metadata: config2 == null ? void 0 : config2.metadata,
          syncMetadata: ((_b = (_a = this.config.sync).getSyncMetadata) == null ? void 0 : _b.call(_a)) || {},
          optimistic: (config2 == null ? void 0 : config2.optimistic) ?? true,
          type: `insert`,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          collection: this.collection
        };
        mutations.push(mutation);
      });
      if (ambientTransaction) {
        ambientTransaction.applyMutations(mutations);
        state.transactions.set(ambientTransaction.id, ambientTransaction);
        state.scheduleTransactionCleanup(ambientTransaction);
        state.recomputeOptimisticState(true);
        return ambientTransaction;
      } else {
        const directOpTransaction = createTransaction({
          mutationFn: async (params) => {
            return await this.config.onInsert({
              transaction: params.transaction,
              collection: this.collection
            });
          }
        });
        directOpTransaction.applyMutations(mutations);
        directOpTransaction.commit().catch(() => void 0);
        state.transactions.set(directOpTransaction.id, directOpTransaction);
        state.scheduleTransactionCleanup(directOpTransaction);
        state.recomputeOptimisticState(true);
        return directOpTransaction;
      }
    };
    this.delete = (keys, config2) => {
      const state = this.state;
      this.lifecycle.validateCollectionUsable(`delete`);
      const ambientTransaction = getActiveTransaction();
      if (!ambientTransaction && !this.config.onDelete) {
        throw new MissingDeleteHandlerError();
      }
      if (Array.isArray(keys) && keys.length === 0) {
        throw new NoKeysPassedToDeleteError();
      }
      const keysArray = Array.isArray(keys) ? keys : [keys];
      const mutations = [];
      for (const key of keysArray) {
        if (!this.state.has(key)) {
          throw new DeleteKeyNotFoundError(key);
        }
        const globalKey = this.generateGlobalKey(key, this.state.get(key));
        const mutation = {
          mutationId: crypto.randomUUID(),
          original: this.state.get(key),
          modified: this.state.get(key),
          changes: this.state.get(key),
          globalKey,
          key,
          metadata: config2 == null ? void 0 : config2.metadata,
          syncMetadata: state.syncedMetadata.get(key) || {},
          optimistic: (config2 == null ? void 0 : config2.optimistic) ?? true,
          type: `delete`,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          collection: this.collection
        };
        mutations.push(mutation);
      }
      if (ambientTransaction) {
        ambientTransaction.applyMutations(mutations);
        state.transactions.set(ambientTransaction.id, ambientTransaction);
        state.scheduleTransactionCleanup(ambientTransaction);
        state.recomputeOptimisticState(true);
        return ambientTransaction;
      }
      const directOpTransaction = createTransaction({
        autoCommit: true,
        mutationFn: async (params) => {
          return this.config.onDelete({
            transaction: params.transaction,
            collection: this.collection
          });
        }
      });
      directOpTransaction.applyMutations(mutations);
      directOpTransaction.commit().catch(() => void 0);
      state.transactions.set(directOpTransaction.id, directOpTransaction);
      state.scheduleTransactionCleanup(directOpTransaction);
      state.recomputeOptimisticState(true);
      return directOpTransaction;
    };
    this.id = id;
    this.config = config;
  }
  setDeps(deps) {
    this.lifecycle = deps.lifecycle;
    this.state = deps.state;
    this.collection = deps.collection;
  }
  ensureStandardSchema(schema) {
    if (schema && `~standard` in schema) {
      return schema;
    }
    throw new InvalidSchemaError();
  }
  validateData(data, type, key) {
    if (!this.config.schema) return data;
    const standardSchema = this.ensureStandardSchema(this.config.schema);
    if (type === `update` && key) {
      const existingData = this.state.get(key);
      if (existingData && data && typeof data === `object` && typeof existingData === `object`) {
        const mergedData = Object.assign({}, existingData, data);
        const result2 = standardSchema[`~standard`].validate(mergedData);
        if (result2 instanceof Promise) {
          throw new SchemaMustBeSynchronousError();
        }
        if (`issues` in result2 && result2.issues) {
          const typedIssues = result2.issues.map((issue) => {
            var _a;
            return {
              message: issue.message,
              path: (_a = issue.path) == null ? void 0 : _a.map((p) => String(p))
            };
          });
          throw new SchemaValidationError(type, typedIssues);
        }
        const validatedMergedData = result2.value;
        const modifiedKeys = Object.keys(data);
        const extractedChanges = Object.fromEntries(
          modifiedKeys.map((k) => [k, validatedMergedData[k]])
        );
        return extractedChanges;
      }
    }
    const result = standardSchema[`~standard`].validate(data);
    if (result instanceof Promise) {
      throw new SchemaMustBeSynchronousError();
    }
    if (`issues` in result && result.issues) {
      const typedIssues = result.issues.map((issue) => {
        var _a;
        return {
          message: issue.message,
          path: (_a = issue.path) == null ? void 0 : _a.map((p) => String(p))
        };
      });
      throw new SchemaValidationError(type, typedIssues);
    }
    return result.value;
  }
  generateGlobalKey(key, item) {
    if (typeof key === `undefined`) {
      throw new UndefinedKeyError(item);
    }
    return `KEY::${this.id}/${key}`;
  }
  /**
   * Updates one or more items in the collection using a callback function
   */
  update(keys, configOrCallback, maybeCallback) {
    if (typeof keys === `undefined`) {
      throw new MissingUpdateArgumentError();
    }
    const state = this.state;
    this.lifecycle.validateCollectionUsable(`update`);
    const ambientTransaction = getActiveTransaction();
    if (!ambientTransaction && !this.config.onUpdate) {
      throw new MissingUpdateHandlerError();
    }
    const isArray = Array.isArray(keys);
    const keysArray = isArray ? keys : [keys];
    if (isArray && keysArray.length === 0) {
      throw new NoKeysPassedToUpdateError();
    }
    const callback = typeof configOrCallback === `function` ? configOrCallback : maybeCallback;
    const config = typeof configOrCallback === `function` ? {} : configOrCallback;
    const currentObjects = keysArray.map((key) => {
      const item = this.state.get(key);
      if (!item) {
        throw new UpdateKeyNotFoundError(key);
      }
      return item;
    });
    let changesArray;
    if (isArray) {
      changesArray = withArrayChangeTracking(
        currentObjects,
        callback
      );
    } else {
      const result = withChangeTracking(
        currentObjects[0],
        callback
      );
      changesArray = [result];
    }
    const mutations = keysArray.map((key, index) => {
      const itemChanges = changesArray[index];
      if (!itemChanges || Object.keys(itemChanges).length === 0) {
        return null;
      }
      const originalItem = currentObjects[index];
      const validatedUpdatePayload = this.validateData(
        itemChanges,
        `update`,
        key
      );
      const modifiedItem = Object.assign(
        {},
        originalItem,
        validatedUpdatePayload
      );
      const originalItemId = this.config.getKey(originalItem);
      const modifiedItemId = this.config.getKey(modifiedItem);
      if (originalItemId !== modifiedItemId) {
        throw new KeyUpdateNotAllowedError(originalItemId, modifiedItemId);
      }
      const globalKey = this.generateGlobalKey(modifiedItemId, modifiedItem);
      return {
        mutationId: crypto.randomUUID(),
        original: originalItem,
        modified: modifiedItem,
        // Pick the values from modifiedItem based on what's passed in - this is for cases
        // where a schema has default values or transforms. The modified data has the extra
        // default or transformed values but for changes, we just want to show the data that
        // was actually passed in.
        changes: Object.fromEntries(
          Object.keys(itemChanges).map((k) => [
            k,
            modifiedItem[k]
          ])
        ),
        globalKey,
        key,
        metadata: config.metadata,
        syncMetadata: state.syncedMetadata.get(key) || {},
        optimistic: config.optimistic ?? true,
        type: `update`,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        collection: this.collection
      };
    }).filter(Boolean);
    if (mutations.length === 0) {
      const emptyTransaction = createTransaction({
        mutationFn: async () => {
        }
      });
      emptyTransaction.commit().catch(() => void 0);
      state.scheduleTransactionCleanup(emptyTransaction);
      return emptyTransaction;
    }
    if (ambientTransaction) {
      ambientTransaction.applyMutations(mutations);
      state.transactions.set(ambientTransaction.id, ambientTransaction);
      state.scheduleTransactionCleanup(ambientTransaction);
      state.recomputeOptimisticState(true);
      return ambientTransaction;
    }
    const directOpTransaction = createTransaction({
      mutationFn: async (params) => {
        return this.config.onUpdate({
          transaction: params.transaction,
          collection: this.collection
        });
      }
    });
    directOpTransaction.applyMutations(mutations);
    directOpTransaction.commit().catch(() => void 0);
    state.transactions.set(directOpTransaction.id, directOpTransaction);
    state.scheduleTransactionCleanup(directOpTransaction);
    state.recomputeOptimisticState(true);
    return directOpTransaction;
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/events.js
var CollectionEventsManager = class extends EventEmitter {
  constructor() {
    super();
  }
  setDeps(deps) {
    this.collection = deps.collection;
  }
  /**
   * Emit an event to all listeners
   * Public API for emitting collection events
   */
  emit(event, eventPayload) {
    this.emitInner(event, eventPayload);
  }
  emitStatusChange(status, previousStatus) {
    this.emit(`status:change`, {
      type: `status:change`,
      collection: this.collection,
      previousStatus,
      status
    });
    const eventKey = `status:${status}`;
    this.emit(eventKey, {
      type: eventKey,
      collection: this.collection,
      previousStatus,
      status
    });
  }
  emitSubscribersChange(subscriberCount, previousSubscriberCount) {
    this.emit(`subscribers:change`, {
      type: `subscribers:change`,
      collection: this.collection,
      previousSubscriberCount,
      subscriberCount
    });
  }
  cleanup() {
    this.clearListeners();
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/collection/index.js
function createCollection(options) {
  const collection = new CollectionImpl(
    options
  );
  if (options.utils) {
    collection.utils = options.utils;
  } else {
    collection.utils = {};
  }
  return collection;
}
var CollectionImpl = class {
  /**
   * Creates a new Collection instance
   *
   * @param config - Configuration object for the collection
   * @throws Error if sync config is missing
   */
  constructor(config) {
    this.utils = {};
    this.insert = (data, config2) => {
      return this._mutations.insert(data, config2);
    };
    this.delete = (keys, config2) => {
      return this._mutations.delete(keys, config2);
    };
    if (!config) {
      throw new CollectionRequiresConfigError();
    }
    if (!config.sync) {
      throw new CollectionRequiresSyncConfigError();
    }
    if (config.id) {
      this.id = config.id;
    } else {
      this.id = crypto.randomUUID();
    }
    this.config = {
      ...config,
      autoIndex: config.autoIndex ?? `eager`
    };
    this._changes = new CollectionChangesManager();
    this._events = new CollectionEventsManager();
    this._indexes = new CollectionIndexesManager();
    this._lifecycle = new CollectionLifecycleManager(config, this.id);
    this._mutations = new CollectionMutationsManager(config, this.id);
    this._state = new CollectionStateManager(config);
    this._sync = new CollectionSyncManager(config, this.id);
    this.comparisonOpts = buildCompareOptionsFromConfig(config);
    this._changes.setDeps({
      collection: this,
      // Required for passing to CollectionSubscription
      lifecycle: this._lifecycle,
      sync: this._sync,
      events: this._events
    });
    this._events.setDeps({
      collection: this
      // Required for adding to emitted events
    });
    this._indexes.setDeps({
      state: this._state,
      lifecycle: this._lifecycle
    });
    this._lifecycle.setDeps({
      changes: this._changes,
      events: this._events,
      indexes: this._indexes,
      state: this._state,
      sync: this._sync
    });
    this._mutations.setDeps({
      collection: this,
      // Required for passing to config.onInsert/onUpdate/onDelete and annotating mutations
      lifecycle: this._lifecycle,
      state: this._state
    });
    this._state.setDeps({
      collection: this,
      // Required for filtering events to only include this collection
      lifecycle: this._lifecycle,
      changes: this._changes,
      indexes: this._indexes
    });
    this._sync.setDeps({
      collection: this,
      // Required for passing to config.sync callback
      state: this._state,
      lifecycle: this._lifecycle,
      events: this._events
    });
    if (config.startSync === true) {
      this._sync.startSync();
    }
  }
  /**
   * Gets the current status of the collection
   */
  get status() {
    return this._lifecycle.status;
  }
  /**
   * Get the number of subscribers to the collection
   */
  get subscriberCount() {
    return this._changes.activeSubscribersCount;
  }
  /**
   * Register a callback to be executed when the collection first becomes ready
   * Useful for preloading collections
   * @param callback Function to call when the collection first becomes ready
   * @example
   * collection.onFirstReady(() => {
   *   console.log('Collection is ready for the first time')
   *   // Safe to access collection.state now
   * })
   */
  onFirstReady(callback) {
    return this._lifecycle.onFirstReady(callback);
  }
  /**
   * Check if the collection is ready for use
   * Returns true if the collection has been marked as ready by its sync implementation
   * @returns true if the collection is ready, false otherwise
   * @example
   * if (collection.isReady()) {
   *   console.log('Collection is ready, data is available')
   *   // Safe to access collection.state
   * } else {
   *   console.log('Collection is still loading')
   * }
   */
  isReady() {
    return this._lifecycle.status === `ready`;
  }
  /**
   * Check if the collection is currently loading more data
   * @returns true if the collection has pending load more operations, false otherwise
   */
  get isLoadingSubset() {
    return this._sync.isLoadingSubset;
  }
  /**
   * Start sync immediately - internal method for compiled queries
   * This bypasses lazy loading for special cases like live query results
   */
  startSyncImmediate() {
    this._sync.startSync();
  }
  /**
   * Preload the collection data by starting sync if not already started
   * Multiple concurrent calls will share the same promise
   */
  preload() {
    return this._sync.preload();
  }
  /**
   * Get the current value for a key (virtual derived state)
   */
  get(key) {
    return this._state.get(key);
  }
  /**
   * Check if a key exists in the collection (virtual derived state)
   */
  has(key) {
    return this._state.has(key);
  }
  /**
   * Get the current size of the collection (cached)
   */
  get size() {
    return this._state.size;
  }
  /**
   * Get all keys (virtual derived state)
   */
  *keys() {
    yield* this._state.keys();
  }
  /**
   * Get all values (virtual derived state)
   */
  *values() {
    yield* this._state.values();
  }
  /**
   * Get all entries (virtual derived state)
   */
  *entries() {
    yield* this._state.entries();
  }
  /**
   * Get all entries (virtual derived state)
   */
  *[Symbol.iterator]() {
    yield* this._state[Symbol.iterator]();
  }
  /**
   * Execute a callback for each entry in the collection
   */
  forEach(callbackfn) {
    return this._state.forEach(callbackfn);
  }
  /**
   * Create a new array with the results of calling a function for each entry in the collection
   */
  map(callbackfn) {
    return this._state.map(callbackfn);
  }
  getKeyFromItem(item) {
    return this.config.getKey(item);
  }
  /**
   * Creates an index on a collection for faster queries.
   * Indexes significantly improve query performance by allowing constant time lookups
   * and logarithmic time range queries instead of full scans.
   *
   * @template TResolver - The type of the index resolver (constructor or async loader)
   * @param indexCallback - Function that extracts the indexed value from each item
   * @param config - Configuration including index type and type-specific options
   * @returns An index proxy that provides access to the index when ready
   *
   * @example
   * // Create a default B+ tree index
   * const ageIndex = collection.createIndex((row) => row.age)
   *
   * // Create a ordered index with custom options
   * const ageIndex = collection.createIndex((row) => row.age, {
   *   indexType: BTreeIndex,
   *   options: {
   *     compareFn: customComparator,
   *     compareOptions: { direction: 'asc', nulls: 'first', stringSort: 'lexical' }
   *   },
   *   name: 'age_btree'
   * })
   *
   * // Create an async-loaded index
   * const textIndex = collection.createIndex((row) => row.content, {
   *   indexType: async () => {
   *     const { FullTextIndex } = await import('./indexes/fulltext.js')
   *     return FullTextIndex
   *   },
   *   options: { language: 'en' }
   * })
   */
  createIndex(indexCallback, config = {}) {
    return this._indexes.createIndex(indexCallback, config);
  }
  /**
   * Get resolved indexes for query optimization
   */
  get indexes() {
    return this._indexes.indexes;
  }
  /**
   * Validates the data against the schema
   */
  validateData(data, type, key) {
    return this._mutations.validateData(data, type, key);
  }
  get compareOptions() {
    return { ...this.comparisonOpts };
  }
  update(keys, configOrCallback, maybeCallback) {
    return this._mutations.update(keys, configOrCallback, maybeCallback);
  }
  /**
   * Gets the current state of the collection as a Map
   * @returns Map containing all items in the collection, with keys as identifiers
   * @example
   * const itemsMap = collection.state
   * console.log(`Collection has ${itemsMap.size} items`)
   *
   * for (const [key, item] of itemsMap) {
   *   console.log(`${key}: ${item.title}`)
   * }
   *
   * // Check if specific item exists
   * if (itemsMap.has("todo-1")) {
   *   console.log("Todo 1 exists:", itemsMap.get("todo-1"))
   * }
   */
  get state() {
    const result = /* @__PURE__ */ new Map();
    for (const [key, value] of this.entries()) {
      result.set(key, value);
    }
    return result;
  }
  /**
   * Gets the current state of the collection as a Map, but only resolves when data is available
   * Waits for the first sync commit to complete before resolving
   *
   * @returns Promise that resolves to a Map containing all items in the collection
   */
  stateWhenReady() {
    if (this.size > 0 || this.isReady()) {
      return Promise.resolve(this.state);
    }
    return this.preload().then(() => this.state);
  }
  /**
   * Gets the current state of the collection as an Array
   *
   * @returns An Array containing all items in the collection
   */
  get toArray() {
    return Array.from(this.values());
  }
  /**
   * Gets the current state of the collection as an Array, but only resolves when data is available
   * Waits for the first sync commit to complete before resolving
   *
   * @returns Promise that resolves to an Array containing all items in the collection
   */
  toArrayWhenReady() {
    if (this.size > 0 || this.isReady()) {
      return Promise.resolve(this.toArray);
    }
    return this.preload().then(() => this.toArray);
  }
  /**
   * Returns the current state of the collection as an array of changes
   * @param options - Options including optional where filter
   * @returns An array of changes
   * @example
   * // Get all items as changes
   * const allChanges = collection.currentStateAsChanges()
   *
   * // Get only items matching a condition
   * const activeChanges = collection.currentStateAsChanges({
   *   where: (row) => row.status === 'active'
   * })
   *
   * // Get only items using a pre-compiled expression
   * const activeChanges = collection.currentStateAsChanges({
   *   whereExpression: eq(row.status, 'active')
   * })
   */
  currentStateAsChanges(options = {}) {
    return currentStateAsChanges(this, options);
  }
  /**
   * Subscribe to changes in the collection
   * @param callback - Function called when items change
   * @param options - Subscription options including includeInitialState and where filter
   * @returns Unsubscribe function - Call this to stop listening for changes
   * @example
   * // Basic subscription
   * const subscription = collection.subscribeChanges((changes) => {
   *   changes.forEach(change => {
   *     console.log(`${change.type}: ${change.key}`, change.value)
   *   })
   * })
   *
   * // Later: subscription.unsubscribe()
   *
   * @example
   * // Include current state immediately
   * const subscription = collection.subscribeChanges((changes) => {
   *   updateUI(changes)
   * }, { includeInitialState: true })
   *
   * @example
   * // Subscribe only to changes matching a condition
   * const subscription = collection.subscribeChanges((changes) => {
   *   updateUI(changes)
   * }, {
   *   includeInitialState: true,
   *   where: (row) => row.status === 'active'
   * })
   *
   * @example
   * // Subscribe using a pre-compiled expression
   * const subscription = collection.subscribeChanges((changes) => {
   *   updateUI(changes)
   * }, {
   *   includeInitialState: true,
   *   whereExpression: eq(row.status, 'active')
   * })
   */
  subscribeChanges(callback, options = {}) {
    return this._changes.subscribeChanges(callback, options);
  }
  /**
   * Subscribe to a collection event
   */
  on(event, callback) {
    return this._events.on(event, callback);
  }
  /**
   * Subscribe to a collection event once
   */
  once(event, callback) {
    return this._events.once(event, callback);
  }
  /**
   * Unsubscribe from a collection event
   */
  off(event, callback) {
    this._events.off(event, callback);
  }
  /**
   * Wait for a collection event
   */
  waitFor(event, timeout) {
    return this._events.waitFor(event, timeout);
  }
  /**
   * Clean up the collection by stopping sync and clearing data
   * This can be called manually or automatically by garbage collection
   */
  async cleanup() {
    this._lifecycle.cleanup();
    return Promise.resolve();
  }
};
function buildCompareOptionsFromConfig(config) {
  if (config.defaultStringCollation) {
    const options = config.defaultStringCollation;
    return {
      stringSort: options.stringSort ?? `locale`,
      locale: options.stringSort === `locale` ? options.locale : void 0,
      localeOptions: options.stringSort === `locale` ? options.localeOptions : void 0
    };
  } else {
    return {
      stringSort: `locale`
    };
  }
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/utils/type-guards.js
function isPromiseLike(value) {
  return !!value && (typeof value === `object` || typeof value === `function`) && typeof value.then === `function`;
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/optimistic-action.js
function createOptimisticAction(options) {
  const { mutationFn, onMutate, ...config } = options;
  return (variables) => {
    const transaction = createTransaction({
      ...config,
      // Wire the mutationFn to use the provided variables
      mutationFn: async (params) => {
        return await mutationFn(variables, params);
      }
    });
    transaction.mutate(() => {
      const maybePromise = onMutate(variables);
      if (isPromiseLike(maybePromise)) {
        throw new OnMutateMustBeSynchronousError();
      }
    });
    return transaction;
  };
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/local-only.js
function localOnlyCollectionOptions(config) {
  const { initialData, onInsert, onUpdate, onDelete, ...restConfig } = config;
  const syncResult = createLocalOnlySync(initialData);
  const wrappedOnInsert = async (params) => {
    let handlerResult;
    if (onInsert) {
      handlerResult = await onInsert(params) ?? {};
    }
    syncResult.confirmOperationsSync(params.transaction.mutations);
    return handlerResult;
  };
  const wrappedOnUpdate = async (params) => {
    let handlerResult;
    if (onUpdate) {
      handlerResult = await onUpdate(params) ?? {};
    }
    syncResult.confirmOperationsSync(params.transaction.mutations);
    return handlerResult;
  };
  const wrappedOnDelete = async (params) => {
    let handlerResult;
    if (onDelete) {
      handlerResult = await onDelete(params) ?? {};
    }
    syncResult.confirmOperationsSync(params.transaction.mutations);
    return handlerResult;
  };
  const acceptMutations = (transaction) => {
    const collectionMutations = transaction.mutations.filter(
      (m) => (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        m.collection === syncResult.collection
      )
    );
    if (collectionMutations.length === 0) {
      return;
    }
    syncResult.confirmOperationsSync(
      collectionMutations
    );
  };
  return {
    ...restConfig,
    sync: syncResult.sync,
    onInsert: wrappedOnInsert,
    onUpdate: wrappedOnUpdate,
    onDelete: wrappedOnDelete,
    utils: {
      acceptMutations
    },
    startSync: true,
    gcTime: 0
  };
}
function createLocalOnlySync(initialData) {
  let syncBegin = null;
  let syncWrite = null;
  let syncCommit = null;
  let collection = null;
  const sync = {
    /**
     * Sync function that captures sync parameters and applies initial data
     * @param params - Sync parameters containing begin, write, and commit functions
     * @returns Unsubscribe function (empty since no ongoing sync is needed)
     */
    sync: (params) => {
      const { begin, write, commit, markReady } = params;
      syncBegin = begin;
      syncWrite = write;
      syncCommit = commit;
      collection = params.collection;
      if (initialData && initialData.length > 0) {
        begin();
        initialData.forEach((item) => {
          write({
            type: `insert`,
            value: item
          });
        });
        commit();
      }
      markReady();
      return () => {
      };
    },
    /**
     * Get sync metadata - returns empty object for local-only collections
     * @returns Empty metadata object
     */
    getSyncMetadata: () => ({})
  };
  const confirmOperationsSync = (mutations) => {
    if (!syncBegin || !syncWrite || !syncCommit) {
      return;
    }
    syncBegin();
    mutations.forEach((mutation) => {
      if (syncWrite) {
        syncWrite({
          type: mutation.type,
          value: mutation.modified
        });
      }
    });
    syncCommit();
  };
  return {
    sync,
    confirmOperationsSync,
    collection
  };
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/local-storage.js
function validateJsonSerializable(parser, value, operation) {
  try {
    parser.stringify(value);
  } catch (error) {
    throw new SerializationError(
      operation,
      error instanceof Error ? error.message : String(error)
    );
  }
}
function generateUuid() {
  return crypto.randomUUID();
}
function encodeStorageKey(key) {
  if (typeof key === `number`) {
    return `n:${key}`;
  }
  return `s:${key}`;
}
function decodeStorageKey(encodedKey) {
  if (encodedKey.startsWith(`n:`)) {
    return Number(encodedKey.slice(2));
  }
  if (encodedKey.startsWith(`s:`)) {
    return encodedKey.slice(2);
  }
  return encodedKey;
}
function createInMemoryStorage() {
  const storage = /* @__PURE__ */ new Map();
  return {
    getItem(key) {
      return storage.get(key) ?? null;
    },
    setItem(key, value) {
      storage.set(key, value);
    },
    removeItem(key) {
      storage.delete(key);
    }
  };
}
function createNoOpStorageEventApi() {
  return {
    addEventListener: () => {
    },
    removeEventListener: () => {
    }
  };
}
function localStorageCollectionOptions(config) {
  if (!config.storageKey) {
    throw new StorageKeyRequiredError();
  }
  const storage = config.storage || (typeof window !== `undefined` ? window.localStorage : null) || createInMemoryStorage();
  const storageEventApi = config.storageEventApi || (typeof window !== `undefined` ? window : null) || createNoOpStorageEventApi();
  const parser = config.parser || JSON;
  const lastKnownData = /* @__PURE__ */ new Map();
  const sync = createLocalStorageSync(
    config.storageKey,
    storage,
    storageEventApi,
    parser,
    config.getKey,
    lastKnownData
  );
  const saveToStorage = (dataMap) => {
    try {
      const objectData = {};
      dataMap.forEach((storedItem, key) => {
        objectData[encodeStorageKey(key)] = storedItem;
      });
      const serialized = parser.stringify(objectData);
      storage.setItem(config.storageKey, serialized);
    } catch (error) {
      console.error(
        `[LocalStorageCollection] Error saving data to storage key "${config.storageKey}":`,
        error
      );
      throw error;
    }
  };
  const clearStorage = () => {
    storage.removeItem(config.storageKey);
  };
  const getStorageSize = () => {
    const data = storage.getItem(config.storageKey);
    return data ? new Blob([data]).size : 0;
  };
  const wrappedOnInsert = async (params) => {
    params.transaction.mutations.forEach((mutation) => {
      validateJsonSerializable(parser, mutation.modified, `insert`);
    });
    let handlerResult = {};
    if (config.onInsert) {
      handlerResult = await config.onInsert(params) ?? {};
    }
    params.transaction.mutations.forEach((mutation) => {
      const storedItem = {
        versionKey: generateUuid(),
        data: mutation.modified
      };
      lastKnownData.set(mutation.key, storedItem);
    });
    saveToStorage(lastKnownData);
    sync.confirmOperationsSync(params.transaction.mutations);
    return handlerResult;
  };
  const wrappedOnUpdate = async (params) => {
    params.transaction.mutations.forEach((mutation) => {
      validateJsonSerializable(parser, mutation.modified, `update`);
    });
    let handlerResult = {};
    if (config.onUpdate) {
      handlerResult = await config.onUpdate(params) ?? {};
    }
    params.transaction.mutations.forEach((mutation) => {
      const storedItem = {
        versionKey: generateUuid(),
        data: mutation.modified
      };
      lastKnownData.set(mutation.key, storedItem);
    });
    saveToStorage(lastKnownData);
    sync.confirmOperationsSync(params.transaction.mutations);
    return handlerResult;
  };
  const wrappedOnDelete = async (params) => {
    let handlerResult = {};
    if (config.onDelete) {
      handlerResult = await config.onDelete(params) ?? {};
    }
    params.transaction.mutations.forEach((mutation) => {
      lastKnownData.delete(mutation.key);
    });
    saveToStorage(lastKnownData);
    sync.confirmOperationsSync(params.transaction.mutations);
    return handlerResult;
  };
  const {
    storageKey: _storageKey,
    storage: _storage,
    storageEventApi: _storageEventApi,
    onInsert: _onInsert,
    onUpdate: _onUpdate,
    onDelete: _onDelete,
    id,
    ...restConfig
  } = config;
  const collectionId = id ?? `local-collection:${config.storageKey}`;
  const acceptMutations = (transaction) => {
    const collectionMutations = transaction.mutations.filter((m) => {
      if (sync.collection && m.collection === sync.collection) {
        return true;
      }
      return m.collection.id === collectionId;
    });
    if (collectionMutations.length === 0) {
      return;
    }
    for (const mutation of collectionMutations) {
      switch (mutation.type) {
        case `insert`:
        case `update`:
          validateJsonSerializable(parser, mutation.modified, mutation.type);
          break;
        case `delete`:
          validateJsonSerializable(parser, mutation.original, mutation.type);
          break;
      }
    }
    for (const mutation of collectionMutations) {
      switch (mutation.type) {
        case `insert`:
        case `update`: {
          const storedItem = {
            versionKey: generateUuid(),
            data: mutation.modified
          };
          lastKnownData.set(mutation.key, storedItem);
          break;
        }
        case `delete`: {
          lastKnownData.delete(mutation.key);
          break;
        }
      }
    }
    saveToStorage(lastKnownData);
    sync.confirmOperationsSync(collectionMutations);
  };
  return {
    ...restConfig,
    id: collectionId,
    sync,
    onInsert: wrappedOnInsert,
    onUpdate: wrappedOnUpdate,
    onDelete: wrappedOnDelete,
    utils: {
      clearStorage,
      getStorageSize,
      acceptMutations
    }
  };
}
function loadFromStorage(storageKey, storage, parser) {
  try {
    const rawData = storage.getItem(storageKey);
    if (!rawData) {
      return /* @__PURE__ */ new Map();
    }
    const parsed = parser.parse(rawData);
    const dataMap = /* @__PURE__ */ new Map();
    if (typeof parsed === `object` && parsed !== null && !Array.isArray(parsed)) {
      Object.entries(parsed).forEach(([encodedKey, value]) => {
        if (value && typeof value === `object` && `versionKey` in value && `data` in value) {
          const storedItem = value;
          const decodedKey = decodeStorageKey(encodedKey);
          dataMap.set(decodedKey, storedItem);
        } else {
          throw new InvalidStorageDataFormatError(storageKey, encodedKey);
        }
      });
    } else {
      throw new InvalidStorageObjectFormatError(storageKey);
    }
    return dataMap;
  } catch (error) {
    console.warn(
      `[LocalStorageCollection] Error loading data from storage key "${storageKey}":`,
      error
    );
    return /* @__PURE__ */ new Map();
  }
}
function createLocalStorageSync(storageKey, storage, storageEventApi, parser, _getKey, lastKnownData) {
  let syncParams = null;
  let collection = null;
  const findChanges = (oldData, newData) => {
    const changes = [];
    oldData.forEach((oldStoredItem, key) => {
      const newStoredItem = newData.get(key);
      if (!newStoredItem) {
        changes.push({ type: `delete`, key, value: oldStoredItem.data });
      } else if (oldStoredItem.versionKey !== newStoredItem.versionKey) {
        changes.push({ type: `update`, key, value: newStoredItem.data });
      }
    });
    newData.forEach((newStoredItem, key) => {
      if (!oldData.has(key)) {
        changes.push({ type: `insert`, key, value: newStoredItem.data });
      }
    });
    return changes;
  };
  const processStorageChanges = () => {
    if (!syncParams) return;
    const { begin, write, commit } = syncParams;
    const newData = loadFromStorage(storageKey, storage, parser);
    const changes = findChanges(lastKnownData, newData);
    if (changes.length > 0) {
      begin();
      changes.forEach(({ type, value }) => {
        if (value) {
          validateJsonSerializable(parser, value, type);
          write({ type, value });
        }
      });
      commit();
      lastKnownData.clear();
      newData.forEach((storedItem, key) => {
        lastKnownData.set(key, storedItem);
      });
    }
  };
  const syncConfig = {
    sync: (params) => {
      const { begin, write, commit, markReady } = params;
      syncParams = params;
      collection = params.collection;
      const initialData = loadFromStorage(storageKey, storage, parser);
      if (initialData.size > 0) {
        begin();
        initialData.forEach((storedItem) => {
          validateJsonSerializable(parser, storedItem.data, `load`);
          write({ type: `insert`, value: storedItem.data });
        });
        commit();
      }
      lastKnownData.clear();
      initialData.forEach((storedItem, key) => {
        lastKnownData.set(key, storedItem);
      });
      markReady();
      const handleStorageEvent = (event) => {
        if (event.key !== storageKey || event.storageArea !== storage) {
          return;
        }
        processStorageChanges();
      };
      storageEventApi.addEventListener(`storage`, handleStorageEvent);
    },
    /**
     * Get sync metadata - returns storage key information
     * @returns Object containing storage key and storage type metadata
     */
    getSyncMetadata: () => ({
      storageKey,
      storageType: storage === (typeof window !== `undefined` ? window.localStorage : null) ? `localStorage` : `custom`
    }),
    // Manual trigger function for local updates
    manualTrigger: processStorageChanges,
    // Collection instance reference
    collection
  };
  const confirmOperationsSync = (mutations) => {
    if (!syncParams) {
      return;
    }
    const { begin, write, commit } = syncParams;
    begin();
    mutations.forEach((mutation) => {
      write({
        type: mutation.type,
        value: mutation.type === `delete` ? mutation.original : mutation.modified
      });
    });
    commit();
  };
  return {
    ...syncConfig,
    confirmOperationsSync
  };
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/paced-mutations.js
function createPacedMutations(config) {
  const { onMutate, mutationFn, strategy, ...transactionConfig } = config;
  let activeTransaction = null;
  const commitCallback = () => {
    if (!activeTransaction) {
      throw new Error(
        `Strategy callback called but no active transaction exists. This indicates a bug in the strategy implementation.`
      );
    }
    if (activeTransaction.state !== `pending`) {
      throw new Error(
        `Strategy callback called but active transaction is in state "${activeTransaction.state}". Expected "pending".`
      );
    }
    const txToCommit = activeTransaction;
    activeTransaction = null;
    txToCommit.commit().catch(() => {
    });
    return txToCommit;
  };
  function mutate(variables) {
    if (!activeTransaction || activeTransaction.state !== `pending`) {
      activeTransaction = createTransaction({
        ...transactionConfig,
        mutationFn,
        autoCommit: false
      });
    }
    activeTransaction.mutate(() => {
      onMutate(variables);
    });
    const txToReturn = activeTransaction;
    if (strategy._type === `queue`) {
      const capturedTx = activeTransaction;
      activeTransaction = null;
      strategy.execute(() => {
        capturedTx.commit().catch(() => {
        });
        return capturedTx;
      });
    } else {
      strategy.execute(commitCallback);
    }
    return txToReturn;
  }
  return mutate;
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/expression-helpers.js
function extractFieldPath(expr) {
  if (expr.type === `ref`) {
    return expr.path;
  }
  return null;
}
function extractValue(expr) {
  if (expr.type === `val`) {
    return expr.value;
  }
  return void 0;
}
function walkExpression(expr, visitor) {
  if (!expr) return;
  visitor(expr);
  if (expr.type === `func`) {
    expr.args.forEach((arg) => walkExpression(arg, visitor));
  }
}
function parseWhereExpression(expr, options) {
  if (!expr) return null;
  const { handlers, onUnknownOperator } = options;
  if (expr.type === `val`) {
    return expr.value;
  }
  if (expr.type === `ref`) {
    return expr.path;
  }
  const { name, args } = expr;
  const handler = handlers[name];
  if (!handler) {
    if (onUnknownOperator) {
      return onUnknownOperator(name, args);
    }
    throw new Error(
      `No handler provided for operator: ${name}. Available handlers: ${Object.keys(handlers).join(`, `)}`
    );
  }
  const parsedArgs = args.map((arg) => {
    if (arg.type === `ref`) {
      return arg.path;
    }
    if (arg.type === `val`) {
      return arg.value;
    }
    return parseWhereExpression(arg, options);
  });
  return handler(...parsedArgs);
}
function parseOrderByExpression(orderBy2) {
  if (!orderBy2 || orderBy2.length === 0) {
    return [];
  }
  return orderBy2.map((clause) => {
    const field = extractFieldPath(clause.expression);
    if (!field) {
      throw new Error(
        `ORDER BY expression must be a field reference, got: ${clause.expression.type}`
      );
    }
    const { direction, nulls } = clause.compareOptions;
    const result = {
      field,
      direction,
      nulls
    };
    if (`stringSort` in clause.compareOptions) {
      result.stringSort = clause.compareOptions.stringSort;
    }
    if (`locale` in clause.compareOptions) {
      result.locale = clause.compareOptions.locale;
    }
    if (`localeOptions` in clause.compareOptions) {
      result.localeOptions = clause.compareOptions.localeOptions;
    }
    return result;
  });
}
function extractSimpleComparisons(expr) {
  if (!expr) return [];
  const comparisons = [];
  function extract(e) {
    if (e.type === `func`) {
      if (e.name === `and`) {
        e.args.forEach((arg) => extract(arg));
        return;
      }
      if (e.name === `not`) {
        const [arg] = e.args;
        if (!arg || arg.type !== `func`) {
          throw new Error(
            `extractSimpleComparisons requires a comparison or null check inside 'not' operator.`
          );
        }
        const nullCheckOps2 = [`isNull`, `isUndefined`];
        if (nullCheckOps2.includes(arg.name)) {
          const [fieldArg] = arg.args;
          const field = (fieldArg == null ? void 0 : fieldArg.type) === `ref` ? fieldArg.path : null;
          if (field) {
            comparisons.push({
              field,
              operator: `not_${arg.name}`
              // No value for null/undefined checks
            });
          } else {
            throw new Error(
              `extractSimpleComparisons requires a field reference for '${arg.name}' operator.`
            );
          }
          return;
        }
        const comparisonOps2 = [`eq`, `gt`, `gte`, `lt`, `lte`, `in`];
        if (comparisonOps2.includes(arg.name)) {
          const [leftArg, rightArg] = arg.args;
          const field = (leftArg == null ? void 0 : leftArg.type) === `ref` ? leftArg.path : null;
          const value = (rightArg == null ? void 0 : rightArg.type) === `val` ? rightArg.value : null;
          if (field && value !== void 0) {
            comparisons.push({
              field,
              operator: `not_${arg.name}`,
              value
            });
          } else {
            throw new Error(
              `extractSimpleComparisons requires simple field-value comparisons. Found complex expression for 'not(${arg.name})' operator.`
            );
          }
          return;
        }
        throw new Error(
          `extractSimpleComparisons does not support 'not(${arg.name})'. NOT can only wrap comparison operators (eq, gt, gte, lt, lte, in) or null checks (isNull, isUndefined).`
        );
      }
      const unsupportedOps = [
        `or`,
        `like`,
        `ilike`,
        `upper`,
        `lower`,
        `length`,
        `concat`,
        `add`,
        `coalesce`,
        `count`,
        `avg`,
        `sum`,
        `min`,
        `max`
      ];
      if (unsupportedOps.includes(e.name)) {
        throw new Error(
          `extractSimpleComparisons does not support '${e.name}' operator. Use parseWhereExpression with custom handlers for complex expressions.`
        );
      }
      const nullCheckOps = [`isNull`, `isUndefined`];
      if (nullCheckOps.includes(e.name)) {
        const [fieldArg] = e.args;
        const field = (fieldArg == null ? void 0 : fieldArg.type) === `ref` ? fieldArg.path : null;
        if (field) {
          comparisons.push({
            field,
            operator: e.name
            // No value for null/undefined checks
          });
        } else {
          throw new Error(
            `extractSimpleComparisons requires a field reference for '${e.name}' operator.`
          );
        }
        return;
      }
      const comparisonOps = [`eq`, `gt`, `gte`, `lt`, `lte`, `in`];
      if (comparisonOps.includes(e.name)) {
        const [leftArg, rightArg] = e.args;
        const field = (leftArg == null ? void 0 : leftArg.type) === `ref` ? leftArg.path : null;
        const value = (rightArg == null ? void 0 : rightArg.type) === `val` ? rightArg.value : null;
        if (field && value !== void 0) {
          comparisons.push({
            field,
            operator: e.name,
            value
          });
        } else {
          throw new Error(
            `extractSimpleComparisons requires simple field-value comparisons. Found complex expression for '${e.name}' operator.`
          );
        }
      } else {
        throw new Error(
          `extractSimpleComparisons encountered unknown operator: '${e.name}'`
        );
      }
    }
  }
  extract(expr);
  return comparisons;
}
function parseLoadSubsetOptions(options) {
  if (!options) {
    return { filters: [], sorts: [] };
  }
  return {
    filters: extractSimpleComparisons(options.where),
    sorts: parseOrderByExpression(options.orderBy),
    limit: options.limit
  };
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/builder/index.js
var BaseQueryBuilder = class _BaseQueryBuilder {
  constructor(query = {}) {
    this.query = {};
    this.query = { ...query };
  }
  /**
   * Creates a CollectionRef or QueryRef from a source object
   * @param source - An object with a single key-value pair
   * @param context - Context string for error messages (e.g., "from clause", "join clause")
   * @returns A tuple of [alias, ref] where alias is the source key and ref is the created reference
   */
  _createRefForSource(source, context) {
    let keys;
    try {
      keys = Object.keys(source);
    } catch {
      const type = source === null ? `null` : `undefined`;
      throw new InvalidSourceTypeError(context, type);
    }
    if (Array.isArray(source)) {
      throw new InvalidSourceTypeError(context, `array`);
    }
    if (keys.length !== 1) {
      if (keys.length === 0) {
        throw new InvalidSourceTypeError(context, `empty object`);
      }
      if (keys.every((k) => !isNaN(Number(k)))) {
        throw new InvalidSourceTypeError(context, `string`);
      }
      throw new OnlyOneSourceAllowedError(context);
    }
    const alias = keys[0];
    const sourceValue = source[alias];
    let ref;
    if (sourceValue instanceof CollectionImpl) {
      ref = new CollectionRef(sourceValue, alias);
    } else if (sourceValue instanceof _BaseQueryBuilder) {
      const subQuery = sourceValue._getQuery();
      if (!subQuery.from) {
        throw new SubQueryMustHaveFromClauseError(context);
      }
      ref = new QueryRef(subQuery, alias);
    } else {
      throw new InvalidSourceError(alias);
    }
    return [alias, ref];
  }
  /**
   * Specify the source table or subquery for the query
   *
   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery
   * @returns A QueryBuilder with the specified source
   *
   * @example
   * ```ts
   * // Query from a collection
   * query.from({ users: usersCollection })
   *
   * // Query from a subquery
   * const activeUsers = query.from({ u: usersCollection }).where(({u}) => u.active)
   * query.from({ activeUsers })
   * ```
   */
  from(source) {
    const [, from] = this._createRefForSource(source, `from clause`);
    return new _BaseQueryBuilder({
      ...this.query,
      from
    });
  }
  /**
   * Join another table or subquery to the current query
   *
   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery
   * @param onCallback - A function that receives table references and returns the join condition
   * @param type - The type of join: 'inner', 'left', 'right', or 'full' (defaults to 'left')
   * @returns A QueryBuilder with the joined table available
   *
   * @example
   * ```ts
   * // Left join users with posts
   * query
   *   .from({ users: usersCollection })
   *   .join({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))
   *
   * // Inner join with explicit type
   * query
   *   .from({ u: usersCollection })
   *   .join({ p: postsCollection }, ({u, p}) => eq(u.id, p.userId), 'inner')
   * ```
   *
   * // Join with a subquery
   * const activeUsers = query.from({ u: usersCollection }).where(({u}) => u.active)
   * query
   *   .from({ activeUsers })
   *   .join({ p: postsCollection }, ({u, p}) => eq(u.id, p.userId))
   */
  join(source, onCallback, type = `left`) {
    const [alias, from] = this._createRefForSource(source, `join clause`);
    const currentAliases = this._getCurrentAliases();
    const newAliases = [...currentAliases, alias];
    const refProxy = createRefProxy(newAliases);
    const onExpression = onCallback(refProxy);
    let left;
    let right;
    if (onExpression.type === `func` && onExpression.name === `eq` && onExpression.args.length === 2) {
      left = onExpression.args[0];
      right = onExpression.args[1];
    } else {
      throw new JoinConditionMustBeEqualityError();
    }
    const joinClause = {
      from,
      type,
      left,
      right
    };
    const existingJoins = this.query.join || [];
    return new _BaseQueryBuilder({
      ...this.query,
      join: [...existingJoins, joinClause]
    });
  }
  /**
   * Perform a LEFT JOIN with another table or subquery
   *
   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery
   * @param onCallback - A function that receives table references and returns the join condition
   * @returns A QueryBuilder with the left joined table available
   *
   * @example
   * ```ts
   * // Left join users with posts
   * query
   *   .from({ users: usersCollection })
   *   .leftJoin({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))
   * ```
   */
  leftJoin(source, onCallback) {
    return this.join(source, onCallback, `left`);
  }
  /**
   * Perform a RIGHT JOIN with another table or subquery
   *
   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery
   * @param onCallback - A function that receives table references and returns the join condition
   * @returns A QueryBuilder with the right joined table available
   *
   * @example
   * ```ts
   * // Right join users with posts
   * query
   *   .from({ users: usersCollection })
   *   .rightJoin({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))
   * ```
   */
  rightJoin(source, onCallback) {
    return this.join(source, onCallback, `right`);
  }
  /**
   * Perform an INNER JOIN with another table or subquery
   *
   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery
   * @param onCallback - A function that receives table references and returns the join condition
   * @returns A QueryBuilder with the inner joined table available
   *
   * @example
   * ```ts
   * // Inner join users with posts
   * query
   *   .from({ users: usersCollection })
   *   .innerJoin({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))
   * ```
   */
  innerJoin(source, onCallback) {
    return this.join(source, onCallback, `inner`);
  }
  /**
   * Perform a FULL JOIN with another table or subquery
   *
   * @param source - An object with a single key-value pair where the key is the table alias and the value is a Collection or subquery
   * @param onCallback - A function that receives table references and returns the join condition
   * @returns A QueryBuilder with the full joined table available
   *
   * @example
   * ```ts
   * // Full join users with posts
   * query
   *   .from({ users: usersCollection })
   *   .fullJoin({ posts: postsCollection }, ({users, posts}) => eq(users.id, posts.userId))
   * ```
   */
  fullJoin(source, onCallback) {
    return this.join(source, onCallback, `full`);
  }
  /**
   * Filter rows based on a condition
   *
   * @param callback - A function that receives table references and returns an expression
   * @returns A QueryBuilder with the where condition applied
   *
   * @example
   * ```ts
   * // Simple condition
   * query
   *   .from({ users: usersCollection })
   *   .where(({users}) => gt(users.age, 18))
   *
   * // Multiple conditions
   * query
   *   .from({ users: usersCollection })
   *   .where(({users}) => and(
   *     gt(users.age, 18),
   *     eq(users.active, true)
   *   ))
   *
   * // Multiple where calls are ANDed together
   * query
   *   .from({ users: usersCollection })
   *   .where(({users}) => gt(users.age, 18))
   *   .where(({users}) => eq(users.active, true))
   * ```
   */
  where(callback) {
    const aliases = this._getCurrentAliases();
    const refProxy = createRefProxy(aliases);
    const expression = callback(refProxy);
    const existingWhere = this.query.where || [];
    return new _BaseQueryBuilder({
      ...this.query,
      where: [...existingWhere, expression]
    });
  }
  /**
   * Filter grouped rows based on aggregate conditions
   *
   * @param callback - A function that receives table references and returns an expression
   * @returns A QueryBuilder with the having condition applied
   *
   * @example
   * ```ts
   * // Filter groups by count
   * query
   *   .from({ posts: postsCollection })
   *   .groupBy(({posts}) => posts.userId)
   *   .having(({posts}) => gt(count(posts.id), 5))
   *
   * // Filter by average
   * query
   *   .from({ orders: ordersCollection })
   *   .groupBy(({orders}) => orders.customerId)
   *   .having(({orders}) => gt(avg(orders.total), 100))
   *
   * // Multiple having calls are ANDed together
   * query
   *   .from({ orders: ordersCollection })
   *   .groupBy(({orders}) => orders.customerId)
   *   .having(({orders}) => gt(count(orders.id), 5))
   *   .having(({orders}) => gt(avg(orders.total), 100))
   * ```
   */
  having(callback) {
    const aliases = this._getCurrentAliases();
    const refProxy = createRefProxy(aliases);
    const expression = callback(refProxy);
    const existingHaving = this.query.having || [];
    return new _BaseQueryBuilder({
      ...this.query,
      having: [...existingHaving, expression]
    });
  }
  /**
   * Select specific columns or computed values from the query
   *
   * @param callback - A function that receives table references and returns an object with selected fields or expressions
   * @returns A QueryBuilder that returns only the selected fields
   *
   * @example
   * ```ts
   * // Select specific columns
   * query
   *   .from({ users: usersCollection })
   *   .select(({users}) => ({
   *     name: users.name,
   *     email: users.email
   *   }))
   *
   * // Select with computed values
   * query
   *   .from({ users: usersCollection })
   *   .select(({users}) => ({
   *     fullName: concat(users.firstName, ' ', users.lastName),
   *     ageInMonths: mul(users.age, 12)
   *   }))
   *
   * // Select with aggregates (requires GROUP BY)
   * query
   *   .from({ posts: postsCollection })
   *   .groupBy(({posts}) => posts.userId)
   *   .select(({posts, count}) => ({
   *     userId: posts.userId,
   *     postCount: count(posts.id)
   *   }))
   * ```
   */
  select(callback) {
    const aliases = this._getCurrentAliases();
    const refProxy = createRefProxy(aliases);
    const selectObject = callback(refProxy);
    const select = buildNestedSelect(selectObject);
    return new _BaseQueryBuilder({
      ...this.query,
      select,
      fnSelect: void 0
      // remove the fnSelect clause if it exists
    });
  }
  /**
   * Sort the query results by one or more columns
   *
   * @param callback - A function that receives table references and returns the field to sort by
   * @param direction - Sort direction: 'asc' for ascending, 'desc' for descending (defaults to 'asc')
   * @returns A QueryBuilder with the ordering applied
   *
   * @example
   * ```ts
   * // Sort by a single column
   * query
   *   .from({ users: usersCollection })
   *   .orderBy(({users}) => users.name)
   *
   * // Sort descending
   * query
   *   .from({ users: usersCollection })
   *   .orderBy(({users}) => users.createdAt, 'desc')
   *
   * // Multiple sorts (chain orderBy calls)
   * query
   *   .from({ users: usersCollection })
   *   .orderBy(({users}) => users.lastName)
   *   .orderBy(({users}) => users.firstName)
   * ```
   */
  orderBy(callback, options = `asc`) {
    const aliases = this._getCurrentAliases();
    const refProxy = createRefProxy(aliases);
    const result = callback(refProxy);
    const opts = typeof options === `string` ? { direction: options, nulls: `first` } : {
      direction: options.direction ?? `asc`,
      nulls: options.nulls ?? `first`,
      stringSort: options.stringSort,
      locale: options.stringSort === `locale` ? options.locale : void 0,
      localeOptions: options.stringSort === `locale` ? options.localeOptions : void 0
    };
    const makeOrderByClause = (res) => {
      return {
        expression: toExpression(res),
        compareOptions: opts
      };
    };
    const orderByClauses = Array.isArray(result) ? result.map((r) => makeOrderByClause(r)) : [makeOrderByClause(result)];
    const existingOrderBy = this.query.orderBy || [];
    return new _BaseQueryBuilder({
      ...this.query,
      orderBy: [...existingOrderBy, ...orderByClauses]
    });
  }
  /**
   * Group rows by one or more columns for aggregation
   *
   * @param callback - A function that receives table references and returns the field(s) to group by
   * @returns A QueryBuilder with grouping applied (enables aggregate functions in SELECT and HAVING)
   *
   * @example
   * ```ts
   * // Group by a single column
   * query
   *   .from({ posts: postsCollection })
   *   .groupBy(({posts}) => posts.userId)
   *   .select(({posts, count}) => ({
   *     userId: posts.userId,
   *     postCount: count()
   *   }))
   *
   * // Group by multiple columns
   * query
   *   .from({ sales: salesCollection })
   *   .groupBy(({sales}) => [sales.region, sales.category])
   *   .select(({sales, sum}) => ({
   *     region: sales.region,
   *     category: sales.category,
   *     totalSales: sum(sales.amount)
   *   }))
   * ```
   */
  groupBy(callback) {
    const aliases = this._getCurrentAliases();
    const refProxy = createRefProxy(aliases);
    const result = callback(refProxy);
    const newExpressions = Array.isArray(result) ? result.map((r) => toExpression(r)) : [toExpression(result)];
    const existingGroupBy = this.query.groupBy || [];
    return new _BaseQueryBuilder({
      ...this.query,
      groupBy: [...existingGroupBy, ...newExpressions]
    });
  }
  /**
   * Limit the number of rows returned by the query
   * `orderBy` is required for `limit`
   *
   * @param count - Maximum number of rows to return
   * @returns A QueryBuilder with the limit applied
   *
   * @example
   * ```ts
   * // Get top 5 posts by likes
   * query
   *   .from({ posts: postsCollection })
   *   .orderBy(({posts}) => posts.likes, 'desc')
   *   .limit(5)
   * ```
   */
  limit(count6) {
    return new _BaseQueryBuilder({
      ...this.query,
      limit: count6
    });
  }
  /**
   * Skip a number of rows before returning results
   * `orderBy` is required for `offset`
   *
   * @param count - Number of rows to skip
   * @returns A QueryBuilder with the offset applied
   *
   * @example
   * ```ts
   * // Get second page of results
   * query
   *   .from({ posts: postsCollection })
   *   .orderBy(({posts}) => posts.createdAt, 'desc')
   *   .offset(page * pageSize)
   *   .limit(pageSize)
   * ```
   */
  offset(count6) {
    return new _BaseQueryBuilder({
      ...this.query,
      offset: count6
    });
  }
  /**
   * Specify that the query should return distinct rows.
   * Deduplicates rows based on the selected columns.
   * @returns A QueryBuilder with distinct enabled
   *
   * @example
   * ```ts
   * // Get countries our users are from
   * query
   *   .from({ users: usersCollection })
   *   .select(({users}) => users.country)
   *   .distinct()
   * ```
   */
  distinct() {
    return new _BaseQueryBuilder({
      ...this.query,
      distinct: true
    });
  }
  /**
   * Specify that the query should return a single result
   * @returns A QueryBuilder that returns the first result
   *
   * @example
   * ```ts
   * // Get the user matching the query
   * query
   *   .from({ users: usersCollection })
   *   .where(({users}) => eq(users.id, 1))
   *   .findOne()
   *```
   */
  findOne() {
    return new _BaseQueryBuilder({
      ...this.query,
      // TODO: enforcing return only one result with also a default orderBy if none is specified
      // limit: 1,
      singleResult: true
    });
  }
  // Helper methods
  _getCurrentAliases() {
    const aliases = [];
    if (this.query.from) {
      aliases.push(this.query.from.alias);
    }
    if (this.query.join) {
      for (const join2 of this.query.join) {
        aliases.push(join2.from.alias);
      }
    }
    return aliases;
  }
  /**
   * Functional variants of the query builder
   * These are imperative function that are called for ery row.
   * Warning: that these cannot be optimized by the query compiler, and may prevent
   * some type of optimizations being possible.
   * @example
   * ```ts
   * q.fn.select((row) => ({
   *   name: row.user.name.toUpperCase(),
   *   age: row.user.age + 1,
   * }))
   * ```
   */
  get fn() {
    const builder = this;
    return {
      /**
       * Select fields using a function that operates on each row
       * Warning: This cannot be optimized by the query compiler
       *
       * @param callback - A function that receives a row and returns the selected value
       * @returns A QueryBuilder with functional selection applied
       *
       * @example
       * ```ts
       * // Functional select (not optimized)
       * query
       *   .from({ users: usersCollection })
       *   .fn.select(row => ({
       *     name: row.users.name.toUpperCase(),
       *     age: row.users.age + 1,
       *   }))
       * ```
       */
      select(callback) {
        return new _BaseQueryBuilder({
          ...builder.query,
          select: void 0,
          // remove the select clause if it exists
          fnSelect: callback
        });
      },
      /**
       * Filter rows using a function that operates on each row
       * Warning: This cannot be optimized by the query compiler
       *
       * @param callback - A function that receives a row and returns a boolean
       * @returns A QueryBuilder with functional filtering applied
       *
       * @example
       * ```ts
       * // Functional where (not optimized)
       * query
       *   .from({ users: usersCollection })
       *   .fn.where(row => row.users.name.startsWith('A'))
       * ```
       */
      where(callback) {
        return new _BaseQueryBuilder({
          ...builder.query,
          fnWhere: [
            ...builder.query.fnWhere || [],
            callback
          ]
        });
      },
      /**
       * Filter grouped rows using a function that operates on each aggregated row
       * Warning: This cannot be optimized by the query compiler
       *
       * @param callback - A function that receives an aggregated row and returns a boolean
       * @returns A QueryBuilder with functional having filter applied
       *
       * @example
       * ```ts
       * // Functional having (not optimized)
       * query
       *   .from({ posts: postsCollection })
       *   .groupBy(({posts}) => posts.userId)
       *   .fn.having(row => row.count > 5)
       * ```
       */
      having(callback) {
        return new _BaseQueryBuilder({
          ...builder.query,
          fnHaving: [
            ...builder.query.fnHaving || [],
            callback
          ]
        });
      }
    };
  }
  _getQuery() {
    if (!this.query.from) {
      throw new QueryMustHaveFromClauseError();
    }
    return this.query;
  }
};
function toExpr(value) {
  if (value === void 0) return toExpression(null);
  if (value instanceof Aggregate || value instanceof Func || value instanceof PropRef || value instanceof Value) {
    return value;
  }
  return toExpression(value);
}
function isPlainObject(value) {
  return value !== null && typeof value === `object` && !isExpressionLike(value) && !value.__refProxy;
}
function buildNestedSelect(obj) {
  if (!isPlainObject(obj)) return toExpr(obj);
  const out = {};
  for (const [k, v] of Object.entries(obj)) {
    if (typeof k === `string` && k.startsWith(`__SPREAD_SENTINEL__`)) {
      out[k] = v;
      continue;
    }
    out[k] = buildNestedSelect(v);
  }
  return out;
}
function buildQuery(fn) {
  const result = fn(new BaseQueryBuilder());
  return getQueryIR(result);
}
function getQueryIR(builder) {
  return builder._getQuery();
}
var Query = BaseQueryBuilder;

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/optimizer.js
function optimizeQuery(query) {
  const sourceWhereClauses = extractSourceWhereClauses(query);
  let optimized = query;
  let previousOptimized;
  let iterations = 0;
  const maxIterations = 10;
  while (iterations < maxIterations && !deepEquals(optimized, previousOptimized)) {
    previousOptimized = optimized;
    optimized = applyRecursiveOptimization(optimized);
    iterations++;
  }
  const cleaned = removeRedundantSubqueries(optimized);
  return {
    optimizedQuery: cleaned,
    sourceWhereClauses
  };
}
function extractSourceWhereClauses(query) {
  const sourceWhereClauses = /* @__PURE__ */ new Map();
  if (!query.where || query.where.length === 0) {
    return sourceWhereClauses;
  }
  const splitWhereClauses = splitAndClauses(query.where);
  const analyzedClauses = splitWhereClauses.map(
    (clause) => analyzeWhereClause(clause)
  );
  const groupedClauses = groupWhereClauses(analyzedClauses);
  for (const [sourceAlias, whereClause] of groupedClauses.singleSource) {
    if (isCollectionReference(query, sourceAlias)) {
      sourceWhereClauses.set(sourceAlias, whereClause);
    }
  }
  return sourceWhereClauses;
}
function isCollectionReference(query, sourceAlias) {
  if (query.from.alias === sourceAlias) {
    return query.from.type === `collectionRef`;
  }
  if (query.join) {
    for (const joinClause of query.join) {
      if (joinClause.from.alias === sourceAlias) {
        return joinClause.from.type === `collectionRef`;
      }
    }
  }
  return false;
}
function applyRecursiveOptimization(query) {
  var _a;
  const subqueriesOptimized = {
    ...query,
    from: query.from.type === `queryRef` ? new QueryRef(
      applyRecursiveOptimization(query.from.query),
      query.from.alias
    ) : query.from,
    join: (_a = query.join) == null ? void 0 : _a.map((joinClause) => ({
      ...joinClause,
      from: joinClause.from.type === `queryRef` ? new QueryRef(
        applyRecursiveOptimization(joinClause.from.query),
        joinClause.from.alias
      ) : joinClause.from
    }))
  };
  return applySingleLevelOptimization(subqueriesOptimized);
}
function applySingleLevelOptimization(query) {
  if (!query.where || query.where.length === 0) {
    return query;
  }
  if (!query.join || query.join.length === 0) {
    if (query.where.length > 1) {
      const splitWhereClauses2 = splitAndClauses(query.where);
      const combinedWhere = combineWithAnd(splitWhereClauses2);
      return {
        ...query,
        where: [combinedWhere]
      };
    }
    return query;
  }
  const nonResidualWhereClauses = query.where.filter(
    (where) => !isResidualWhere(where)
  );
  const splitWhereClauses = splitAndClauses(nonResidualWhereClauses);
  const analyzedClauses = splitWhereClauses.map(
    (clause) => analyzeWhereClause(clause)
  );
  const groupedClauses = groupWhereClauses(analyzedClauses);
  const optimizedQuery = applyOptimizations(query, groupedClauses);
  const residualWhereClauses = query.where.filter(
    (where) => isResidualWhere(where)
  );
  if (residualWhereClauses.length > 0) {
    optimizedQuery.where = [
      ...optimizedQuery.where || [],
      ...residualWhereClauses
    ];
  }
  return optimizedQuery;
}
function removeRedundantSubqueries(query) {
  var _a;
  return {
    ...query,
    from: removeRedundantFromClause(query.from),
    join: (_a = query.join) == null ? void 0 : _a.map((joinClause) => ({
      ...joinClause,
      from: removeRedundantFromClause(joinClause.from)
    }))
  };
}
function removeRedundantFromClause(from) {
  if (from.type === `collectionRef`) {
    return from;
  }
  const processedQuery = removeRedundantSubqueries(from.query);
  if (isRedundantSubquery(processedQuery)) {
    const innerFrom = removeRedundantFromClause(processedQuery.from);
    if (innerFrom.type === `collectionRef`) {
      return new CollectionRef(innerFrom.collection, from.alias);
    } else {
      return new QueryRef(innerFrom.query, from.alias);
    }
  }
  return new QueryRef(processedQuery, from.alias);
}
function isRedundantSubquery(query) {
  return (!query.where || query.where.length === 0) && !query.select && (!query.groupBy || query.groupBy.length === 0) && (!query.having || query.having.length === 0) && (!query.orderBy || query.orderBy.length === 0) && (!query.join || query.join.length === 0) && query.limit === void 0 && query.offset === void 0 && !query.fnSelect && (!query.fnWhere || query.fnWhere.length === 0) && (!query.fnHaving || query.fnHaving.length === 0);
}
function splitAndClauses(whereClauses) {
  const result = [];
  for (const whereClause of whereClauses) {
    const clause = getWhereExpression(whereClause);
    result.push(...splitAndClausesRecursive(clause));
  }
  return result;
}
function splitAndClausesRecursive(clause) {
  if (clause.type === `func` && clause.name === `and`) {
    const result = [];
    for (const arg of clause.args) {
      result.push(...splitAndClausesRecursive(arg));
    }
    return result;
  } else {
    return [clause];
  }
}
function analyzeWhereClause(clause) {
  const touchedSources = /* @__PURE__ */ new Set();
  let hasNamespaceOnlyRef = false;
  function collectSources(expr) {
    switch (expr.type) {
      case `ref`:
        if (expr.path && expr.path.length > 0) {
          const firstElement = expr.path[0];
          if (firstElement) {
            touchedSources.add(firstElement);
            if (expr.path.length === 1) {
              hasNamespaceOnlyRef = true;
            }
          }
        }
        break;
      case `func`:
        if (expr.args) {
          expr.args.forEach(collectSources);
        }
        break;
      case `val`:
        break;
      case `agg`:
        if (expr.args) {
          expr.args.forEach(collectSources);
        }
        break;
    }
  }
  collectSources(clause);
  return {
    expression: clause,
    touchedSources,
    hasNamespaceOnlyRef
  };
}
function groupWhereClauses(analyzedClauses) {
  const singleSource = /* @__PURE__ */ new Map();
  const multiSource = [];
  for (const clause of analyzedClauses) {
    if (clause.touchedSources.size === 1 && !clause.hasNamespaceOnlyRef) {
      const source = Array.from(clause.touchedSources)[0];
      if (!singleSource.has(source)) {
        singleSource.set(source, []);
      }
      singleSource.get(source).push(clause.expression);
    } else if (clause.touchedSources.size > 1 || clause.hasNamespaceOnlyRef) {
      multiSource.push(clause.expression);
    }
  }
  const combinedSingleSource = /* @__PURE__ */ new Map();
  for (const [source, clauses] of singleSource) {
    combinedSingleSource.set(source, combineWithAnd(clauses));
  }
  const combinedMultiSource = multiSource.length > 0 ? combineWithAnd(multiSource) : void 0;
  return {
    singleSource: combinedSingleSource,
    multiSource: combinedMultiSource
  };
}
function applyOptimizations(query, groupedClauses) {
  const actuallyOptimized = /* @__PURE__ */ new Set();
  const optimizedFrom = optimizeFromWithTracking(
    query.from,
    groupedClauses.singleSource,
    actuallyOptimized
  );
  const optimizedJoins = query.join ? query.join.map((joinClause) => ({
    ...joinClause,
    from: optimizeFromWithTracking(
      joinClause.from,
      groupedClauses.singleSource,
      actuallyOptimized
    )
  })) : void 0;
  const remainingWhereClauses = [];
  if (groupedClauses.multiSource) {
    remainingWhereClauses.push(groupedClauses.multiSource);
  }
  const hasOuterJoins = query.join && query.join.some(
    (join2) => join2.type === `left` || join2.type === `right` || join2.type === `full`
  );
  for (const [source, clause] of groupedClauses.singleSource) {
    if (!actuallyOptimized.has(source)) {
      remainingWhereClauses.push(clause);
    } else if (hasOuterJoins) {
      remainingWhereClauses.push(createResidualWhere(clause));
    }
  }
  const finalWhere = remainingWhereClauses.length > 1 ? [
    combineWithAnd(
      remainingWhereClauses.flatMap(
        (clause) => splitAndClausesRecursive(getWhereExpression(clause))
      )
    )
  ] : remainingWhereClauses;
  const optimizedQuery = {
    // Copy all non-optimized fields as-is
    select: query.select,
    groupBy: query.groupBy ? [...query.groupBy] : void 0,
    having: query.having ? [...query.having] : void 0,
    orderBy: query.orderBy ? [...query.orderBy] : void 0,
    limit: query.limit,
    offset: query.offset,
    distinct: query.distinct,
    fnSelect: query.fnSelect,
    fnWhere: query.fnWhere ? [...query.fnWhere] : void 0,
    fnHaving: query.fnHaving ? [...query.fnHaving] : void 0,
    // Use the optimized FROM and JOIN clauses
    from: optimizedFrom,
    join: optimizedJoins,
    // Include combined WHERE clauses
    where: finalWhere.length > 0 ? finalWhere : []
  };
  return optimizedQuery;
}
function deepCopyQuery(query) {
  return {
    // Recursively copy the FROM clause
    from: query.from.type === `collectionRef` ? new CollectionRef(query.from.collection, query.from.alias) : new QueryRef(deepCopyQuery(query.from.query), query.from.alias),
    // Copy all other fields, creating new arrays where necessary
    select: query.select,
    join: query.join ? query.join.map((joinClause) => ({
      type: joinClause.type,
      left: joinClause.left,
      right: joinClause.right,
      from: joinClause.from.type === `collectionRef` ? new CollectionRef(
        joinClause.from.collection,
        joinClause.from.alias
      ) : new QueryRef(
        deepCopyQuery(joinClause.from.query),
        joinClause.from.alias
      )
    })) : void 0,
    where: query.where ? [...query.where] : void 0,
    groupBy: query.groupBy ? [...query.groupBy] : void 0,
    having: query.having ? [...query.having] : void 0,
    orderBy: query.orderBy ? [...query.orderBy] : void 0,
    limit: query.limit,
    offset: query.offset,
    fnSelect: query.fnSelect,
    fnWhere: query.fnWhere ? [...query.fnWhere] : void 0,
    fnHaving: query.fnHaving ? [...query.fnHaving] : void 0
  };
}
function optimizeFromWithTracking(from, singleSourceClauses, actuallyOptimized) {
  const whereClause = singleSourceClauses.get(from.alias);
  if (!whereClause) {
    if (from.type === `collectionRef`) {
      return new CollectionRef(from.collection, from.alias);
    }
    return new QueryRef(deepCopyQuery(from.query), from.alias);
  }
  if (from.type === `collectionRef`) {
    const subQuery = {
      from: new CollectionRef(from.collection, from.alias),
      where: [whereClause]
    };
    actuallyOptimized.add(from.alias);
    return new QueryRef(subQuery, from.alias);
  }
  if (!isSafeToPushIntoExistingSubquery(from.query, whereClause, from.alias)) {
    return new QueryRef(deepCopyQuery(from.query), from.alias);
  }
  if (referencesAliasWithRemappedSelect(from.query, whereClause, from.alias)) {
    return new QueryRef(deepCopyQuery(from.query), from.alias);
  }
  const existingWhere = from.query.where || [];
  const optimizedSubQuery = {
    ...deepCopyQuery(from.query),
    where: [...existingWhere, whereClause]
  };
  actuallyOptimized.add(from.alias);
  return new QueryRef(optimizedSubQuery, from.alias);
}
function unsafeSelect(query, whereClause, outerAlias) {
  if (!query.select) return false;
  return selectHasAggregates(query.select) || whereReferencesComputedSelectFields(query.select, whereClause, outerAlias);
}
function unsafeGroupBy(query) {
  return query.groupBy && query.groupBy.length > 0;
}
function unsafeHaving(query) {
  return query.having && query.having.length > 0;
}
function unsafeOrderBy(query) {
  return query.orderBy && query.orderBy.length > 0 && (query.limit !== void 0 || query.offset !== void 0);
}
function unsafeFnSelect(query) {
  return query.fnSelect || query.fnWhere && query.fnWhere.length > 0 || query.fnHaving && query.fnHaving.length > 0;
}
function isSafeToPushIntoExistingSubquery(query, whereClause, outerAlias) {
  return !(unsafeSelect(query, whereClause, outerAlias) || unsafeGroupBy(query) || unsafeHaving(query) || unsafeOrderBy(query) || unsafeFnSelect(query));
}
function selectHasAggregates(select) {
  for (const value of Object.values(select)) {
    if (typeof value === `object`) {
      const v = value;
      if (v.type === `agg`) return true;
      if (!(`type` in v)) {
        if (selectHasAggregates(v)) return true;
      }
    }
  }
  return false;
}
function collectRefs(expr) {
  const refs = [];
  if (expr == null || typeof expr !== `object`) return refs;
  switch (expr.type) {
    case `ref`:
      refs.push(expr);
      break;
    case `func`:
    case `agg`:
      for (const arg of expr.args ?? []) {
        refs.push(...collectRefs(arg));
      }
      break;
  }
  return refs;
}
function whereReferencesComputedSelectFields(select, whereClause, outerAlias) {
  const computed = /* @__PURE__ */ new Set();
  for (const [key, value] of Object.entries(select)) {
    if (key.startsWith(`__SPREAD_SENTINEL__`)) continue;
    if (value instanceof PropRef) continue;
    computed.add(key);
  }
  const refs = collectRefs(whereClause);
  for (const ref of refs) {
    const path = ref.path;
    if (!Array.isArray(path) || path.length < 2) continue;
    const alias = path[0];
    const field = path[1];
    if (alias !== outerAlias) continue;
    if (computed.has(field)) return true;
  }
  return false;
}
function referencesAliasWithRemappedSelect(subquery, whereClause, outerAlias) {
  const refs = collectRefs(whereClause);
  if (refs.every((ref) => ref.path[0] !== outerAlias)) {
    return false;
  }
  if (subquery.fnSelect) {
    return true;
  }
  const select = subquery.select;
  if (!select) {
    return false;
  }
  for (const ref of refs) {
    const path = ref.path;
    if (path.length < 2) continue;
    if (path[0] !== outerAlias) continue;
    const projected = select[path[1]];
    if (!projected) continue;
    if (!(projected instanceof PropRef)) {
      return true;
    }
    if (projected.path.length < 2) {
      return true;
    }
    const [innerAlias, innerField] = projected.path;
    if (innerAlias !== outerAlias && innerAlias !== subquery.from.alias) {
      return true;
    }
    if (innerField !== path[1]) {
      return true;
    }
  }
  return false;
}
function combineWithAnd(expressions) {
  if (expressions.length === 0) {
    throw new CannotCombineEmptyExpressionListError();
  }
  if (expressions.length === 1) {
    return expressions[0];
  }
  return new Func(`and`, expressions);
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/compiler/joins.js
function processJoins(pipeline, joinClauses, sources, mainCollectionId, mainSource, allInputs, cache, queryMapping, collections, subscriptions, callbacks, lazySources, optimizableOrderByCollections, setWindowFn, rawQuery, onCompileSubquery, aliasToCollectionId, aliasRemapping) {
  let resultPipeline = pipeline;
  for (const joinClause of joinClauses) {
    resultPipeline = processJoin(
      resultPipeline,
      joinClause,
      sources,
      mainCollectionId,
      mainSource,
      allInputs,
      cache,
      queryMapping,
      collections,
      subscriptions,
      callbacks,
      lazySources,
      optimizableOrderByCollections,
      setWindowFn,
      rawQuery,
      onCompileSubquery,
      aliasToCollectionId,
      aliasRemapping
    );
  }
  return resultPipeline;
}
function processJoin(pipeline, joinClause, sources, mainCollectionId, mainSource, allInputs, cache, queryMapping, collections, subscriptions, callbacks, lazySources, optimizableOrderByCollections, setWindowFn, rawQuery, onCompileSubquery, aliasToCollectionId, aliasRemapping) {
  const isCollectionRef = joinClause.from.type === `collectionRef`;
  const {
    alias: joinedSource,
    input: joinedInput,
    collectionId: joinedCollectionId
  } = processJoinSource(
    joinClause.from,
    allInputs,
    collections,
    subscriptions,
    callbacks,
    lazySources,
    optimizableOrderByCollections,
    setWindowFn,
    cache,
    queryMapping,
    onCompileSubquery,
    aliasToCollectionId,
    aliasRemapping
  );
  sources[joinedSource] = joinedInput;
  if (isCollectionRef) {
    aliasToCollectionId[joinedSource] = joinedCollectionId;
  }
  const mainCollection = collections[mainCollectionId];
  const joinedCollection = collections[joinedCollectionId];
  if (!mainCollection) {
    throw new JoinCollectionNotFoundError(mainCollectionId);
  }
  if (!joinedCollection) {
    throw new JoinCollectionNotFoundError(joinedCollectionId);
  }
  const { activeSource, lazySource } = getActiveAndLazySources(
    joinClause.type,
    mainCollection,
    joinedCollection
  );
  const availableSources = Object.keys(sources);
  const { mainExpr, joinedExpr } = analyzeJoinExpressions(
    joinClause.left,
    joinClause.right,
    availableSources,
    joinedSource
  );
  const compiledMainExpr = compileExpression(mainExpr);
  const compiledJoinedExpr = compileExpression(joinedExpr);
  let mainPipeline = pipeline.pipe(
    map(([currentKey, namespacedRow]) => {
      const mainKey = compiledMainExpr(namespacedRow);
      return [mainKey, [currentKey, namespacedRow]];
    })
  );
  let joinedPipeline = joinedInput.pipe(
    map(([currentKey, row]) => {
      const namespacedRow = { [joinedSource]: row };
      const joinedKey = compiledJoinedExpr(namespacedRow);
      return [joinedKey, [currentKey, namespacedRow]];
    })
  );
  if (![`inner`, `left`, `right`, `full`].includes(joinClause.type)) {
    throw new UnsupportedJoinTypeError(joinClause.type);
  }
  if (activeSource) {
    const lazyFrom = activeSource === `main` ? joinClause.from : rawQuery.from;
    const limitedSubquery = lazyFrom.type === `queryRef` && (lazyFrom.query.limit || lazyFrom.query.offset);
    const hasComputedJoinExpr = mainExpr.type === `func` || joinedExpr.type === `func`;
    if (!limitedSubquery && !hasComputedJoinExpr) {
      const lazyAlias = activeSource === `main` ? joinedSource : mainSource;
      lazySources.add(lazyAlias);
      const activePipeline = activeSource === `main` ? mainPipeline : joinedPipeline;
      const lazySourceJoinExpr = activeSource === `main` ? joinedExpr : mainExpr;
      const followRefResult = followRef(
        rawQuery,
        lazySourceJoinExpr,
        lazySource
      );
      const followRefCollection = followRefResult.collection;
      const fieldName = followRefResult.path[0];
      if (fieldName) {
        ensureIndexForField(
          fieldName,
          followRefResult.path,
          followRefCollection
        );
      }
      const activePipelineWithLoading = activePipeline.pipe(
        tap((data) => {
          const resolvedAlias = aliasRemapping[lazyAlias] || lazyAlias;
          const lazySourceSubscription = subscriptions[resolvedAlias];
          if (!lazySourceSubscription) {
            throw new SubscriptionNotFoundError(
              resolvedAlias,
              lazyAlias,
              lazySource.id,
              Object.keys(subscriptions)
            );
          }
          if (lazySourceSubscription.hasLoadedInitialState()) {
            return;
          }
          const joinKeys = data.getInner().map(([[joinKey]]) => joinKey);
          const lazyJoinRef = new PropRef(followRefResult.path);
          const loaded = lazySourceSubscription.requestSnapshot({
            where: inArray(lazyJoinRef, joinKeys),
            optimizedOnly: true
          });
          if (!loaded) {
            lazySourceSubscription.requestSnapshot();
          }
        })
      );
      if (activeSource === `main`) {
        mainPipeline = activePipelineWithLoading;
      } else {
        joinedPipeline = activePipelineWithLoading;
      }
    }
  }
  return mainPipeline.pipe(
    join(joinedPipeline, joinClause.type),
    processJoinResults(joinClause.type)
  );
}
function analyzeJoinExpressions(left, right, allAvailableSourceAliases, joinedSource) {
  const availableSources = allAvailableSourceAliases.filter(
    (alias) => alias !== joinedSource
  );
  const leftSourceAlias = getSourceAliasFromExpression(left);
  const rightSourceAlias = getSourceAliasFromExpression(right);
  if (leftSourceAlias && availableSources.includes(leftSourceAlias) && rightSourceAlias === joinedSource) {
    return { mainExpr: left, joinedExpr: right };
  }
  if (leftSourceAlias === joinedSource && rightSourceAlias && availableSources.includes(rightSourceAlias)) {
    return { mainExpr: right, joinedExpr: left };
  }
  if (!leftSourceAlias || !rightSourceAlias) {
    throw new InvalidJoinConditionSourceMismatchError();
  }
  if (leftSourceAlias === rightSourceAlias) {
    throw new InvalidJoinConditionSameSourceError(leftSourceAlias);
  }
  if (!availableSources.includes(leftSourceAlias)) {
    throw new InvalidJoinConditionLeftSourceError(leftSourceAlias);
  }
  if (rightSourceAlias !== joinedSource) {
    throw new InvalidJoinConditionRightSourceError(joinedSource);
  }
  throw new InvalidJoinCondition();
}
function getSourceAliasFromExpression(expr) {
  switch (expr.type) {
    case `ref`:
      return expr.path[0] || null;
    case `func`: {
      const sourceAliases = /* @__PURE__ */ new Set();
      for (const arg of expr.args) {
        const alias = getSourceAliasFromExpression(arg);
        if (alias) {
          sourceAliases.add(alias);
        }
      }
      return sourceAliases.size === 1 ? Array.from(sourceAliases)[0] : null;
    }
    default:
      return null;
  }
}
function processJoinSource(from, allInputs, collections, subscriptions, callbacks, lazySources, optimizableOrderByCollections, setWindowFn, cache, queryMapping, onCompileSubquery, aliasToCollectionId, aliasRemapping) {
  switch (from.type) {
    case `collectionRef`: {
      const input = allInputs[from.alias];
      if (!input) {
        throw new CollectionInputNotFoundError(
          from.alias,
          from.collection.id,
          Object.keys(allInputs)
        );
      }
      aliasToCollectionId[from.alias] = from.collection.id;
      return { alias: from.alias, input, collectionId: from.collection.id };
    }
    case `queryRef`: {
      const originalQuery = queryMapping.get(from.query) || from.query;
      const subQueryResult = onCompileSubquery(
        originalQuery,
        allInputs,
        collections,
        subscriptions,
        callbacks,
        lazySources,
        optimizableOrderByCollections,
        setWindowFn,
        cache,
        queryMapping
      );
      Object.assign(aliasToCollectionId, subQueryResult.aliasToCollectionId);
      Object.assign(aliasRemapping, subQueryResult.aliasRemapping);
      const innerAlias = Object.keys(subQueryResult.aliasToCollectionId).find(
        (alias) => subQueryResult.aliasToCollectionId[alias] === subQueryResult.collectionId
      );
      if (innerAlias && innerAlias !== from.alias) {
        aliasRemapping[from.alias] = innerAlias;
      }
      const subQueryInput = subQueryResult.pipeline;
      const extractedInput = subQueryInput.pipe(
        map((data) => {
          const [key, [value, _orderByIndex]] = data;
          return [key, value];
        })
      );
      return {
        alias: from.alias,
        input: extractedInput,
        collectionId: subQueryResult.collectionId
      };
    }
    default:
      throw new UnsupportedJoinSourceTypeError(from.type);
  }
}
function processJoinResults(joinType) {
  return function(pipeline) {
    return pipeline.pipe(
      // Process the join result and handle nulls
      filter((result) => {
        const [_key, [main, joined]] = result;
        const mainNamespacedRow = main == null ? void 0 : main[1];
        const joinedNamespacedRow = joined == null ? void 0 : joined[1];
        if (joinType === `inner`) {
          return !!(mainNamespacedRow && joinedNamespacedRow);
        }
        if (joinType === `left`) {
          return !!mainNamespacedRow;
        }
        if (joinType === `right`) {
          return !!joinedNamespacedRow;
        }
        return true;
      }),
      map((result) => {
        const [_key, [main, joined]] = result;
        const mainKey = main == null ? void 0 : main[0];
        const mainNamespacedRow = main == null ? void 0 : main[1];
        const joinedKey = joined == null ? void 0 : joined[0];
        const joinedNamespacedRow = joined == null ? void 0 : joined[1];
        const mergedNamespacedRow = {};
        if (mainNamespacedRow) {
          Object.assign(mergedNamespacedRow, mainNamespacedRow);
        }
        if (joinedNamespacedRow) {
          Object.assign(mergedNamespacedRow, joinedNamespacedRow);
        }
        const resultKey = `[${mainKey},${joinedKey}]`;
        return [resultKey, mergedNamespacedRow];
      })
    );
  };
}
function getActiveAndLazySources(joinType, leftCollection, rightCollection) {
  switch (joinType) {
    case `left`:
      return { activeSource: `main`, lazySource: rightCollection };
    case `right`:
      return { activeSource: `joined`, lazySource: leftCollection };
    case `inner`:
      return leftCollection.size < rightCollection.size ? { activeSource: `main`, lazySource: rightCollection } : { activeSource: `joined`, lazySource: leftCollection };
    default:
      return { activeSource: void 0, lazySource: void 0 };
  }
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/compiler/select.js
function unwrapVal(input) {
  if (input instanceof Value) return input.value;
  return input;
}
function processMerge(op, namespacedRow, selectResults) {
  const value = op.source(namespacedRow);
  if (value && typeof value === `object`) {
    let cursor = selectResults;
    const path = op.targetPath;
    if (path.length === 0) {
      for (const [k, v] of Object.entries(value)) {
        selectResults[k] = unwrapVal(v);
      }
    } else {
      for (let i = 0; i < path.length; i++) {
        const seg = path[i];
        if (i === path.length - 1) {
          const dest = cursor[seg] ?? (cursor[seg] = {});
          if (typeof dest === `object`) {
            for (const [k, v] of Object.entries(value)) {
              dest[k] = unwrapVal(v);
            }
          }
        } else {
          const next = cursor[seg];
          if (next == null || typeof next !== `object`) {
            cursor[seg] = {};
          }
          cursor = cursor[seg];
        }
      }
    }
  }
}
function processNonMergeOp(op, namespacedRow, selectResults) {
  const path = op.alias.split(`.`);
  if (path.length === 1) {
    selectResults[op.alias] = op.compiled(namespacedRow);
  } else {
    let cursor = selectResults;
    for (let i = 0; i < path.length - 1; i++) {
      const seg = path[i];
      const next = cursor[seg];
      if (next == null || typeof next !== `object`) {
        cursor[seg] = {};
      }
      cursor = cursor[seg];
    }
    cursor[path[path.length - 1]] = unwrapVal(op.compiled(namespacedRow));
  }
}
function processRow([key, namespacedRow], ops) {
  const selectResults = {};
  for (const op of ops) {
    if (op.kind === `merge`) {
      processMerge(op, namespacedRow, selectResults);
    } else {
      processNonMergeOp(op, namespacedRow, selectResults);
    }
  }
  return [
    key,
    {
      ...namespacedRow,
      __select_results: selectResults
    }
  ];
}
function processSelect(pipeline, select, _allInputs) {
  const ops = [];
  addFromObject([], select, ops);
  return pipeline.pipe(map((row) => processRow(row, ops)));
}
function isAggregateExpression(expr) {
  return expr.type === `agg`;
}
function isNestedSelectObject(obj) {
  return obj && typeof obj === `object` && !isExpressionLike(obj);
}
function addFromObject(prefixPath, obj, ops) {
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith(`__SPREAD_SENTINEL__`)) {
      const rest = key.slice(`__SPREAD_SENTINEL__`.length);
      const splitIndex = rest.lastIndexOf(`__`);
      const pathStr = splitIndex >= 0 ? rest.slice(0, splitIndex) : rest;
      const isRefExpr = value && typeof value === `object` && `type` in value && value.type === `ref`;
      if (pathStr.includes(`.`) || isRefExpr) {
        const targetPath = [...prefixPath];
        const expr = isRefExpr ? value : new PropRef(pathStr.split(`.`));
        const compiled = compileExpression(expr);
        ops.push({ kind: `merge`, targetPath, source: compiled });
      } else {
        const tableAlias = pathStr;
        const targetPath = [...prefixPath];
        ops.push({
          kind: `merge`,
          targetPath,
          source: (row) => row[tableAlias]
        });
      }
      continue;
    }
    const expression = value;
    if (isNestedSelectObject(expression)) {
      addFromObject([...prefixPath, key], expression, ops);
      continue;
    }
    if (isAggregateExpression(expression)) {
      ops.push({
        kind: `field`,
        alias: [...prefixPath, key].join(`.`),
        compiled: () => null
      });
    } else {
      if (expression === void 0 || !isExpressionLike(expression)) {
        ops.push({
          kind: `field`,
          alias: [...prefixPath, key].join(`.`),
          compiled: () => expression
        });
        continue;
      }
      if (expression instanceof Value) {
        const val = expression.value;
        ops.push({
          kind: `field`,
          alias: [...prefixPath, key].join(`.`),
          compiled: () => val
        });
      } else {
        ops.push({
          kind: `field`,
          alias: [...prefixPath, key].join(`.`),
          compiled: compileExpression(expression)
        });
      }
    }
  }
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/compiler/index.js
function compileQuery(rawQuery, inputs, collections, subscriptions, callbacks, lazySources, optimizableOrderByCollections, setWindowFn, cache = /* @__PURE__ */ new WeakMap(), queryMapping = /* @__PURE__ */ new WeakMap()) {
  const cachedResult = cache.get(rawQuery);
  if (cachedResult) {
    return cachedResult;
  }
  validateQueryStructure(rawQuery);
  const { optimizedQuery: query, sourceWhereClauses } = optimizeQuery(rawQuery);
  queryMapping.set(query, rawQuery);
  mapNestedQueries(query, rawQuery, queryMapping);
  const allInputs = { ...inputs };
  const aliasToCollectionId = {};
  const aliasRemapping = {};
  const sources = {};
  const {
    alias: mainSource,
    input: mainInput,
    collectionId: mainCollectionId
  } = processFrom(
    query.from,
    allInputs,
    collections,
    subscriptions,
    callbacks,
    lazySources,
    optimizableOrderByCollections,
    setWindowFn,
    cache,
    queryMapping,
    aliasToCollectionId,
    aliasRemapping
  );
  sources[mainSource] = mainInput;
  let pipeline = mainInput.pipe(
    map(([key, row]) => {
      const ret = [key, { [mainSource]: row }];
      return ret;
    })
  );
  if (query.join && query.join.length > 0) {
    pipeline = processJoins(
      pipeline,
      query.join,
      sources,
      mainCollectionId,
      mainSource,
      allInputs,
      cache,
      queryMapping,
      collections,
      subscriptions,
      callbacks,
      lazySources,
      optimizableOrderByCollections,
      setWindowFn,
      rawQuery,
      compileQuery,
      aliasToCollectionId,
      aliasRemapping
    );
  }
  if (query.where && query.where.length > 0) {
    for (const where of query.where) {
      const whereExpression = getWhereExpression(where);
      const compiledWhere = compileExpression(whereExpression);
      pipeline = pipeline.pipe(
        filter(([_key, namespacedRow]) => {
          return toBooleanPredicate(compiledWhere(namespacedRow));
        })
      );
    }
  }
  if (query.fnWhere && query.fnWhere.length > 0) {
    for (const fnWhere of query.fnWhere) {
      pipeline = pipeline.pipe(
        filter(([_key, namespacedRow]) => {
          return toBooleanPredicate(fnWhere(namespacedRow));
        })
      );
    }
  }
  if (query.distinct && !query.fnSelect && !query.select) {
    throw new DistinctRequiresSelectError();
  }
  if (query.fnSelect) {
    pipeline = pipeline.pipe(
      map(([key, namespacedRow]) => {
        const selectResults = query.fnSelect(namespacedRow);
        return [
          key,
          {
            ...namespacedRow,
            __select_results: selectResults
          }
        ];
      })
    );
  } else if (query.select) {
    pipeline = processSelect(pipeline, query.select);
  } else {
    pipeline = pipeline.pipe(
      map(([key, namespacedRow]) => {
        const selectResults = !query.join && !query.groupBy ? namespacedRow[mainSource] : namespacedRow;
        return [
          key,
          {
            ...namespacedRow,
            __select_results: selectResults
          }
        ];
      })
    );
  }
  if (query.groupBy && query.groupBy.length > 0) {
    pipeline = processGroupBy(
      pipeline,
      query.groupBy,
      query.having,
      query.select,
      query.fnHaving
    );
  } else if (query.select) {
    const hasAggregates = Object.values(query.select).some(
      (expr) => expr.type === `agg`
    );
    if (hasAggregates) {
      pipeline = processGroupBy(
        pipeline,
        [],
        // Empty group by means single group
        query.having,
        query.select,
        query.fnHaving
      );
    }
  }
  if (query.having && (!query.groupBy || query.groupBy.length === 0)) {
    const hasAggregates = query.select ? Object.values(query.select).some((expr) => expr.type === `agg`) : false;
    if (!hasAggregates) {
      throw new HavingRequiresGroupByError();
    }
  }
  if (query.fnHaving && query.fnHaving.length > 0 && (!query.groupBy || query.groupBy.length === 0)) {
    for (const fnHaving of query.fnHaving) {
      pipeline = pipeline.pipe(
        filter(([_key, namespacedRow]) => {
          return fnHaving(namespacedRow);
        })
      );
    }
  }
  if (query.distinct) {
    pipeline = pipeline.pipe(distinct(([_key, row]) => row.__select_results));
  }
  if (query.orderBy && query.orderBy.length > 0) {
    const orderedPipeline = processOrderBy(
      rawQuery,
      pipeline,
      query.orderBy,
      query.select || {},
      collections[mainCollectionId],
      optimizableOrderByCollections,
      setWindowFn,
      query.limit,
      query.offset
    );
    const resultPipeline2 = orderedPipeline.pipe(
      map(([key, [row, orderByIndex]]) => {
        const raw = row.__select_results;
        const finalResults = unwrapValue(raw);
        return [key, [finalResults, orderByIndex]];
      })
    );
    const result2 = resultPipeline2;
    const compilationResult2 = {
      collectionId: mainCollectionId,
      pipeline: result2,
      sourceWhereClauses,
      aliasToCollectionId,
      aliasRemapping
    };
    cache.set(rawQuery, compilationResult2);
    return compilationResult2;
  } else if (query.limit !== void 0 || query.offset !== void 0) {
    throw new LimitOffsetRequireOrderByError();
  }
  const resultPipeline = pipeline.pipe(
    map(([key, row]) => {
      const raw = row.__select_results;
      const finalResults = unwrapValue(raw);
      return [key, [finalResults, void 0]];
    })
  );
  const result = resultPipeline;
  const compilationResult = {
    collectionId: mainCollectionId,
    pipeline: result,
    sourceWhereClauses,
    aliasToCollectionId,
    aliasRemapping
  };
  cache.set(rawQuery, compilationResult);
  return compilationResult;
}
function collectDirectCollectionAliases(query) {
  const aliases = /* @__PURE__ */ new Set();
  if (query.from.type === `collectionRef`) {
    aliases.add(query.from.alias);
  }
  if (query.join) {
    for (const joinClause of query.join) {
      if (joinClause.from.type === `collectionRef`) {
        aliases.add(joinClause.from.alias);
      }
    }
  }
  return aliases;
}
function validateQueryStructure(query, parentCollectionAliases = /* @__PURE__ */ new Set()) {
  const currentLevelAliases = collectDirectCollectionAliases(query);
  for (const alias of currentLevelAliases) {
    if (parentCollectionAliases.has(alias)) {
      throw new DuplicateAliasInSubqueryError(
        alias,
        Array.from(parentCollectionAliases)
      );
    }
  }
  const combinedAliases = /* @__PURE__ */ new Set([
    ...parentCollectionAliases,
    ...currentLevelAliases
  ]);
  if (query.from.type === `queryRef`) {
    validateQueryStructure(query.from.query, combinedAliases);
  }
  if (query.join) {
    for (const joinClause of query.join) {
      if (joinClause.from.type === `queryRef`) {
        validateQueryStructure(joinClause.from.query, combinedAliases);
      }
    }
  }
}
function processFrom(from, allInputs, collections, subscriptions, callbacks, lazySources, optimizableOrderByCollections, setWindowFn, cache, queryMapping, aliasToCollectionId, aliasRemapping) {
  switch (from.type) {
    case `collectionRef`: {
      const input = allInputs[from.alias];
      if (!input) {
        throw new CollectionInputNotFoundError(
          from.alias,
          from.collection.id,
          Object.keys(allInputs)
        );
      }
      aliasToCollectionId[from.alias] = from.collection.id;
      return { alias: from.alias, input, collectionId: from.collection.id };
    }
    case `queryRef`: {
      const originalQuery = queryMapping.get(from.query) || from.query;
      const subQueryResult = compileQuery(
        originalQuery,
        allInputs,
        collections,
        subscriptions,
        callbacks,
        lazySources,
        optimizableOrderByCollections,
        setWindowFn,
        cache,
        queryMapping
      );
      Object.assign(aliasToCollectionId, subQueryResult.aliasToCollectionId);
      Object.assign(aliasRemapping, subQueryResult.aliasRemapping);
      const innerAlias = Object.keys(subQueryResult.aliasToCollectionId).find(
        (alias) => subQueryResult.aliasToCollectionId[alias] === subQueryResult.collectionId
      );
      if (innerAlias && innerAlias !== from.alias) {
        aliasRemapping[from.alias] = innerAlias;
      }
      const subQueryInput = subQueryResult.pipeline;
      const extractedInput = subQueryInput.pipe(
        map((data) => {
          const [key, [value, _orderByIndex]] = data;
          const unwrapped = unwrapValue(value);
          return [key, unwrapped];
        })
      );
      return {
        alias: from.alias,
        input: extractedInput,
        collectionId: subQueryResult.collectionId
      };
    }
    default:
      throw new UnsupportedFromTypeError(from.type);
  }
}
function isValue(raw) {
  return raw instanceof Value || raw && typeof raw === `object` && `type` in raw && raw.type === `val`;
}
function unwrapValue(value) {
  return isValue(value) ? value.value : value;
}
function mapNestedQueries(optimizedQuery, originalQuery, queryMapping) {
  if (optimizedQuery.from.type === `queryRef` && originalQuery.from.type === `queryRef`) {
    queryMapping.set(optimizedQuery.from.query, originalQuery.from.query);
    mapNestedQueries(
      optimizedQuery.from.query,
      originalQuery.from.query,
      queryMapping
    );
  }
  if (optimizedQuery.join && originalQuery.join) {
    for (let i = 0; i < optimizedQuery.join.length && i < originalQuery.join.length; i++) {
      const optimizedJoin = optimizedQuery.join[i];
      const originalJoin = originalQuery.join[i];
      if (optimizedJoin.from.type === `queryRef` && originalJoin.from.type === `queryRef`) {
        queryMapping.set(optimizedJoin.from.query, originalJoin.from.query);
        mapNestedQueries(
          optimizedJoin.from.query,
          originalJoin.from.query,
          queryMapping
        );
      }
    }
  }
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/compiler/expressions.js
function normalizeExpressionPaths(whereClause, collectionAlias) {
  const tpe = whereClause.type;
  if (tpe === `val`) {
    return new Value(whereClause.value);
  } else if (tpe === `ref`) {
    const path = whereClause.path;
    if (Array.isArray(path)) {
      if (path[0] === collectionAlias && path.length > 1) {
        return new PropRef(path.slice(1));
      } else if (path.length === 1 && path[0] !== void 0) {
        return new PropRef([path[0]]);
      }
    }
    return new PropRef(Array.isArray(path) ? path : [String(path)]);
  } else {
    const args = [];
    for (const arg of whereClause.args) {
      const convertedArg = normalizeExpressionPaths(
        arg,
        collectionAlias
      );
      args.push(convertedArg);
    }
    return new Func(whereClause.name, args);
  }
}
function normalizeOrderByPaths(orderBy2, collectionAlias) {
  const normalizedOrderBy = orderBy2.map((clause) => {
    const basicExp = normalizeExpressionPaths(
      clause.expression,
      collectionAlias
    );
    return {
      ...clause,
      expression: basicExp
    };
  });
  return normalizedOrderBy;
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/live/collection-subscriber.js
var loadMoreCallbackSymbol = Symbol.for(
  `@tanstack/db.collection-config-builder`
);
var CollectionSubscriber = class {
  constructor(alias, collectionId, collection, collectionConfigBuilder) {
    this.alias = alias;
    this.collectionId = collectionId;
    this.collection = collection;
    this.collectionConfigBuilder = collectionConfigBuilder;
    this.biggest = void 0;
    this.subscriptionLoadingPromises = /* @__PURE__ */ new Map();
  }
  subscribe() {
    const whereClause = this.getWhereClauseForAlias();
    if (whereClause) {
      const whereExpression = normalizeExpressionPaths(whereClause, this.alias);
      return this.subscribeToChanges(whereExpression);
    }
    return this.subscribeToChanges();
  }
  subscribeToChanges(whereExpression) {
    let subscription;
    const orderByInfo = this.getOrderByInfo();
    if (orderByInfo) {
      subscription = this.subscribeToOrderedChanges(
        whereExpression,
        orderByInfo
      );
    } else {
      const includeInitialState = !this.collectionConfigBuilder.isLazyAlias(
        this.alias
      );
      subscription = this.subscribeToMatchingChanges(
        whereExpression,
        includeInitialState
      );
    }
    const trackLoadPromise = () => {
      if (!this.subscriptionLoadingPromises.has(subscription)) {
        let resolve;
        const promise = new Promise((res) => {
          resolve = res;
        });
        this.subscriptionLoadingPromises.set(subscription, {
          resolve
        });
        this.collectionConfigBuilder.liveQueryCollection._sync.trackLoadPromise(
          promise
        );
      }
    };
    if (subscription.status === `loadingSubset`) {
      trackLoadPromise();
    }
    const statusUnsubscribe = subscription.on(`status:change`, (event) => {
      if (event.status === `loadingSubset`) {
        trackLoadPromise();
      } else {
        const deferred = this.subscriptionLoadingPromises.get(subscription);
        if (deferred) {
          this.subscriptionLoadingPromises.delete(subscription);
          deferred.resolve();
        }
      }
    });
    const unsubscribe = () => {
      const deferred = this.subscriptionLoadingPromises.get(subscription);
      if (deferred) {
        this.subscriptionLoadingPromises.delete(subscription);
        deferred.resolve();
      }
      statusUnsubscribe();
      subscription.unsubscribe();
    };
    this.collectionConfigBuilder.currentSyncState.unsubscribeCallbacks.add(
      unsubscribe
    );
    return subscription;
  }
  sendChangesToPipeline(changes, callback) {
    const input = this.collectionConfigBuilder.currentSyncState.inputs[this.alias];
    const sentChanges = sendChangesToInput(
      input,
      changes,
      this.collection.config.getKey
    );
    const dataLoader = sentChanges > 0 ? callback : void 0;
    this.collectionConfigBuilder.scheduleGraphRun(dataLoader, {
      alias: this.alias
    });
  }
  subscribeToMatchingChanges(whereExpression, includeInitialState = false) {
    const sendChanges = (changes) => {
      this.sendChangesToPipeline(changes);
    };
    const subscription = this.collection.subscribeChanges(sendChanges, {
      includeInitialState,
      whereExpression
    });
    return subscription;
  }
  subscribeToOrderedChanges(whereExpression, orderByInfo) {
    const { orderBy: orderBy2, offset, limit, index } = orderByInfo;
    const sendChangesInRange = (changes) => {
      const splittedChanges = splitUpdates(changes);
      this.sendChangesToPipelineWithTracking(splittedChanges, subscription);
    };
    const subscription = this.collection.subscribeChanges(sendChangesInRange, {
      whereExpression
    });
    subscription.setOrderByIndex(index);
    const normalizedOrderBy = normalizeOrderByPaths(orderBy2, this.alias);
    subscription.requestLimitedSnapshot({
      limit: offset + limit,
      orderBy: normalizedOrderBy
    });
    return subscription;
  }
  // This function is called by maybeRunGraph
  // after each iteration of the query pipeline
  // to ensure that the orderBy operator has enough data to work with
  loadMoreIfNeeded(subscription) {
    const orderByInfo = this.getOrderByInfo();
    if (!orderByInfo) {
      return true;
    }
    const { dataNeeded } = orderByInfo;
    if (!dataNeeded) {
      throw new Error(
        `Missing dataNeeded callback for collection ${this.collectionId}`
      );
    }
    const n = dataNeeded();
    if (n > 0) {
      this.loadNextItems(n, subscription);
    }
    return true;
  }
  sendChangesToPipelineWithTracking(changes, subscription) {
    const orderByInfo = this.getOrderByInfo();
    if (!orderByInfo) {
      this.sendChangesToPipeline(changes);
      return;
    }
    const trackedChanges = this.trackSentValues(changes, orderByInfo.comparator);
    const subscriptionWithLoader = subscription;
    subscriptionWithLoader[loadMoreCallbackSymbol] ?? (subscriptionWithLoader[loadMoreCallbackSymbol] = this.loadMoreIfNeeded.bind(this, subscription));
    this.sendChangesToPipeline(
      trackedChanges,
      subscriptionWithLoader[loadMoreCallbackSymbol]
    );
  }
  // Loads the next `n` items from the collection
  // starting from the biggest item it has sent
  loadNextItems(n, subscription) {
    const orderByInfo = this.getOrderByInfo();
    if (!orderByInfo) {
      return;
    }
    const { orderBy: orderBy2, valueExtractorForRawRow } = orderByInfo;
    const biggestSentRow = this.biggest;
    const biggestSentValue = biggestSentRow ? valueExtractorForRawRow(biggestSentRow) : biggestSentRow;
    const normalizedOrderBy = normalizeOrderByPaths(orderBy2, this.alias);
    subscription.requestLimitedSnapshot({
      orderBy: normalizedOrderBy,
      limit: n,
      minValue: biggestSentValue
    });
  }
  getWhereClauseForAlias() {
    const sourceWhereClausesCache = this.collectionConfigBuilder.sourceWhereClausesCache;
    if (!sourceWhereClausesCache) {
      return void 0;
    }
    return sourceWhereClausesCache.get(this.alias);
  }
  getOrderByInfo() {
    const info = this.collectionConfigBuilder.optimizableOrderByCollections[this.collectionId];
    if (info && info.alias === this.alias) {
      return info;
    }
    return void 0;
  }
  *trackSentValues(changes, comparator) {
    for (const change of changes) {
      if (!this.biggest) {
        this.biggest = change.value;
      } else if (comparator(this.biggest, change.value) < 0) {
        this.biggest = change.value;
      }
      yield change;
    }
  }
};
function sendChangesToInput(input, changes, getKey2) {
  const multiSetArray = [];
  for (const change of changes) {
    const key = getKey2(change.value);
    if (change.type === `insert`) {
      multiSetArray.push([[key, change.value], 1]);
    } else if (change.type === `update`) {
      multiSetArray.push([[key, change.previousValue], -1]);
      multiSetArray.push([[key, change.value], 1]);
    } else {
      multiSetArray.push([[key, change.value], -1]);
    }
  }
  if (multiSetArray.length !== 0) {
    input.sendData(new MultiSet(multiSetArray));
  }
  return multiSetArray.length;
}
function* splitUpdates(changes) {
  for (const change of changes) {
    if (change.type === `update`) {
      yield { type: `delete`, key: change.key, value: change.previousValue };
      yield { type: `insert`, key: change.key, value: change.value };
    } else {
      yield change;
    }
  }
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/live/collection-registry.js
var collectionBuilderRegistry = /* @__PURE__ */ new WeakMap();
function getBuilderFromConfig(config) {
  var _a, _b, _c;
  return (_c = (_b = (_a = config.utils) == null ? void 0 : _a[LIVE_QUERY_INTERNAL]) == null ? void 0 : _b.getBuilder) == null ? void 0 : _c.call(_b);
}
function registerCollectionBuilder(collection, builder) {
  collectionBuilderRegistry.set(collection, builder);
}
function getCollectionBuilder(collection) {
  return collectionBuilderRegistry.get(collection);
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/live/collection-config-builder.js
var liveQueryCollectionCounter = 0;
var CollectionConfigBuilder = class {
  constructor(config) {
    this.config = config;
    this.compiledAliasToCollectionId = {};
    this.resultKeys = /* @__PURE__ */ new WeakMap();
    this.orderByIndices = /* @__PURE__ */ new WeakMap();
    this.isGraphRunning = false;
    this.runCount = 0;
    this.isInErrorState = false;
    this.aliasDependencies = {};
    this.builderDependencies = /* @__PURE__ */ new Set();
    this.pendingGraphRuns = /* @__PURE__ */ new Map();
    this.subscriptions = {};
    this.lazySourcesCallbacks = {};
    this.lazySources = /* @__PURE__ */ new Set();
    this.optimizableOrderByCollections = {};
    this.id = config.id || `live-query-${++liveQueryCollectionCounter}`;
    this.query = buildQueryFromConfig(config);
    this.collections = extractCollectionsFromQuery(this.query);
    const collectionAliasesById = extractCollectionAliases(this.query);
    this.collectionByAlias = {};
    for (const [collectionId, aliases] of collectionAliasesById.entries()) {
      const collection = this.collections[collectionId];
      if (!collection) continue;
      for (const alias of aliases) {
        this.collectionByAlias[alias] = collection;
      }
    }
    if (this.query.orderBy && this.query.orderBy.length > 0) {
      this.compare = createOrderByComparator(this.orderByIndices);
    }
    this.compareOptions = this.config.defaultStringCollation ?? extractCollectionFromSource(this.query).compareOptions;
    this.compileBasePipeline();
  }
  /**
   * Recursively checks if a query or any of its subqueries contains joins
   */
  hasJoins(query) {
    if (query.join && query.join.length > 0) {
      return true;
    }
    if (query.from.type === `queryRef`) {
      if (this.hasJoins(query.from.query)) {
        return true;
      }
    }
    return false;
  }
  getConfig() {
    return {
      id: this.id,
      getKey: this.config.getKey || ((item) => this.resultKeys.get(item)),
      sync: this.getSyncConfig(),
      compare: this.compare,
      defaultStringCollation: this.compareOptions,
      gcTime: this.config.gcTime || 5e3,
      // 5 seconds by default for live queries
      schema: this.config.schema,
      onInsert: this.config.onInsert,
      onUpdate: this.config.onUpdate,
      onDelete: this.config.onDelete,
      startSync: this.config.startSync,
      singleResult: this.query.singleResult,
      utils: {
        getRunCount: this.getRunCount.bind(this),
        setWindow: this.setWindow.bind(this),
        getWindow: this.getWindow.bind(this),
        [LIVE_QUERY_INTERNAL]: {
          getBuilder: () => this,
          hasCustomGetKey: !!this.config.getKey,
          hasJoins: this.hasJoins(this.query)
        }
      }
    };
  }
  setWindow(options) {
    var _a, _b;
    if (!this.windowFn) {
      throw new SetWindowRequiresOrderByError();
    }
    this.currentWindow = options;
    this.windowFn(options);
    (_a = this.maybeRunGraphFn) == null ? void 0 : _a.call(this);
    if ((_b = this.liveQueryCollection) == null ? void 0 : _b.isLoadingSubset) {
      return new Promise((resolve) => {
        const unsubscribe = this.liveQueryCollection.on(
          `loadingSubset:change`,
          (event) => {
            if (!event.isLoadingSubset) {
              unsubscribe();
              resolve();
            }
          }
        );
      });
    }
    return true;
  }
  getWindow() {
    if (!this.windowFn || !this.currentWindow) {
      return void 0;
    }
    return {
      offset: this.currentWindow.offset ?? 0,
      limit: this.currentWindow.limit ?? 0
    };
  }
  /**
   * Resolves a collection alias to its collection ID.
   *
   * Uses a two-tier lookup strategy:
   * 1. First checks compiled aliases (includes subquery inner aliases)
   * 2. Falls back to declared aliases from the query's from/join clauses
   *
   * @param alias - The alias to resolve (e.g., "employee", "manager")
   * @returns The collection ID that the alias references
   * @throws {Error} If the alias is not found in either lookup
   */
  getCollectionIdForAlias(alias) {
    const compiled = this.compiledAliasToCollectionId[alias];
    if (compiled) {
      return compiled;
    }
    const collection = this.collectionByAlias[alias];
    if (collection) {
      return collection.id;
    }
    throw new Error(`Unknown source alias "${alias}"`);
  }
  isLazyAlias(alias) {
    return this.lazySources.has(alias);
  }
  // The callback function is called after the graph has run.
  // This gives the callback a chance to load more data if needed,
  // that's used to optimize orderBy operators that set a limit,
  // in order to load some more data if we still don't have enough rows after the pipeline has run.
  // That can happen because even though we load N rows, the pipeline might filter some of these rows out
  // causing the orderBy operator to receive less than N rows or even no rows at all.
  // So this callback would notice that it doesn't have enough rows and load some more.
  // The callback returns a boolean, when it's true it's done loading data and we can mark the collection as ready.
  maybeRunGraph(callback) {
    if (this.isGraphRunning) {
      return;
    }
    if (!this.currentSyncConfig || !this.currentSyncState) {
      throw new Error(
        `maybeRunGraph called without active sync session. This should not happen.`
      );
    }
    this.isGraphRunning = true;
    try {
      const { begin, commit } = this.currentSyncConfig;
      const syncState = this.currentSyncState;
      if (this.isInErrorState) {
        return;
      }
      if (syncState.subscribedToAllCollections) {
        while (syncState.graph.pendingWork()) {
          syncState.graph.run();
          callback == null ? void 0 : callback();
        }
        if (syncState.messagesCount === 0) {
          begin();
          commit();
          this.updateLiveQueryStatus(this.currentSyncConfig);
        }
      }
    } finally {
      this.isGraphRunning = false;
    }
  }
  /**
   * Schedules a graph run with the transaction-scoped scheduler.
   * Ensures each builder runs at most once per transaction, with automatic dependency tracking
   * to run parent queries before child queries. Outside a transaction, runs immediately.
   *
   * Multiple calls during a transaction are coalesced into a single execution.
   * Dependencies are auto-discovered from subscribed live queries, or can be overridden.
   * Load callbacks are combined when entries merge.
   *
   * Uses the current sync session's config and syncState from instance properties.
   *
   * @param callback - Optional callback to load more data if needed (returns true when done)
   * @param options - Optional scheduling configuration
   * @param options.contextId - Transaction ID to group work; defaults to active transaction
   * @param options.jobId - Unique identifier for this job; defaults to this builder instance
   * @param options.alias - Source alias that triggered this schedule; adds alias-specific dependencies
   * @param options.dependencies - Explicit dependency list; overrides auto-discovered dependencies
   */
  scheduleGraphRun(callback, options) {
    var _a;
    const contextId = (options == null ? void 0 : options.contextId) ?? ((_a = getActiveTransaction()) == null ? void 0 : _a.id);
    const jobId = (options == null ? void 0 : options.jobId) ?? this;
    const dependentBuilders = (() => {
      if (options == null ? void 0 : options.dependencies) {
        return options.dependencies;
      }
      const deps = new Set(this.builderDependencies);
      if (options == null ? void 0 : options.alias) {
        const aliasDeps = this.aliasDependencies[options.alias];
        if (aliasDeps) {
          for (const dep of aliasDeps) {
            deps.add(dep);
          }
        }
      }
      deps.delete(this);
      return Array.from(deps);
    })();
    if (contextId) {
      for (const dep of dependentBuilders) {
        if (typeof dep.scheduleGraphRun === `function`) {
          dep.scheduleGraphRun(void 0, { contextId });
        }
      }
    }
    if (!this.currentSyncConfig || !this.currentSyncState) {
      throw new Error(
        `scheduleGraphRun called without active sync session. This should not happen.`
      );
    }
    let pending = contextId ? this.pendingGraphRuns.get(contextId) : void 0;
    if (!pending) {
      pending = {
        loadCallbacks: /* @__PURE__ */ new Set()
      };
      if (contextId) {
        this.pendingGraphRuns.set(contextId, pending);
      }
    }
    if (callback) {
      pending.loadCallbacks.add(callback);
    }
    const pendingToPass = contextId ? void 0 : pending;
    transactionScopedScheduler.schedule({
      contextId,
      jobId,
      dependencies: dependentBuilders,
      run: () => this.executeGraphRun(contextId, pendingToPass)
    });
  }
  /**
   * Clears pending graph run state for a specific context.
   * Called when the scheduler clears a context (e.g., transaction rollback/abort).
   */
  clearPendingGraphRun(contextId) {
    this.pendingGraphRuns.delete(contextId);
  }
  /**
   * Returns true if this builder has a pending graph run for the given context.
   */
  hasPendingGraphRun(contextId) {
    return this.pendingGraphRuns.has(contextId);
  }
  /**
   * Executes a pending graph run. Called by the scheduler when dependencies are satisfied.
   * Clears the pending state BEFORE execution so that any re-schedules during the run
   * create fresh state and don't interfere with the current execution.
   * Uses instance sync state - if sync has ended, gracefully returns without executing.
   *
   * @param contextId - Optional context ID to look up pending state
   * @param pendingParam - For immediate execution (no context), pending state is passed directly
   */
  executeGraphRun(contextId, pendingParam) {
    const pending = pendingParam ?? (contextId ? this.pendingGraphRuns.get(contextId) : void 0);
    if (contextId) {
      this.pendingGraphRuns.delete(contextId);
    }
    if (!pending) {
      return;
    }
    if (!this.currentSyncConfig || !this.currentSyncState) {
      return;
    }
    this.incrementRunCount();
    const combinedLoader = () => {
      let allDone = true;
      let firstError;
      pending.loadCallbacks.forEach((loader) => {
        try {
          allDone = loader() && allDone;
        } catch (error) {
          allDone = false;
          firstError ?? (firstError = error);
        }
      });
      if (firstError) {
        throw firstError;
      }
      return allDone;
    };
    this.maybeRunGraph(combinedLoader);
  }
  getSyncConfig() {
    return {
      rowUpdateMode: `full`,
      sync: this.syncFn.bind(this)
    };
  }
  incrementRunCount() {
    this.runCount++;
  }
  getRunCount() {
    return this.runCount;
  }
  syncFn(config) {
    this.liveQueryCollection = config.collection;
    this.currentSyncConfig = config;
    const syncState = {
      messagesCount: 0,
      subscribedToAllCollections: false,
      unsubscribeCallbacks: /* @__PURE__ */ new Set()
    };
    const fullSyncState = this.extendPipelineWithChangeProcessing(
      config,
      syncState
    );
    this.currentSyncState = fullSyncState;
    this.unsubscribeFromSchedulerClears = transactionScopedScheduler.onClear(
      (contextId) => {
        this.clearPendingGraphRun(contextId);
      }
    );
    const loadSubsetDataCallbacks = this.subscribeToAllCollections(
      config,
      fullSyncState
    );
    this.maybeRunGraphFn = () => this.scheduleGraphRun(loadSubsetDataCallbacks);
    this.scheduleGraphRun(loadSubsetDataCallbacks);
    return () => {
      var _a;
      syncState.unsubscribeCallbacks.forEach((unsubscribe) => unsubscribe());
      this.currentSyncConfig = void 0;
      this.currentSyncState = void 0;
      this.pendingGraphRuns.clear();
      this.graphCache = void 0;
      this.inputsCache = void 0;
      this.pipelineCache = void 0;
      this.sourceWhereClausesCache = void 0;
      this.lazySources.clear();
      this.optimizableOrderByCollections = {};
      this.lazySourcesCallbacks = {};
      Object.keys(this.subscriptions).forEach(
        (key) => delete this.subscriptions[key]
      );
      this.compiledAliasToCollectionId = {};
      (_a = this.unsubscribeFromSchedulerClears) == null ? void 0 : _a.call(this);
      this.unsubscribeFromSchedulerClears = void 0;
    };
  }
  /**
   * Compiles the query pipeline with all declared aliases.
   */
  compileBasePipeline() {
    this.graphCache = new D2();
    this.inputsCache = Object.fromEntries(
      Object.keys(this.collectionByAlias).map((alias) => [
        alias,
        this.graphCache.newInput()
      ])
    );
    const compilation = compileQuery(
      this.query,
      this.inputsCache,
      this.collections,
      this.subscriptions,
      this.lazySourcesCallbacks,
      this.lazySources,
      this.optimizableOrderByCollections,
      (windowFn) => {
        this.windowFn = windowFn;
      }
    );
    this.pipelineCache = compilation.pipeline;
    this.sourceWhereClausesCache = compilation.sourceWhereClauses;
    this.compiledAliasToCollectionId = compilation.aliasToCollectionId;
    const missingAliases = Object.keys(this.compiledAliasToCollectionId).filter(
      (alias) => !Object.hasOwn(this.inputsCache, alias)
    );
    if (missingAliases.length > 0) {
      throw new MissingAliasInputsError(missingAliases);
    }
  }
  maybeCompileBasePipeline() {
    if (!this.graphCache || !this.inputsCache || !this.pipelineCache) {
      this.compileBasePipeline();
    }
    return {
      graph: this.graphCache,
      inputs: this.inputsCache,
      pipeline: this.pipelineCache
    };
  }
  extendPipelineWithChangeProcessing(config, syncState) {
    const { begin, commit } = config;
    const { graph, inputs, pipeline } = this.maybeCompileBasePipeline();
    pipeline.pipe(
      output((data) => {
        const messages = data.getInner();
        syncState.messagesCount += messages.length;
        begin();
        messages.reduce(
          accumulateChanges,
          /* @__PURE__ */ new Map()
        ).forEach(this.applyChanges.bind(this, config));
        commit();
      })
    );
    graph.finalize();
    syncState.graph = graph;
    syncState.inputs = inputs;
    syncState.pipeline = pipeline;
    return syncState;
  }
  applyChanges(config, changes, key) {
    const { write, collection } = config;
    const { deletes, inserts, value, orderByIndex } = changes;
    this.resultKeys.set(value, key);
    if (orderByIndex !== void 0) {
      this.orderByIndices.set(value, orderByIndex);
    }
    if (inserts && deletes === 0) {
      write({
        value,
        type: `insert`
      });
    } else if (
      // Insert & update(s) (updates are a delete & insert)
      inserts > deletes || // Just update(s) but the item is already in the collection (so
      // was inserted previously).
      inserts === deletes && collection.has(collection.getKeyFromItem(value))
    ) {
      write({
        value,
        type: `update`
      });
    } else if (deletes > 0) {
      write({
        value,
        type: `delete`
      });
    } else {
      throw new Error(
        `Could not apply changes: ${JSON.stringify(changes)}. This should never happen.`
      );
    }
  }
  /**
   * Handle status changes from source collections
   */
  handleSourceStatusChange(config, collectionId, event) {
    const { status } = event;
    if (status === `error`) {
      this.transitionToError(
        `Source collection '${collectionId}' entered error state`
      );
      return;
    }
    if (status === `cleaned-up`) {
      this.transitionToError(
        `Source collection '${collectionId}' was manually cleaned up while live query '${this.id}' depends on it. Live queries prevent automatic GC, so this was likely a manual cleanup() call.`
      );
      return;
    }
    this.updateLiveQueryStatus(config);
  }
  /**
   * Update the live query status based on source collection statuses
   */
  updateLiveQueryStatus(config) {
    const { markReady } = config;
    if (this.isInErrorState) {
      return;
    }
    if (this.allCollectionsReady()) {
      markReady();
    }
  }
  /**
   * Transition the live query to error state
   */
  transitionToError(message) {
    var _a;
    this.isInErrorState = true;
    console.error(`[Live Query Error] ${message}`);
    (_a = this.liveQueryCollection) == null ? void 0 : _a._lifecycle.setStatus(`error`);
  }
  allCollectionsReady() {
    return Object.values(this.collections).every(
      (collection) => collection.isReady()
    );
  }
  /**
   * Creates per-alias subscriptions enabling self-join support.
   * Each alias gets its own subscription with independent filters, even for the same collection.
   * Example: `{ employee: col, manager: col }` creates two separate subscriptions.
   */
  subscribeToAllCollections(config, syncState) {
    const compiledAliases = Object.entries(this.compiledAliasToCollectionId);
    if (compiledAliases.length === 0) {
      throw new Error(
        `Compiler returned no alias metadata for query '${this.id}'. This should not happen; please report.`
      );
    }
    const loaders = compiledAliases.map(([alias, collectionId]) => {
      const collection = this.collectionByAlias[alias] ?? this.collections[collectionId];
      const dependencyBuilder = getCollectionBuilder(collection);
      if (dependencyBuilder && dependencyBuilder !== this) {
        this.aliasDependencies[alias] = [dependencyBuilder];
        this.builderDependencies.add(dependencyBuilder);
      } else {
        this.aliasDependencies[alias] = [];
      }
      const collectionSubscriber = new CollectionSubscriber(
        alias,
        collectionId,
        collection,
        this
      );
      const statusUnsubscribe = collection.on(`status:change`, (event) => {
        this.handleSourceStatusChange(config, collectionId, event);
      });
      syncState.unsubscribeCallbacks.add(statusUnsubscribe);
      const subscription = collectionSubscriber.subscribe();
      this.subscriptions[alias] = subscription;
      const loadMore = collectionSubscriber.loadMoreIfNeeded.bind(
        collectionSubscriber,
        subscription
      );
      return loadMore;
    });
    const loadSubsetDataCallbacks = () => {
      loaders.map((loader) => loader());
      return true;
    };
    syncState.subscribedToAllCollections = true;
    this.updateLiveQueryStatus(config);
    return loadSubsetDataCallbacks;
  }
};
function buildQueryFromConfig(config) {
  if (typeof config.query === `function`) {
    return buildQuery(config.query);
  }
  return getQueryIR(config.query);
}
function createOrderByComparator(orderByIndices) {
  return (val1, val2) => {
    const index1 = orderByIndices.get(val1);
    const index2 = orderByIndices.get(val2);
    if (index1 && index2) {
      if (index1 < index2) {
        return -1;
      } else if (index1 > index2) {
        return 1;
      } else {
        return 0;
      }
    }
    return 0;
  };
}
function extractCollectionsFromQuery(query) {
  const collections = {};
  function extractFromSource(source) {
    if (source.type === `collectionRef`) {
      collections[source.collection.id] = source.collection;
    } else if (source.type === `queryRef`) {
      extractFromQuery(source.query);
    }
  }
  function extractFromQuery(q) {
    if (q.from) {
      extractFromSource(q.from);
    }
    if (q.join && Array.isArray(q.join)) {
      for (const joinClause of q.join) {
        if (joinClause.from) {
          extractFromSource(joinClause.from);
        }
      }
    }
  }
  extractFromQuery(query);
  return collections;
}
function extractCollectionFromSource(query) {
  const from = query.from;
  if (from.type === `collectionRef`) {
    return from.collection;
  } else if (from.type === `queryRef`) {
    return extractCollectionFromSource(from.query);
  }
  throw new Error(
    `Failed to extract collection. Invalid FROM clause: ${JSON.stringify(query)}`
  );
}
function extractCollectionAliases(query) {
  const aliasesById = /* @__PURE__ */ new Map();
  function recordAlias(source) {
    if (!source) return;
    if (source.type === `collectionRef`) {
      const { id } = source.collection;
      const existing = aliasesById.get(id);
      if (existing) {
        existing.add(source.alias);
      } else {
        aliasesById.set(id, /* @__PURE__ */ new Set([source.alias]));
      }
    } else if (source.type === `queryRef`) {
      traverse(source.query);
    }
  }
  function traverse(q) {
    if (!q) return;
    recordAlias(q.from);
    if (q.join) {
      for (const joinClause of q.join) {
        recordAlias(joinClause.from);
      }
    }
  }
  traverse(query);
  return aliasesById;
}
function accumulateChanges(acc, [[key, tupleData], multiplicity]) {
  const [value, orderByIndex] = tupleData;
  const changes = acc.get(key) || {
    deletes: 0,
    inserts: 0,
    value,
    orderByIndex
  };
  if (multiplicity < 0) {
    changes.deletes += Math.abs(multiplicity);
  } else if (multiplicity > 0) {
    changes.inserts += multiplicity;
    changes.value = value;
    changes.orderByIndex = orderByIndex;
  }
  acc.set(key, changes);
  return acc;
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/live-query-collection.js
function liveQueryCollectionOptions(config) {
  const collectionConfigBuilder = new CollectionConfigBuilder(config);
  return collectionConfigBuilder.getConfig();
}
function createLiveQueryCollection(configOrQuery) {
  if (typeof configOrQuery === `function`) {
    const config = {
      query: configOrQuery
    };
    const options = liveQueryCollectionOptions(config);
    return bridgeToCreateCollection(options);
  } else {
    const config = configOrQuery;
    const options = liveQueryCollectionOptions(config);
    if (config.utils) {
      options.utils = { ...options.utils, ...config.utils };
    }
    return bridgeToCreateCollection(options);
  }
}
function bridgeToCreateCollection(options) {
  const collection = createCollection(options);
  const builder = getBuilderFromConfig(options);
  if (builder) {
    registerCollectionBuilder(collection, builder);
  }
  return collection;
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/predicate-utils.js
function isWhereSubset(subset, superset) {
  if (subset === void 0 && superset === void 0) {
    return true;
  }
  if (subset === void 0 && superset !== void 0) {
    return false;
  }
  if (superset === void 0 && subset !== void 0) {
    return true;
  }
  return isWhereSubsetInternal(subset, superset);
}
function makeDisjunction(preds) {
  if (preds.length === 0) {
    return new Value(false);
  }
  if (preds.length === 1) {
    return preds[0];
  }
  return new Func(`or`, preds);
}
function convertInToOr(inField) {
  const equalities = inField.values.map(
    (value) => new Func(`eq`, [inField.ref, new Value(value)])
  );
  return makeDisjunction(equalities);
}
function isWhereSubsetInternal(subset, superset) {
  if (subset.type === `val` && subset.value === false) {
    return true;
  }
  if (areExpressionsEqual(subset, superset)) {
    return true;
  }
  if (superset.type === `func` && superset.name === `and`) {
    return superset.args.every(
      (arg) => isWhereSubsetInternal(subset, arg)
    );
  }
  if (subset.type === `func` && subset.name === `and`) {
    return subset.args.some(
      (arg) => isWhereSubsetInternal(arg, superset)
    );
  }
  if (subset.type === `func` && subset.name === `in`) {
    const inField = extractInField(subset);
    if (inField) {
      return isWhereSubsetInternal(convertInToOr(inField), superset);
    }
  }
  if (superset.type === `func` && superset.name === `in`) {
    const inField = extractInField(superset);
    if (inField) {
      return isWhereSubsetInternal(subset, convertInToOr(inField));
    }
  }
  if (subset.type === `func` && subset.name === `or`) {
    return subset.args.every(
      (arg) => isWhereSubsetInternal(arg, superset)
    );
  }
  if (superset.type === `func` && superset.name === `or`) {
    return superset.args.some(
      (arg) => isWhereSubsetInternal(subset, arg)
    );
  }
  if (subset.type === `func` && superset.type === `func`) {
    const subsetFunc = subset;
    const supersetFunc = superset;
    const subsetField = extractComparisonField(subsetFunc);
    const supersetField = extractComparisonField(supersetFunc);
    if (subsetField && supersetField && areRefsEqual(subsetField.ref, supersetField.ref)) {
      return isComparisonSubset(
        subsetFunc,
        subsetField.value,
        supersetFunc,
        supersetField.value
      );
    }
  }
  return false;
}
function combineWherePredicates(predicates, operation, simplifyFn) {
  const emptyValue = operation === `and` ? true : false;
  const identityValue = operation === `and` ? true : false;
  if (predicates.length === 0) {
    return { type: `val`, value: emptyValue };
  }
  if (predicates.length === 1) {
    return predicates[0];
  }
  const flatPredicates = [];
  for (const pred of predicates) {
    if (pred.type === `func` && pred.name === operation) {
      flatPredicates.push(...pred.args);
    } else {
      flatPredicates.push(pred);
    }
  }
  const grouped = groupPredicatesByField(flatPredicates);
  const simplified = [];
  for (const [field, preds] of grouped.entries()) {
    if (field === null) {
      simplified.push(...preds);
    } else {
      const result = simplifyFn(preds);
      if (result) {
        simplified.push(result);
      }
    }
  }
  if (simplified.length === 0) {
    return { type: `val`, value: identityValue };
  }
  if (simplified.length === 1) {
    return simplified[0];
  }
  return {
    type: `func`,
    name: operation,
    args: simplified
  };
}
function unionWherePredicates(predicates) {
  return combineWherePredicates(predicates, `or`, unionSameFieldPredicates);
}
function minusWherePredicates(fromPredicate, subtractPredicate) {
  if (subtractPredicate === void 0) {
    return fromPredicate ?? { type: `val`, value: true };
  }
  if (fromPredicate === void 0) {
    return {
      type: `func`,
      name: `not`,
      args: [subtractPredicate]
    };
  }
  if (isWhereSubset(fromPredicate, subtractPredicate)) {
    return { type: `val`, value: false };
  }
  const commonConditions = findCommonConditions(
    fromPredicate,
    subtractPredicate
  );
  if (commonConditions.length > 0) {
    const fromWithoutCommon = removeConditions(fromPredicate, commonConditions);
    const subtractWithoutCommon = removeConditions(
      subtractPredicate,
      commonConditions
    );
    const simplifiedDifference = minusWherePredicates(
      fromWithoutCommon,
      subtractWithoutCommon
    );
    if (simplifiedDifference !== null) {
      return combineConditions([...commonConditions, simplifiedDifference]);
    }
  }
  if (fromPredicate.type === `func` && subtractPredicate.type === `func`) {
    const result = minusSameFieldPredicates(fromPredicate, subtractPredicate);
    if (result !== null) {
      return result;
    }
  }
  return null;
}
function minusSameFieldPredicates(fromPred, subtractPred) {
  const fromField = extractComparisonField(fromPred) || extractEqualityField(fromPred) || extractInField(fromPred);
  const subtractField = extractComparisonField(subtractPred) || extractEqualityField(subtractPred) || extractInField(subtractPred);
  if (!fromField || !subtractField || !areRefsEqual(fromField.ref, subtractField.ref)) {
    return null;
  }
  if (fromPred.name === `in` && subtractPred.name === `in`) {
    const fromInField = fromField;
    const subtractInField = subtractField;
    const remainingValues = fromInField.values.filter(
      (v) => !arrayIncludesWithSet(
        subtractInField.values,
        v,
        subtractInField.primitiveSet ?? null,
        subtractInField.areAllPrimitives
      )
    );
    if (remainingValues.length === 0) {
      return { type: `val`, value: false };
    }
    if (remainingValues.length === 1) {
      return {
        type: `func`,
        name: `eq`,
        args: [fromField.ref, { type: `val`, value: remainingValues[0] }]
      };
    }
    return {
      type: `func`,
      name: `in`,
      args: [fromField.ref, { type: `val`, value: remainingValues }]
    };
  }
  if (fromPred.name === `in` && subtractPred.name === `eq`) {
    const fromInField = fromField;
    const subtractValue = subtractField.value;
    const remainingValues = fromInField.values.filter(
      (v) => !areValuesEqual2(v, subtractValue)
    );
    if (remainingValues.length === 0) {
      return { type: `val`, value: false };
    }
    if (remainingValues.length === 1) {
      return {
        type: `func`,
        name: `eq`,
        args: [fromField.ref, { type: `val`, value: remainingValues[0] }]
      };
    }
    return {
      type: `func`,
      name: `in`,
      args: [fromField.ref, { type: `val`, value: remainingValues }]
    };
  }
  if (fromPred.name === `eq` && subtractPred.name === `eq`) {
    const fromValue = fromField.value;
    const subtractValue = subtractField.value;
    if (areValuesEqual2(fromValue, subtractValue)) {
      return { type: `val`, value: false };
    }
    return fromPred;
  }
  const fromComp = extractComparisonField(fromPred);
  const subtractComp = extractComparisonField(subtractPred);
  if (fromComp && subtractComp && areRefsEqual(fromComp.ref, subtractComp.ref)) {
    const result = minusRangePredicates(
      fromPred,
      fromComp.value,
      subtractPred,
      subtractComp.value
    );
    return result;
  }
  return null;
}
function minusRangePredicates(fromFunc, fromValue, subtractFunc, subtractValue) {
  const fromOp = fromFunc.name;
  const subtractOp = subtractFunc.name;
  const ref = (extractComparisonField(fromFunc) || extractEqualityField(fromFunc)).ref;
  if (fromOp === `gt` && subtractOp === `gt`) {
    if (fromValue < subtractValue) {
      return {
        type: `func`,
        name: `and`,
        args: [
          fromFunc,
          {
            type: `func`,
            name: `lte`,
            args: [ref, { type: `val`, value: subtractValue }]
          }
        ]
      };
    }
    return fromFunc;
  }
  if (fromOp === `gte` && subtractOp === `gte`) {
    if (fromValue < subtractValue) {
      return {
        type: `func`,
        name: `and`,
        args: [
          fromFunc,
          {
            type: `func`,
            name: `lt`,
            args: [ref, { type: `val`, value: subtractValue }]
          }
        ]
      };
    }
    return fromFunc;
  }
  if (fromOp === `gt` && subtractOp === `gte`) {
    if (fromValue < subtractValue) {
      return {
        type: `func`,
        name: `and`,
        args: [
          fromFunc,
          {
            type: `func`,
            name: `lt`,
            args: [ref, { type: `val`, value: subtractValue }]
          }
        ]
      };
    }
    return fromFunc;
  }
  if (fromOp === `gte` && subtractOp === `gt`) {
    if (fromValue <= subtractValue) {
      return {
        type: `func`,
        name: `and`,
        args: [
          fromFunc,
          {
            type: `func`,
            name: `lte`,
            args: [ref, { type: `val`, value: subtractValue }]
          }
        ]
      };
    }
    return fromFunc;
  }
  if (fromOp === `lt` && subtractOp === `lt`) {
    if (fromValue > subtractValue) {
      return {
        type: `func`,
        name: `and`,
        args: [
          {
            type: `func`,
            name: `gte`,
            args: [ref, { type: `val`, value: subtractValue }]
          },
          fromFunc
        ]
      };
    }
    return fromFunc;
  }
  if (fromOp === `lte` && subtractOp === `lte`) {
    if (fromValue > subtractValue) {
      return {
        type: `func`,
        name: `and`,
        args: [
          {
            type: `func`,
            name: `gt`,
            args: [ref, { type: `val`, value: subtractValue }]
          },
          fromFunc
        ]
      };
    }
    return fromFunc;
  }
  if (fromOp === `lt` && subtractOp === `lte`) {
    if (fromValue > subtractValue) {
      return {
        type: `func`,
        name: `and`,
        args: [
          {
            type: `func`,
            name: `gt`,
            args: [ref, { type: `val`, value: subtractValue }]
          },
          fromFunc
        ]
      };
    }
    return fromFunc;
  }
  if (fromOp === `lte` && subtractOp === `lt`) {
    if (fromValue >= subtractValue) {
      return {
        type: `func`,
        name: `and`,
        args: [
          {
            type: `func`,
            name: `gte`,
            args: [ref, { type: `val`, value: subtractValue }]
          },
          fromFunc
        ]
      };
    }
    return fromFunc;
  }
  return null;
}
function isOrderBySubset(subset, superset) {
  if (!subset || subset.length === 0) {
    return true;
  }
  if (!superset || superset.length === 0) {
    return false;
  }
  if (subset.length > superset.length) {
    return false;
  }
  for (let i = 0; i < subset.length; i++) {
    const subClause = subset[i];
    const superClause = superset[i];
    if (!areExpressionsEqual(subClause.expression, superClause.expression)) {
      return false;
    }
    if (!areCompareOptionsEqual(
      subClause.compareOptions,
      superClause.compareOptions
    )) {
      return false;
    }
  }
  return true;
}
function isLimitSubset(subset, superset) {
  if (superset === void 0) {
    return true;
  }
  if (subset === void 0) {
    return false;
  }
  return subset <= superset;
}
function isPredicateSubset(subset, superset) {
  return isWhereSubset(subset.where, superset.where) && isOrderBySubset(subset.orderBy, superset.orderBy) && isLimitSubset(subset.limit, superset.limit);
}
function findCommonConditions(predicate1, predicate2) {
  const conditions1 = extractAllConditions(predicate1);
  const conditions2 = extractAllConditions(predicate2);
  const common = [];
  for (const cond1 of conditions1) {
    for (const cond2 of conditions2) {
      if (areExpressionsEqual(cond1, cond2)) {
        if (!common.some((c) => areExpressionsEqual(c, cond1))) {
          common.push(cond1);
        }
        break;
      }
    }
  }
  return common;
}
function extractAllConditions(predicate) {
  if (predicate.type === `func` && predicate.name === `and`) {
    const conditions = [];
    for (const arg of predicate.args) {
      conditions.push(...extractAllConditions(arg));
    }
    return conditions;
  }
  return [predicate];
}
function removeConditions(predicate, conditionsToRemove) {
  if (predicate.type === `func` && predicate.name === `and`) {
    const remainingArgs = predicate.args.filter(
      (arg) => !conditionsToRemove.some(
        (cond) => areExpressionsEqual(arg, cond)
      )
    );
    if (remainingArgs.length === 0) {
      return void 0;
    } else if (remainingArgs.length === 1) {
      return remainingArgs[0];
    } else {
      return {
        type: `func`,
        name: `and`,
        args: remainingArgs
      };
    }
  }
  return predicate;
}
function combineConditions(conditions) {
  if (conditions.length === 0) {
    return { type: `val`, value: true };
  } else if (conditions.length === 1) {
    return conditions[0];
  } else {
    const flattenedConditions = [];
    for (const condition of conditions) {
      if (condition.type === `func` && condition.name === `and`) {
        flattenedConditions.push(...condition.args);
      } else {
        flattenedConditions.push(condition);
      }
    }
    if (flattenedConditions.length === 1) {
      return flattenedConditions[0];
    } else {
      return {
        type: `func`,
        name: `and`,
        args: flattenedConditions
      };
    }
  }
}
function findPredicateWithOperator(predicates, operator, value) {
  return predicates.find((p) => {
    if (p.type === `func`) {
      const f = p;
      const field = extractComparisonField(f);
      return f.name === operator && field && areValuesEqual2(field.value, value);
    }
    return false;
  });
}
function areExpressionsEqual(a, b) {
  if (a.type !== b.type) {
    return false;
  }
  if (a.type === `val` && b.type === `val`) {
    return areValuesEqual2(a.value, b.value);
  }
  if (a.type === `ref` && b.type === `ref`) {
    return areRefsEqual(a, b);
  }
  if (a.type === `func` && b.type === `func`) {
    const aFunc = a;
    const bFunc = b;
    if (aFunc.name !== bFunc.name) {
      return false;
    }
    if (aFunc.args.length !== bFunc.args.length) {
      return false;
    }
    return aFunc.args.every(
      (arg, i) => areExpressionsEqual(arg, bFunc.args[i])
    );
  }
  return false;
}
function areValuesEqual2(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a === `number` && typeof b === `number` && isNaN(a) && isNaN(b)) {
    return true;
  }
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }
  if (typeof a === `object` && typeof b === `object` && a !== null && b !== null) {
    return a === b;
  }
  return false;
}
function areRefsEqual(a, b) {
  if (a.path.length !== b.path.length) {
    return false;
  }
  return a.path.every((segment, i) => segment === b.path[i]);
}
function isPrimitive(value) {
  return value === null || value === void 0 || typeof value === `string` || typeof value === `number` || typeof value === `boolean`;
}
function areAllPrimitives(values) {
  return values.every(isPrimitive);
}
function arrayIncludesWithSet(array, value, primitiveSet, arrayIsAllPrimitives) {
  if (primitiveSet) {
    if (arrayIsAllPrimitives || isPrimitive(value)) {
      return primitiveSet.has(value);
    }
    return false;
  }
  return array.some((v) => areValuesEqual2(v, value));
}
function maxValue(a, b) {
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() > b.getTime() ? a : b;
  }
  return Math.max(a, b);
}
function minValue(a, b) {
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() < b.getTime() ? a : b;
  }
  return Math.min(a, b);
}
function areCompareOptionsEqual(a, b) {
  return a.direction === b.direction;
}
function extractComparisonField(func) {
  if ([`eq`, `gt`, `gte`, `lt`, `lte`].includes(func.name)) {
    const firstArg = func.args[0];
    const secondArg = func.args[1];
    if ((firstArg == null ? void 0 : firstArg.type) === `ref` && (secondArg == null ? void 0 : secondArg.type) === `val`) {
      return {
        ref: firstArg,
        value: secondArg.value
      };
    }
  }
  return null;
}
function extractEqualityField(func) {
  if (func.name === `eq`) {
    const firstArg = func.args[0];
    const secondArg = func.args[1];
    if ((firstArg == null ? void 0 : firstArg.type) === `ref` && (secondArg == null ? void 0 : secondArg.type) === `val`) {
      return {
        ref: firstArg,
        value: secondArg.value
      };
    }
  }
  return null;
}
function extractInField(func) {
  if (func.name === `in`) {
    const firstArg = func.args[0];
    const secondArg = func.args[1];
    if ((firstArg == null ? void 0 : firstArg.type) === `ref` && (secondArg == null ? void 0 : secondArg.type) === `val` && Array.isArray(secondArg.value)) {
      let values = secondArg.value;
      const allPrimitives = areAllPrimitives(values);
      let primitiveSet = null;
      if (allPrimitives && values.length > 10) {
        primitiveSet = new Set(values);
        if (primitiveSet.size < values.length) {
          values = Array.from(primitiveSet);
        }
      }
      return {
        ref: firstArg,
        values,
        areAllPrimitives: allPrimitives,
        primitiveSet
      };
    }
  }
  return null;
}
function isComparisonSubset(subsetFunc, subsetValue, supersetFunc, supersetValue) {
  const subOp = subsetFunc.name;
  const superOp = supersetFunc.name;
  if (subOp === superOp) {
    if (subOp === `eq`) {
      if (isPrimitive(subsetValue) && isPrimitive(supersetValue)) {
        return subsetValue === supersetValue;
      }
      return areValuesEqual2(subsetValue, supersetValue);
    } else if (subOp === `gt`) {
      return subsetValue >= supersetValue;
    } else if (subOp === `gte`) {
      return subsetValue >= supersetValue;
    } else if (subOp === `lt`) {
      return subsetValue <= supersetValue;
    } else if (subOp === `lte`) {
      return subsetValue <= supersetValue;
    }
  }
  if (subOp === `eq` && superOp === `gt`) {
    return subsetValue > supersetValue;
  }
  if (subOp === `eq` && superOp === `gte`) {
    return subsetValue >= supersetValue;
  }
  if (subOp === `eq` && superOp === `lt`) {
    return subsetValue < supersetValue;
  }
  if (subOp === `eq` && superOp === `lte`) {
    return subsetValue <= supersetValue;
  }
  if (subOp === `gt` && superOp === `gte`) {
    return subsetValue >= supersetValue;
  }
  if (subOp === `gte` && superOp === `gt`) {
    return subsetValue > supersetValue;
  }
  if (subOp === `lt` && superOp === `lte`) {
    return subsetValue <= supersetValue;
  }
  if (subOp === `lte` && superOp === `lt`) {
    return subsetValue < supersetValue;
  }
  return false;
}
function groupPredicatesByField(predicates) {
  const groups = /* @__PURE__ */ new Map();
  for (const pred of predicates) {
    let fieldKey = null;
    if (pred.type === `func`) {
      const func = pred;
      const field = extractComparisonField(func) || extractEqualityField(func) || extractInField(func);
      if (field) {
        fieldKey = field.ref.path.join(`.`);
      }
    }
    const group = groups.get(fieldKey) || [];
    group.push(pred);
    groups.set(fieldKey, group);
  }
  return groups;
}
function unionSameFieldPredicates(predicates) {
  if (predicates.length === 1) {
    return predicates[0];
  }
  let maxGt = null;
  let maxGte = null;
  let minLt = null;
  let minLte = null;
  const eqValues = /* @__PURE__ */ new Set();
  const inValues = /* @__PURE__ */ new Set();
  const otherPredicates = [];
  for (const pred of predicates) {
    if (pred.type === `func`) {
      const func = pred;
      const field = extractComparisonField(func);
      if (field) {
        const value = field.value;
        if (func.name === `gt`) {
          maxGt = maxGt === null ? value : minValue(maxGt, value);
        } else if (func.name === `gte`) {
          maxGte = maxGte === null ? value : minValue(maxGte, value);
        } else if (func.name === `lt`) {
          minLt = minLt === null ? value : maxValue(minLt, value);
        } else if (func.name === `lte`) {
          minLte = minLte === null ? value : maxValue(minLte, value);
        } else if (func.name === `eq`) {
          eqValues.add(value);
        } else {
          otherPredicates.push(pred);
        }
      } else {
        const inField = extractInField(func);
        if (inField) {
          for (const val of inField.values) {
            inValues.add(val);
          }
        } else {
          otherPredicates.push(pred);
        }
      }
    } else {
      otherPredicates.push(pred);
    }
  }
  if (eqValues.size > 1 || eqValues.size > 0 && inValues.size > 0) {
    const allValues = [...eqValues, ...inValues];
    const ref = predicates.find((p) => {
      if (p.type === `func`) {
        const field = extractComparisonField(p) || extractInField(p);
        return field !== null;
      }
      return false;
    });
    if (ref && ref.type === `func`) {
      const field = extractComparisonField(ref) || extractInField(ref);
      if (field) {
        return {
          type: `func`,
          name: `in`,
          args: [
            field.ref,
            { type: `val`, value: allValues }
          ]
        };
      }
    }
  }
  const result = [];
  if (maxGt !== null && maxGte !== null) {
    const pred = maxGte <= maxGt ? findPredicateWithOperator(predicates, `gte`, maxGte) : findPredicateWithOperator(predicates, `gt`, maxGt);
    if (pred) result.push(pred);
  } else if (maxGt !== null) {
    const pred = findPredicateWithOperator(predicates, `gt`, maxGt);
    if (pred) result.push(pred);
  } else if (maxGte !== null) {
    const pred = findPredicateWithOperator(predicates, `gte`, maxGte);
    if (pred) result.push(pred);
  }
  if (minLt !== null && minLte !== null) {
    const pred = minLte >= minLt ? findPredicateWithOperator(predicates, `lte`, minLte) : findPredicateWithOperator(predicates, `lt`, minLt);
    if (pred) result.push(pred);
  } else if (minLt !== null) {
    const pred = findPredicateWithOperator(predicates, `lt`, minLt);
    if (pred) result.push(pred);
  } else if (minLte !== null) {
    const pred = findPredicateWithOperator(predicates, `lte`, minLte);
    if (pred) result.push(pred);
  }
  if (eqValues.size === 1 && inValues.size === 0) {
    const pred = findPredicateWithOperator(predicates, `eq`, [...eqValues][0]);
    if (pred) result.push(pred);
  }
  if (eqValues.size === 0 && inValues.size > 0) {
    result.push(
      predicates.find((p) => {
        if (p.type === `func`) {
          return p.name === `in`;
        }
        return false;
      })
    );
  }
  result.push(...otherPredicates);
  if (result.length === 0) {
    return { type: `val`, value: true };
  }
  if (result.length === 1) {
    return result[0];
  }
  return {
    type: `func`,
    name: `or`,
    args: result
  };
}

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/query/subset-dedupe.js
var DeduplicatedLoadSubset = class {
  constructor(opts) {
    this.unlimitedWhere = void 0;
    this.hasLoadedAllData = false;
    this.limitedCalls = [];
    this.inflightCalls = [];
    this.generation = 0;
    this.loadSubset = (options) => {
      var _a, _b, _c;
      if (this.hasLoadedAllData) {
        (_a = this.onDeduplicate) == null ? void 0 : _a.call(this, options);
        return true;
      }
      if (this.unlimitedWhere !== void 0 && options.where !== void 0) {
        if (isWhereSubset(options.where, this.unlimitedWhere)) {
          (_b = this.onDeduplicate) == null ? void 0 : _b.call(this, options);
          return true;
        }
      }
      if (options.limit !== void 0) {
        const alreadyLoaded = this.limitedCalls.some(
          (loaded) => isPredicateSubset(options, loaded)
        );
        if (alreadyLoaded) {
          (_c = this.onDeduplicate) == null ? void 0 : _c.call(this, options);
          return true;
        }
      }
      const matchingInflight = this.inflightCalls.find(
        (inflight) => isPredicateSubset(options, inflight.options)
      );
      if (matchingInflight !== void 0) {
        const prom = matchingInflight.promise;
        prom.then(() => {
          var _a2;
          return (_a2 = this.onDeduplicate) == null ? void 0 : _a2.call(this, options);
        }).catch();
        return prom;
      }
      const clonedOptions = cloneOptions(options);
      if (this.unlimitedWhere !== void 0 && options.limit === void 0) {
        clonedOptions.where = minusWherePredicates(clonedOptions.where, this.unlimitedWhere) ?? clonedOptions.where;
      }
      const resultPromise = this._loadSubset(clonedOptions);
      if (resultPromise === true) {
        this.updateTracking(clonedOptions);
        return true;
      } else {
        const capturedGeneration = this.generation;
        const inflightEntry = {
          options: clonedOptions,
          // Store cloned options for subset matching
          promise: resultPromise.then((result) => {
            if (capturedGeneration === this.generation) {
              this.updateTracking(clonedOptions);
            }
            return result;
          }).finally(() => {
            const index = this.inflightCalls.indexOf(inflightEntry);
            if (index !== -1) {
              this.inflightCalls.splice(index, 1);
            }
          })
        };
        this.inflightCalls.push(inflightEntry);
        return inflightEntry.promise;
      }
    };
    this._loadSubset = opts.loadSubset;
    this.onDeduplicate = opts.onDeduplicate;
  }
  /**
   * Reset all tracking state.
   * Clears the history of loaded predicates and in-flight calls.
   * Use this when you want to start fresh, for example after clearing the underlying data store.
   *
   * Note: Any in-flight requests will still complete, but they will not update the tracking
   * state after the reset. This prevents old requests from repopulating cleared state.
   */
  reset() {
    this.unlimitedWhere = void 0;
    this.hasLoadedAllData = false;
    this.limitedCalls = [];
    this.inflightCalls = [];
    this.generation++;
  }
  updateTracking(options) {
    if (options.limit === void 0) {
      if (options.where === void 0) {
        this.hasLoadedAllData = true;
        this.unlimitedWhere = void 0;
        this.limitedCalls = [];
        this.inflightCalls = [];
      } else if (this.unlimitedWhere === void 0) {
        this.unlimitedWhere = options.where;
      } else {
        this.unlimitedWhere = unionWherePredicates([
          this.unlimitedWhere,
          options.where
        ]);
      }
    } else {
      this.limitedCalls.push(options);
    }
  }
};
function cloneOptions(options) {
  return { ...options };
}

// ../node_modules/.pnpm/@tanstack+pacer-lite@0.1.0/node_modules/@tanstack/pacer-lite/dist/esm/lite-debouncer.js
var LiteDebouncer = class {
  constructor(fn, options) {
    this.fn = fn;
    this.options = options;
    this.canLeadingExecute = true;
    this.maybeExecute = (...args) => {
      var _a, _b;
      let didLeadingExecute = false;
      if (this.options.leading && this.canLeadingExecute) {
        this.canLeadingExecute = false;
        didLeadingExecute = true;
        this.fn(...args);
        (_b = (_a = this.options).onExecute) == null ? void 0 : _b.call(_a, args, this);
      }
      this.lastArgs = args;
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
      }
      this.timeoutId = setTimeout(() => {
        var _a2, _b2;
        this.canLeadingExecute = true;
        if (this.options.trailing && !didLeadingExecute && this.lastArgs) {
          this.fn(...this.lastArgs);
          (_b2 = (_a2 = this.options).onExecute) == null ? void 0 : _b2.call(_a2, this.lastArgs, this);
        }
        this.lastArgs = void 0;
      }, this.options.wait);
    };
    this.flush = () => {
      var _a, _b;
      if (this.timeoutId && this.lastArgs) {
        clearTimeout(this.timeoutId);
        this.timeoutId = void 0;
        const args = this.lastArgs;
        this.fn(...args);
        (_b = (_a = this.options).onExecute) == null ? void 0 : _b.call(_a, args, this);
        this.lastArgs = void 0;
        this.canLeadingExecute = true;
      }
    };
    this.cancel = () => {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = void 0;
      }
      this.lastArgs = void 0;
      this.canLeadingExecute = true;
    };
    if (this.options.leading === void 0 && this.options.trailing === void 0) {
      this.options.trailing = true;
    }
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/strategies/debounceStrategy.js
function debounceStrategy(options) {
  const debouncer = new LiteDebouncer(
    (callback) => callback(),
    options
  );
  return {
    _type: `debounce`,
    options,
    execute: (fn) => {
      debouncer.maybeExecute(fn);
    },
    cleanup: () => {
      debouncer.cancel();
    }
  };
}

// ../node_modules/.pnpm/@tanstack+pacer-lite@0.1.0/node_modules/@tanstack/pacer-lite/dist/esm/lite-queuer.js
var LiteQueuer = class {
  constructor(fn, options = {}) {
    this.fn = fn;
    this.options = options;
    this.items = [];
    this.timeoutId = null;
    this.isRunning = true;
    this.pendingTick = false;
    this.addItem = (item, position = this.options.addItemsTo, startProcessing = true) => {
      if (this.items.length >= this.options.maxSize) {
        return false;
      }
      if (this.options.getPriority) {
        const priority = this.options.getPriority(item);
        if (priority !== void 0) {
          const insertIndex = this.items.findIndex((existing) => {
            const existingPriority = this.options.getPriority(existing);
            const effectivePriority = existingPriority ?? -Infinity;
            return effectivePriority < priority;
          });
          if (insertIndex === -1) {
            this.items.push(item);
          } else {
            this.items.splice(insertIndex, 0, item);
          }
        } else {
          this.insertAtPosition(item, position);
        }
      } else {
        this.insertAtPosition(item, position);
      }
      if (startProcessing && this.isRunning && !this.pendingTick) {
        this.tick();
      }
      return true;
    };
    this.insertAtPosition = (item, position) => {
      if (position === "front") {
        this.items.unshift(item);
      } else {
        this.items.push(item);
      }
    };
    this.getNextItem = (position = this.options.getItemsFrom) => {
      if (this.items.length === 0) {
        return void 0;
      }
      let item;
      if (this.options.getPriority || position === "front") {
        item = this.items.shift();
      } else {
        item = this.items.pop();
      }
      return item;
    };
    this.execute = (position) => {
      const item = this.getNextItem(position);
      if (item !== void 0) {
        this.fn(item);
      }
      return item;
    };
    this.tick = () => {
      if (!this.isRunning) {
        this.pendingTick = false;
        return;
      }
      this.pendingTick = true;
      while (this.items.length > 0) {
        const item = this.execute(this.options.getItemsFrom);
        if (item === void 0) {
          break;
        }
        const wait = this.options.wait;
        if (wait > 0) {
          this.timeoutId = setTimeout(() => this.tick(), wait);
          return;
        }
      }
      this.pendingTick = false;
    };
    this.start = () => {
      this.isRunning = true;
      if (!this.pendingTick && this.items.length > 0) {
        this.tick();
      }
    };
    this.stop = () => {
      this.clearTimeout();
      this.isRunning = false;
      this.pendingTick = false;
    };
    this.clearTimeout = () => {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    };
    this.peekNextItem = (position = "front") => {
      if (this.items.length === 0) {
        return void 0;
      }
      if (this.options.getPriority || position === "front") {
        return this.items[0];
      } else {
        return this.items[this.items.length - 1];
      }
    };
    this.peekAllItems = () => {
      return [...this.items];
    };
    this.flush = (numberOfItems = this.items.length, position) => {
      this.clearTimeout();
      for (let i = 0; i < numberOfItems && this.items.length > 0; i++) {
        this.execute(position);
      }
      if (this.isRunning && this.items.length > 0 && !this.pendingTick) {
        this.tick();
      }
    };
    this.flushAsBatch = (batchFunction) => {
      const items = this.peekAllItems();
      this.clear();
      batchFunction(items);
    };
    this.clear = () => {
      this.items = [];
    };
    this.options.addItemsTo = this.options.addItemsTo ?? "back";
    this.options.getItemsFrom = this.options.getItemsFrom ?? "front";
    this.options.maxSize = this.options.maxSize ?? Infinity;
    this.options.started = this.options.started ?? true;
    this.options.wait = this.options.wait ?? 0;
    this.isRunning = this.options.started;
    if (this.options.initialItems) {
      for (const item of this.options.initialItems) {
        this.addItem(item, this.options.addItemsTo, false);
      }
    }
    if (this.isRunning && this.items.length > 0) {
      this.tick();
    }
  }
  /**
   * Number of items currently in the queue
   */
  get size() {
    return this.items.length;
  }
  /**
   * Whether the queue is empty
   */
  get isEmpty() {
    return this.items.length === 0;
  }
  /**
   * Whether the queue is currently running (auto-processing items)
   */
  get isQueueRunning() {
    return this.isRunning;
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/strategies/queueStrategy.js
function queueStrategy(options) {
  let processingChain = Promise.resolve();
  const queuer = new LiteQueuer(
    (fn) => {
      processingChain = processingChain.then(async () => {
        const transaction = fn();
        await transaction.isPersisted.promise;
      }).catch(() => {
      });
    },
    {
      wait: (options == null ? void 0 : options.wait) ?? 0,
      maxSize: options == null ? void 0 : options.maxSize,
      addItemsTo: (options == null ? void 0 : options.addItemsTo) ?? `back`,
      // Default FIFO: add to back
      getItemsFrom: (options == null ? void 0 : options.getItemsFrom) ?? `front`,
      // Default FIFO: get from front
      started: true
      // Start processing immediately
    }
  );
  return {
    _type: `queue`,
    options,
    execute: (fn) => {
      queuer.addItem(fn);
    },
    cleanup: () => {
      queuer.stop();
      queuer.clear();
    }
  };
}

// ../node_modules/.pnpm/@tanstack+pacer-lite@0.1.0/node_modules/@tanstack/pacer-lite/dist/esm/lite-throttler.js
var LiteThrottler = class {
  constructor(fn, options) {
    this.fn = fn;
    this.options = options;
    this.lastExecutionTime = 0;
    this.isPending = false;
    this.maybeExecute = (...args) => {
      const now = Date.now();
      const timeSinceLastExecution = now - this.lastExecutionTime;
      if (this.options.leading && timeSinceLastExecution >= this.options.wait) {
        this.execute(...args);
      } else {
        this.lastArgs = args;
        if (!this.timeoutId && this.options.trailing) {
          const timeoutDuration = this.options.wait - timeSinceLastExecution;
          this.isPending = true;
          this.timeoutId = setTimeout(() => {
            if (this.lastArgs !== void 0) {
              this.execute(...this.lastArgs);
            }
          }, timeoutDuration);
        }
      }
    };
    this.execute = (...args) => {
      var _a, _b;
      this.fn(...args);
      (_b = (_a = this.options).onExecute) == null ? void 0 : _b.call(_a, args, this);
      this.lastExecutionTime = Date.now();
      this.clearTimeout();
      this.lastArgs = void 0;
      this.isPending = false;
    };
    this.flush = () => {
      if (this.isPending && this.lastArgs) {
        this.execute(...this.lastArgs);
      }
    };
    this.cancel = () => {
      this.clearTimeout();
      this.lastArgs = void 0;
      this.isPending = false;
    };
    this.clearTimeout = () => {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = void 0;
      }
    };
    if (this.options.leading === void 0 && this.options.trailing === void 0) {
      this.options.leading = true;
      this.options.trailing = true;
    }
  }
};

// ../node_modules/.pnpm/@tanstack+db@0.5.6_typescript@5.9.2/node_modules/@tanstack/db/dist/esm/strategies/throttleStrategy.js
function throttleStrategy(options) {
  const throttler = new LiteThrottler(
    (callback) => callback(),
    options
  );
  return {
    _type: `throttle`,
    options,
    execute: (fn) => {
      throttler.maybeExecute(fn);
    },
    cleanup: () => {
      throttler.cancel();
    }
  };
}

export {
  ir_exports,
  TanStackDBError,
  NonRetriableError,
  SchemaValidationError,
  DuplicateDbInstanceError,
  CollectionConfigurationError,
  CollectionRequiresConfigError,
  CollectionRequiresSyncConfigError,
  InvalidSchemaError,
  SchemaMustBeSynchronousError,
  CollectionStateError,
  CollectionInErrorStateError,
  InvalidCollectionStatusTransitionError,
  CollectionIsInErrorStateError,
  NegativeActiveSubscribersError,
  CollectionOperationError,
  UndefinedKeyError,
  DuplicateKeyError,
  DuplicateKeySyncError,
  MissingUpdateArgumentError,
  NoKeysPassedToUpdateError,
  UpdateKeyNotFoundError,
  KeyUpdateNotAllowedError,
  NoKeysPassedToDeleteError,
  DeleteKeyNotFoundError,
  MissingHandlerError,
  MissingInsertHandlerError,
  MissingUpdateHandlerError,
  MissingDeleteHandlerError,
  TransactionError,
  MissingMutationFunctionError,
  OnMutateMustBeSynchronousError,
  TransactionNotPendingMutateError,
  TransactionAlreadyCompletedRollbackError,
  TransactionNotPendingCommitError,
  NoPendingSyncTransactionWriteError,
  SyncTransactionAlreadyCommittedWriteError,
  NoPendingSyncTransactionCommitError,
  SyncTransactionAlreadyCommittedError,
  QueryBuilderError,
  OnlyOneSourceAllowedError,
  SubQueryMustHaveFromClauseError,
  InvalidSourceError,
  InvalidSourceTypeError,
  JoinConditionMustBeEqualityError,
  QueryMustHaveFromClauseError,
  QueryCompilationError,
  DistinctRequiresSelectError,
  HavingRequiresGroupByError,
  LimitOffsetRequireOrderByError,
  CollectionInputNotFoundError,
  DuplicateAliasInSubqueryError,
  UnsupportedFromTypeError,
  UnknownExpressionTypeError,
  EmptyReferencePathError,
  UnknownFunctionError,
  JoinCollectionNotFoundError,
  JoinError,
  UnsupportedJoinTypeError,
  InvalidJoinConditionSameSourceError,
  InvalidJoinConditionSourceMismatchError,
  InvalidJoinConditionLeftSourceError,
  InvalidJoinConditionRightSourceError,
  InvalidJoinCondition,
  UnsupportedJoinSourceTypeError,
  GroupByError,
  NonAggregateExpressionNotInGroupByError,
  UnsupportedAggregateFunctionError,
  AggregateFunctionNotInSelectError,
  UnknownHavingExpressionTypeError,
  StorageError,
  SerializationError,
  LocalStorageCollectionError,
  StorageKeyRequiredError,
  InvalidStorageDataFormatError,
  InvalidStorageObjectFormatError,
  SyncCleanupError,
  QueryOptimizerError,
  CannotCombineEmptyExpressionListError,
  WhereClauseConversionError,
  SubscriptionNotFoundError,
  AggregateNotSupportedError,
  MissingAliasInputsError,
  SetWindowRequiresOrderByError,
  eq,
  gt,
  gte,
  lt,
  lte,
  and,
  or,
  not,
  isUndefined,
  isNull,
  inArray,
  like,
  ilike,
  upper,
  lower,
  length,
  concat,
  coalesce,
  add,
  count,
  avg,
  sum,
  min,
  max,
  operators,
  IndexOperation,
  BaseIndex,
  BTreeIndex,
  SortedMap,
  LazyIndexWrapper,
  IndexProxy,
  createChangeProxy,
  createArrayChangeProxy,
  withChangeTracking,
  withArrayChangeTracking,
  createTransaction,
  getActiveTransaction,
  createCollection,
  CollectionImpl,
  createOptimisticAction,
  localOnlyCollectionOptions,
  localStorageCollectionOptions,
  createPacedMutations,
  extractFieldPath,
  extractValue,
  walkExpression,
  parseWhereExpression,
  parseOrderByExpression,
  extractSimpleComparisons,
  parseLoadSubsetOptions,
  BaseQueryBuilder,
  Query,
  compileQuery,
  liveQueryCollectionOptions,
  createLiveQueryCollection,
  isWhereSubset,
  unionWherePredicates,
  minusWherePredicates,
  isOrderBySubset,
  isLimitSubset,
  isPredicateSubset,
  DeduplicatedLoadSubset,
  debounceStrategy,
  queueStrategy,
  throttleStrategy
};
//# sourceMappingURL=chunk-F26V5VXB.js.map
