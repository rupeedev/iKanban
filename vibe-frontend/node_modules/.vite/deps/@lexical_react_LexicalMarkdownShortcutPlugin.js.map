{
  "version": 3,
  "sources": ["../../@lexical/react/useLexicalNodeSelection.dev.mjs", "../../@lexical/react/LexicalHorizontalRuleNode.dev.mjs", "../../@lexical/react/LexicalMarkdownShortcutPlugin.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { $getSelection, $isNodeSelection, $createNodeSelection, $setSelection, $getNodeByKey } from 'lexical';\nimport { useState, useEffect, useCallback } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * A helper function to determine if a specific node is selected in a Lexical editor.\n *\n * @param {LexicalEditor} editor - The LexicalEditor instance.\n * @param {NodeKey} key - The key of the node to check.\n * @returns {boolean} Whether the node is selected.\n */\n\nfunction isNodeSelected(editor, key) {\n  return editor.getEditorState().read(() => {\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      return false; // Node doesn't exist, so it's not selected.\n    }\n    return node.isSelected(); // Check if the node is selected.\n  });\n}\n\n/**\n * A custom hook to manage the selection state of a specific node in a Lexical editor.\n *\n * This hook provides utilities to:\n * - Check if a node is selected.\n * - Update its selection state.\n * - Clear the selection.\n *\n * @param {NodeKey} key - The key of the node to track selection for.\n * @returns {[boolean, (selected: boolean) => void, () => void]} A tuple containing:\n * - `isSelected` (boolean): Whether the node is currently selected.\n * - `setSelected` (function): A function to set the selection state of the node.\n * - `clearSelected` (function): A function to clear the selection of the node.\n *\n */\n\nfunction useLexicalNodeSelection(key) {\n  const [editor] = useLexicalComposerContext();\n\n  // State to track whether the node is currently selected.\n  const [isSelected, setIsSelected] = useState(() => isNodeSelected(editor, key));\n  useEffect(() => {\n    let isMounted = true;\n    const unregister = editor.registerUpdateListener(() => {\n      if (isMounted) {\n        setIsSelected(isNodeSelected(editor, key));\n      }\n    });\n    return () => {\n      isMounted = false; // Prevent updates after component unmount.\n      unregister();\n    };\n  }, [editor, key]);\n  const setSelected = useCallback(selected => {\n    editor.update(() => {\n      let selection = $getSelection();\n      if (!$isNodeSelection(selection)) {\n        selection = $createNodeSelection();\n        $setSelection(selection);\n      }\n      if ($isNodeSelection(selection)) {\n        if (selected) {\n          selection.add(key);\n        } else {\n          selection.delete(key);\n        }\n      }\n    });\n  }, [editor, key]);\n  const clearSelected = useCallback(() => {\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isNodeSelection(selection)) {\n        selection.clear();\n      }\n    });\n  }, [editor]);\n  return [isSelected, setSelected, clearSelected];\n}\n\nexport { useLexicalNodeSelection };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { HorizontalRuleNode as HorizontalRuleNode$1 } from '@lexical/extension';\nexport { $isHorizontalRuleNode, INSERT_HORIZONTAL_RULE_COMMAND } from '@lexical/extension';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLexicalNodeSelection } from '@lexical/react/useLexicalNodeSelection';\nimport { mergeRegister, addClassNamesToElement, removeClassNamesFromElement } from '@lexical/utils';\nimport { $applyNodeReplacement, CLICK_COMMAND, COMMAND_PRIORITY_LOW } from 'lexical';\nimport { useEffect } from 'react';\nimport { jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection(nodeKey);\n  useEffect(() => {\n    return mergeRegister(editor.registerCommand(CLICK_COMMAND, event => {\n      const hrElem = editor.getElementByKey(nodeKey);\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n        setSelected(!isSelected);\n        return true;\n      }\n      return false;\n    }, COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, setSelected]);\n  useEffect(() => {\n    const hrElem = editor.getElementByKey(nodeKey);\n    const isSelectedClassName = editor._config.theme.hrSelected ?? 'selected';\n    if (hrElem !== null) {\n      if (isSelected) {\n        addClassNamesToElement(hrElem, isSelectedClassName);\n      } else {\n        removeClassNamesFromElement(hrElem, isSelectedClassName);\n      }\n    }\n  }, [editor, isSelected, nodeKey]);\n  return null;\n}\n\n/**\n * @deprecated A pure Lexical implementation is available in `@lexical/extension` as HorizontalRuleExtension\n */\nclass HorizontalRuleNode extends HorizontalRuleNode$1 {\n  static getType() {\n    return 'horizontalrule';\n  }\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode().updateFromJSON(serializedNode);\n  }\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n  decorate() {\n    return /*#__PURE__*/jsx(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n}\nfunction $convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\n\n/**\n * @deprecated A pure Lexical implementation is available in `@lexical/extension` as HorizontalRuleExtension\n */\nfunction $createHorizontalRuleNode() {\n  return $applyNodeReplacement(new HorizontalRuleNode());\n}\n\nexport { $createHorizontalRuleNode, HorizontalRuleNode };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { TRANSFORMERS, registerMarkdownShortcuts } from '@lexical/markdown';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { HorizontalRuleNode, $createHorizontalRuleNode, $isHorizontalRuleNode } from '@lexical/react/LexicalHorizontalRuleNode';\nimport { useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HR = {\n  dependencies: [HorizontalRuleNode],\n  export: node => {\n    return $isHorizontalRuleNode(node) ? '***' : null;\n  },\n  regExp: /^(---|\\*\\*\\*|___)\\s?$/,\n  replace: (parentNode, _1, _2, isImport) => {\n    const line = $createHorizontalRuleNode();\n\n    // TODO: Get rid of isImport flag\n    if (isImport || parentNode.getNextSibling() != null) {\n      parentNode.replace(line);\n    } else {\n      parentNode.insertBefore(line);\n    }\n    line.selectNext();\n  },\n  type: 'element'\n};\nconst DEFAULT_TRANSFORMERS = [HR, ...TRANSFORMERS];\nfunction MarkdownShortcutPlugin({\n  transformers = DEFAULT_TRANSFORMERS\n}) {\n  const [editor] = useLexicalComposerContext();\n  useEffect(() => {\n    return registerMarkdownShortcuts(editor, transformers);\n  }, [editor, transformers]);\n  return null;\n}\n\nexport { DEFAULT_TRANSFORMERS, MarkdownShortcutPlugin };\n"],
  "mappings": "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",
  "names": ["import_react", "HorizontalRuleNode", "import_react", "HorizontalRuleNode"]
}
