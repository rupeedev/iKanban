import {
  require_jsx_runtime
} from "./chunk-7BUGFXDR.js";
import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@virtuoso.dev/gurx/dist/index.js
var p = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var T = Object.defineProperty;
var L = (s, t, e) => t in s ? T(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var g = (s, t, e) => L(s, typeof t != "symbol" ? t + "" : t, e);
var x = class _x {
  constructor(t = /* @__PURE__ */ new Map()) {
    this.map = t;
  }
  clone() {
    return new _x(new Map(this.map));
  }
  decrement(t, e) {
    let n = this.map.get(t);
    n !== void 0 && (n -= 1, this.map.set(t, n), n === 0 && e());
  }
  increment(t) {
    const e = this.map.get(t) ?? 0;
    this.map.set(t, e + 1);
  }
};
var C = class {
  constructor() {
    g(this, "map", /* @__PURE__ */ new Map());
  }
  delete(t) {
    return this.map.delete(t);
  }
  get(t) {
    return this.map.get(t);
  }
  getOrCreate(t) {
    let e = this.map.get(t);
    return e === void 0 && (e = /* @__PURE__ */ new Set(), this.map.set(t, e)), e;
  }
  use(t, e) {
    const n = this.get(t);
    n !== void 0 && e(n);
  }
};
function m(s, t) {
  return t(s), s;
}
function E() {
}
var V = "cell";
var j = "signal";
function R(s, t) {
  return s === t;
}
var w = /* @__PURE__ */ new Map();
var M;
var K = class {
  /**
   * Creates a new realm.
   * @param initialValues - the initial cell values that will populate the realm.
   * Those values will not trigger a recomputation cycle, and will overwrite the initial values specified for each cell.
   */
  constructor(t = {}) {
    g(this, "definitionRegistry", /* @__PURE__ */ new Set());
    g(this, "distinctNodes", /* @__PURE__ */ new Map());
    g(this, "executionMaps", /* @__PURE__ */ new Map());
    g(this, "graph", new C());
    g(this, "pipeMap", /* @__PURE__ */ new Map());
    g(this, "singletonSubscriptions", /* @__PURE__ */ new Map());
    g(this, "state", /* @__PURE__ */ new Map());
    g(this, "subscriptions", new C());
    for (const e of Object.getOwnPropertySymbols(t))
      this.state.set(e, t[e]);
  }
  /**
   * Creates or resolves an existing cell instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the cell.
   * @param value - the initial value of the cell
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a cell. If the cell has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  cellInstance(t, e = true, n = Symbol()) {
    return this.state.has(n) || this.state.set(n, t), e !== false && !this.distinctNodes.has(n) && this.distinctNodes.set(n, e === true ? R : e), n;
  }
  /**
   * Convenient for mutation of cells that contian non-primitive values (e.g. arrays, or objects).
   * Specifies that the cell value should be changed when source emits, with the result of the map callback parameter.
   * the map parameter gets called with the current value of the cell and the value published through the source.
   * @typeParam T - the type of the cell value.
   * @typeParam K - the type of the value published through the source.
   * @example
   * ```ts
   * const items$ = Cell<string[]([])
   * const addItem$ = Signal<string>(false, (r) => {
   *   r.changeWith(items$, addItem$, (items, item) => [...items, item])
   * })
   * const r = new Realm()
   * r.pub(addItem$, 'foo')
   * r.pub(addItem$, 'bar')
   * r.getValue(items$) // ['foo', 'bar']
   * ```
   */
  changeWith(t, e, n) {
    this.connect({
      map: (i) => (r, o) => {
        i(n(o, r));
      },
      pulls: [t],
      sink: t,
      sources: [e]
    });
  }
  // prettier-ignore
  combine(...t) {
    return m(this.signalInstance(), (e) => {
      this.connect({
        map: (n) => (...i) => {
          n(i);
        },
        sink: e,
        sources: t
      });
    });
  }
  // prettier-ignore
  combineCells(...t) {
    return m(
      this.cellInstance(
        t.map((e) => this.getValue(e)),
        true
      ),
      (e) => {
        this.connect({
          map: (n) => (...i) => {
            n(i);
          },
          sink: e,
          sources: t
        });
      }
    );
  }
  /**
   * A low-level utility that connects multiple nodes to a sink node with a map function. Used as a foundation for the higher-level operators.
   * The nodes can be active (sources) or passive (pulls).
   */
  connect({
    map: t,
    pulls: e = [],
    sink: n,
    sources: i
  }) {
    const r = {
      map: t,
      pulls: new Set(e),
      sink: this.register(n),
      sources: new Set(i)
    };
    for (const o of [...i, ...e])
      this.register(o), this.graph.getOrCreate(o).add(r);
    this.executionMaps.clear();
  }
  /**
   * Gets the current value of a node. The node must be stateful.
   * @remark if possible, use {@link withLatestFrom} or {@link combine}, as getValue will not create a dependency to the passed node,
   * which means that if you call it within a computational cycle, you may not get the correct value.
   * @param node - the node instance.
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   *
   * const r = new Realm()
   * r.getValue(foo$) // 'foo'
   * r.pub(foo$, 'bar')
   * //...
   * r.getValue(foo$) // 'bar'
   * ```
   */
  getValue(t) {
    return this.register(t), this.state.get(t);
  }
  getValues(t) {
    return t.map((e) => this.getValue(e));
  }
  inContext(t) {
    const e = M;
    M = this;
    const n = t();
    return M = e, n;
  }
  /**
   * Links the output of a node to the input of another node.
   */
  link(t, e) {
    this.connect({
      map: (n) => (i) => {
        n(i);
      },
      sink: e,
      sources: [t]
    });
  }
  pipe(t, ...e) {
    return this.combineOperators(...e)(t);
  }
  pub(t, e) {
    this.pubIn({ [t]: e });
  }
  /**
   * Publishes into multiple nodes simultaneously, triggering a single re-computation cycle.
   * @param values - a record of node references and their values.
   *
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   * const bar$ = Cell('bar')
   *
   * const r = new Realm()
   * r.pubIn({[foo$]: 'foo1', [bar$]: 'bar1'})
   * ```
   */
  pubIn(t) {
    var y;
    const e = Reflect.ownKeys(t).map((a) => this.pipeMap.get(a) ?? a), n = Reflect.ownKeys(t).reduce((a, u) => {
      const h2 = u, S = t[h2], f = this.pipeMap.get(h2) ?? h2;
      return a[f] = S, a;
    }, {}), i = this.getExecutionMap(e), r = i.refCount.clone(), o = i.participatingNodes.slice(), c = new Map(this.state), l = (a) => {
      this.graph.use(a, (u) => {
        for (const { sink: h2, sources: S } of u)
          S.has(a) && r.decrement(h2, () => {
            o.splice(o.indexOf(h2), 1), l(h2);
          });
      });
    };
    for (; ; ) {
      const a = o.shift();
      if (a === void 0)
        break;
      const u = a;
      let h2 = false;
      const S = (f) => {
        const b = this.distinctNodes.get(u);
        if (b != null && b(c.get(u), f)) {
          h2 = false;
          return;
        }
        h2 = true, c.set(u, f), this.state.has(u) && this.state.set(u, f);
      };
      if (Object.hasOwn(n, u) ? S(n[u]) : i.projections.use(u, (f) => {
        for (const b of f) {
          const k2 = [...Array.from(b.sources), ...Array.from(b.pulls)].map((v) => c.get(v));
          b.map(S)(...k2);
        }
      }), h2) {
        const f = c.get(u);
        this.inContext(() => {
          this.subscriptions.use(u, (b) => {
            for (const k2 of b)
              k2(f);
          });
        }), (y = this.singletonSubscriptions.get(u)) == null || y(f);
      } else
        l(u);
    }
  }
  /**
   * Explicitly includes the specified cell/signal/pipe reference in the realm.
   * Most of the time you don't need to do that, since any interaction with the node through a realm will register it.
   * The only exception of that rule should be when the interaction is conditional, and the node definition includes an init function that needs to be eagerly evaluated.
   */
  register(t) {
    const e = w.get(t);
    if (e === void 0)
      return t;
    if (!this.definitionRegistry.has(t)) {
      if (this.definitionRegistry.add(t), e.type === V)
        return m(this.cellInstance(e.initial, e.distinct, t), (o) => {
          this.inContext(() => {
            e.init(this, o);
          });
        });
      if (e.type === j)
        return m(this.signalInstance(e.distinct, t), (o) => {
          this.inContext(() => {
            e.init(this, o);
          });
        });
      const n = this.signalInstance(e.distinct), i = this.cellInstance(e.initial, true), r = this.cellInstance(e.initial, e.distinct, t);
      return this.link(i, r), this.pipeMap.set(r, n), this.inContext(() => {
        e.init(this, n, i);
      }), r;
    }
    return t;
  }
  /**
   * Clears all exclusive subscriptions.
   */
  resetSingletonSubs() {
    this.singletonSubscriptions.clear();
  }
  /**
   * Creates or resolves an existing signal instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the signal.
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a signal. If the signal has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  signalInstance(t = true, e = Symbol()) {
    return t !== false && this.distinctNodes.set(e, t === true ? R : t), e;
  }
  /**
   * Subscribes exclusively to values in the referred node.
   * Calling this multiple times on a single node will remove the previous subscription created through `singletonSub`.
   * Subscriptions created through `sub` are not affected.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * // console.log will run only once.
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.pub(signal$, 2)
   * ```
   */
  singletonSub(t, e) {
    return this.register(t), e === void 0 ? this.singletonSubscriptions.delete(t) : this.singletonSubscriptions.set(t, e), () => this.singletonSubscriptions.delete(t);
  }
  /**
   * Subscribes to the values published in the referred node.
   * @param node - the cell/signal to subscribe to.
   * @param subscription - the callback to execute when the node receives a new value.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * const unsub = r.sub(signal$, console.log)
   * r.pub(signal$, 2)
   * unsub()
   * r.pub(signal$, 3)
   * ```
   */
  sub(t, e) {
    this.register(t);
    const n = this.subscriptions.getOrCreate(t);
    return n.add(e), () => n.delete(e);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  subMultiple(t, e) {
    const n = this.signalInstance();
    return this.connect({
      map: (i) => (...r) => {
        i(r);
      },
      sink: n,
      sources: t
    }), this.sub(n, e);
  }
  transformer(...t) {
    return (e) => m(this.signalInstance(), (n) => (this.link(this.pipe(n, ...t), e), n));
  }
  calculateExecutionMap(t) {
    const e = [], n = /* @__PURE__ */ new Set(), i = new C(), r = new x(), o = new C(), c = (l, y = 0) => {
      r.increment(l), !n.has(l) && (this.register(l), i.use(l, (a) => {
        y = Math.max(...Array.from(a).map((u) => e.indexOf(u))) + 1;
      }), this.graph.use(l, (a) => {
        for (const u of a)
          u.sources.has(l) ? (o.getOrCreate(u.sink).add(u), c(u.sink, y)) : i.getOrCreate(u.sink).add(l);
      }), n.add(l), e.splice(y, 0, l));
    };
    return t.forEach(c), { participatingNodes: e, pendingPulls: i, projections: o, refCount: r };
  }
  combineOperators(...t) {
    return (e) => {
      for (const n of t)
        e = n(e, this);
      return e;
    };
  }
  getExecutionMap(t) {
    let e = t;
    if (t.length === 1) {
      e = t[0];
      const i = this.executionMaps.get(e);
      if (i !== void 0)
        return i;
    } else
      for (const [i, r] of this.executionMaps.entries())
        if (Array.isArray(i) && i.length === t.length && i.every((o) => t.includes(o)))
          return r;
    const n = this.calculateExecutionMap(t);
    return this.executionMaps.set(e, n), n;
  }
};
function G(s, t = E, e = true) {
  return m(Symbol(), (n) => {
    w.set(n, { distinct: e, init: t, initial: s, type: V });
  });
}
function B(s = E, t = false) {
  return m(Symbol(), (e) => {
    w.set(e, { distinct: t, init: s, type: "signal" });
  });
}
function H(s = E) {
  return m(Symbol(), (t) => {
    w.set(t, { distinct: false, init: s, type: "signal" });
  });
}
var O = p.createContext(null);
var _ = typeof document < "u" ? p.useLayoutEffect : p.useEffect;
function I() {
  const s = p.useContext(O);
  if (s === null)
    throw new Error("useRealm must be used within a RealmContextProvider");
  return s;
}
function Q(s) {
  const t = I();
  t.register(s);
  const e = p.useCallback((n) => t.sub(s, n), [t, s]);
  return p.useSyncExternalStore(
    e,
    () => t.getValue(s),
    () => t.getValue(s)
  );
}
function D(s) {
  const t = I();
  t.register(s);
  const [e, n] = p.useState(() => t.getValue(s));
  return _(() => {
    const i = t.sub(s, () => {
      n(() => t.getValue(s));
    });
    return () => {
      i();
    };
  }, [t, s]), e;
}
var P = "useSyncExternalStore" in p ? Q : D;
function ot(...s) {
  const t = I(), e = p.useMemo(() => t.combineCells(...s), [t, ...s]);
  return P(e);
}
function U(s) {
  const t = I();
  return t.register(s), p.useCallback(
    (e) => {
      t.pub(s, e);
    },
    [t, s]
  );
}
function ct(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (r) => {
        i(s(r));
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function at(...s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (...r) => {
        i(r);
      },
      pulls: s,
      sink: n,
      sources: [t]
    }), n;
  };
}
function lt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => () => {
        i(s);
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function pt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (r) => {
        s(r) && i(r);
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function ft(s, t) {
  return (e, n) => {
    const i = n.signalInstance();
    return n.connect({
      map: (r) => (o) => {
        r(t = s(t, o));
      },
      sink: i,
      sources: [e]
    }), i;
  };
}
function gt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    let i, r = null;
    return e.sub(t, (o) => {
      i = o, r === null && (r = setTimeout(() => {
        r = null, e.pub(n, i);
      }, s));
    }), n;
  };
}
function mt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    let i, r = null;
    return e.sub(t, (o) => {
      i = o, r !== null && clearTimeout(r), r = setTimeout(() => {
        e.pub(n, i);
      }, s);
    }), n;
  };
}
function bt() {
  return (s, t) => {
    const e = t.signalInstance();
    return t.sub(s, (n) => {
      queueMicrotask(() => {
        t.pub(e, n);
      });
    }), e;
  };
}
function dt(s) {
  return (t, e) => {
    const n = e.signalInstance(), i = Symbol();
    let r = i;
    return e.connect({
      map: (o) => (c) => {
        r !== i && (o([r, c]), r = i);
      },
      sink: n,
      sources: [s]
    }), e.sub(t, (o) => {
      r = o;
    }), n;
  };
}

// node_modules/@virtuoso.dev/message-list/dist/index.js
var import_react = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function Me(e, t) {
  const n = G(e, (o) => {
    o.link(t(o), n);
  });
  return n;
}
var _e = { lvl: 0 };
function wn(e, t, n, o = _e, i = _e) {
  return { k: e, l: o, lvl: n, r: i, v: t };
}
function T2(e) {
  return e === _e;
}
function Ae() {
  return _e;
}
function zt(e, t) {
  if (T2(e)) return _e;
  const { k: n, l: o, r: i } = e;
  if (t === n) {
    if (T2(o))
      return i;
    if (T2(i))
      return o;
    const [s, l] = Ln(o);
    return bt2(A2(e, { k: s, l: Rn(o), v: l }));
  }
  return t < n ? bt2(A2(e, { l: zt(o, t) })) : bt2(A2(e, { r: zt(i, t) }));
}
function he(e, t, n = "k") {
  if (T2(e))
    return [Number.NEGATIVE_INFINITY, void 0];
  if (e[n] === t)
    return [e.k, e.v];
  if (e[n] < t) {
    const o = he(e.r, t, n);
    return o[0] === Number.NEGATIVE_INFINITY ? [e.k, e.v] : o;
  }
  return he(e.l, t, n);
}
function P2(e, t, n) {
  return T2(e) ? wn(t, n, 1) : t === e.k ? A2(e, { k: t, v: n }) : t < e.k ? In(A2(e, { l: P2(e.l, t, n) })) : In(A2(e, { r: P2(e.r, t, n) }));
}
function Yt(e, t, n) {
  if (T2(e))
    return [];
  const { k: o, v: i, l: s, r: l } = e;
  let r = [];
  return o > t && (r = r.concat(Yt(s, t, n))), o >= t && o <= n && r.push({ k: o, v: i }), o <= n && (r = r.concat(Yt(l, t, n))), r;
}
function Bo(e, t, n, o) {
  if (T2(e))
    return _e;
  let i = Ae();
  for (const { k: s, v: l } of de(e))
    s > t && s <= n ? i = P2(i, ...o(s, l)) : i = P2(i, s, l);
  return i;
}
function Fo(e, t, n) {
  let o = Ae(), i = -1;
  for (const { start: s, end: l, value: r } of _o(e))
    s < t ? (o = P2(o, s, r), i = r) : s > t + n ? o = P2(o, s - n, r) : l >= t + n && i !== r && (o = P2(o, t, r));
  return o;
}
function de(e) {
  return T2(e) ? [] : [...de(e.l), { k: e.k, v: e.v }, ...de(e.r)];
}
function Ln(e) {
  return T2(e.r) ? [e.k, e.v] : Ln(e.r);
}
function Rn(e) {
  return T2(e.r) ? e.l : bt2(A2(e, { r: Rn(e.r) }));
}
function A2(e, t) {
  return wn(t.k ?? e.k, t.v ?? e.v, t.lvl ?? e.lvl, t.l ?? e.l, t.r ?? e.r);
}
function _t(e) {
  return T2(e) || e.lvl > e.r.lvl;
}
function In(e) {
  return jt(Dn(e));
}
function bt2(e) {
  const { l: t, r: n, lvl: o } = e;
  if (n.lvl >= o - 1 && t.lvl >= o - 1)
    return e;
  if (o > n.lvl + 1) {
    if (_t(t))
      return Dn(A2(e, { lvl: o - 1 }));
    if (!T2(t) && !T2(t.r))
      return A2(t.r, {
        l: A2(t, { r: t.r.l }),
        lvl: o,
        r: A2(e, {
          l: t.r.r,
          lvl: o - 1
        })
      });
    throw new Error("Unexpected empty nodes");
  }
  if (_t(e))
    return jt(A2(e, { lvl: o - 1 }));
  if (!T2(n) && !T2(n.l)) {
    const i = n.l, s = _t(i) ? n.lvl - 1 : n.lvl;
    return A2(i, {
      l: A2(e, {
        lvl: o - 1,
        r: i.l
      }),
      lvl: i.lvl + 1,
      r: jt(A2(n, { l: i.r, lvl: s }))
    });
  }
  throw new Error("Unexpected empty nodes");
}
function _o(e) {
  return An(de(e));
}
function Cn(e, t, n) {
  if (T2(e))
    return [];
  const o = he(e, t)[0];
  return An(Yt(e, o, n));
}
function Mn(e, t) {
  const n = e.length;
  if (n === 0)
    return [];
  let { index: o, value: i } = t(e[0]);
  const s = [];
  for (let l = 1; l < n; l++) {
    const { index: r, value: a } = t(e[l]);
    s.push({ end: r - 1, start: o, value: i }), o = r, i = a;
  }
  return s.push({ end: Number.POSITIVE_INFINITY, start: o, value: i }), s;
}
function An(e) {
  return Mn(e, ({ k: t, v: n }) => ({ index: t, value: n }));
}
function jt(e) {
  const { r: t, lvl: n } = e;
  return !T2(t) && !T2(t.r) && t.lvl === n && t.r.lvl === n ? A2(t, { l: A2(e, { r: t.l }), lvl: n + 1 }) : e;
}
function Dn(e) {
  const { l: t } = e;
  return !T2(t) && t.lvl === e.lvl ? A2(t, { r: A2(e, { l: t.r }) }) : e;
}
function $t(e, t, n, o = 0) {
  let i = e.length - 1;
  for (; o <= i; ) {
    const s = Math.floor((o + i) / 2), l = e[s], r = n(l, t);
    if (r === 0)
      return s;
    if (r === -1) {
      if (i - o < 2)
        return s - 1;
      i = s - 1;
    } else {
      if (i === o)
        return s;
      o = s + 1;
    }
  }
  throw new Error(`Failed binary finding record in array - ${e.join(",")}, searched for ${t}`);
}
function Vn(e, t, n) {
  return e[$t(e, t, n)];
}
function Po(e, t, n, o) {
  const i = $t(e, t, o), s = $t(e, n, o, i);
  return e.slice(i, s + 1);
}
function ln({ index: e }, t) {
  return t === e ? 0 : t < e ? -1 : 1;
}
function Wo({ offset: e }, t) {
  return t === e ? 0 : t < e ? -1 : 1;
}
function zo(e) {
  return { index: e.index, value: e };
}
function Yo(e, t, n, o = 0) {
  return o > 0 && (t = Math.max(t, Vn(e, o, ln).offset)), t = Math.max(0, t), Mn(Po(e, t, n, Wo), zo);
}
var Pe = [[], 0, 0, 0];
function jo(e, [t, n]) {
  let o = 0, i = 0, s = 0, l = 0;
  if (n !== 0) {
    l = $t(e, n - 1, ln), s = e[l].offset;
    const a = he(t, n - 1);
    o = a[0], i = a[1], e.length && e[l].height === he(t, n)[1] && (l -= 1), e = e.slice(0, l + 1);
  } else
    e = [];
  for (const { start: r, value: a } of Cn(t, n, Number.POSITIVE_INFINITY)) {
    const c = (r - o) * i + s;
    e.push({ height: a, index: r, offset: c }), o = r, s = c, i = a;
  }
  return [e, i, s, o];
}
function Ko(e) {
  const { size: t, startIndex: n, endIndex: o } = e;
  return (i) => i.start === n && (i.end === o || i.end === Number.POSITIVE_INFINITY) && i.value === t;
}
function qo(e, t) {
  let n = T2(e) ? 0 : Number.POSITIVE_INFINITY;
  for (const o of t) {
    const { size: i, startIndex: s, endIndex: l } = o;
    if (n = Math.min(n, s), T2(e)) {
      e = P2(e, 0, i);
      continue;
    }
    const r = Cn(e, s - 1, l + 1);
    if (r.some(Ko(o)))
      continue;
    let a = false, c = false;
    for (const { start: p2, end: g2, value: b } of r)
      a ? (l >= p2 || i === b) && (e = zt(e, p2)) : (c = b !== i, a = true), g2 > l && l >= p2 && b !== i && (e = P2(e, l + 1, b));
    c && (e = P2(e, s, i));
  }
  return [e, n];
}
var ot2 = [Ae(), 0];
function Uo(e, [t, n]) {
  if (n.length > 0 && T2(e) && t.length === 2) {
    const o = t[0].size, i = t[1].size;
    return [
      n.reduce((s, l) => P2(P2(s, l, o), l + 1, i), Ae()),
      0
    ];
  }
  return qo(e, t);
}
var fe = B();
G([]);
G([]);
G(0);
G(null);
G(Number.NaN);
var ye = G(false);
var Q2 = G(ot2, (e) => {
  e.link(
    e.pipe(
      fe,
      pt((t) => t.length > 0),
      at(ee),
      ct(([t, n]) => Uo(n, [t, []]))
    ),
    Q2
  );
});
var ee = G(ot2[0], (e) => {
  e.link(
    e.pipe(
      Q2,
      ct(([t]) => t)
    ),
    ee
  );
});
var On = G(ot2[1], (e) => {
  e.link(
    e.pipe(
      Q2,
      ct(([, t]) => t)
    ),
    On
  );
});
var $e = G(Pe[1]);
var te = G(Pe[0]);
var Je = G(Pe, (e) => {
  e.link(
    e.pipe(
      ee,
      at(On),
      ft(([t], [n, o]) => jo(t, [n, o]), Pe)
    ),
    Je
  ), e.link(
    e.pipe(
      Je,
      ct(([, t]) => t)
    ),
    $e
  ), e.link(
    e.pipe(
      Je,
      ct(([t]) => t)
    ),
    te
  );
});
var Hn = G(Pe[2], (e) => {
  e.link(
    e.pipe(
      Je,
      ct(([, , t]) => t)
    ),
    Hn
  );
});
var Nn = G(Pe[3], (e) => {
  e.link(
    e.pipe(
      Je,
      ct(([, , , t]) => t)
    ),
    Nn
  );
});
var Ke = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(De, Nn, Hn, $e),
      ct(([t, n, o, i]) => o + (t - n) * i)
    ),
    Ke
  );
});
function Bn(e, t) {
  if (t.length === 0)
    return [0, 0];
  const { offset: n, index: o, height: i } = Vn(t, e, ln);
  return [i * (e - o) + n, i];
}
function we(e, t) {
  return Bn(e, t)[0];
}
function Fn(e, t) {
  return Math.abs(e - t) < 1.01;
}
function _n() {
  return typeof navigator > "u" ? false : /Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 1 || /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);
}
function Go(e) {
  return !e;
}
function Zo(e) {
  return e === 1 ? 1 : 1 - 2 ** (-10 * e);
}
function Mt(e = 1) {
  return (t, n) => {
    const o = n.signalInstance();
    return n.sub(t, (i) => {
      let s = e;
      function l() {
        s > 0 ? (s--, requestAnimationFrame(l)) : n.pub(o, i);
      }
      l();
    }), o;
  };
}
var Kt = "up";
var Pt = "down";
var Jo = "none";
var Xo = {
  atBottom: false,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollTop: 0,
    viewportHeight: 0,
    viewportWidth: 0,
    scrollHeight: 0
  }
};
var Qo = 0;
var ei = 4;
function vn(e) {
  return (t, n) => {
    const o = n.signalInstance();
    return n.sub(t, (i) => {
      e > 0 ? e-- : n.pub(o, i);
    }), o;
  };
}
G(false);
var Pn = G(true);
B();
var xe = G(false);
var ti = B((e) => {
  e.link(e.pipe(Pn, gt(50)), ti);
});
var Wn = G(ei);
var ni = G(Qo, (e) => {
  e.link(
    e.pipe(
      e.combine(L2, ni),
      ct(([t, n]) => t <= n)
    ),
    Pn
  );
});
var et = G(false, (e) => {
  e.link(e.pipe(L2, vn(1), lt(true)), et), e.link(e.pipe(L2, vn(1), lt(false), mt(100)), et);
});
var qt = G(false, (e) => {
  e.link(e.pipe(q, lt(true)), qt), e.link(e.pipe(q, lt(false), mt(200)), qt);
});
var rn = G(false);
var It = G(
  null,
  (e) => {
    e.link(
      e.pipe(
        e.combine(
          V2,
          L2,
          U2,
          Et,
          Wn,
          Ct,
          Dt,
          ee
        ),
        pt(([, , , , , , , t]) => !T2(t)),
        ft((t, [n, o, i, s, l, r]) => {
          const c = o + i - n + r > -l, p2 = {
            viewportWidth: s,
            viewportHeight: i,
            scrollTop: o,
            scrollHeight: n,
            listMarginTop: r
          };
          if (c) {
            let b, I2;
            return o > t.state.scrollTop ? (b = "SCROLLED_DOWN", I2 = t.state.scrollTop - o) : (b = n === i ? "LIST_TOO_SHORT" : "SIZE_DECREASED", I2 = t.state.scrollTop - o || t.scrollTopDelta), {
              atBottom: true,
              state: p2,
              atBottomBecause: b,
              scrollTopDelta: I2
            };
          }
          let g2;
          return i < t.state.viewportHeight ? g2 = "VIEWPORT_HEIGHT_DECREASING" : s < t.state.viewportWidth ? g2 = "VIEWPORT_WIDTH_DECREASING" : o < t.state.scrollTop ? g2 = "SCROLLING_UPWARDS" : p2.scrollHeight > t.state.scrollHeight || p2.listMarginTop < t.state.listMarginTop ? t.atBottom ? g2 = "SIZE_INCREASED" : g2 = t.notAtBottomBecause : t.atBottom ? g2 = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM" : g2 = t.notAtBottomBecause, {
            atBottom: false,
            notAtBottomBecause: g2,
            state: p2
          };
        }, Xo)
      ),
      It
    ), e.link(
      e.pipe(
        It,
        ft(
          ({ prev: t }, n) => {
            const o = !!(t && n && t.atBottom && !n.atBottom && n.notAtBottomBecause === "SIZE_INCREASED");
            return {
              prev: n,
              shouldScroll: o
            };
          },
          { prev: null, shouldScroll: false }
        ),
        ct(({ shouldScroll: t }) => t)
      ),
      rn
    ), e.sub(
      e.pipe(
        U2,
        at(It, hn, tt),
        pt(([, , t, n]) => !t && !n),
        ft(
          (t, [n, o]) => {
            let i = 0;
            return t.viewportHeight > n && o && !o.atBottom && o.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && (i = t.viewportHeight - n), { viewportHeight: n, delta: i };
          },
          { viewportHeight: 0, delta: 0 }
        )
      ),
      (t) => {
        t.delta && e.pub(q, t.delta);
      }
    );
  },
  (e, t) => !e || e.atBottom !== (t == null ? void 0 : t.atBottom) ? false : !e.atBottom && !t.atBottom ? e.notAtBottomBecause === t.notAtBottomBecause : true
);
var zn = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(L2, V2, U2),
      ft(
        (t, [n, o, i]) => {
          if (!Fn(t.scrollHeight, o)) {
            const s = o - (n + i) < 1;
            return t.scrollTop !== n && s ? {
              scrollHeight: o,
              scrollTop: n,
              jump: t.scrollTop - n,
              changed: true
            } : {
              scrollHeight: o,
              scrollTop: n,
              jump: 0,
              changed: true
            };
          }
          return {
            scrollTop: n,
            scrollHeight: o,
            jump: 0,
            changed: false
          };
        },
        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }
      ),
      pt((t) => t.changed),
      ct((t) => t.jump)
    ),
    zn
  );
});
var wt = G(Pt, (e) => {
  e.link(
    e.pipe(
      L2,
      ft(
        (t, n) => {
          if (n < 0)
            return { direction: Kt, prevScrollTop: 0 };
          if (e.getValue(qt))
            return { direction: t.direction, prevScrollTop: n };
          const i = n === t.prevScrollTop && n === 0;
          return {
            direction: n < t.prevScrollTop || i ? Kt : Pt,
            prevScrollTop: n
          };
        },
        { direction: Pt, prevScrollTop: 0 }
      ),
      ct((t) => t.direction)
    ),
    wt
  ), e.link(e.pipe(L2, mt(100), lt(Jo)), wt);
});
var kn = G(0, (e) => {
  e.link(e.pipe(et, pt(Go), lt(0)), kn), e.link(
    e.pipe(
      L2,
      gt(100),
      at(et),
      pt(([, t]) => !!t),
      ft(([, t], [n]) => [t, n], [0, 0]),
      ct(([t, n]) => n - t)
    ),
    kn
  );
});
function un(e, t) {
  if (typeof e == "number")
    return {
      index: e,
      offset: 0,
      behavior: "auto",
      align: "start-no-overflow"
    };
  const n = {
    index: Number.NaN,
    align: e.align ?? "start-no-overflow",
    behavior: e.behavior ?? "auto",
    offset: e.offset ?? 0
  };
  return e.index === "LAST" ? n.index = t : e.index < 0 ? n.index = t + e.index : n.index = e.index, n;
}
function Yn({
  location: e,
  sizeTree: t,
  offsetTree: n,
  totalHeight: o,
  totalCount: i,
  viewportHeight: s,
  headerHeight: l,
  stickyHeaderHeight: r,
  stickyFooterHeight: a
}) {
  const { align: c, behavior: p2, offset: g2, index: b } = un(e, i - 1);
  function I2() {
    const y = he(t, b)[1];
    if (y === void 0)
      throw new Error(`Item at index ${b} not found`);
    return y;
  }
  s -= r + a;
  let f = we(b, n) + l - r;
  c === "end" ? f = f - s + I2() : c === "center" && (f = f - s / 2 + I2() / 2), g2 && (f += g2);
  let m2 = 0;
  return c === "start" && (m2 = Math.max(0, Math.min(f - (o - s)))), f = Math.max(0, f), { top: f, behavior: p2, align: c, forceBottomSpace: m2 };
}
var Ze = G(null);
var oi = G(false);
var Xe = G(true);
var Ut = B((e) => {
  e.link(
    e.pipe(
      Ut,
      ct(() => true)
    ),
    Xe
  ), e.link(
    e.pipe(
      Ut,
      ct(() => null)
    ),
    Ze
  );
});
var jn = B((e) => {
  e.link(
    e.pipe(
      jn,
      at(De, te, ct2),
      ct(([t, n, o, i]) => {
        let { align: s, behavior: l, offset: r, index: a } = un(t, n - 1);
        const c = typeof t != "number" ? t.done : void 0, [p2, g2] = Bn(a, o);
        return p2 < -i.listOffset ? ((typeof t == "number" || t.align === void 0) && (s = "start-no-overflow"), { index: a, align: s, behavior: l, offset: r, done: c }) : p2 + g2 > -i.listOffset + i.visibleListHeight ? ((typeof t == "number" || t.align === void 0) && (s = "end"), { index: a, align: s, behavior: l, offset: r, done: c }) : null;
      }),
      pt((t) => t !== null)
    ),
    // @ts-expect-error contra variance
    X
  );
});
var X = B((e) => {
  const t = e.pipe(
    X,
    at(
      ee,
      te,
      De,
      U2,
      ut,
      qe,
      rt,
      Ke
    ),
    ct(
      ([n, o, i, s, l, r, a, c, p2]) => {
        try {
          return Yn({
            location: n,
            totalHeight: p2,
            sizeTree: o,
            offsetTree: i,
            totalCount: s,
            viewportHeight: l,
            headerHeight: r,
            stickyHeaderHeight: a,
            stickyFooterHeight: c
          });
        } catch {
          return null;
        }
      }
    ),
    pt((n) => n !== null)
  );
  e.link(X, Ze), e.link(t, Re), e.link(
    e.pipe(
      X,
      pt((n) => typeof n != "number" && n.index === "LAST"),
      lt(true)
    ),
    xe
  ), e.link(e.pipe(t, lt(false)), Xe), e.link(e.pipe(t, lt(false)), oi), e.link(
    e.pipe(
      ee,
      // wait for the list to render with the specified sizeTree, so that enough space is available to scroll by
      mt(0),
      at(Xe, Ze),
      pt(([, n, o]) => !n && o !== null),
      ct(([, , n]) => n)
    ),
    X
  ), e.sub(e.pipe(st, mt(10)), () => {
    const n = e.getValue(Ze);
    n !== null && typeof n != "number" && n.done !== void 0 && n.done(), e.pubIn({
      [Ze]: null,
      [Xe]: true
    });
  }), e.link(
    e.pipe(
      yt,
      // wait for the list to render with the specified scrollOffset, so that enough space is available to scroll by
      bt(),
      pt((n) => n !== 0)
    ),
    q
  ), e.link(
    e.pipe(
      yt,
      dt(L2),
      ct(() => 0)
    ),
    yt
  );
});
var Te = G(null);
var We = G(
  null,
  (e) => {
    e.link(
      e.pipe(
        We,
        pt((n) => n !== null)
      ),
      Te
    );
    const t = e.pipe(
      e.combine(We, ee),
      at(Te),
      pt(([[n, o], i]) => n !== null && !T2(o) && i !== null),
      ct(([[n]]) => n)
    );
    e.link(e.pipe(t, bt()), X), e.link(
      e.pipe(
        t,
        dt(
          e.pipe(
            Xe,
            pt((n) => n)
          )
        ),
        lt(null)
        // unset the location after the scroll completes
      ),
      Te
    );
  },
  false
);
function ii(e, t) {
  var l, r;
  const n = t.slice();
  let o = 0;
  const i = [];
  for (const { k: a, v: c } of de(e)) {
    for (; n.length && n[0] < a; )
      n.shift(), o++;
    const p2 = Math.max(0, a - o), g2 = ((l = i.at(-1)) == null ? void 0 : l.k) ?? -1;
    p2 === g2 ? (((r = i.at(-2)) == null ? void 0 : r.v) ?? -1) === c ? i.pop() : i[i.length - 1].v = c : i.push({ k: p2, v: c });
  }
  let s = Ae();
  for (const { k: a, v: c } of i)
    s = P2(s, a, c);
  return s;
}
var De = G(0);
var ze = G(null);
var k = G(null, (e) => {
  e.link(
    e.pipe(
      k,
      pt((t) => t !== null),
      ct((t) => t.length)
    ),
    De
  );
});
var vt = G(null);
function Sn(e, t, n) {
  function o() {
    e.pubIn({
      [K2]: 0,
      [Qt]: 0,
      [vt]: null,
      [Ye]: false,
      [Jt]: false,
      [xt]: null
    });
  }
  e.pubIn({
    [Jt]: true,
    [q]: t,
    [Qt]: t
  }), n ? requestAnimationFrame(o) : o();
}
var se = B((e) => {
  e.link(
    e.pipe(
      se,
      at($e),
      ct(([t, n]) => -(n * t.length))
    ),
    K2
  ), e.link(e.pipe(se, lt(true)), Ye), e.link(e.pipe(se, bt()), vt), e.sub(
    e.pipe(
      te,
      at(vt),
      pt(([, t]) => t !== null),
      ct(([t, n]) => {
        if (n === null)
          throw new Error("Unexpected null items");
        return we(n.length, t);
      })
    ),
    (t) => {
      Sn(e, t, false);
    }
  ), e.sub(
    e.pipe(
      se,
      Mt(2),
      at(te, vt),
      pt(([, , t]) => t !== null),
      ct(([t, n]) => we(t.length, n))
    ),
    (t) => {
      Sn(e, t, true);
    }
  ), e.changeWith(k, se, (t, n) => t ? [...n, ...t] : n.slice()), e.link(
    e.pipe(
      se,
      at(ee, $e),
      ct(([t, n, o]) => {
        const i = t.length, s = o;
        return de(n).reduce(
          (r, { k: a, v: c }) => ({
            ranges: [...r.ranges, { startIndex: r.prevIndex, endIndex: a + i - 1, size: r.prevSize }],
            prevIndex: a + i,
            prevSize: c
          }),
          {
            ranges: [],
            prevIndex: 0,
            prevSize: s
          }
        ).ranges;
      })
    ),
    fe
  );
});
var it = B((e) => {
  const t = e.pipe(
    it,
    at(ct2, cn, ze, ee),
    pt(([, , , , o]) => !T2(o)),
    ct(([{ data: o, scrollToBottom: i }, s, l, r]) => {
      if (i === false || i === void 0)
        return null;
      let a = "auto";
      const c = s.isAtBottom;
      if (typeof i == "function") {
        const p2 = i({ data: o, scrollLocation: s, scrollInProgress: l, context: r, atBottom: c });
        if (!p2)
          return null;
        if (typeof p2 == "object")
          return p2;
        if (typeof p2 == "number")
          return { index: p2, align: "end", behavior: "auto" };
        a = p2;
      } else {
        if (!c)
          return null;
        a = i;
      }
      return a === true && (a = "auto"), { index: "LAST", align: "end", behavior: a };
    })
  );
  e.link(
    e.pipe(
      t,
      pt((o) => o !== null),
      ct(() => true)
    ),
    xe
  ), e.link(
    e.pipe(
      st,
      at(xe),
      pt(([o, i]) => i),
      ct(() => false)
    ),
    xe
  );
  const n = e.pipe(
    fn,
    at(xe),
    pt(([o, i]) => o === "up" && i)
  );
  e.link(
    e.pipe(
      n,
      ct(() => false)
    ),
    xe
  ), e.link(e.pipe(n, lt(true)), Ut), e.link(
    e.pipe(
      t,
      pt((o) => o !== null),
      mt(20)
    ),
    X
  );
});
var Lt = B((e) => {
  e.changeWith(k, Lt, (t, n) => t ? [...t, ...n.data] : n.data.slice()), e.link(Lt, it);
});
var kt = B((e) => {
  e.changeWith(k, kt, (t, n) => t ? [...t.slice(0, n.offset), ...n.data, ...t.slice(n.offset)] : n.data.slice()), e.changeWith(Q2, kt, ([t], n) => {
    const i = he(t, n.offset, "k")[0], s = n.data.length;
    return [Bo(t, i, Number.POSITIVE_INFINITY, (r, a) => [r + s, a]), i];
  }), e.link(kt, it);
});
var Gt = B((e) => {
  e.changeWith(k, Gt, (t, { offset: n, count: o }) => t ? t.slice(0, n).concat(t.slice(n + o)) : []), e.changeWith(Q2, Gt, ([t], { offset: n, count: o }) => [Fo(t, n, o), n]);
});
var Wt = G(null);
var Fe = B((e) => {
  e.sub(
    e.pipe(
      Fe,
      at(k),
      pt(([{ purgeItemSizes: t }, n]) => !!t || n === null || n.length === 0)
    ),
    ([t, n]) => {
      n === null || n.length === 0 ? e.pubIn({
        ...t.initialLocation ? { [We]: t.initialLocation } : {},
        [k]: t.data.slice()
      }) : e.pubIn({
        ...t.initialLocation ? { [We]: t.initialLocation } : {},
        [Q2]: ot2,
        [Ve]: Be,
        [Wt]: t.data.slice()
      });
    }
  ), e.sub(
    e.pipe(
      to,
      at(Wt),
      Mt(),
      pt(([, t]) => t !== null)
    ),
    ([, t]) => {
      e.pubIn({
        [k]: t,
        [Wt]: null
      });
    }
  ), e.link(
    e.pipe(
      Fe,
      pt(({ purgeItemSizes: t }) => !t),
      at($e),
      pt(([, t]) => t > 0),
      ct(([{ data: t }, n]) => [
        {
          size: n,
          startIndex: t.length,
          endIndex: Number.POSITIVE_INFINITY
        }
      ])
    ),
    fe
  ), e.sub(
    e.pipe(
      Fe,
      pt(({ purgeItemSizes: t }) => !t)
    ),
    ({ data: t, initialLocation: n, suppressItemMeasure: o }) => {
      requestAnimationFrame(() => {
        o || e.pub(eo), requestAnimationFrame(() => {
          n && e.pubIn({
            [X]: n
          });
        });
      }), e.pubIn({
        [k]: t.slice()
      });
    }
  );
});
var St = B((e) => {
  e.link(
    e.pipe(
      St,
      at(te),
      ct(([t, n]) => -we(t, n))
    ),
    q
  ), e.changeWith(k, e.pipe(St, bt()), (t, n) => t ? t.slice(n) : []), e.changeWith(Q2, e.pipe(St, bt()), ([t], n) => [de(t).reduce((i, { k: s, v: l }) => P2(i, Math.max(0, s - n), l), Ae()), 0]);
});
var xn = B((e) => {
  e.changeWith(k, xn, (t, n) => t ? t.slice(0, t.length - n) : []), e.link(
    e.pipe(
      xn,
      at(De, $e),
      ct(([, t, n]) => [
        {
          size: n,
          startIndex: t,
          endIndex: Number.POSITIVE_INFINITY
        }
      ])
    ),
    fe
  );
});
var Kn = B((e) => {
  const t = e.pipe(
    Kn,
    at(k),
    ct(([n, o]) => {
      if (!o) return [];
      const i = [];
      return o.forEach((s, l) => {
        n(s, l) && i.push(l);
      }), i;
    })
  );
  e.changeWith(k, t, (n, o) => n ? n.filter((i, s) => !o.includes(s)) : []), e.changeWith(Q2, t, ([n], o) => [ii(n, o), 0]);
});
var xt = G(null);
var Ne = B((e) => {
  e.changeWith(k, Ne, (t, { mapper: n }) => t ? t.map(n) : []), e.link(
    e.pipe(
      Ne,
      pt(({ anchorItemIndex: t }) => t !== void 0),
      lt(true)
    ),
    Ye
  ), e.link(
    e.pipe(
      Ne,
      pt(({ anchorItemIndex: t }) => t !== void 0),
      at(te),
      ct(([{ anchorItemIndex: t }, n]) => {
        const o = t;
        return {
          oldOffset: we(o, n),
          index: o
        };
      })
    ),
    xt
  ), e.sub(
    e.pipe(
      te,
      at(xt),
      pt(([, t]) => t !== null),
      ct(([t, n]) => we(n.index, t) - n.oldOffset)
    ),
    (t) => {
      e.pubIn({
        [Ye]: false,
        [xt]: null,
        [q]: t
      });
    }
  ), e.link(
    e.pipe(
      Ne,
      Mt(3),
      at(rn),
      pt(([{ autoscrollToBottomBehavior: t }, n]) => n && !!t),
      ct(([{ autoscrollToBottomBehavior: t }]) => typeof t == "object" ? t.location() : { index: "LAST", align: "end", behavior: t }),
      pt((t) => !!t)
    ),
    X
  );
});
var Zt = B((e) => {
  e.changeWith(k, Zt, (t, { newData: n }) => n), e.link(
    e.pipe(
      Zt,
      Mt(3),
      at(rn),
      pt(([{ autoscrollToBottomBehavior: t }, n]) => n && !!t),
      ct(([{ autoscrollToBottomBehavior: t }]) => typeof t == "object" ? t.location() : { index: "LAST", align: "end", behavior: t }),
      pt((t) => !!t)
    ),
    X
  );
});
function si(e, t) {
  return [
    {
      data: t == null ? void 0 : t[e],
      prevData: (t == null ? void 0 : t[e - 1]) ?? null,
      nextData: (t == null ? void 0 : t[e + 1]) ?? null,
      height: 0,
      index: e,
      offset: 0,
      type: "flat"
    }
  ];
}
var li = [];
var Be = {
  items: li,
  listBottom: 0,
  listTop: 0,
  offsetTree: [],
  paddingBottom: 0,
  paddingTop: 0,
  totalCount: 0,
  totalHeight: 0,
  deviationDelta: 0,
  visibleListHeight: 0,
  data: null
};
var Jt = G(false);
var Ve = G(Be, (e) => {
  e.link(
    e.pipe(
      e.combine(
        ri,
        Jn,
        ee,
        te,
        De,
        Ke,
        k,
        yt,
        We,
        Te,
        lt2,
        qe,
        rt,
        K2,
        Jt,
        ye,
        J
      ),
      pt((t) => {
        const n = t.at(-1), o = t.at(-2), i = t.at(-3);
        return !o && !n && !i;
      }),
      ft(
        (t, [
          n,
          o,
          i,
          s,
          l,
          r,
          a,
          c,
          p2,
          g2,
          b,
          I2,
          f,
          m2
        ]) => {
          var Ie;
          if ((a == null ? void 0 : a.length) === 0)
            return Be;
          if (T2(i)) {
            let oe = 0;
            return p2 !== null && (oe = un(p2, l - 1).index), { ...Be, items: si(oe, a), offsetTree: s, totalCount: l, data: a };
          }
          let y = 0;
          g2 !== null && n === 0 && (y = Yn({
            totalHeight: r,
            location: g2,
            sizeTree: i,
            offsetTree: s,
            totalCount: l,
            viewportHeight: e.getValue(U2),
            headerHeight: e.getValue(ut),
            stickyHeaderHeight: I2,
            stickyFooterHeight: f
          }).top ?? 0);
          let G2 = 0;
          e.getValue(L2) !== 0 && !e.getValue(At) && e.getValue(wt) === Kt && t.totalCount === l && t.items.length > 0 && (G2 = r - t.totalHeight, G2 !== 0 && (G2 += e.getValue(zn)));
          const Z = e.getValue(Un), Y = Math.min(
            Math.max(
              n + y + c - m2 - b + G2 - Z,
              0
            ),
            r - o
          ), me = Y + o + Z * 2;
          if (t.offsetTree === s && t.totalCount === l && t.data === a && Y >= t.listTop && me <= t.listBottom)
            return t;
          const ne = [], Ue = l - 1, be = 0, W = Yo(s, Y, me, be);
          let F = 0, M2 = 0, j2 = false;
          for (const oe of W) {
            const {
              value: { offset: ve, height: ke }
            } = oe;
            let ie = oe.start;
            F = ve, ve < Y && (ie += Math.floor((Y - ve) / ke), F += (ie - oe.start) * ke), ie < be && (F += (be - ie) * ke, ie = be);
            const Ht = Math.min(oe.end, Ue);
            for (let ue = ie; ue <= Ht && !(F >= me); ue++) {
              const at2 = {
                data: a == null ? void 0 : a[ue],
                prevData: (a == null ? void 0 : a[ue - 1]) ?? null,
                nextData: (a == null ? void 0 : a[ue + 1]) ?? null,
                height: ke,
                index: ue,
                offset: F,
                type: "flat"
              };
              j2 || (j2 = true, M2 = F), ne.push(at2), F += ke;
            }
          }
          ne.length === 0 && (M2 = F = 0);
          const R2 = r - F, re = ((Ie = ne[0]) == null ? void 0 : Ie.offset) || 0;
          return {
            items: ne,
            listBottom: F,
            listTop: M2,
            offsetTree: s,
            paddingBottom: R2,
            paddingTop: re,
            totalCount: l,
            totalHeight: r,
            data: a,
            deviationDelta: G2,
            visibleListHeight: o
          };
        },
        Be
      )
    ),
    Ve
  );
});
var Rt = Me([], (e) => e.pipe(
  e.combine(Ve, L2),
  ct(([t, n]) => {
    const o = t.items.slice();
    for (; o.length > 0 && o[0].offset + o[0].height < n; )
      o.shift();
    return o.map((i) => i.data);
  })
));
var J = G(false);
var Ye = G(false);
var Tt = B((e) => {
  e.link(
    e.pipe(
      Ve,
      ct((t) => t.deviationDelta),
      pt((t) => t !== 0)
    ),
    Tt
  ), _n() ? (e.sub(e.pipe(Tt, at(K2, L2)), ([t, n]) => {
    e.pub(K2, n - t);
  }), e.sub(
    e.pipe(e.combine(L2, K2, ye, Ye)),
    ([t, n, o, i]) => {
      o || i || (n > 0 && t < n ? (e.pub(J, true), e.pub(Re, { top: 0, behavior: "instant" }), setTimeout(() => {
        e.pubIn({
          [J]: false,
          [K2]: 0
        });
      })) : n < 0 && t <= 0 && (e.pubIn({
        [J]: true,
        [K2]: 0
      }), setTimeout(() => {
        e.pub(Re, { top: 0, behavior: "instant" }), e.pub(J, false);
      })));
    }
  ), e.sub(
    e.pipe(
      e.combine(et, K2, J, ye, Ye),
      pt(
        ([t, n, o, i, s]) => !t && n !== 0 && !o && !i && !s
      ),
      gt(100)
    ),
    ([, t]) => {
      e.pub(J, true), t < 0 ? requestAnimationFrame(() => {
        e.pub(q, -t), e.pub(K2, 0), requestAnimationFrame(() => {
          e.pub(J, false);
        });
      }) : requestAnimationFrame(() => {
        e.pub(q, -t), e.pub(K2, 0), requestAnimationFrame(() => {
          e.pub(J, false);
        });
      });
    }
  )) : e.link(Tt, q);
});
var At = B();
var cn = G(false);
var st = B((e) => {
  e.link(e.pipe(st, lt(false)), At);
}, false);
var L2 = G(0);
var U2 = G(0);
var Et = G(0);
var V2 = G(0);
var ri = L2;
var yt = G(0);
var qe = G(0);
var lt2 = G(0);
var rt = G(0);
var an = G(0);
var Le = G(null);
var qn = H();
var Un = G(0);
var Gn = G(false);
var ui = Zo;
var ci = 50;
var ut = Me(0, (e) => e.pipe(
  e.combine(qe, lt2),
  ct(([t, n]) => t + n)
));
var Zn = Me(0, (e) => e.pipe(
  e.combine(rt, an),
  ct(([t, n]) => t + n)
));
var ai = Me(0, (e) => e.pipe(
  e.combine(qe, lt2, L2),
  ct(([t, n, o]) => t + Math.max(n - o, 0))
));
var pi = Me(0, (e) => e.pipe(
  e.combine(rt, an, L2, U2, V2),
  ct(([t, n, o, i, s]) => {
    o = Math.min(o, s - i);
    const l = Math.max(n - (s - (o + i)), 0);
    return t + l;
  })
));
var Jn = Me(0, (e) => e.pipe(
  e.combine(U2, ai, pi),
  ct(([t, n, o]) => Math.max(0, t - n - o))
));
var Dt = G(0);
var Xn = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(Xn, Ke, U2, ut, qe),
      ct(([t, n, o, i, s]) => t === 0 ? 0 : Math.max(0, Math.min(t - (n + i + s - o))))
    ),
    Dt
  );
});
var Re = B((e) => {
  e.link(
    e.pipe(
      Re,
      ct((t) => t.align === "start" ? t.top ?? 0 : 0)
    ),
    Xn
  ), e.link(
    e.pipe(
      Re,
      at(L2),
      pt(([t, n]) => t.top !== n),
      lt(true)
    ),
    At
  );
});
var pn = B((e) => {
  e.link(
    e.pipe(
      Re,
      at(nt),
      ct(([t, n]) => ("top" in t && typeof t.top < "u" && (t = { ...t, top: t.top + n }), t))
    ),
    pn
  );
});
var ct2 = Me(
  {
    listOffset: 0,
    visibleListHeight: 0,
    scrollHeight: 0,
    bottomOffset: 0,
    isAtBottom: false
  },
  (e) => e.pipe(
    e.combine(
      L2,
      ut,
      Zn,
      lt2,
      Jn,
      V2,
      Dt,
      ye,
      Te,
      J,
      xe
    ),
    pt(([, , , , , , , t, n, o]) => !t && n === null && !o),
    ct(
      ([
        t,
        n,
        o,
        i,
        s,
        l,
        r,
        a,
        c,
        p2,
        g2
      ]) => {
        const b = e.getValue(Wn), I2 = l - n - o, f = -t + i, m2 = I2 + Math.min(0, f) - s - r;
        return {
          scrollHeight: I2,
          listOffset: f,
          visibleListHeight: s,
          bottomOffset: m2,
          isAtBottom: g2 || m2 <= b
        };
      }
    )
  )
);
var Xt = B((e) => {
  e.link(
    e.pipe(
      L2,
      mt(0),
      at(ct2, Te, ye),
      pt(([, t, n, o]) => t.scrollHeight > 0 && n == null && !o),
      ct(([, t]) => t)
    ),
    Xt
  );
});
var q = B();
var K2 = G(0);
var Qt = G(0);
var Ct = G(0);
var Qn = G("");
var fn = B();
var eo = H();
var to = H();
var hn = G(false);
var tt = G(null);
G(0);
var nt = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(je, ge, nt),
      ct(([t, n, o]) => t - Math.max(0, o - n))
    ),
    U2
  );
});
var ge = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(ge, nt),
      ct(([t, n]) => Math.max(0, t - n))
    ),
    L2
  );
});
var je = G(0);
function no(e) {
  return {
    data: {
      prepend: (t) => {
        e.pub(se, t);
      },
      append: (t, n) => {
        e.pub(Lt, {
          data: t,
          scrollToBottom: n
        });
      },
      replace: (t, n) => {
        e.pub(Fe, {
          ...n,
          data: t
        });
      },
      map: (t, n) => {
        e.pub(Ne, {
          mapper: t,
          autoscrollToBottomBehavior: n
        });
      },
      mapWithAnchor: (t, n) => {
        e.pub(Ne, {
          mapper: t,
          anchorItemIndex: n
        });
      },
      findAndDelete: (t) => {
        e.pub(Kn, t);
      },
      findIndex: (t) => e.getValue(k).findIndex(t),
      find: (t) => e.getValue(k).find(t),
      insert: (t, n, o) => {
        e.pub(kt, {
          data: t,
          offset: n,
          scrollToBottom: o
        });
      },
      deleteRange: (t, n) => {
        e.pub(Gt, {
          offset: t,
          count: n
        });
      },
      batch: (t, n) => {
        e.pub(ye, true), t(), e.pub(ye, false), e.pub(it, { data: [], scrollToBottom: n });
      },
      get: () => e.getValue(k).slice(),
      getCurrentlyRendered: () => e.getValue(Rt),
      removeFromStart: (t) => {
        e.pub(St, t);
      }
    },
    scrollToItem: (t) => {
      e.pub(X, t);
    },
    scrollIntoView: (t) => {
      e.pub(jn, t);
    },
    scrollerElement: () => e.getValue(Le),
    getScrollLocation() {
      return e.getValue(ct2);
    },
    cancelSmoothScroll() {
      e.pub(qn);
    },
    height: (t) => {
      var i;
      const n = ((i = e.getValue(k)) == null ? void 0 : i.indexOf(t)) ?? -1;
      if (n === -1)
        return 0;
      const o = e.getValue(ee);
      return he(o, n)[1] ?? 0;
    }
  };
}
function Yi() {
  return P(ct2);
}
function ji() {
  return P(Rt);
}
function Ki() {
  const e = I();
  return import_react.default.useMemo(() => no(e), [e]);
}
var qi = {
  prepend: "prepend",
  removeFromStart: "remove-from-start",
  removeFromEnd: "remove-from-end"
};
var oo = G(null);
var io = G(null);
var so = G(null);
var lo = G(null);
var ro = G(null);
var uo = G("div");
var fi = {
  position: "sticky",
  top: 0,
  zIndex: 1
};
var gt2 = {
  overflowAnchor: "none"
};
var hi = {
  position: "sticky",
  bottom: 0
};
var co = import_react.default.forwardRef((e, t) => (0, import_jsx_runtime2.jsx)("div", { style: { zIndex: 1 }, ...e, ref: t }));
var ao = import_react.default.forwardRef((e, t) => (0, import_jsx_runtime2.jsx)("div", { ...e, ref: t }));
var po = import_react.default.forwardRef(
  ({ style: e, ...t }, n) => (0, import_jsx_runtime2.jsx)("div", { ...t, style: { ...fi, ...e }, ref: n })
);
var fo = import_react.default.forwardRef(
  ({ style: e, ...t }, n) => (0, import_jsx_runtime2.jsx)("div", { ...t, style: { ...hi, ...e }, ref: n })
);
var ho = G(co);
var go = G(po);
var mo = G(ao);
var bo = G(fo);
var Io = ({ index: e }) => (0, import_jsx_runtime2.jsxs)("div", { children: [
  "Item ",
  e
] });
var vo = ({ index: e }) => e;
var en = G(Io);
var ko = G(vo);
var tn = (e) => e;
var So = G(tn);
var xo = G(
  null,
  (e) => {
    e.sub(
      e.pipe(xo, at(k, So, te, Q2)),
      ([t, n, o, i, s]) => {
        if (t === void 0)
          return;
        if (!t || !t.data || !t.data.length) {
          e.pubIn({
            [k]: [],
            [Q2]: ot2,
            [Ve]: Be
          });
          return;
        }
        const l = t.data, r = t.scrollModifier;
        if (r === "prepend") {
          if (n === null || !n.length) {
            e.pub(k, l);
            return;
          }
          const a = n[0], c = l.findIndex((b) => o(b) === o(a)), p2 = c === -1 ? l : l.slice(0, c), g2 = c === -1 ? [] : l.slice(c);
          e.pubIn({
            [k]: g2
          }), e.pubIn({
            [se]: p2
          });
          return;
        }
        if (r === "remove-from-start") {
          const a = l[0], c = (n == null ? void 0 : n.findIndex((g2) => o(g2) === o(a))) ?? -1;
          if (c === -1) {
            e.pub(k, l);
            return;
          }
          const p2 = we(c, i);
          e.pub(q, -p2), queueMicrotask(() => {
            e.pub(k, l);
            const g2 = de(s[0]).reduce((b, { k: I2, v: f }) => P2(b, Math.max(0, I2 - c), f), Ae());
            e.pub(Q2, [g2, 0]);
          });
          return;
        }
        if (r === "remove-from-end") {
          e.pub(k, l), e.pub(fe, [
            {
              size: e.getValue($e),
              startIndex: l.length,
              endIndex: Number.POSITIVE_INFINITY
            }
          ]);
          return;
        }
        if ((r == null ? void 0 : r.type) === "item-location") {
          l !== n && e.pubIn({
            [Fe]: {
              data: l,
              initialLocation: r.location,
              purgeItemSizes: r.purgeItemSizes
            }
          });
          return;
        }
        if ((r == null ? void 0 : r.type) === "auto-scroll-to-bottom") {
          e.pubIn({
            [k]: l,
            [it]: {
              data: l,
              scrollToBottom: r.autoScroll
            }
          });
          return;
        }
        if ((r == null ? void 0 : r.type) === "items-change") {
          e.pub(Zt, {
            newData: l,
            autoscrollToBottomBehavior: r.behavior
          });
          return;
        }
        e.pub(k, l);
      }
    );
  },
  (e, t) => e ? e.data === (t == null ? void 0 : t.data) : false
);
var di = ({ item: e, ItemContent: t, mount: n, unmount: o }) => {
  const i = P(ze), s = import_react.default.useRef(null), l = import_react.default.useCallback(
    (r) => {
      r ? (s.current = r, n(r)) : s.current && (o(s.current), s.current = null);
    },
    [n, o]
  );
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      ref: l,
      "data-index": e.index,
      "data-known-size": e.height,
      style: {
        overflowAnchor: "none",
        position: "absolute",
        width: "100%",
        top: e.offset
      },
      children: (0, import_jsx_runtime2.jsx)(t, { index: e.index, prevData: e.prevData, nextData: e.nextData, data: e.data, context: i })
    }
  );
};
var gi = import_react.default.memo(di, (e, t) => {
  const n = e.item, o = t.item;
  return n.index === o.index && n.height === o.height && n.offset === o.offset && n.data === o.data && n.prevData === o.prevData && n.nextData === o.nextData && e.ItemContent === t.ItemContent;
});
var nn = G("top", (e) => {
  e.link(
    e.pipe(
      e.combine(nn, Ke, U2, ut, Zn),
      pt(([t]) => t === "bottom" || t === "bottom-smooth"),
      ct(([, t, n, o, i]) => Math.max(0, n - t - o - i))
    ),
    Ct
  ), e.link(
    e.pipe(
      e.combine(Ct, nn),
      pt(([, t]) => t === "bottom-smooth"),
      ft(
        (t, [n]) => [t[1], n],
        [0, 0]
      ),
      ct(([t, n]) => t > 0 && n > 0 ? "margin-top 0.2s ease-out" : "")
    ),
    Qn
  );
});
function mt2(e) {
  const t = import_react.default.useRef(null);
  return [import_react.default.useCallback(
    (o) => {
      o ? (t.current = o, e == null || e.observe(o, { box: "border-box" })) : t.current && (e == null || e.unobserve(t.current), t.current = null);
    },
    [e]
  ), t];
}
function mi(e, t) {
  return Math.abs(e - t) < 0.5;
}
function bi(e, t, n) {
  const o = I(), i = import_react.default.useRef(null), s = import_react.default.useRef(null), l = import_react.default.useCallback(() => {
    i.current && (cancelAnimationFrame(i.current), i.current = null, s.current = null);
  }, []);
  import_react.default.useEffect(() => o.sub(fn, (c) => {
    c !== s.current && l();
  }), [o, l]), import_react.default.useEffect(() => o.sub(qn, l), [o, l]);
  const r = import_react.default.useCallback(
    (c, p2, g2) => {
      var y;
      i.current && l();
      const b = ((y = e.current) == null ? void 0 : y.scrollTop) ?? 0;
      s.current = b < c ? "down" : "up";
      let I2 = 0, f = 0;
      function m2() {
        var Z, Y;
        const G2 = b + (c - b) * p2(I2);
        (Z = e.current) == null || Z.scrollTo({ top: G2, behavior: "instant" }), I2 += 1 / g2, f += 1, f < g2 ? i.current = requestAnimationFrame(m2) : ((Y = e.current) == null || Y.scrollTo({ top: c, behavior: "instant" }), i.current = null, s.current = null);
      }
      m2();
    },
    [e, l]
  );
  return import_react.default.useCallback(
    (c) => {
      var I2, f;
      const p2 = e.current;
      if (!p2 || c.top === void 0)
        return;
      const g2 = p2.scrollHeight - p2.clientHeight, b = Math.max(0, Math.min(c.top, g2));
      if (mi(b, p2.scrollTop) || p2.scrollHeight <= p2.clientHeight) {
        requestAnimationFrame(() => {
          var m2;
          o.pub(st, (m2 = e.current) == null ? void 0 : m2.scrollTop);
        });
        return;
      }
      if (n.current = b, o.pub(cn, true), c.forceBottomSpace !== void 0 && t.current && (t.current.style.paddingBottom = `${c.forceBottomSpace}px`), c.behavior === "smooth")
        r(b ?? 0, ui, ci);
      else if (c.behavior === "auto" || c.behavior === "instant" || c.behavior === void 0)
        l(), (I2 = e.current) == null || I2.scrollTo(c);
      else {
        const { easing: m2, animationFrameCount: y } = c.behavior(((f = e.current) == null ? void 0 : f.scrollTop) ?? 0, b ?? 0);
        r(b ?? 0, m2, y);
      }
    },
    [o, r, t, e, n, l]
  );
}
function Ii(e) {
  return vi(Si(xi(ki(e), 8 * e.length))).toLowerCase();
}
function vi(e) {
  for (var t, n = "0123456789ABCDEF", o = "", i = 0; i < e.length; i++)
    t = e.charCodeAt(i), o += n.charAt(t >>> 4 & 15) + n.charAt(15 & t);
  return o;
}
function ki(e) {
  for (var t = Array(e.length >> 2), n = 0; n < t.length; n++) t[n] = 0;
  for (n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << n % 32;
  return t;
}
function Si(e) {
  for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> n % 32 & 255);
  return t;
}
function xi(e, t) {
  e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
  for (var n = 1732584193, o = -271733879, i = -1732584194, s = 271733878, l = 0; l < e.length; l += 16) {
    const r = n, a = o, c = i, p2 = s;
    o = B2(
      o = B2(
        o = B2(
          o = B2(
            o = N(
              o = N(
                o = N(
                  o = N(
                    o = H2(
                      o = H2(
                        o = H2(
                          o = H2(
                            o = O2(
                              o = O2(
                                o = O2(
                                  o = O2(
                                    o,
                                    i = O2(
                                      i,
                                      s = O2(s, n = O2(n, o, i, s, e[l + 0], 7, -680876936), o, i, e[l + 1], 12, -389564586),
                                      n,
                                      o,
                                      e[l + 2],
                                      17,
                                      606105819
                                    ),
                                    s,
                                    n,
                                    e[l + 3],
                                    22,
                                    -1044525330
                                  ),
                                  i = O2(
                                    i,
                                    s = O2(s, n = O2(n, o, i, s, e[l + 4], 7, -176418897), o, i, e[l + 5], 12, 1200080426),
                                    n,
                                    o,
                                    e[l + 6],
                                    17,
                                    -1473231341
                                  ),
                                  s,
                                  n,
                                  e[l + 7],
                                  22,
                                  -45705983
                                ),
                                i = O2(
                                  i,
                                  s = O2(s, n = O2(n, o, i, s, e[l + 8], 7, 1770035416), o, i, e[l + 9], 12, -1958414417),
                                  n,
                                  o,
                                  e[l + 10],
                                  17,
                                  -42063
                                ),
                                s,
                                n,
                                e[l + 11],
                                22,
                                -1990404162
                              ),
                              i = O2(
                                i,
                                s = O2(s, n = O2(n, o, i, s, e[l + 12], 7, 1804603682), o, i, e[l + 13], 12, -40341101),
                                n,
                                o,
                                e[l + 14],
                                17,
                                -1502002290
                              ),
                              s,
                              n,
                              e[l + 15],
                              22,
                              1236535329
                            ),
                            i = H2(
                              i,
                              s = H2(s, n = H2(n, o, i, s, e[l + 1], 5, -165796510), o, i, e[l + 6], 9, -1069501632),
                              n,
                              o,
                              e[l + 11],
                              14,
                              643717713
                            ),
                            s,
                            n,
                            e[l + 0],
                            20,
                            -373897302
                          ),
                          i = H2(
                            i,
                            s = H2(s, n = H2(n, o, i, s, e[l + 5], 5, -701558691), o, i, e[l + 10], 9, 38016083),
                            n,
                            o,
                            e[l + 15],
                            14,
                            -660478335
                          ),
                          s,
                          n,
                          e[l + 4],
                          20,
                          -405537848
                        ),
                        i = H2(
                          i,
                          s = H2(s, n = H2(n, o, i, s, e[l + 9], 5, 568446438), o, i, e[l + 14], 9, -1019803690),
                          n,
                          o,
                          e[l + 3],
                          14,
                          -187363961
                        ),
                        s,
                        n,
                        e[l + 8],
                        20,
                        1163531501
                      ),
                      i = H2(
                        i,
                        s = H2(s, n = H2(n, o, i, s, e[l + 13], 5, -1444681467), o, i, e[l + 2], 9, -51403784),
                        n,
                        o,
                        e[l + 7],
                        14,
                        1735328473
                      ),
                      s,
                      n,
                      e[l + 12],
                      20,
                      -1926607734
                    ),
                    i = N(
                      i,
                      s = N(s, n = N(n, o, i, s, e[l + 5], 4, -378558), o, i, e[l + 8], 11, -2022574463),
                      n,
                      o,
                      e[l + 11],
                      16,
                      1839030562
                    ),
                    s,
                    n,
                    e[l + 14],
                    23,
                    -35309556
                  ),
                  i = N(
                    i,
                    s = N(s, n = N(n, o, i, s, e[l + 1], 4, -1530992060), o, i, e[l + 4], 11, 1272893353),
                    n,
                    o,
                    e[l + 7],
                    16,
                    -155497632
                  ),
                  s,
                  n,
                  e[l + 10],
                  23,
                  -1094730640
                ),
                i = N(
                  i,
                  s = N(s, n = N(n, o, i, s, e[l + 13], 4, 681279174), o, i, e[l + 0], 11, -358537222),
                  n,
                  o,
                  e[l + 3],
                  16,
                  -722521979
                ),
                s,
                n,
                e[l + 6],
                23,
                76029189
              ),
              i = N(
                i,
                s = N(s, n = N(n, o, i, s, e[l + 9], 4, -640364487), o, i, e[l + 12], 11, -421815835),
                n,
                o,
                e[l + 15],
                16,
                530742520
              ),
              s,
              n,
              e[l + 2],
              23,
              -995338651
            ),
            i = B2(
              i,
              s = B2(s, n = B2(n, o, i, s, e[l + 0], 6, -198630844), o, i, e[l + 7], 10, 1126891415),
              n,
              o,
              e[l + 14],
              15,
              -1416354905
            ),
            s,
            n,
            e[l + 5],
            21,
            -57434055
          ),
          i = B2(
            i,
            s = B2(s, n = B2(n, o, i, s, e[l + 12], 6, 1700485571), o, i, e[l + 3], 10, -1894986606),
            n,
            o,
            e[l + 10],
            15,
            -1051523
          ),
          s,
          n,
          e[l + 1],
          21,
          -2054922799
        ),
        i = B2(
          i,
          s = B2(s, n = B2(n, o, i, s, e[l + 8], 6, 1873313359), o, i, e[l + 15], 10, -30611744),
          n,
          o,
          e[l + 6],
          15,
          -1560198380
        ),
        s,
        n,
        e[l + 13],
        21,
        1309151649
      ),
      i = B2(
        i,
        s = B2(s, n = B2(n, o, i, s, e[l + 4], 6, -145523070), o, i, e[l + 11], 10, -1120210379),
        n,
        o,
        e[l + 2],
        15,
        718787259
      ),
      s,
      n,
      e[l + 9],
      21,
      -343485551
    ), n = pe(n, r), o = pe(o, a), i = pe(i, c), s = pe(s, p2);
  }
  return [n, o, i, s];
}
function Vt(e, t, n, o, i, s) {
  return pe(Ti(pe(pe(t, e), pe(o, s)), i), n);
}
function O2(e, t, n, o, i, s, l) {
  return Vt(t & n | ~t & o, e, t, i, s, l);
}
function H2(e, t, n, o, i, s, l) {
  return Vt(t & o | n & ~o, e, t, i, s, l);
}
function N(e, t, n, o, i, s, l) {
  return Vt(t ^ n ^ o, e, t, i, s, l);
}
function B2(e, t, n, o, i, s, l) {
  return Vt(n ^ (t | ~o), e, t, i, s, l);
}
function pe(e, t) {
  const n = (65535 & e) + (65535 & t);
  return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n;
}
function Ti(e, t) {
  return e << t | e >>> 32 - t;
}
var To = Symbol("INVALID_KEY");
function Ei(e) {
  const t = e.slice(0, 32), n = e.slice(32), o = atob(n);
  if (t !== Ii(n))
    return To;
  const [i, s] = o.split(";"), l = i.slice(2), r = new Date(Number(s.slice(2)));
  return { orderNumber: l, expiryDate: r };
}
var yi = {
  valid: false,
  consoleMessage: "The VirtuosoMessageList license wrapper component is missing. Enclose the VirtuosoMessageList with VirtuosoMessageListLicense and add your key at the lisenceKey property.",
  watermarkMessage: "The VirtuosoMessageList license wrapper component is missing. Enclose the VirtuosoMessageList with VirtuosoMessageListLicense and add your key at the lisenceKey property."
};
var $i = {
  valid: false,
  consoleMessage: "Your VirtuosoMessageListLicense is missing a license key. Purchase one from https://virtuoso.dev/pricing/",
  watermarkMessage: "Your VirtuosoMessageListLicense is missing a license key. Purchase one from https://virtuoso.dev/pricing/"
};
var wi = {
  valid: false,
  consoleMessage: "Your VirtuosoMessageListLicense component is missing a license key - this component will not work if deployed in production. Purchase a key from https://virtuoso.dev/pricing/ before you deploy to production."
};
var Eo = {
  valid: true
};
var Li = {
  valid: false,
  consoleMessage: "Your Virtuoso Message List license key is invalid. Ensure that you have copy-pasted the key from the purchase email correctly.",
  watermarkMessage: "Your Virtuoso Message List license key is invalid"
};
var Ri = {
  valid: false,
  consoleMessage: "Your annual license key to use Virtuoso Message List in non-production environments has expired. You can still use it in production. To keep using it in development, purchase a new key from https://virtuoso.dev/pricing/",
  watermarkMessage: "Your annual license key to use Virtuoso Message List in non-production environments has expired. You can still use it in production. To keep using it in development, purchase a new key from https://virtuoso.dev/pricing/"
};
var Ci = {
  valid: false,
  consoleMessage: "You have installed a version of `@virtuoso.dev/message-list` that is newer than the period of your license key. Either downgrade to a supported version, or purchase a new license from https://virtuoso.dev/pricing/",
  watermarkMessage: "You have installed a version of `@virtuoso.dev/message-list` that is newer than the period of your license key. Either downgrade to a supported version, or purchase a new license from https://virtuoso.dev/pricing/"
};
var Mi = Eo;
var Ai = /^(?:127\.0\.0\.1|localhost|0\.0\.0\.0|.+\.local)$/;
var Di = ["virtuoso.dev", "csb.app", "codesandbox.io"];
function Vi({ licenseKey: e, now: t, hostname: n, packageTimestamp: o }) {
  const i = n.match(Ai), s = Di.some((r) => n.endsWith(r));
  if (!e)
    return s ? Mi : i ? wi : $i;
  const l = Ei(e);
  if (l === To)
    return Li;
  if (l.expiryDate.getTime() < t.getTime()) {
    if (i)
      return Ri;
    if (l.expiryDate.getTime() < o)
      return Ci;
  }
  return Eo;
}
var yo = import_react.default.createContext(yi);
function Ui({ licenseKey: e, children: t }) {
  const n = Vi({
    licenseKey: e,
    hostname: typeof window < "u" ? window.location.hostname : "localhost",
    now: /* @__PURE__ */ new Date(),
    packageTimestamp: 1766318635275
  });
  return (0, import_jsx_runtime2.jsx)(yo.Provider, { value: n, children: t });
}
var Ot = import_react.default.createContext(void 0);
var Tn = false;
var Oi = import_react.default.forwardRef(
  ({
    initialData: e = [],
    computeItemKey: t = vo,
    context: n = null,
    initialLocation: o = null,
    shortSizeAlign: i = "top",
    onScroll: s,
    onRenderedDataChange: l,
    ItemContent: r = Io,
    Header: a = null,
    StickyHeader: c = null,
    Footer: p2 = null,
    StickyFooter: g2 = null,
    EmptyPlaceholder: b = null,
    HeaderWrapper: I2 = co,
    StickyHeaderWrapper: f = po,
    FooterWrapper: m2 = ao,
    StickyFooterWrapper: y = fo,
    useWindowScroll: G2 = false,
    customScrollParent: Z = null,
    ScrollElement: Y = "div",
    increaseViewportBy: me = 0,
    data: ne,
    enforceStickyFooterAtBottom: Ue = false,
    itemIdentity: be = tn,
    ...W
  }, F) => {
    const M2 = import_react.default.useMemo(() => {
      const R2 = new K();
      return R2.register(Ve), R2.register(At), R2.register(wt), R2.register(Tt), R2.register(It), R2.register(Lt), R2.register(se), R2.register(Fe), R2.pubIn({
        [k]: e.slice(),
        [So]: tn,
        [ze]: n,
        [ko]: t,
        [We]: o,
        [en]: r,
        [oo]: a,
        [so]: p2,
        [io]: c,
        [lo]: g2,
        [ro]: b,
        [uo]: Y,
        [bo]: y,
        [go]: f,
        [mo]: m2,
        [ho]: I2,
        [nn]: i,
        [hn]: G2,
        [tt]: Z,
        [Un]: me,
        [Gn]: Ue
      }), R2.singletonSub(Xt, s), R2.singletonSub(Rt, l), R2;
    }, []);
    import_react.default.useImperativeHandle(F, () => no(M2), [M2]), import_react.default.useEffect(() => {
      M2.pubIn({
        [ze]: n,
        [en]: r,
        [tt]: Z,
        [xo]: ne
      }), M2.singletonSub(Xt, s), M2.singletonSub(Rt, l);
    }, [n, r, Z, s, l, M2, ne]);
    const j2 = import_react.default.useContext(yo);
    return import_react.default.useEffect(() => {
      j2.consoleMessage && (Tn || (Tn = true, console.warn(j2.consoleMessage)));
    }, [j2]), import_react.default.useEffect(() => {
      const R2 = (re) => {
        var Ie;
        (Ie = re.message) != null && Ie.includes("ResizeObserver loop") && (re.preventDefault(), re.stopPropagation(), re.stopImmediatePropagation());
      };
      return window.addEventListener("error", R2, { capture: true }), () => {
        window.removeEventListener("error", R2);
      };
    }, []), typeof window < "u" && j2.watermarkMessage ? (0, import_jsx_runtime2.jsx)(
      "div",
      {
        style: {
          color: "red",
          pointerEvents: "none"
        },
        children: j2.watermarkMessage
      }
    ) : (0, import_jsx_runtime2.jsx)(O.Provider, { value: M2, children: (0, import_jsx_runtime2.jsx)(Hi, { ...W }) });
  }
);
Oi.displayName = "VirtuosoMessageList";
var Hi = ({ style: e, ...t }) => {
  const n = I(), o = import_react.default.useContext(Ot), [
    i,
    s,
    l,
    r,
    a,
    c,
    p2,
    g2,
    b,
    I2,
    f
  ] = ot(
    oo,
    io,
    ho,
    go,
    so,
    lo,
    mo,
    bo,
    en,
    ro,
    tt
  ), [m2] = import_react.default.useState(() => {
    if (typeof window < "u" && typeof ResizeObserver > "u")
      throw new Error("ResizeObserver not found. Please ensure that you have a polyfill installed.");
    if (!(typeof ResizeObserver > "u"))
      return new ResizeObserver((x2) => {
        var ht, He, Ge, mn;
        const Se = x2.length, z = [];
        let w2 = {};
        for (let Nt = 0; Nt < Se; Nt++) {
          const ce = x2[Nt], D2 = ce.target;
          if (D2 === ne.current) {
            w2 = {
              ...w2,
              [lt2]: ce.contentRect.height,
              [V2]: (ht = W.current) == null ? void 0 : ht.scrollHeight
            };
            continue;
          }
          if (D2 === be.current) {
            w2 = {
              ...w2,
              [qe]: ce.contentRect.height,
              [V2]: (He = W.current) == null ? void 0 : He.scrollHeight
            };
            continue;
          }
          if (D2 === G2.current) {
            w2 = {
              ...w2,
              [an]: ce.contentRect.height,
              [V2]: (Ge = W.current) == null ? void 0 : Ge.scrollHeight
            };
            continue;
          }
          if (D2 === Y.current) {
            w2 = {
              ...w2,
              [rt]: ce.contentRect.height,
              [V2]: (mn = W.current) == null ? void 0 : mn.scrollHeight
            };
            continue;
          }
          if (D2 === W.current) {
            w2 = {
              ...w2,
              [L2]: D2.scrollTop,
              [V2]: D2.scrollHeight,
              [U2]: ce.contentRect.height,
              [Et]: D2.clientWidth
            };
            continue;
          }
          if (D2 === M2.current) {
            W.current && (w2 = {
              ...w2,
              [V2]: W.current.scrollHeight
            });
            continue;
          }
          if (D2 === F.current) {
            const ae = D2.ownerDocument.defaultView;
            ae !== null && (w2 = {
              ...w2,
              [V2]: ce.contentRect.height,
              [ge]: ae.scrollY,
              [je]: ae.innerHeight,
              [nt]: D2.getBoundingClientRect().top + ae.scrollY,
              [Et]: D2.clientWidth
            });
            continue;
          }
          if (D2 === f || D2 === j2.current) {
            const ae = R2.current, dt2 = j2.current;
            ae && dt2 && (w2 = {
              ...w2,
              [V2]: dt2.getBoundingClientRect().height,
              [ge]: ae.scrollTop,
              [je]: ae.clientHeight,
              [nt]: dt2.offsetTop,
              [Et]: dt2.clientWidth
            });
            continue;
          }
          if (D2.dataset.index === void 0)
            continue;
          const Bt = Number.parseInt(D2.dataset.index), Ao = Number.parseFloat(D2.dataset.knownSize ?? ""), Ft = ce.contentRect.height;
          if (Ft === Ao)
            continue;
          const bn = z[z.length - 1];
          z.length === 0 || bn.size !== Ft || bn.endIndex !== Bt - 1 ? z.push({ endIndex: Bt, size: Ft, startIndex: Bt }) : z[z.length - 1].endIndex++;
        }
        z.length > 0 && (w2 = {
          ...w2,
          [fe]: z
        }), n.pubIn(w2);
      });
  }), [y, G2] = mt2(m2), [Z, Y] = mt2(m2), [me, ne] = mt2(m2), [Ue, be] = mt2(m2), W = import_react.default.useRef(null), F = import_react.default.useRef(null), M2 = import_react.default.useRef(null), j2 = import_react.default.useRef(null), R2 = import_react.default.useRef(null);
  (0, import_react.useEffect)(() => {
    R2.current = f;
  }, [f]);
  const re = import_react.default.useCallback(
    (x2) => {
      if (o) {
        const Se = Number.parseInt(x2.dataset.index ?? "");
        n.pub(fe, [
          {
            startIndex: Se,
            endIndex: Se,
            size: o.itemHeight
          }
        ]);
      }
      m2 == null || m2.observe(x2);
    },
    [m2, n, o]
  ), Ie = import_react.default.useCallback(
    (x2) => {
      m2 == null || m2.unobserve(x2);
    },
    [m2]
  ), oe = import_react.default.useCallback(
    (x2) => {
      x2 ? (M2.current = x2, m2 == null || m2.observe(x2, { box: "border-box" })) : M2.current && (m2 == null || m2.unobserve(M2.current), M2.current = null);
    },
    [m2]
  ), { items: ve, visibleListHeight: ke } = P(Ve), ie = import_react.default.useCallback(() => {
    var Se;
    const x2 = [];
    for (const z of ((Se = M2.current) == null ? void 0 : Se.children) ?? []) {
      if (z.dataset.index === void 0)
        continue;
      const w2 = Number.parseInt(z.dataset.index), ht = Number.parseFloat(z.dataset.knownSize ?? ""), He = z.getBoundingClientRect().height;
      if (He === ht)
        continue;
      const Ge = x2[x2.length - 1];
      x2.length === 0 || Ge.size !== He || Ge.endIndex !== w2 - 1 ? x2.push({ endIndex: w2, size: He, startIndex: w2 }) : x2[x2.length - 1].endIndex++;
    }
    n.pub(fe, x2);
  }, [n]);
  import_react.default.useLayoutEffect(() => n.sub(eo, ie), [ie, n]);
  const Ht = P(K2), ue = P(Qt), at2 = P(Ct), $o = P(Dt), wo = P(Qn), Oe = P(ze), Lo = P(ko), pt2 = P(De), Ro = P(Ke), Co = P(hn), ft2 = P(Te), Mo = P(Gn);
  return import_react.default.useLayoutEffect(() => {
    ve.length === 0 && n.pub(to);
  }, [ve, n]), import_react.default.useLayoutEffect(() => {
    var x2;
    pt2 > 0 && ft2 === null && I2 !== null && n.pub(V2, (x2 = W.current) == null ? void 0 : x2.scrollHeight);
  }, [n, pt2, ft2, I2]), (0, import_jsx_runtime2.jsxs)(
    f ? Fi : Co ? Bi : Ni,
    {
      ...t,
      observer: m2,
      scrollerRef: W,
      customScrollParentWrapperRef: j2,
      listRef: M2,
      style: e,
      windowScrollWrapperRef: F,
      children: [
        (pt2 === 0 || ft2) && I2 ? (0, import_jsx_runtime2.jsx)(I2, { context: Oe }) : null,
        s && (0, import_jsx_runtime2.jsx)(r, { ref: Ue, style: gt2, children: (0, import_jsx_runtime2.jsx)(s, { context: Oe }) }),
        i && (0, import_jsx_runtime2.jsx)(l, { ref: me, style: gt2, children: (0, import_jsx_runtime2.jsx)(i, { context: Oe }) }),
        pt2 > 0 ? (0, import_jsx_runtime2.jsx)(
          "div",
          {
            ref: oe,
            "data-testid": "virtuoso-list",
            style: {
              boxSizing: "content-box",
              height: Ro,
              paddingBottom: $o,
              overflowAnchor: "none",
              marginTop: at2,
              transition: wo,
              position: "relative",
              transform: `translateY(${Ht + ue}px)`,
              ...Mo ? { minHeight: ke - at2 } : {},
              visibility: ft2 ? "hidden" : "visible"
            },
            children: ve.map((x2) => (0, import_jsx_runtime2.jsx)(
              gi,
              {
                mount: re,
                unmount: Ie,
                item: x2,
                ItemContent: b
              },
              Lo({ index: x2.index, data: x2.data, context: Oe })
            ))
          }
        ) : null,
        a && (0, import_jsx_runtime2.jsx)(p2, { ref: y, style: gt2, children: (0, import_jsx_runtime2.jsx)(a, { context: Oe }) }),
        c && (0, import_jsx_runtime2.jsx)(g2, { ref: Z, style: gt2, children: (0, import_jsx_runtime2.jsx)(c, { context: Oe }) })
      ]
    }
  );
};
var Ni = ({
  customScrollParentWrapperRef: e,
  windowScrollWrapperRef: t,
  observer: n,
  children: o,
  listRef: i,
  scrollerRef: s,
  style: l,
  ...r
}) => {
  const a = I(), c = import_react.default.useContext(Ot), p2 = P(uo), { onScroll: g2, onWheel: b } = dn({
    listRef: i,
    scrollTopCell$: L2,
    scrollToSignal$: Re,
    scrollableRef: s
  }), I2 = import_react.default.useCallback(
    (y) => {
      y ? (a.pub(Le, y), s.current = y, y.addEventListener("scroll", g2), y.addEventListener("wheel", b), c && a.pubIn({
        [U2]: c.viewportHeight,
        [V2]: c.viewportHeight,
        [L2]: 0
      }), n == null || n.observe(y, { box: "border-box" })) : s.current && (s.current.removeEventListener("scroll", g2), s.current.removeEventListener("wheel", b), a.pub(Le, null), n == null || n.unobserve(s.current), s.current = null);
    },
    [n, a, g2, b, c, s]
  );
  gn(() => {
    var y;
    return (y = s.current) == null ? void 0 : y.scrollHeight;
  });
  const f = P(J), m2 = P(ze);
  return (0, import_jsx_runtime2.jsx)(
    p2,
    {
      ...r,
      ref: I2,
      "data-testid": "virtuoso-scroller",
      style: {
        overflowY: f ? "hidden" : "scroll",
        boxSizing: "border-box",
        ...l
      },
      ...p2 === "div" ? {} : { context: m2 },
      children: o
    }
  );
};
var Bi = ({
  observer: e,
  children: t,
  windowScrollWrapperRef: n,
  customScrollParentWrapperRef: o,
  listRef: i,
  ...s
}) => {
  const l = import_react.default.useRef(null), r = I(), a = import_react.default.useContext(Ot), { onScroll: c, onWheel: p2 } = dn({
    listRef: i,
    scrollTopCell$: ge,
    scrollToSignal$: pn,
    scrollableRef: l
  }), g2 = import_react.default.useCallback(() => {
    var f;
    const I2 = l.current;
    I2 !== null && r.pub(je, (f = I2.ownerDocument.defaultView) == null ? void 0 : f.innerHeight);
  }, [r]), b = import_react.default.useCallback(
    (I2) => {
      if (I2) {
        r.pub(Le, I2), n.current = I2;
        const f = I2.ownerDocument.defaultView;
        f && (f.addEventListener("scroll", c), f.addEventListener("wheel", p2), f.addEventListener("resize", g2), a && r.pubIn({
          [je]: f == null ? void 0 : f.innerHeight,
          [V2]: I2.getBoundingClientRect().height,
          [ge]: 0
        }), l.current = I2.ownerDocument.documentElement), e == null || e.observe(I2, { box: "border-box" });
      } else {
        if (n.current) {
          const f = n.current.ownerDocument.defaultView;
          f && (f.removeEventListener("scroll", c), f.removeEventListener("wheel", p2), f.removeEventListener("resize", g2)), r.pub(Le, null), e == null || e.unobserve(n.current), n.current = null;
        }
        l.current = null;
      }
    },
    [e, r, c, p2, g2, a, n]
  );
  return gn(() => {
    var I2;
    return (I2 = n.current) == null ? void 0 : I2.getBoundingClientRect().height;
  }), (0, import_jsx_runtime2.jsx)("div", { ref: b, ...s, children: t });
};
var Fi = ({
  scrollerRef: e,
  windowScrollWrapperRef: t,
  children: n,
  listRef: o,
  customScrollParentWrapperRef: i,
  observer: s,
  ...l
}) => {
  const r = I(), a = import_react.default.useContext(Ot), c = P(tt), p2 = import_react.default.useRef(c);
  (0, import_react.useEffect)(() => {
    p2.current = c;
  }, [c]);
  const { onWheel: g2, onScroll: b } = dn({
    listRef: o,
    scrollTopCell$: ge,
    scrollToSignal$: pn,
    scrollableRef: p2
  }), I2 = import_react.default.useCallback(
    (f) => {
      if (f) {
        const m2 = p2.current;
        r.pub(Le, m2), i.current = f, m2 && (m2.addEventListener("scroll", b), m2.addEventListener("wheel", g2), a && r.pubIn({
          [je]: m2.clientHeight,
          [V2]: f.getBoundingClientRect().height,
          [ge]: 0
        }), s == null || s.observe(m2, { box: "border-box" })), s == null || s.observe(f, { box: "border-box" });
      } else {
        const m2 = p2.current;
        m2 && (m2.removeEventListener("scroll", b), m2.removeEventListener("wheel", g2), r.pub(Le, null), s == null || s.unobserve(m2)), i.current && (s == null || s.unobserve(i.current)), i.current = null;
      }
    },
    [s, r, b, g2, a, i]
  );
  return gn(() => {
    var f;
    return (f = i.current) == null ? void 0 : f.getBoundingClientRect().height;
  }), (0, import_jsx_runtime2.jsx)("div", { ref: I2, ...l, children: n });
};
function dn({ scrollToSignal$: e, scrollableRef: t, listRef: n, scrollTopCell$: o }) {
  const i = I(), s = import_react.default.useRef(null), l = bi(t, n, s), r = import_react.default.useCallback(
    (p2) => {
      t.current && (t.current.scrollTop += p2);
    },
    [t]
  ), a = import_react.default.useCallback(() => {
    const p2 = t.current;
    if (p2 !== null && (i.pub(o, p2.scrollTop), s.current !== null)) {
      const g2 = p2.scrollHeight - p2.clientHeight;
      Fn(p2.scrollTop, Math.min(g2, s.current)) && (s.current = null, i.pub(cn, false), i.pub(st, p2.scrollTop));
    }
  }, [i, t, o]), c = import_react.default.useCallback(
    (p2) => {
      i.pub(fn, p2.deltaY > 0 ? "down" : "up");
    },
    [i]
  );
  return import_react.default.useLayoutEffect(() => i.sub(e, l), [l, i, e]), import_react.default.useLayoutEffect(() => i.sub(q, r), [r, i]), {
    onScroll: a,
    onWheel: c
  };
}
function gn(e) {
  const t = U(V2);
  (0, import_react.useLayoutEffect)(() => {
    if (!_n())
      return;
    const n = setInterval(() => {
      t(e() ?? 0);
    }, 1e3);
    return () => {
      clearInterval(n);
    };
  }, [t, e]);
}
export {
  qi as ScrollModifierOption,
  Oi as VirtuosoMessageList,
  Ui as VirtuosoMessageListLicense,
  Ot as VirtuosoMessageListTestingContext,
  ji as useCurrentlyRenderedData,
  Yi as useVirtuosoLocation,
  Ki as useVirtuosoMethods
};
//# sourceMappingURL=@virtuoso__dev_message-list.js.map
