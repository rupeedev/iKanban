import {
  require_jsx_runtime
} from "./chunk-6MKRZZUI.js";
import {
  require_react
} from "./chunk-V6PNIP46.js";
import {
  __toESM
} from "./chunk-OL46QLBJ.js";

// ../node_modules/.pnpm/@virtuoso.dev+gurx@1.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@virtuoso.dev/gurx/dist/index.js
var h = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var T = Object.defineProperty;
var L = (s, t, e) => t in s ? T(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var g = (s, t, e) => L(s, typeof t != "symbol" ? t + "" : t, e);
var x = class _x {
  constructor(t = /* @__PURE__ */ new Map()) {
    this.map = t;
  }
  clone() {
    return new _x(new Map(this.map));
  }
  decrement(t, e) {
    let n = this.map.get(t);
    n !== void 0 && (n -= 1, this.map.set(t, n), n === 0 && e());
  }
  increment(t) {
    const e = this.map.get(t) ?? 0;
    this.map.set(t, e + 1);
  }
};
var M = class {
  constructor() {
    g(this, "map", /* @__PURE__ */ new Map());
  }
  delete(t) {
    return this.map.delete(t);
  }
  get(t) {
    return this.map.get(t);
  }
  getOrCreate(t) {
    let e = this.map.get(t);
    return e === void 0 && (e = /* @__PURE__ */ new Set(), this.map.set(t, e)), e;
  }
  use(t, e) {
    const n = this.get(t);
    n !== void 0 && e(n);
  }
};
function m(s, t) {
  return t(s), s;
}
function E() {
}
var V = "cell";
var j = "signal";
function R(s, t) {
  return s === t;
}
var w = /* @__PURE__ */ new Map();
var I;
var K = class {
  /**
   * Creates a new realm.
   * @param initialValues - the initial cell values that will populate the realm.
   * Those values will not trigger a recomputation cycle, and will overwrite the initial values specified for each cell.
   */
  constructor(t = {}) {
    g(this, "definitionRegistry", /* @__PURE__ */ new Set());
    g(this, "distinctNodes", /* @__PURE__ */ new Map());
    g(this, "executionMaps", /* @__PURE__ */ new Map());
    g(this, "graph", new M());
    g(this, "pipeMap", /* @__PURE__ */ new Map());
    g(this, "singletonSubscriptions", /* @__PURE__ */ new Map());
    g(this, "state", /* @__PURE__ */ new Map());
    g(this, "subscriptions", new M());
    for (const e of Object.getOwnPropertySymbols(t))
      this.state.set(e, t[e]);
  }
  /**
   * Creates or resolves an existing cell instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the cell.
   * @param value - the initial value of the cell
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a cell. If the cell has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  cellInstance(t, e = true, n = Symbol()) {
    return this.state.has(n) || this.state.set(n, t), e !== false && !this.distinctNodes.has(n) && this.distinctNodes.set(n, e === true ? R : e), n;
  }
  /**
   * Convenient for mutation of cells that contian non-primitive values (e.g. arrays, or objects).
   * Specifies that the cell value should be changed when source emits, with the result of the map callback parameter.
   * the map parameter gets called with the current value of the cell and the value published through the source.
   * @typeParam T - the type of the cell value.
   * @typeParam K - the type of the value published through the source.
   * @example
   * ```ts
   * const items$ = Cell<string[]([])
   * const addItem$ = Signal<string>(false, (r) => {
   *   r.changeWith(items$, addItem$, (items, item) => [...items, item])
   * })
   * const r = new Realm()
   * r.pub(addItem$, 'foo')
   * r.pub(addItem$, 'bar')
   * r.getValue(items$) // ['foo', 'bar']
   * ```
   */
  changeWith(t, e, n) {
    this.connect({
      map: (i) => (r, u) => {
        i(n(u, r));
      },
      pulls: [t],
      sink: t,
      sources: [e]
    });
  }
  // prettier-ignore
  combine(...t) {
    return m(this.signalInstance(), (e) => {
      this.connect({
        map: (n) => (...i) => {
          n(i);
        },
        sink: e,
        sources: t
      });
    });
  }
  // prettier-ignore
  combineCells(...t) {
    return m(
      this.cellInstance(
        t.map((e) => this.getValue(e)),
        true
      ),
      (e) => {
        this.connect({
          map: (n) => (...i) => {
            n(i);
          },
          sink: e,
          sources: t
        });
      }
    );
  }
  /**
   * A low-level utility that connects multiple nodes to a sink node with a map function. Used as a foundation for the higher-level operators.
   * The nodes can be active (sources) or passive (pulls).
   */
  connect({
    map: t,
    pulls: e = [],
    sink: n,
    sources: i
  }) {
    const r = {
      map: t,
      pulls: new Set(e),
      sink: this.register(n),
      sources: new Set(i)
    };
    for (const u of [...i, ...e])
      this.register(u), this.graph.getOrCreate(u).add(r);
    this.executionMaps.clear();
  }
  /**
   * Gets the current value of a node. The node must be stateful.
   * @remark if possible, use {@link withLatestFrom} or {@link combine}, as getValue will not create a dependency to the passed node,
   * which means that if you call it within a computational cycle, you may not get the correct value.
   * @param node - the node instance.
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   *
   * const r = new Realm()
   * r.getValue(foo$) // 'foo'
   * r.pub(foo$, 'bar')
   * //...
   * r.getValue(foo$) // 'bar'
   * ```
   */
  getValue(t) {
    return this.register(t), this.state.get(t);
  }
  getValues(t) {
    return t.map((e) => this.getValue(e));
  }
  inContext(t) {
    const e = I;
    I = this;
    const n = t();
    return I = e, n;
  }
  /**
   * Links the output of a node to the input of another node.
   */
  link(t, e) {
    this.connect({
      map: (n) => (i) => {
        n(i);
      },
      sink: e,
      sources: [t]
    });
  }
  pipe(t, ...e) {
    return this.combineOperators(...e)(t);
  }
  pub(t, e) {
    this.pubIn({ [t]: e });
  }
  /**
   * Publishes into multiple nodes simultaneously, triggering a single re-computation cycle.
   * @param values - a record of node references and their values.
   *
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   * const bar$ = Cell('bar')
   *
   * const r = new Realm()
   * r.pubIn({[foo$]: 'foo1', [bar$]: 'bar1'})
   * ```
   */
  pubIn(t) {
    var d;
    const e = Reflect.ownKeys(t).map((a) => this.pipeMap.get(a) ?? a), n = Reflect.ownKeys(t).reduce((a, o) => {
      const p = o, S2 = t[p], f = this.pipeMap.get(p) ?? p;
      return a[f] = S2, a;
    }, {}), i = this.getExecutionMap(e), r = i.refCount.clone(), u = i.participatingNodes.slice(), c = new Map(this.state), l = (a) => {
      this.graph.use(a, (o) => {
        for (const { sink: p, sources: S2 } of o)
          S2.has(a) && r.decrement(p, () => {
            u.splice(u.indexOf(p), 1), l(p);
          });
      });
    };
    for (; ; ) {
      const a = u.shift();
      if (a === void 0)
        break;
      const o = a;
      let p = false;
      const S2 = (f) => {
        const b = this.distinctNodes.get(o);
        if (b != null && b(c.get(o), f)) {
          p = false;
          return;
        }
        p = true, c.set(o, f), this.state.has(o) && this.state.set(o, f);
      };
      if (Object.hasOwn(n, o) ? S2(n[o]) : i.projections.use(o, (f) => {
        for (const b of f) {
          const k = [...Array.from(b.sources), ...Array.from(b.pulls)].map((v) => c.get(v));
          b.map(S2)(...k);
        }
      }), p) {
        const f = c.get(o);
        this.inContext(() => {
          this.subscriptions.use(o, (b) => {
            for (const k of b)
              k(f);
          });
        }), (d = this.singletonSubscriptions.get(o)) == null || d(f);
      } else
        l(o);
    }
  }
  /**
   * Explicitly includes the specified cell/signal/pipe reference in the realm.
   * Most of the time you don't need to do that, since any interaction with the node through a realm will register it.
   * The only exception of that rule should be when the interaction is conditional, and the node definition includes an init function that needs to be eagerly evaluated.
   */
  register(t) {
    const e = w.get(t);
    if (e === void 0)
      return t;
    if (!this.definitionRegistry.has(t)) {
      if (this.definitionRegistry.add(t), e.type === V)
        return m(this.cellInstance(e.initial, e.distinct, t), (u) => {
          this.inContext(() => {
            e.init(this, u);
          });
        });
      if (e.type === j)
        return m(this.signalInstance(e.distinct, t), (u) => {
          this.inContext(() => {
            e.init(this, u);
          });
        });
      const n = this.signalInstance(e.distinct), i = this.cellInstance(e.initial, true), r = this.cellInstance(e.initial, e.distinct, t);
      return this.link(i, r), this.pipeMap.set(r, n), this.inContext(() => {
        e.init(this, n, i);
      }), r;
    }
    return t;
  }
  /**
   * Clears all exclusive subscriptions.
   */
  resetSingletonSubs() {
    this.singletonSubscriptions.clear();
  }
  /**
   * Creates or resolves an existing signal instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the signal.
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a signal. If the signal has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  signalInstance(t = true, e = Symbol()) {
    return t !== false && this.distinctNodes.set(e, t === true ? R : t), e;
  }
  /**
   * Subscribes exclusively to values in the referred node.
   * Calling this multiple times on a single node will remove the previous subscription created through `singletonSub`.
   * Subscriptions created through `sub` are not affected.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * // console.log will run only once.
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.pub(signal$, 2)
   * ```
   */
  singletonSub(t, e) {
    return this.register(t), e === void 0 ? this.singletonSubscriptions.delete(t) : this.singletonSubscriptions.set(t, e), () => this.singletonSubscriptions.delete(t);
  }
  /**
   * Subscribes to the values published in the referred node.
   * @param node - the cell/signal to subscribe to.
   * @param subscription - the callback to execute when the node receives a new value.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * const unsub = r.sub(signal$, console.log)
   * r.pub(signal$, 2)
   * unsub()
   * r.pub(signal$, 3)
   * ```
   */
  sub(t, e) {
    this.register(t);
    const n = this.subscriptions.getOrCreate(t);
    return n.add(e), () => n.delete(e);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  subMultiple(t, e) {
    const n = this.signalInstance();
    return this.connect({
      map: (i) => (...r) => {
        i(r);
      },
      sink: n,
      sources: t
    }), this.sub(n, e);
  }
  transformer(...t) {
    return (e) => m(this.signalInstance(), (n) => (this.link(this.pipe(n, ...t), e), n));
  }
  calculateExecutionMap(t) {
    const e = [], n = /* @__PURE__ */ new Set(), i = new M(), r = new x(), u = new M(), c = (l, d = 0) => {
      r.increment(l), !n.has(l) && (this.register(l), i.use(l, (a) => {
        d = Math.max(...Array.from(a).map((o) => e.indexOf(o))) + 1;
      }), this.graph.use(l, (a) => {
        for (const o of a)
          o.sources.has(l) ? (u.getOrCreate(o.sink).add(o), c(o.sink, d)) : i.getOrCreate(o.sink).add(l);
      }), n.add(l), e.splice(d, 0, l));
    };
    return t.forEach(c), { participatingNodes: e, pendingPulls: i, projections: u, refCount: r };
  }
  combineOperators(...t) {
    return (e) => {
      for (const n of t)
        e = n(e, this);
      return e;
    };
  }
  getExecutionMap(t) {
    let e = t;
    if (t.length === 1) {
      e = t[0];
      const i = this.executionMaps.get(e);
      if (i !== void 0)
        return i;
    } else
      for (const [i, r] of this.executionMaps.entries())
        if (Array.isArray(i) && i.length === t.length && i.every((u) => t.includes(u)))
          return r;
    const n = this.calculateExecutionMap(t);
    return this.executionMaps.set(e, n), n;
  }
};
function G(s, t = E, e = true) {
  return m(Symbol(), (n) => {
    w.set(n, { distinct: e, init: t, initial: s, type: V });
  });
}
function B(s = E, t = false) {
  return m(Symbol(), (e) => {
    w.set(e, { distinct: t, init: s, type: "signal" });
  });
}
function H(s = E) {
  return m(Symbol(), (t) => {
    w.set(t, { distinct: false, init: s, type: "signal" });
  });
}
var O = h.createContext(null);
var _ = typeof document < "u" ? h.useLayoutEffect : h.useEffect;
function C() {
  const s = h.useContext(O);
  if (s === null)
    throw new Error("useRealm must be used within a RealmContextProvider");
  return s;
}
function Q(s) {
  const t = C();
  t.register(s);
  const e = h.useCallback((n) => t.sub(s, n), [t, s]);
  return h.useSyncExternalStore(
    e,
    () => t.getValue(s),
    () => t.getValue(s)
  );
}
function D(s) {
  const t = C();
  t.register(s);
  const [e, n] = h.useState(() => t.getValue(s));
  return _(() => {
    const i = t.sub(s, () => {
      n(() => t.getValue(s));
    });
    return () => {
      i();
    };
  }, [t, s]), e;
}
var P = "useSyncExternalStore" in h ? Q : D;
function ut(...s) {
  const t = C();
  return P(t.combineCells.apply(t, s));
}
function U(s) {
  const t = C();
  return t.register(s), h.useCallback(
    (e) => {
      t.pub(s, e);
    },
    [t, s]
  );
}
function ct(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (r) => {
        i(s(r));
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function at(...s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (...r) => {
        i(r);
      },
      pulls: s,
      sink: n,
      sources: [t]
    }), n;
  };
}
function lt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => () => {
        i(s);
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function pt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (r) => {
        s(r) && i(r);
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function ft(s, t) {
  return (e, n) => {
    const i = n.signalInstance();
    return n.connect({
      map: (r) => (u) => {
        r(t = s(t, u));
      },
      sink: i,
      sources: [e]
    }), i;
  };
}
function gt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    let i, r = null;
    return e.sub(t, (u) => {
      i = u, r === null && (r = setTimeout(() => {
        r = null, e.pub(n, i);
      }, s));
    }), n;
  };
}
function mt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    let i, r = null;
    return e.sub(t, (u) => {
      i = u, r !== null && clearTimeout(r), r = setTimeout(() => {
        e.pub(n, i);
      }, s);
    }), n;
  };
}
function bt() {
  return (s, t) => {
    const e = t.signalInstance();
    return t.sub(s, (n) => {
      queueMicrotask(() => {
        t.pub(e, n);
      });
    }), e;
  };
}
function yt(s) {
  return (t, e) => {
    const n = e.signalInstance(), i = Symbol();
    let r = i;
    return e.connect({
      map: (u) => (c) => {
        r !== i && (u([r, c]), r = i);
      },
      sink: n,
      sources: [s]
    }), e.sub(t, (u) => {
      r = u;
    }), n;
  };
}

// ../node_modules/.pnpm/@virtuoso.dev+message-list@1.13.3_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@virtuoso.dev/message-list/dist/index.js
var import_react = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function Le(e, t) {
  const n = G(e, (o) => {
    o.link(t(o), n);
  });
  return n;
}
var Be = { lvl: 0 };
function yn(e, t, n, o = Be, i = Be) {
  return { k: e, l: o, lvl: n, r: i, v: t };
}
function T2(e) {
  return e === Be;
}
function Re() {
  return Be;
}
function zt(e, t) {
  if (T2(e)) return Be;
  const { k: n, l: o, r: i } = e;
  if (t === n) {
    if (T2(o))
      return i;
    if (T2(i))
      return o;
    const [s, l] = $n(o);
    return mt2(V2(e, { k: s, l: wn(o), v: l }));
  }
  return t < n ? mt2(V2(e, { l: zt(o, t) })) : mt2(V2(e, { r: zt(i, t) }));
}
function he(e, t, n = "k") {
  if (T2(e))
    return [Number.NEGATIVE_INFINITY, void 0];
  if (e[n] === t)
    return [e.k, e.v];
  if (e[n] < t) {
    const o = he(e.r, t, n);
    return o[0] === Number.NEGATIVE_INFINITY ? [e.k, e.v] : o;
  }
  return he(e.l, t, n);
}
function H2(e, t, n) {
  return T2(e) ? yn(t, n, 1) : t === e.k ? V2(e, { k: t, v: n }) : t < e.k ? bn(V2(e, { l: H2(e.l, t, n) })) : bn(V2(e, { r: H2(e.r, t, n) }));
}
function Yt(e, t, n) {
  if (T2(e))
    return [];
  const { k: o, v: i, l: s, r: l } = e;
  let r = [];
  return o > t && (r = r.concat(Yt(s, t, n))), o >= t && o <= n && r.push({ k: o, v: i }), o <= n && (r = r.concat(Yt(l, t, n))), r;
}
function Ao(e, t, n, o) {
  if (T2(e))
    return Be;
  let i = Re();
  for (const { k: s, v: l } of de(e))
    s > t && s <= n ? i = H2(i, ...o(s, l)) : i = H2(i, s, l);
  return i;
}
function Oo(e, t, n) {
  let o = Re(), i = -1;
  for (const { start: s, end: l, value: r } of Do(e))
    s < t ? (o = H2(o, s, r), i = r) : s > t + n ? o = H2(o, s - n, r) : l >= t + n && i !== r && (o = H2(o, t, r));
  return o;
}
function de(e) {
  return T2(e) ? [] : [...de(e.l), { k: e.k, v: e.v }, ...de(e.r)];
}
function $n(e) {
  return T2(e.r) ? [e.k, e.v] : $n(e.r);
}
function wn(e) {
  return T2(e.r) ? e.l : mt2(V2(e, { r: wn(e.r) }));
}
function V2(e, t) {
  return yn(t.k ?? e.k, t.v ?? e.v, t.lvl ?? e.lvl, t.l ?? e.l, t.r ?? e.r);
}
function Ht(e) {
  return T2(e) || e.lvl > e.r.lvl;
}
function bn(e) {
  return jt(Mn(e));
}
function mt2(e) {
  const { l: t, r: n, lvl: o } = e;
  if (n.lvl >= o - 1 && t.lvl >= o - 1)
    return e;
  if (o > n.lvl + 1) {
    if (Ht(t))
      return Mn(V2(e, { lvl: o - 1 }));
    if (!T2(t) && !T2(t.r))
      return V2(t.r, {
        l: V2(t, { r: t.r.l }),
        lvl: o,
        r: V2(e, {
          l: t.r.r,
          lvl: o - 1
        })
      });
    throw new Error("Unexpected empty nodes");
  }
  if (Ht(e))
    return jt(V2(e, { lvl: o - 1 }));
  if (!T2(n) && !T2(n.l)) {
    const i = n.l, s = Ht(i) ? n.lvl - 1 : n.lvl;
    return V2(i, {
      l: V2(e, {
        lvl: o - 1,
        r: i.l
      }),
      lvl: i.lvl + 1,
      r: jt(V2(n, { l: i.r, lvl: s }))
    });
  }
  throw new Error("Unexpected empty nodes");
}
function Do(e) {
  return Cn(de(e));
}
function Ln(e, t, n) {
  if (T2(e))
    return [];
  const o = he(e, t)[0];
  return Cn(Yt(e, o, n));
}
function Rn(e, t) {
  const n = e.length;
  if (n === 0)
    return [];
  let { index: o, value: i } = t(e[0]);
  const s = [];
  for (let l = 1; l < n; l++) {
    const { index: r, value: a } = t(e[l]);
    s.push({ end: r - 1, start: o, value: i }), o = r, i = a;
  }
  return s.push({ end: Number.POSITIVE_INFINITY, start: o, value: i }), s;
}
function Cn(e) {
  return Rn(e, ({ k: t, v: n }) => ({ index: t, value: n }));
}
function jt(e) {
  const { r: t, lvl: n } = e;
  return !T2(t) && !T2(t.r) && t.lvl === n && t.r.lvl === n ? V2(t, { l: V2(e, { r: t.l }), lvl: n + 1 }) : e;
}
function Mn(e) {
  const { l: t } = e;
  return !T2(t) && t.lvl === e.lvl ? V2(t, { r: V2(e, { l: t.r }) }) : e;
}
function yt2(e, t, n, o = 0) {
  let i = e.length - 1;
  for (; o <= i; ) {
    const s = Math.floor((o + i) / 2), l = e[s], r = n(l, t);
    if (r === 0)
      return s;
    if (r === -1) {
      if (i - o < 2)
        return s - 1;
      i = s - 1;
    } else {
      if (i === o)
        return s;
      o = s + 1;
    }
  }
  throw new Error(`Failed binary finding record in array - ${e.join(",")}, searched for ${t}`);
}
function Vn(e, t, n) {
  return e[yt2(e, t, n)];
}
function No(e, t, n, o) {
  const i = yt2(e, t, o), s = yt2(e, n, o, i);
  return e.slice(i, s + 1);
}
function sn({ index: e }, t) {
  return t === e ? 0 : t < e ? -1 : 1;
}
function Bo({ offset: e }, t) {
  return t === e ? 0 : t < e ? -1 : 1;
}
function _o(e) {
  return { index: e.index, value: e };
}
function Fo(e, t, n, o = 0) {
  return o > 0 && (t = Math.max(t, Vn(e, o, sn).offset)), t = Math.max(0, t), Rn(No(e, t, n, Bo), _o);
}
var _e = [[], 0, 0, 0];
function Ho(e, [t, n]) {
  let o = 0, i = 0, s = 0, l = 0;
  if (n !== 0) {
    l = yt2(e, n - 1, sn), s = e[l].offset;
    const a = he(t, n - 1);
    o = a[0], i = a[1], e.length && e[l].height === he(t, n)[1] && (l -= 1), e = e.slice(0, l + 1);
  } else
    e = [];
  for (const { start: r, value: a } of Ln(t, n, Number.POSITIVE_INFINITY)) {
    const u = (r - o) * i + s;
    e.push({ height: a, index: r, offset: u }), o = r, s = u, i = a;
  }
  return [e, i, s, o];
}
function Po(e) {
  const { size: t, startIndex: n, endIndex: o } = e;
  return (i) => i.start === n && (i.end === o || i.end === Number.POSITIVE_INFINITY) && i.value === t;
}
function Wo(e, t) {
  let n = T2(e) ? 0 : Number.POSITIVE_INFINITY;
  for (const o of t) {
    const { size: i, startIndex: s, endIndex: l } = o;
    if (n = Math.min(n, s), T2(e)) {
      e = H2(e, 0, i);
      continue;
    }
    const r = Ln(e, s - 1, l + 1);
    if (r.some(Po(o)))
      continue;
    let a = false, u = false;
    for (const { start: p, end: d, value: I2 } of r)
      a ? (l >= p || i === I2) && (e = zt(e, p)) : (u = I2 !== i, a = true), d > l && l >= p && I2 !== i && (e = H2(e, l + 1, I2));
    u && (e = H2(e, s, i));
  }
  return [e, n];
}
var tt = [Re(), 0];
function zo(e, [t, n]) {
  if (n.length > 0 && T2(e) && t.length === 2) {
    const o = t[0].size, i = t[1].size;
    return [
      n.reduce((s, l) => H2(H2(s, l, o), l + 1, i), Re()),
      0
    ];
  }
  return Wo(e, t);
}
var fe = B();
G([]);
G([]);
G(0);
G(null);
G(Number.NaN);
var Te = G(false);
var J = G(tt, (e) => {
  e.link(
    e.pipe(
      fe,
      pt((t) => t.length > 0),
      at(Q2),
      ct(([t, n]) => zo(n, [t, []]))
    ),
    J
  );
});
var Q2 = G(tt[0], (e) => {
  e.link(
    e.pipe(
      J,
      ct(([t]) => t)
    ),
    Q2
  );
});
var An = G(tt[1], (e) => {
  e.link(
    e.pipe(
      J,
      ct(([, t]) => t)
    ),
    An
  );
});
var Ee = G(_e[1]);
var ge = G(_e[0]);
var qe = G(_e, (e) => {
  e.link(
    e.pipe(
      Q2,
      at(An),
      ft(([t], [n, o]) => Ho(t, [n, o]), _e)
    ),
    qe
  ), e.link(
    e.pipe(
      qe,
      ct(([, t]) => t)
    ),
    Ee
  ), e.link(
    e.pipe(
      qe,
      ct(([t]) => t)
    ),
    ge
  );
});
var On = G(_e[2], (e) => {
  e.link(
    e.pipe(
      qe,
      ct(([, , t]) => t)
    ),
    On
  );
});
var Dn = G(_e[3], (e) => {
  e.link(
    e.pipe(
      qe,
      ct(([, , , t]) => t)
    ),
    Dn
  );
});
var We = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(Ce, Dn, On, Ee),
      ct(([t, n, o, i]) => o + (t - n) * i)
    ),
    We
  );
});
function Nn(e, t) {
  if (t.length === 0)
    return [0, 0];
  const { offset: n, index: o, height: i } = Vn(t, e, sn);
  return [i * (e - o) + n, i];
}
function Je(e, t) {
  return Nn(e, t)[0];
}
function Bn(e, t) {
  return Math.abs(e - t) < 1.01;
}
function _n() {
  return typeof navigator > "u" ? false : /Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 1 || /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);
}
function Yo(e) {
  return !e;
}
function jo(e) {
  return e === 1 ? 1 : 1 - 2 ** (-10 * e);
}
function Ct(e = 1) {
  return (t, n) => {
    const o = n.signalInstance();
    return n.sub(t, (i) => {
      let s = e;
      function l() {
        s > 0 ? (s--, requestAnimationFrame(l)) : n.pub(o, i);
      }
      l();
    }), o;
  };
}
var Kt = "up";
var Pt = "down";
var Ko = "none";
var qo = {
  atBottom: false,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollTop: 0,
    viewportHeight: 0,
    viewportWidth: 0,
    scrollHeight: 0
  }
};
var Uo = 0;
var Go = 4;
function In(e) {
  return (t, n) => {
    const o = n.signalInstance();
    return n.sub(t, (i) => {
      e > 0 ? e-- : n.pub(o, i);
    }), o;
  };
}
G(false);
var Fn = G(true);
B();
var Se = G(false);
var Zo = B((e) => {
  e.link(e.pipe(Fn, gt(50)), Zo);
});
var Hn = G(Go);
var Jo = G(Uo, (e) => {
  e.link(
    e.pipe(
      e.combine(w2, Jo),
      ct(([t, n]) => t <= n)
    ),
    Fn
  );
});
var Xe = G(false, (e) => {
  e.link(e.pipe(w2, In(1), lt(true)), Xe), e.link(e.pipe(w2, In(1), lt(false), mt(100)), Xe);
});
var qt = G(false, (e) => {
  e.link(e.pipe(X, lt(true)), qt), e.link(e.pipe(X, lt(false), mt(200)), qt);
});
var ln = G(false);
var bt2 = G(
  null,
  (e) => {
    e.link(
      e.pipe(
        e.combine(
          D2,
          w2,
          K2,
          xt,
          Hn,
          Rt,
          Vt,
          Q2
        ),
        pt(([, , , , , , , t]) => !T2(t)),
        ft((t, [n, o, i, s, l, r]) => {
          const u = o + i - n + r > -l, p = {
            viewportWidth: s,
            viewportHeight: i,
            scrollTop: o,
            scrollHeight: n,
            listMarginTop: r
          };
          if (u) {
            let I2, b;
            return o > t.state.scrollTop ? (I2 = "SCROLLED_DOWN", b = t.state.scrollTop - o) : (I2 = n === i ? "LIST_TOO_SHORT" : "SIZE_DECREASED", b = t.state.scrollTop - o || t.scrollTopDelta), {
              atBottom: true,
              state: p,
              atBottomBecause: I2,
              scrollTopDelta: b
            };
          }
          let d;
          return i < t.state.viewportHeight ? d = "VIEWPORT_HEIGHT_DECREASING" : s < t.state.viewportWidth ? d = "VIEWPORT_WIDTH_DECREASING" : o < t.state.scrollTop ? d = "SCROLLING_UPWARDS" : p.scrollHeight > t.state.scrollHeight || p.listMarginTop < t.state.listMarginTop ? t.atBottom ? d = "SIZE_INCREASED" : d = t.notAtBottomBecause : t.atBottom ? d = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM" : d = t.notAtBottomBecause, {
            atBottom: false,
            notAtBottomBecause: d,
            state: p
          };
        }, qo)
      ),
      bt2
    ), e.link(
      e.pipe(
        bt2,
        ft(
          ({ prev: t }, n) => {
            const o = !!(t && n && t.atBottom && !n.atBottom && n.notAtBottomBecause === "SIZE_INCREASED");
            return {
              prev: n,
              shouldScroll: o
            };
          },
          { prev: null, shouldScroll: false }
        ),
        ct(({ shouldScroll: t }) => t)
      ),
      ln
    ), e.sub(
      e.pipe(
        K2,
        at(bt2, fn, Qe),
        pt(([, , t, n]) => !t && !n),
        ft(
          (t, [n, o]) => {
            let i = 0;
            return t.viewportHeight > n && o && !o.atBottom && o.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && (i = t.viewportHeight - n), { viewportHeight: n, delta: i };
          },
          { viewportHeight: 0, delta: 0 }
        )
      ),
      (t) => {
        t.delta && e.pub(X, t.delta);
      }
    );
  },
  (e, t) => !e || e.atBottom !== (t == null ? void 0 : t.atBottom) ? false : !e.atBottom && !t.atBottom ? e.notAtBottomBecause === t.notAtBottomBecause : true
);
var Pn = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(w2, D2, K2),
      ft(
        (t, [n, o, i]) => {
          if (!Bn(t.scrollHeight, o)) {
            const s = o - (n + i) < 1;
            return t.scrollTop !== n && s ? {
              scrollHeight: o,
              scrollTop: n,
              jump: t.scrollTop - n,
              changed: true
            } : {
              scrollHeight: o,
              scrollTop: n,
              jump: 0,
              changed: true
            };
          }
          return {
            scrollTop: n,
            scrollHeight: o,
            jump: 0,
            changed: false
          };
        },
        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }
      ),
      pt((t) => t.changed),
      ct((t) => t.jump)
    ),
    Pn
  );
});
var $t = G(Pt, (e) => {
  e.link(
    e.pipe(
      w2,
      ft(
        (t, n) => {
          if (n < 0)
            return { direction: Kt, prevScrollTop: 0 };
          if (e.getValue(qt))
            return { direction: t.direction, prevScrollTop: n };
          const i = n === t.prevScrollTop && n === 0;
          return {
            direction: n < t.prevScrollTop || i ? Kt : Pt,
            prevScrollTop: n
          };
        },
        { direction: Pt, prevScrollTop: 0 }
      ),
      ct((t) => t.direction)
    ),
    $t
  ), e.link(e.pipe(w2, mt(100), lt(Ko)), $t);
});
var vn = G(0, (e) => {
  e.link(e.pipe(Xe, pt(Yo), lt(0)), vn), e.link(
    e.pipe(
      w2,
      gt(100),
      at(Xe),
      pt(([, t]) => !!t),
      ft(([, t], [n]) => [t, n], [0, 0]),
      ct(([t, n]) => n - t)
    ),
    vn
  );
});
function rn(e, t) {
  if (typeof e == "number")
    return {
      index: e,
      offset: 0,
      behavior: "auto",
      align: "start-no-overflow"
    };
  const n = {
    index: Number.NaN,
    align: e.align ?? "start-no-overflow",
    behavior: e.behavior ?? "auto",
    offset: e.offset ?? 0
  };
  return e.index === "LAST" ? n.index = t : e.index < 0 ? n.index = t + e.index : n.index = e.index, n;
}
function Wn({
  location: e,
  sizeTree: t,
  offsetTree: n,
  totalHeight: o,
  totalCount: i,
  viewportHeight: s,
  headerHeight: l,
  stickyHeaderHeight: r,
  stickyFooterHeight: a
}) {
  const { align: u, behavior: p, offset: d, index: I2 } = rn(e, i - 1);
  function b() {
    const L2 = he(t, I2)[1];
    if (L2 === void 0)
      throw new Error(`Item at index ${I2} not found`);
    return L2;
  }
  s -= r + a;
  let f = Je(I2, n) + l - r;
  u === "end" ? f = f - s + b() : u === "center" && (f = f - s / 2 + b() / 2), d && (f += d);
  let m2 = 0;
  return u === "start" && (m2 = Math.max(0, Math.min(f - (o - s)))), f = Math.max(0, f), { top: f, behavior: p, align: u, forceBottomSpace: m2 };
}
var Ke = G(null);
var Xo = G(false);
var Ue = G(true);
var Ut = B((e) => {
  e.link(
    e.pipe(
      Ut,
      ct(() => true)
    ),
    Ue
  ), e.link(
    e.pipe(
      Ut,
      ct(() => null)
    ),
    Ke
  );
});
var zn = B((e) => {
  e.link(
    e.pipe(
      zn,
      at(Ce, ge, rt),
      ct(([t, n, o, i]) => {
        let { align: s, behavior: l, offset: r, index: a } = rn(t, n - 1);
        const u = typeof t != "number" ? t.done : void 0, [p, d] = Nn(a, o);
        return p < -i.listOffset ? ((typeof t == "number" || t.align === void 0) && (s = "start-no-overflow"), { index: a, align: s, behavior: l, offset: r, done: u }) : p + d > -i.listOffset + i.visibleListHeight ? ((typeof t == "number" || t.align === void 0) && (s = "end"), { index: a, align: s, behavior: l, offset: r, done: u }) : null;
      }),
      pt((t) => t !== null)
    ),
    // @ts-expect-error contra variance
    Z
  );
});
var Z = B((e) => {
  const t = e.pipe(
    Z,
    at(
      Q2,
      ge,
      Ce,
      K2,
      lt2,
      ze,
      st,
      We
    ),
    ct(
      ([n, o, i, s, l, r, a, u, p]) => {
        try {
          return Wn({
            location: n,
            totalHeight: p,
            sizeTree: o,
            offsetTree: i,
            totalCount: s,
            viewportHeight: l,
            headerHeight: r,
            stickyHeaderHeight: a,
            stickyFooterHeight: u
          });
        } catch {
          return null;
        }
      }
    ),
    pt((n) => n !== null)
  );
  e.link(Z, Ke), e.link(t, $e), e.link(
    e.pipe(
      Z,
      pt((n) => typeof n != "number" && n.index === "LAST"),
      lt(true)
    ),
    Se
  ), e.link(e.pipe(t, lt(false)), Ue), e.link(e.pipe(t, lt(false)), Xo), e.link(
    e.pipe(
      Q2,
      // wait for the list to render with the specified sizeTree, so that enough space is available to scroll by
      mt(0),
      at(Ue, Ke),
      pt(([, n, o]) => !n && o !== null),
      ct(([, , n]) => n)
    ),
    Z
  ), e.sub(e.pipe(ot, mt(10)), () => {
    const n = e.getValue(Ke);
    n !== null && typeof n != "number" && n.done !== void 0 && n.done(), e.pubIn({
      [Ke]: null,
      [Ue]: true
    });
  }), e.link(
    e.pipe(
      Tt,
      // wait for the list to render with the specified scrollOffset, so that enough space is available to scroll by
      bt(),
      pt((n) => n !== 0)
    ),
    X
  ), e.link(
    e.pipe(
      Tt,
      yt(w2),
      ct(() => 0)
    ),
    Tt
  );
});
var ke = G(null);
var Fe = G(
  null,
  (e) => {
    e.link(
      e.pipe(
        Fe,
        pt((n) => n !== null)
      ),
      ke
    );
    const t = e.pipe(
      e.combine(Fe, Q2),
      at(ke),
      pt(([[n, o], i]) => n !== null && !T2(o) && i !== null),
      ct(([[n]]) => n)
    );
    e.link(e.pipe(t, bt()), Z), e.link(
      e.pipe(
        t,
        yt(
          e.pipe(
            Ue,
            pt((n) => n)
          )
        ),
        lt(null)
        // unset the location after the scroll completes
      ),
      ke
    );
  },
  false
);
function Qo(e, t) {
  var l, r;
  const n = t.slice();
  let o = 0;
  const i = [];
  for (const { k: a, v: u } of de(e)) {
    for (; n.length && n[0] < a; )
      n.shift(), o++;
    const p = Math.max(0, a - o), d = ((l = i.at(-1)) == null ? void 0 : l.k) ?? -1;
    p === d ? (((r = i.at(-2)) == null ? void 0 : r.v) ?? -1) === u ? i.pop() : i[i.length - 1].v = u : i.push({ k: p, v: u });
  }
  let s = Re();
  for (const { k: a, v: u } of i)
    s = H2(s, a, u);
  return s;
}
var Ce = G(0);
var He = G(null);
var S = G(null, (e) => {
  e.link(
    e.pipe(
      S,
      pt((t) => t !== null),
      ct((t) => t.length)
    ),
    Ce
  );
});
var je = G(null);
var oe = B((e) => {
  e.link(
    e.pipe(
      oe,
      at(Ee),
      ct(([n, o]) => -(o * n.length))
    ),
    Y
  ), e.link(e.pipe(oe, lt(true)), Ge), e.link(e.pipe(oe, bt()), je);
  function t(n, o) {
    e.pubIn({
      [St]: true,
      [X]: n,
      [Et]: n
    }), o ? requestAnimationFrame(() => {
      e.pubIn({
        [Y]: 0,
        [Et]: 0,
        [je]: null,
        [Ge]: false,
        [St]: false
      });
    }) : e.pubIn({
      [Y]: 0,
      [Et]: 0,
      [je]: null,
      [Ge]: false,
      [St]: false
    });
  }
  e.sub(
    e.pipe(
      ge,
      at(je),
      pt(([, n]) => n !== null),
      ct(([n, o]) => {
        if (o === null)
          throw new Error("Unexpected null items");
        return Je(o.length, n);
      })
    ),
    (n) => {
      t(n, false);
    }
  ), e.sub(
    e.pipe(
      oe,
      Ct(2),
      at(ge, je),
      pt(([, , n]) => n !== null),
      ct(([n, o]) => Je(n.length, o))
    ),
    (n) => {
      t(n, true);
    }
  ), e.changeWith(S, oe, (n, o) => n ? [...o, ...n] : o.slice()), e.link(
    e.pipe(
      oe,
      at(Q2, Ee),
      ct(([n, o, i]) => {
        const s = n.length, l = i;
        return de(o).reduce(
          (a, { k: u, v: p }) => ({
            ranges: [...a.ranges, { startIndex: a.prevIndex, endIndex: u + s - 1, size: a.prevSize }],
            prevIndex: u + s,
            prevSize: p
          }),
          {
            ranges: [],
            prevIndex: 0,
            prevSize: l
          }
        ).ranges;
      })
    ),
    fe
  );
});
var nt = B((e) => {
  const t = e.pipe(
    nt,
    at(rt, un, He, Q2),
    pt(([, , , , o]) => !T2(o)),
    ct(([{ data: o, scrollToBottom: i }, s, l, r]) => {
      if (i === false || i === void 0)
        return null;
      let a = "auto";
      const u = s.isAtBottom;
      if (typeof i == "function") {
        const p = i({ data: o, scrollLocation: s, scrollInProgress: l, context: r, atBottom: u });
        if (!p)
          return null;
        if (typeof p == "object")
          return p;
        if (typeof p == "number")
          return { index: p, align: "end", behavior: "auto" };
        a = p;
      } else {
        if (!u)
          return null;
        a = i;
      }
      return a === true && (a = "auto"), { index: "LAST", align: "end", behavior: a };
    })
  );
  e.link(
    e.pipe(
      t,
      pt((o) => o !== null),
      ct(() => true)
    ),
    Se
  ), e.link(
    e.pipe(
      ot,
      at(Se),
      pt(([o, i]) => i),
      ct(() => false)
    ),
    Se
  );
  const n = e.pipe(
    pn,
    at(Se),
    pt(([o, i]) => o === "up" && i)
  );
  e.link(
    e.pipe(
      n,
      ct(() => false)
    ),
    Se
  ), e.link(e.pipe(n, lt(true)), Ut), e.link(
    e.pipe(
      t,
      pt((o) => o !== null),
      mt(20)
    ),
    Z
  );
});
var wt = B((e) => {
  e.changeWith(S, wt, (t, n) => t ? [...t, ...n.data] : n.data.slice()), e.link(wt, nt);
});
var It = B((e) => {
  e.changeWith(S, It, (t, n) => t ? [...t.slice(0, n.offset), ...n.data, ...t.slice(n.offset)] : n.data.slice()), e.changeWith(J, It, ([t], n) => {
    const i = he(t, n.offset, "k")[0], s = n.data.length;
    return [Ao(t, i, Number.POSITIVE_INFINITY, (r, a) => [r + s, a]), i];
  }), e.link(It, nt);
});
var Gt = B((e) => {
  e.changeWith(S, Gt, (t, { offset: n, count: o }) => t ? t.slice(0, n).concat(t.slice(n + o)) : []), e.changeWith(J, Gt, ([t], { offset: n, count: o }) => [Oo(t, n, o), n]);
});
var Wt = G(null);
var Ne = B((e) => {
  e.sub(
    e.pipe(
      Ne,
      at(S),
      pt(([{ purgeItemSizes: t }, n]) => !!t || n === null || n.length === 0)
    ),
    ([t, n]) => {
      n === null || n.length === 0 ? e.pubIn({
        ...t.initialLocation ? { [Fe]: t.initialLocation } : {},
        [S]: t.data.slice()
      }) : e.pubIn({
        ...t.initialLocation ? { [Fe]: t.initialLocation } : {},
        [J]: tt,
        [Me]: De,
        [Wt]: t.data.slice()
      });
    }
  ), e.sub(
    e.pipe(
      Xn,
      at(Wt),
      Ct(),
      pt(([, t]) => t !== null)
    ),
    ([, t]) => {
      e.pubIn({
        [S]: t,
        [Wt]: null
      });
    }
  ), e.link(
    e.pipe(
      Ne,
      pt(({ purgeItemSizes: t }) => !t),
      at(Ee),
      pt(([, t]) => t > 0),
      ct(([{ data: t }, n]) => [
        {
          size: n,
          startIndex: t.length,
          endIndex: Number.POSITIVE_INFINITY
        }
      ])
    ),
    fe
  ), e.sub(
    e.pipe(
      Ne,
      pt(({ purgeItemSizes: t }) => !t)
    ),
    ({ data: t, initialLocation: n, suppressItemMeasure: o }) => {
      requestAnimationFrame(() => {
        o || e.pub(Jn), requestAnimationFrame(() => {
          n && e.pubIn({
            [Z]: n
          });
        });
      }), e.pubIn({
        [S]: t.slice()
      });
    }
  );
});
var vt = B((e) => {
  e.link(
    e.pipe(
      vt,
      at(ge),
      ct(([t, n]) => -Je(t, n))
    ),
    X
  ), e.changeWith(S, e.pipe(vt, bt()), (t, n) => t ? t.slice(n) : []), e.changeWith(J, e.pipe(vt, bt()), ([t], n) => [de(t).reduce((i, { k: s, v: l }) => H2(i, Math.max(0, s - n), l), Re()), 0]);
});
var Sn = B((e) => {
  e.changeWith(S, Sn, (t, n) => t ? t.slice(0, t.length - n) : []), e.link(
    e.pipe(
      Sn,
      at(Ce, Ee),
      ct(([, t, n]) => [
        {
          size: n,
          startIndex: t,
          endIndex: Number.POSITIVE_INFINITY
        }
      ])
    ),
    fe
  );
});
var Yn = B((e) => {
  const t = e.pipe(
    Yn,
    at(S),
    ct(([n, o]) => {
      if (!o) return [];
      const i = [];
      return o.forEach((s, l) => {
        n(s, l) && i.push(l);
      }), i;
    })
  );
  e.changeWith(S, t, (n, o) => n ? n.filter((i, s) => !o.includes(s)) : []), e.changeWith(J, t, ([n], o) => [Qo(n, o), 0]);
});
var Zt = B((e) => {
  e.changeWith(S, Zt, (t, { mapper: n }) => t ? t.map(n) : []), e.link(
    e.pipe(
      Zt,
      Ct(3),
      at(ln),
      pt(([{ autoscrollToBottomBehavior: t }, n]) => n && !!t),
      ct(([{ autoscrollToBottomBehavior: t }]) => typeof t == "object" ? t.location() : { index: "LAST", align: "end", behavior: t }),
      pt((t) => !!t)
    ),
    Z
  );
});
var Jt = B((e) => {
  e.changeWith(S, Jt, (t, { newData: n }) => n), e.link(
    e.pipe(
      Jt,
      Ct(3),
      at(ln),
      pt(([{ autoscrollToBottomBehavior: t }, n]) => n && !!t),
      ct(([{ autoscrollToBottomBehavior: t }]) => typeof t == "object" ? t.location() : { index: "LAST", align: "end", behavior: t }),
      pt((t) => !!t)
    ),
    Z
  );
});
function ei(e, t) {
  return [
    {
      data: t == null ? void 0 : t[e],
      prevData: (t == null ? void 0 : t[e - 1]) ?? null,
      nextData: (t == null ? void 0 : t[e + 1]) ?? null,
      height: 0,
      index: e,
      offset: 0,
      type: "flat"
    }
  ];
}
var ti = [];
var De = {
  items: ti,
  listBottom: 0,
  listTop: 0,
  offsetTree: [],
  paddingBottom: 0,
  paddingTop: 0,
  totalCount: 0,
  totalHeight: 0,
  deviationDelta: 0,
  data: null
};
var St = G(false);
var Me = G(De, (e) => {
  e.link(
    e.pipe(
      e.combine(
        ni,
        Un,
        Q2,
        ge,
        Ce,
        We,
        S,
        Tt,
        Fe,
        ke,
        it,
        ze,
        st,
        Y,
        St,
        Te,
        G2
      ),
      pt((t) => {
        const n = t.at(-1), o = t.at(-2), i = t.at(-3);
        return !o && !n && !i;
      }),
      ft(
        (t, [
          n,
          o,
          i,
          s,
          l,
          r,
          a,
          u,
          p,
          d,
          I2,
          b,
          f,
          m2
        ]) => {
          var ct2;
          if ((a == null ? void 0 : a.length) === 0)
            return De;
          if (T2(i)) {
            let ne = 0;
            return p !== null && (ne = rn(p, l - 1).index), { ...De, items: ei(ne, a), offsetTree: s, totalCount: l, data: a };
          }
          let L2 = 0;
          d !== null && n === 0 && (L2 = Wn({
            totalHeight: r,
            location: d,
            sizeTree: i,
            offsetTree: s,
            totalCount: l,
            viewportHeight: e.getValue(K2),
            headerHeight: e.getValue(lt2),
            stickyHeaderHeight: b,
            stickyFooterHeight: f
          }).top ?? 0);
          let q = 0;
          e.getValue(w2) !== 0 && !e.getValue(Mt) && e.getValue($t) === Kt && t.totalCount === l && t.items.length > 0 && (q = r - t.totalHeight, q !== 0 && (q += e.getValue(Pn)));
          const U2 = e.getValue(Kn), j2 = Math.min(
            Math.max(
              n + L2 + u - m2 - I2 + q - U2,
              0
            ),
            r - o
          ), be = j2 + o + U2 * 2;
          if (t.offsetTree === s && t.totalCount === l && t.data === a && j2 >= t.listTop && be <= t.listBottom)
            return t;
          const ee = [], ut2 = l - 1, se = 0, W = Fo(s, j2, be, se);
          let C2 = 0, O2 = 0, R2 = false;
          for (const ne of W) {
            const {
              value: { offset: Ie, height: le }
            } = ne;
            let re = ne.start;
            C2 = Ie, Ie < j2 && (re += Math.floor((j2 - Ie) / le), C2 += (re - ne.start) * le), re < se && (C2 += (se - re) * le, re = se);
            const Dt = Math.min(ne.end, ut2);
            for (let ue = re; ue <= Dt && !(C2 >= be); ue++) {
              const Nt = {
                data: a == null ? void 0 : a[ue],
                prevData: (a == null ? void 0 : a[ue - 1]) ?? null,
                nextData: (a == null ? void 0 : a[ue + 1]) ?? null,
                height: le,
                index: ue,
                offset: C2,
                type: "flat"
              };
              R2 || (R2 = true, O2 = C2), ee.push(Nt), C2 += le;
            }
          }
          ee.length === 0 && (O2 = C2 = 0);
          const te = r - C2, Ve = ((ct2 = ee[0]) == null ? void 0 : ct2.offset) || 0;
          return { items: ee, listBottom: C2, listTop: O2, offsetTree: s, paddingBottom: te, paddingTop: Ve, totalCount: l, totalHeight: r, data: a, deviationDelta: q };
        },
        De
      )
    ),
    Me
  );
});
var Lt = Le([], (e) => e.pipe(
  e.combine(Me, w2),
  ct(([t, n]) => {
    const o = t.items.slice();
    for (; o.length > 0 && o[0].offset + o[0].height < n; )
      o.shift();
    return o.map((i) => i.data);
  })
));
var G2 = G(false);
var Ge = G(false);
var kt = B((e) => {
  e.link(
    e.pipe(
      Me,
      ct((t) => t.deviationDelta),
      pt((t) => t !== 0)
    ),
    kt
  ), _n() ? (e.sub(e.pipe(kt, at(Y, w2)), ([t, n]) => {
    e.pub(Y, n - t);
  }), e.sub(
    e.pipe(e.combine(w2, Y, Te, Ge)),
    ([t, n, o, i]) => {
      o || i || (n > 0 && t < n ? (e.pub(G2, true), e.pub($e, { top: 0, behavior: "instant" }), setTimeout(() => {
        e.pubIn({
          [G2]: false,
          [Y]: 0
        });
      })) : n < 0 && t <= 0 && (e.pubIn({
        [G2]: true,
        [Y]: 0
      }), setTimeout(() => {
        e.pub($e, { top: 0, behavior: "instant" }), e.pub(G2, false);
      })));
    }
  ), e.sub(
    e.pipe(
      e.combine(Xe, Y, G2, Te, Ge),
      pt(
        ([t, n, o, i, s]) => !t && n !== 0 && !o && !i && !s
      ),
      gt(100)
    ),
    ([, t]) => {
      e.pub(G2, true), t < 0 ? requestAnimationFrame(() => {
        e.pub(X, -t), e.pub(Y, 0), requestAnimationFrame(() => {
          e.pub(G2, false);
        });
      }) : requestAnimationFrame(() => {
        e.pub(X, -t), e.pub(Y, 0), requestAnimationFrame(() => {
          e.pub(G2, false);
        });
      });
    }
  )) : e.link(kt, X);
});
var Mt = B();
var un = G(false);
var ot = B((e) => {
  e.link(e.pipe(ot, lt(false)), Mt);
}, false);
var w2 = G(0);
var K2 = G(0);
var xt = G(0);
var D2 = G(0);
var ni = w2;
var Tt = G(0);
var ze = G(0);
var it = G(0);
var st = G(0);
var cn = G(0);
var ye = G(null);
var jn = H();
var Kn = G(0);
var oi = jo;
var ii = 50;
var lt2 = Le(0, (e) => e.pipe(
  e.combine(ze, it),
  ct(([t, n]) => t + n)
));
var qn = Le(0, (e) => e.pipe(
  e.combine(st, cn),
  ct(([t, n]) => t + n)
));
var si = Le(0, (e) => e.pipe(
  e.combine(ze, it, w2),
  ct(([t, n, o]) => t + Math.max(n - o, 0))
));
var li = Le(0, (e) => e.pipe(
  e.combine(st, cn, w2, K2, D2),
  ct(([t, n, o, i, s]) => {
    o = Math.min(o, s - i);
    const l = Math.max(n - (s - (o + i)), 0);
    return t + l;
  })
));
var Un = Le(0, (e) => e.pipe(
  e.combine(K2, si, li),
  ct(([t, n, o]) => Math.max(0, t - n - o))
));
var Vt = G(0);
var Gn = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(Gn, We, K2, lt2, ze),
      ct(([t, n, o, i, s]) => t === 0 ? 0 : Math.max(0, Math.min(t - (n + i + s - o))))
    ),
    Vt
  );
});
var $e = B((e) => {
  e.link(
    e.pipe(
      $e,
      ct((t) => t.align === "start" ? t.top ?? 0 : 0)
    ),
    Gn
  ), e.link(
    e.pipe(
      $e,
      at(w2),
      pt(([t, n]) => t.top !== n),
      lt(true)
    ),
    Mt
  );
});
var an = B((e) => {
  e.link(
    e.pipe(
      $e,
      at(et),
      ct(([t, n]) => ("top" in t && typeof t.top < "u" && (t = { ...t, top: t.top + n }), t))
    ),
    an
  );
});
var rt = Le(
  {
    listOffset: 0,
    visibleListHeight: 0,
    scrollHeight: 0,
    bottomOffset: 0,
    isAtBottom: false
  },
  (e) => e.pipe(
    e.combine(
      w2,
      lt2,
      qn,
      it,
      Un,
      D2,
      Vt,
      Te,
      ke,
      G2,
      Se
    ),
    pt(([, , , , , , , t, n, o]) => !t && n === null && !o),
    ct(
      ([
        t,
        n,
        o,
        i,
        s,
        l,
        r,
        a,
        u,
        p,
        d
      ]) => {
        const I2 = e.getValue(Hn), b = l - n - o, f = -t + i, m2 = b + Math.min(0, f) - s - r;
        return {
          scrollHeight: b,
          listOffset: f,
          visibleListHeight: s,
          bottomOffset: m2,
          isAtBottom: d || m2 <= I2
        };
      }
    )
  )
);
var Xt = B((e) => {
  e.link(
    e.pipe(
      w2,
      mt(0),
      at(rt, ke, Te),
      pt(([, t, n, o]) => t.scrollHeight > 0 && n == null && !o),
      ct(([, t]) => t)
    ),
    Xt
  );
});
var X = B();
var Y = G(0);
var Et = G(0);
var Rt = G(0);
var Zn = G("");
var pn = B();
var Jn = H();
var Xn = H();
var fn = G(false);
var Qe = G(null);
G(0);
var et = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(Pe, me, et),
      ct(([t, n, o]) => t - Math.max(0, o - n))
    ),
    K2
  );
});
var me = G(0, (e) => {
  e.link(
    e.pipe(
      e.combine(me, et),
      ct(([t, n]) => Math.max(0, t - n))
    ),
    w2
  );
});
var Pe = G(0);
function Qn(e) {
  return {
    data: {
      prepend: (t) => {
        e.pub(oe, t);
      },
      append: (t, n) => {
        e.pub(wt, {
          data: t,
          scrollToBottom: n
        });
      },
      replace: (t, n) => {
        e.pub(Ne, {
          ...n,
          data: t
        });
      },
      map: (t, n) => {
        e.pub(Zt, {
          mapper: t,
          autoscrollToBottomBehavior: n
        });
      },
      findAndDelete: (t) => {
        e.pub(Yn, t);
      },
      findIndex: (t) => e.getValue(S).findIndex(t),
      find: (t) => e.getValue(S).find(t),
      insert: (t, n, o) => {
        e.pub(It, {
          data: t,
          offset: n,
          scrollToBottom: o
        });
      },
      deleteRange: (t, n) => {
        e.pub(Gt, {
          offset: t,
          count: n
        });
      },
      batch: (t, n) => {
        e.pub(Te, true), t(), e.pub(Te, false), e.pub(nt, { data: [], scrollToBottom: n });
      },
      get: () => e.getValue(S).slice(),
      getCurrentlyRendered: () => e.getValue(Lt),
      removeFromStart: (t) => {
        e.pub(vt, t);
      }
    },
    scrollToItem: (t) => {
      e.pub(Z, t);
    },
    scrollIntoView: (t) => {
      e.pub(zn, t);
    },
    scrollerElement: () => e.getValue(ye),
    getScrollLocation() {
      return e.getValue(rt);
    },
    cancelSmoothScroll() {
      e.pub(jn);
    },
    height: (t) => {
      var i;
      const n = ((i = e.getValue(S)) == null ? void 0 : i.indexOf(t)) ?? -1;
      if (n === -1)
        return 0;
      const o = e.getValue(Q2);
      return he(o, n)[1] ?? 0;
    }
  };
}
function Fi() {
  return P(rt);
}
function Hi() {
  return P(Lt);
}
function Pi() {
  const e = C();
  return import_react.default.useMemo(() => Qn(e), [e]);
}
var Wi = {
  prepend: "prepend",
  removeFromStart: "remove-from-start",
  removeFromEnd: "remove-from-end"
};
var eo = G(null);
var to = G(null);
var no = G(null);
var oo = G(null);
var io = G(null);
var so = G("div");
var ri = {
  position: "sticky",
  top: 0,
  zIndex: 1
};
var dt = {
  overflowAnchor: "none"
};
var ui = {
  position: "sticky",
  bottom: 0
};
var lo = import_react.default.forwardRef((e, t) => (0, import_jsx_runtime2.jsx)("div", { style: { zIndex: 1 }, ...e, ref: t }));
var ro = import_react.default.forwardRef((e, t) => (0, import_jsx_runtime2.jsx)("div", { ...e, ref: t }));
var uo = import_react.default.forwardRef(
  ({ style: e, ...t }, n) => (0, import_jsx_runtime2.jsx)("div", { ...t, style: { ...ri, ...e }, ref: n })
);
var co = import_react.default.forwardRef(
  ({ style: e, ...t }, n) => (0, import_jsx_runtime2.jsx)("div", { ...t, style: { ...ui, ...e }, ref: n })
);
var ao = G(lo);
var po = G(uo);
var fo = G(ro);
var ho = G(co);
var go = ({ index: e }) => (0, import_jsx_runtime2.jsxs)("div", { children: [
  "Item ",
  e
] });
var mo = ({ index: e }) => e;
var Qt = G(go);
var bo = G(mo);
var en = (e) => e;
var Io = G(en);
var vo = G(
  null,
  (e) => {
    e.sub(
      e.pipe(vo, at(S, Io, ge, J)),
      ([t, n, o, i, s]) => {
        if (t === void 0)
          return;
        if (!t || !t.data || !t.data.length) {
          e.pubIn({
            [S]: [],
            [J]: tt,
            [Me]: De
          });
          return;
        }
        const l = t.data, r = t.scrollModifier;
        if (r === "prepend") {
          if (n === null || !n.length) {
            e.pub(S, l);
            return;
          }
          const a = n[0], u = l.findIndex((I2) => o(I2) === o(a)), p = u === -1 ? l : l.slice(0, u), d = u === -1 ? [] : l.slice(u);
          e.pubIn({
            [S]: d
          }), e.pubIn({
            [oe]: p
          });
          return;
        }
        if (r === "remove-from-start") {
          const a = l[0], u = (n == null ? void 0 : n.findIndex((d) => o(d) === o(a))) ?? -1;
          if (u === -1) {
            e.pub(S, l);
            return;
          }
          const p = Je(u, i);
          e.pub(X, -p), queueMicrotask(() => {
            e.pub(S, l);
            const d = de(s[0]).reduce((I2, { k: b, v: f }) => H2(I2, Math.max(0, b - u), f), Re());
            e.pub(J, [d, 0]);
          });
          return;
        }
        if (r === "remove-from-end") {
          e.pub(S, l), e.pub(fe, [
            {
              size: e.getValue(Ee),
              startIndex: l.length,
              endIndex: Number.POSITIVE_INFINITY
            }
          ]);
          return;
        }
        if ((r == null ? void 0 : r.type) === "item-location") {
          l !== n && e.pubIn({
            [Ne]: {
              data: l,
              initialLocation: r.location,
              purgeItemSizes: r.purgeItemSizes
            }
          });
          return;
        }
        if ((r == null ? void 0 : r.type) === "auto-scroll-to-bottom") {
          e.pubIn({
            [S]: l,
            [nt]: {
              data: l,
              scrollToBottom: r.autoScroll
            }
          });
          return;
        }
        if ((r == null ? void 0 : r.type) === "items-change") {
          e.pub(Jt, {
            newData: l,
            autoscrollToBottomBehavior: r.behavior
          });
          return;
        }
        e.pub(S, l);
      }
    );
  },
  (e, t) => e ? e.data === (t == null ? void 0 : t.data) : false
);
var ci = ({ item: e, ItemContent: t, mount: n, unmount: o }) => {
  const i = P(He), s = import_react.default.useRef(null), l = import_react.default.useCallback(
    (r) => {
      r ? (s.current = r, n(r)) : s.current && (o(s.current), s.current = null);
    },
    [n, o]
  );
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      ref: l,
      "data-index": e.index,
      "data-known-size": e.height,
      style: {
        overflowAnchor: "none",
        position: "absolute",
        width: "100%",
        top: e.offset
      },
      children: (0, import_jsx_runtime2.jsx)(t, { index: e.index, prevData: e.prevData, nextData: e.nextData, data: e.data, context: i })
    }
  );
};
var tn = G("top", (e) => {
  e.link(
    e.pipe(
      e.combine(tn, We, K2, lt2, qn),
      pt(([t]) => t === "bottom" || t === "bottom-smooth"),
      ct(([, t, n, o, i]) => Math.max(0, n - t - o - i))
    ),
    Rt
  ), e.link(
    e.pipe(
      e.combine(Rt, tn),
      pt(([, t]) => t === "bottom-smooth"),
      ft(
        (t, [n]) => [t[1], n],
        [0, 0]
      ),
      ct(([t, n]) => t > 0 && n > 0 ? "margin-top 0.2s ease-out" : "")
    ),
    Zn
  );
});
function gt2(e) {
  const t = import_react.default.useRef(null);
  return [import_react.default.useCallback(
    (o) => {
      o ? (t.current = o, e == null || e.observe(o, { box: "border-box" })) : t.current && (e == null || e.unobserve(t.current), t.current = null);
    },
    [e]
  ), t];
}
function ai(e, t) {
  return Math.abs(e - t) < 0.5;
}
function pi(e, t, n) {
  const o = C(), i = import_react.default.useRef(null), s = import_react.default.useRef(null), l = import_react.default.useCallback(() => {
    i.current && (cancelAnimationFrame(i.current), i.current = null, s.current = null);
  }, []);
  import_react.default.useEffect(() => o.sub(pn, (u) => {
    u !== s.current && l();
  }), [o, l]), import_react.default.useEffect(() => o.sub(jn, l), [o, l]);
  const r = import_react.default.useCallback(
    (u, p, d) => {
      var L2;
      i.current && l();
      const I2 = ((L2 = e.current) == null ? void 0 : L2.scrollTop) ?? 0;
      s.current = I2 < u ? "down" : "up";
      let b = 0, f = 0;
      function m2() {
        var U2, j2;
        const q = I2 + (u - I2) * p(b);
        (U2 = e.current) == null || U2.scrollTo({ top: q, behavior: "instant" }), b += 1 / d, f += 1, f < d ? i.current = requestAnimationFrame(m2) : ((j2 = e.current) == null || j2.scrollTo({ top: u, behavior: "instant" }), i.current = null, s.current = null);
      }
      m2();
    },
    [e, l]
  );
  return import_react.default.useCallback(
    (u) => {
      var d, I2;
      const p = e.current;
      if (!(!p || u.top === void 0)) {
        if (ai(u.top, p.scrollTop)) {
          requestAnimationFrame(() => {
            var b;
            o.pub(ot, (b = e.current) == null ? void 0 : b.scrollTop);
          });
          return;
        }
        if (n.current = u.top, o.pub(un, true), u.forceBottomSpace !== void 0 && t.current && (t.current.style.paddingBottom = `${u.forceBottomSpace}px`), u.behavior === "smooth")
          r(u.top ?? 0, oi, ii);
        else if (u.behavior === "auto" || u.behavior === "instant" || u.behavior === void 0)
          l(), (d = e.current) == null || d.scrollTo(u);
        else {
          const { easing: b, animationFrameCount: f } = u.behavior(((I2 = e.current) == null ? void 0 : I2.scrollTop) ?? 0, u.top ?? 0);
          r(u.top ?? 0, b, f);
        }
      }
    },
    [o, r, t, e, n, l]
  );
}
function fi(e) {
  return hi(gi(mi(di(e), 8 * e.length))).toLowerCase();
}
function hi(e) {
  for (var t, n = "0123456789ABCDEF", o = "", i = 0; i < e.length; i++)
    t = e.charCodeAt(i), o += n.charAt(t >>> 4 & 15) + n.charAt(15 & t);
  return o;
}
function di(e) {
  for (var t = Array(e.length >> 2), n = 0; n < t.length; n++) t[n] = 0;
  for (n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << n % 32;
  return t;
}
function gi(e) {
  for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> n % 32 & 255);
  return t;
}
function mi(e, t) {
  e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
  for (var n = 1732584193, o = -271733879, i = -1732584194, s = 271733878, l = 0; l < e.length; l += 16) {
    const r = n, a = o, u = i, p = s;
    o = F(
      o = F(
        o = F(
          o = F(
            o = _2(
              o = _2(
                o = _2(
                  o = _2(
                    o = B2(
                      o = B2(
                        o = B2(
                          o = B2(
                            o = N(
                              o = N(
                                o = N(
                                  o = N(
                                    o,
                                    i = N(
                                      i,
                                      s = N(s, n = N(n, o, i, s, e[l + 0], 7, -680876936), o, i, e[l + 1], 12, -389564586),
                                      n,
                                      o,
                                      e[l + 2],
                                      17,
                                      606105819
                                    ),
                                    s,
                                    n,
                                    e[l + 3],
                                    22,
                                    -1044525330
                                  ),
                                  i = N(
                                    i,
                                    s = N(s, n = N(n, o, i, s, e[l + 4], 7, -176418897), o, i, e[l + 5], 12, 1200080426),
                                    n,
                                    o,
                                    e[l + 6],
                                    17,
                                    -1473231341
                                  ),
                                  s,
                                  n,
                                  e[l + 7],
                                  22,
                                  -45705983
                                ),
                                i = N(
                                  i,
                                  s = N(s, n = N(n, o, i, s, e[l + 8], 7, 1770035416), o, i, e[l + 9], 12, -1958414417),
                                  n,
                                  o,
                                  e[l + 10],
                                  17,
                                  -42063
                                ),
                                s,
                                n,
                                e[l + 11],
                                22,
                                -1990404162
                              ),
                              i = N(
                                i,
                                s = N(s, n = N(n, o, i, s, e[l + 12], 7, 1804603682), o, i, e[l + 13], 12, -40341101),
                                n,
                                o,
                                e[l + 14],
                                17,
                                -1502002290
                              ),
                              s,
                              n,
                              e[l + 15],
                              22,
                              1236535329
                            ),
                            i = B2(
                              i,
                              s = B2(s, n = B2(n, o, i, s, e[l + 1], 5, -165796510), o, i, e[l + 6], 9, -1069501632),
                              n,
                              o,
                              e[l + 11],
                              14,
                              643717713
                            ),
                            s,
                            n,
                            e[l + 0],
                            20,
                            -373897302
                          ),
                          i = B2(
                            i,
                            s = B2(s, n = B2(n, o, i, s, e[l + 5], 5, -701558691), o, i, e[l + 10], 9, 38016083),
                            n,
                            o,
                            e[l + 15],
                            14,
                            -660478335
                          ),
                          s,
                          n,
                          e[l + 4],
                          20,
                          -405537848
                        ),
                        i = B2(
                          i,
                          s = B2(s, n = B2(n, o, i, s, e[l + 9], 5, 568446438), o, i, e[l + 14], 9, -1019803690),
                          n,
                          o,
                          e[l + 3],
                          14,
                          -187363961
                        ),
                        s,
                        n,
                        e[l + 8],
                        20,
                        1163531501
                      ),
                      i = B2(
                        i,
                        s = B2(s, n = B2(n, o, i, s, e[l + 13], 5, -1444681467), o, i, e[l + 2], 9, -51403784),
                        n,
                        o,
                        e[l + 7],
                        14,
                        1735328473
                      ),
                      s,
                      n,
                      e[l + 12],
                      20,
                      -1926607734
                    ),
                    i = _2(
                      i,
                      s = _2(s, n = _2(n, o, i, s, e[l + 5], 4, -378558), o, i, e[l + 8], 11, -2022574463),
                      n,
                      o,
                      e[l + 11],
                      16,
                      1839030562
                    ),
                    s,
                    n,
                    e[l + 14],
                    23,
                    -35309556
                  ),
                  i = _2(
                    i,
                    s = _2(s, n = _2(n, o, i, s, e[l + 1], 4, -1530992060), o, i, e[l + 4], 11, 1272893353),
                    n,
                    o,
                    e[l + 7],
                    16,
                    -155497632
                  ),
                  s,
                  n,
                  e[l + 10],
                  23,
                  -1094730640
                ),
                i = _2(
                  i,
                  s = _2(s, n = _2(n, o, i, s, e[l + 13], 4, 681279174), o, i, e[l + 0], 11, -358537222),
                  n,
                  o,
                  e[l + 3],
                  16,
                  -722521979
                ),
                s,
                n,
                e[l + 6],
                23,
                76029189
              ),
              i = _2(
                i,
                s = _2(s, n = _2(n, o, i, s, e[l + 9], 4, -640364487), o, i, e[l + 12], 11, -421815835),
                n,
                o,
                e[l + 15],
                16,
                530742520
              ),
              s,
              n,
              e[l + 2],
              23,
              -995338651
            ),
            i = F(
              i,
              s = F(s, n = F(n, o, i, s, e[l + 0], 6, -198630844), o, i, e[l + 7], 10, 1126891415),
              n,
              o,
              e[l + 14],
              15,
              -1416354905
            ),
            s,
            n,
            e[l + 5],
            21,
            -57434055
          ),
          i = F(
            i,
            s = F(s, n = F(n, o, i, s, e[l + 12], 6, 1700485571), o, i, e[l + 3], 10, -1894986606),
            n,
            o,
            e[l + 10],
            15,
            -1051523
          ),
          s,
          n,
          e[l + 1],
          21,
          -2054922799
        ),
        i = F(
          i,
          s = F(s, n = F(n, o, i, s, e[l + 8], 6, 1873313359), o, i, e[l + 15], 10, -30611744),
          n,
          o,
          e[l + 6],
          15,
          -1560198380
        ),
        s,
        n,
        e[l + 13],
        21,
        1309151649
      ),
      i = F(
        i,
        s = F(s, n = F(n, o, i, s, e[l + 4], 6, -145523070), o, i, e[l + 11], 10, -1120210379),
        n,
        o,
        e[l + 2],
        15,
        718787259
      ),
      s,
      n,
      e[l + 9],
      21,
      -343485551
    ), n = pe(n, r), o = pe(o, a), i = pe(i, u), s = pe(s, p);
  }
  return [n, o, i, s];
}
function At(e, t, n, o, i, s) {
  return pe(bi(pe(pe(t, e), pe(o, s)), i), n);
}
function N(e, t, n, o, i, s, l) {
  return At(t & n | ~t & o, e, t, i, s, l);
}
function B2(e, t, n, o, i, s, l) {
  return At(t & o | n & ~o, e, t, i, s, l);
}
function _2(e, t, n, o, i, s, l) {
  return At(t ^ n ^ o, e, t, i, s, l);
}
function F(e, t, n, o, i, s, l) {
  return At(n ^ (t | ~o), e, t, i, s, l);
}
function pe(e, t) {
  const n = (65535 & e) + (65535 & t);
  return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n;
}
function bi(e, t) {
  return e << t | e >>> 32 - t;
}
var So = Symbol("INVALID_KEY");
function Ii(e) {
  const t = e.slice(0, 32), n = e.slice(32), o = atob(n);
  if (t !== fi(n))
    return So;
  const [i, s] = o.split(";"), l = i.slice(2), r = new Date(Number(s.slice(2)));
  return { orderNumber: l, expiryDate: r };
}
var vi = {
  valid: false,
  consoleMessage: "The VirtuosoMessageList license wrapper component is missing. Enclose the VirtuosoMessageList with VirtuosoMessageListLicense and add your key at the lisenceKey property.",
  watermarkMessage: "The VirtuosoMessageList license wrapper component is missing. Enclose the VirtuosoMessageList with VirtuosoMessageListLicense and add your key at the lisenceKey property."
};
var Si = {
  valid: false,
  consoleMessage: "Your VirtuosoMessageListLicense is missing a license key. Purchase one from https://virtuoso.dev/pricing/",
  watermarkMessage: "Your VirtuosoMessageListLicense is missing a license key. Purchase one from https://virtuoso.dev/pricing/"
};
var ki = {
  valid: false,
  consoleMessage: "Your VirtuosoMessageListLicense component is missing a license key - this component will not work if deployed in production. Purchase a key from https://virtuoso.dev/pricing/ before you deploy to production."
};
var ko = {
  valid: true
};
var xi = {
  valid: false,
  consoleMessage: "Your Virtuoso Message List license key is invalid. Ensure that you have copy-pasted the key from the purchase email correctly.",
  watermarkMessage: "Your Virtuoso Message List license key is invalid"
};
var Ti = {
  valid: false,
  consoleMessage: "Your annual license key to use Virtuoso Message List in non-production environments has expired. You can still use it in production. To keep using it in development, purchase a new key from https://virtuoso.dev/pricing/",
  watermarkMessage: "Your annual license key to use Virtuoso Message List in non-production environments has expired. You can still use it in production. To keep using it in development, purchase a new key from https://virtuoso.dev/pricing/"
};
var Ei = {
  valid: false,
  consoleMessage: "You have installed a version of `@virtuoso.dev/message-list` that is newer than the period of your license key. Either downgrade to a supported version, or purchase a new license from https://virtuoso.dev/pricing/",
  watermarkMessage: "You have installed a version of `@virtuoso.dev/message-list` that is newer than the period of your license key. Either downgrade to a supported version, or purchase a new license from https://virtuoso.dev/pricing/"
};
var yi = ko;
var $i = /^(?:127\.0\.0\.1|localhost|0\.0\.0\.0|.+\.local)$/;
var wi = ["virtuoso.dev", "csb.app", "codesandbox.io"];
function Li({ licenseKey: e, now: t, hostname: n, packageTimestamp: o }) {
  const i = n.match($i), s = wi.some((r) => n.endsWith(r));
  if (!e)
    return s ? yi : i ? ki : Si;
  const l = Ii(e);
  if (l === So)
    return xi;
  if (l.expiryDate.getTime() < t.getTime()) {
    if (i)
      return Ti;
    if (l.expiryDate.getTime() < o)
      return Ei;
  }
  return ko;
}
var xo = import_react.default.createContext(vi);
var Ri = ({
  licenseKey: e,
  children: t
}) => {
  const n = Li({
    licenseKey: e,
    hostname: typeof window < "u" ? window.location.hostname : "localhost",
    now: /* @__PURE__ */ new Date(),
    packageTimestamp: 1755842099641
  });
  return (0, import_jsx_runtime2.jsx)(xo.Provider, { value: n, children: t });
};
Ri.displayName = Math.random().toString(36).slice(2, 8);
var Ot = import_react.default.createContext(void 0);
var kn = false;
var Ci = import_react.default.forwardRef(
  ({
    initialData: e = [],
    computeItemKey: t = mo,
    context: n = null,
    initialLocation: o = null,
    shortSizeAlign: i = "top",
    onScroll: s,
    onRenderedDataChange: l,
    ItemContent: r = go,
    Header: a = null,
    StickyHeader: u = null,
    Footer: p = null,
    StickyFooter: d = null,
    EmptyPlaceholder: I2 = null,
    HeaderWrapper: b = lo,
    StickyHeaderWrapper: f = uo,
    FooterWrapper: m2 = ro,
    StickyFooterWrapper: L2 = co,
    useWindowScroll: q = false,
    customScrollParent: U2 = null,
    ScrollElement: j2 = "div",
    increaseViewportBy: be = 0,
    data: ee,
    itemIdentity: ut2 = en,
    ...se
  }, W) => {
    const C2 = import_react.default.useMemo(() => {
      const R2 = new K();
      return R2.register(Me), R2.register(Mt), R2.register($t), R2.register(kt), R2.register(bt2), R2.register(wt), R2.register(oe), R2.register(Ne), R2.pubIn({
        [S]: e.slice(),
        [Io]: en,
        [He]: n,
        [bo]: t,
        [Fe]: o,
        [Qt]: r,
        [eo]: a,
        [no]: p,
        [to]: u,
        [oo]: d,
        [io]: I2,
        [so]: j2,
        [ho]: L2,
        [po]: f,
        [fo]: m2,
        [ao]: b,
        [tn]: i,
        [fn]: q,
        [Qe]: U2,
        [Kn]: be
      }), R2.singletonSub(Xt, s), R2.singletonSub(Lt, l), R2;
    }, []);
    import_react.default.useImperativeHandle(W, () => Qn(C2), [C2]), import_react.default.useEffect(() => {
      C2.pubIn({
        [He]: n,
        [Qt]: r,
        [Qe]: U2,
        [vo]: ee
      }), C2.singletonSub(Xt, s), C2.singletonSub(Lt, l);
    }, [n, r, U2, s, l, C2, ee]);
    const O2 = import_react.default.useContext(xo);
    return import_react.default.useEffect(() => {
      O2.consoleMessage && (kn || (kn = true, console.warn(O2.consoleMessage)));
    }, [O2]), import_react.default.useEffect(() => {
      const R2 = (te) => {
        var Ve;
        (Ve = te.message) != null && Ve.includes("ResizeObserver loop") && (te.preventDefault(), te.stopPropagation(), te.stopImmediatePropagation());
      };
      return window.addEventListener("error", R2, { capture: true }), () => {
        window.removeEventListener("error", R2);
      };
    }, []), typeof window < "u" && O2.watermarkMessage ? (0, import_jsx_runtime2.jsx)(
      "div",
      {
        style: {
          color: "red",
          pointerEvents: "none"
        },
        children: O2.watermarkMessage
      }
    ) : (0, import_jsx_runtime2.jsx)(O.Provider, { value: C2, children: (0, import_jsx_runtime2.jsx)(Mi, { ...se }) });
  }
);
Ci.displayName = "VirtuosoMessageList";
var Mi = ({ style: e, ...t }) => {
  const n = C(), o = import_react.default.useContext(Ot), [
    i,
    s,
    l,
    r,
    a,
    u,
    p,
    d,
    I2,
    b,
    f
  ] = ut(
    eo,
    to,
    ao,
    po,
    no,
    oo,
    fo,
    ho,
    Qt,
    io,
    Qe
  ), [m2] = import_react.default.useState(() => {
    if (typeof window < "u" && typeof ResizeObserver > "u")
      throw new Error("ResizeObserver not found. Please ensure that you have a polyfill installed.");
    if (!(typeof ResizeObserver > "u"))
      return new ResizeObserver((x2) => {
        var ft2, Oe, Ye, gn;
        const ve = x2.length, z = [];
        let $ = {};
        for (let Bt = 0; Bt < ve; Bt++) {
          const ce = x2[Bt], A2 = ce.target;
          if (A2 === ee.current) {
            $ = {
              ...$,
              [it]: ce.contentRect.height,
              [D2]: (ft2 = W.current) == null ? void 0 : ft2.scrollHeight
            };
            continue;
          }
          if (A2 === se.current) {
            $ = {
              ...$,
              [ze]: ce.contentRect.height,
              [D2]: (Oe = W.current) == null ? void 0 : Oe.scrollHeight
            };
            continue;
          }
          if (A2 === q.current) {
            $ = {
              ...$,
              [cn]: ce.contentRect.height,
              [D2]: (Ye = W.current) == null ? void 0 : Ye.scrollHeight
            };
            continue;
          }
          if (A2 === j2.current) {
            $ = {
              ...$,
              [st]: ce.contentRect.height,
              [D2]: (gn = W.current) == null ? void 0 : gn.scrollHeight
            };
            continue;
          }
          if (A2 === W.current) {
            $ = {
              ...$,
              [w2]: A2.scrollTop,
              [D2]: A2.scrollHeight,
              [K2]: ce.contentRect.height,
              [xt]: A2.clientWidth
            };
            continue;
          }
          if (A2 === O2.current) {
            W.current && ($ = {
              ...$,
              [D2]: W.current.scrollHeight
            });
            continue;
          }
          if (A2 === C2.current) {
            const ae = A2.ownerDocument.defaultView;
            ae !== null && ($ = {
              ...$,
              [D2]: ce.contentRect.height,
              [me]: ae.scrollY,
              [Pe]: ae.innerHeight,
              [et]: A2.getBoundingClientRect().top + ae.scrollY,
              [xt]: A2.clientWidth
            });
            continue;
          }
          if (A2 === f || A2 === R2.current) {
            const ae = te.current, ht = R2.current;
            ae && ht && ($ = {
              ...$,
              [D2]: ht.getBoundingClientRect().height,
              [me]: ae.scrollTop,
              [Pe]: ae.clientHeight,
              [et]: ht.offsetTop,
              [xt]: ht.clientWidth
            });
            continue;
          }
          if (A2.dataset.index === void 0)
            continue;
          const _t = Number.parseInt(A2.dataset.index), wo = Number.parseFloat(A2.dataset.knownSize ?? ""), Ft = ce.contentRect.height;
          if (Ft === wo)
            continue;
          const mn = z[z.length - 1];
          z.length === 0 || mn.size !== Ft || mn.endIndex !== _t - 1 ? z.push({ endIndex: _t, size: Ft, startIndex: _t }) : z[z.length - 1].endIndex++;
        }
        z.length > 0 && ($ = {
          ...$,
          [fe]: z
        }), n.pubIn($);
      });
  }), [L2, q] = gt2(m2), [U2, j2] = gt2(m2), [be, ee] = gt2(m2), [ut2, se] = gt2(m2), W = import_react.default.useRef(null), C2 = import_react.default.useRef(null), O2 = import_react.default.useRef(null), R2 = import_react.default.useRef(null), te = import_react.default.useRef(null);
  (0, import_react.useEffect)(() => {
    te.current = f;
  }, [f]);
  const Ve = import_react.default.useCallback(
    (x2) => {
      if (o) {
        const ve = Number.parseInt(x2.dataset.index ?? "");
        n.pub(fe, [
          {
            startIndex: ve,
            endIndex: ve,
            size: o.itemHeight
          }
        ]);
      }
      m2 == null || m2.observe(x2);
    },
    [m2, n, o]
  ), ct2 = import_react.default.useCallback(
    (x2) => {
      m2 == null || m2.unobserve(x2);
    },
    [m2]
  ), ne = import_react.default.useCallback(
    (x2) => {
      x2 ? (O2.current = x2, m2 == null || m2.observe(x2, { box: "border-box" })) : O2.current && (m2 == null || m2.unobserve(O2.current), O2.current = null);
    },
    [m2]
  ), { items: Ie } = P(Me), le = import_react.default.useCallback(() => {
    var ve;
    const x2 = [];
    for (const z of ((ve = O2.current) == null ? void 0 : ve.children) ?? []) {
      if (z.dataset.index === void 0)
        continue;
      const $ = Number.parseInt(z.dataset.index), ft2 = Number.parseFloat(z.dataset.knownSize ?? ""), Oe = z.getBoundingClientRect().height;
      if (Oe === ft2)
        continue;
      const Ye = x2[x2.length - 1];
      x2.length === 0 || Ye.size !== Oe || Ye.endIndex !== $ - 1 ? x2.push({ endIndex: $, size: Oe, startIndex: $ }) : x2[x2.length - 1].endIndex++;
    }
    n.pub(fe, x2);
  }, [n]);
  import_react.default.useLayoutEffect(() => n.sub(Jn, le), [le, n]);
  const re = P(Y), Dt = P(Et), ue = P(Rt), Nt = P(Vt), To = P(Zn), Ae = P(He), Eo = P(bo), at2 = P(Ce), yo = P(We), $o = P(fn), pt2 = P(ke);
  return import_react.default.useLayoutEffect(() => {
    Ie.length === 0 && n.pub(Xn);
  }, [Ie, n]), import_react.default.useLayoutEffect(() => {
    var x2;
    at2 > 0 && pt2 === null && b !== null && n.pub(D2, (x2 = W.current) == null ? void 0 : x2.scrollHeight);
  }, [n, at2, pt2, b]), (0, import_jsx_runtime2.jsxs)(
    f ? Oi : $o ? Ai : Vi,
    {
      ...t,
      observer: m2,
      scrollerRef: W,
      customScrollParentWrapperRef: R2,
      listRef: O2,
      style: e,
      windowScrollWrapperRef: C2,
      children: [
        (at2 === 0 || pt2) && b ? (0, import_jsx_runtime2.jsx)(b, { context: Ae }) : null,
        s && (0, import_jsx_runtime2.jsx)(r, { ref: ut2, style: dt, children: (0, import_jsx_runtime2.jsx)(s, { context: Ae }) }),
        i && (0, import_jsx_runtime2.jsx)(l, { ref: be, style: dt, children: (0, import_jsx_runtime2.jsx)(i, { context: Ae }) }),
        at2 > 0 ? (0, import_jsx_runtime2.jsx)(
          "div",
          {
            ref: ne,
            "data-testid": "virtuoso-list",
            style: {
              boxSizing: "content-box",
              height: yo,
              paddingBottom: Nt,
              overflowAnchor: "none",
              marginTop: ue,
              transition: To,
              position: "relative",
              transform: `translateY(${re + Dt}px)`,
              visibility: pt2 ? "hidden" : "visible"
            },
            children: Ie.map((x2) => (0, import_jsx_runtime2.jsx)(
              ci,
              {
                mount: Ve,
                unmount: ct2,
                item: x2,
                ItemContent: I2
              },
              Eo({ index: x2.index, data: x2.data, context: Ae })
            ))
          }
        ) : null,
        a && (0, import_jsx_runtime2.jsx)(p, { ref: L2, style: dt, children: (0, import_jsx_runtime2.jsx)(a, { context: Ae }) }),
        u && (0, import_jsx_runtime2.jsx)(d, { ref: U2, style: dt, children: (0, import_jsx_runtime2.jsx)(u, { context: Ae }) })
      ]
    }
  );
};
var Vi = ({
  customScrollParentWrapperRef: e,
  windowScrollWrapperRef: t,
  observer: n,
  children: o,
  listRef: i,
  scrollerRef: s,
  style: l,
  ...r
}) => {
  const a = C(), u = import_react.default.useContext(Ot), p = P(so), { onScroll: d, onWheel: I2 } = hn({
    listRef: i,
    scrollTopCell$: w2,
    scrollToSignal$: $e,
    scrollableRef: s
  }), b = import_react.default.useCallback(
    (L2) => {
      L2 ? (a.pub(ye, L2), s.current = L2, L2.addEventListener("scroll", d), L2.addEventListener("wheel", I2), u && a.pubIn({
        [K2]: u.viewportHeight,
        [D2]: u.viewportHeight,
        [w2]: 0
      }), n == null || n.observe(L2, { box: "border-box" })) : s.current && (s.current.removeEventListener("scroll", d), s.current.removeEventListener("wheel", I2), a.pub(ye, null), n == null || n.unobserve(s.current), s.current = null);
    },
    [n, a, d, I2, u, s]
  );
  dn(() => {
    var L2;
    return (L2 = s.current) == null ? void 0 : L2.scrollHeight;
  });
  const f = P(G2), m2 = P(He);
  return (0, import_jsx_runtime2.jsx)(
    p,
    {
      ...r,
      ref: b,
      "data-testid": "virtuoso-scroller",
      style: {
        overflowY: f ? "hidden" : "scroll",
        boxSizing: "border-box",
        ...l
      },
      ...p === "div" ? {} : { context: m2 },
      children: o
    }
  );
};
var Ai = ({
  observer: e,
  children: t,
  windowScrollWrapperRef: n,
  customScrollParentWrapperRef: o,
  listRef: i,
  ...s
}) => {
  const l = import_react.default.useRef(null), r = C(), a = import_react.default.useContext(Ot), { onScroll: u, onWheel: p } = hn({
    listRef: i,
    scrollTopCell$: me,
    scrollToSignal$: an,
    scrollableRef: l
  }), d = import_react.default.useCallback(() => {
    var f;
    const b = l.current;
    b !== null && r.pub(Pe, (f = b.ownerDocument.defaultView) == null ? void 0 : f.innerHeight);
  }, [r]), I2 = import_react.default.useCallback(
    (b) => {
      if (b) {
        r.pub(ye, b), n.current = b;
        const f = b.ownerDocument.defaultView;
        f && (f.addEventListener("scroll", u), f.addEventListener("wheel", p), f.addEventListener("resize", d), a && r.pubIn({
          [Pe]: f == null ? void 0 : f.innerHeight,
          [D2]: b.getBoundingClientRect().height,
          [me]: 0
        }), l.current = b.ownerDocument.documentElement), e == null || e.observe(b, { box: "border-box" });
      } else {
        if (n.current) {
          const f = n.current.ownerDocument.defaultView;
          f && (f.removeEventListener("scroll", u), f.removeEventListener("wheel", p), f.removeEventListener("resize", d)), r.pub(ye, null), e == null || e.unobserve(n.current), n.current = null;
        }
        l.current = null;
      }
    },
    [e, r, u, p, d, a, n]
  );
  return dn(() => {
    var b;
    return (b = n.current) == null ? void 0 : b.getBoundingClientRect().height;
  }), (0, import_jsx_runtime2.jsx)("div", { ref: I2, ...s, children: t });
};
var Oi = ({
  scrollerRef: e,
  windowScrollWrapperRef: t,
  children: n,
  listRef: o,
  customScrollParentWrapperRef: i,
  observer: s,
  ...l
}) => {
  const r = C(), a = import_react.default.useContext(Ot), u = P(Qe), p = import_react.default.useRef(u);
  (0, import_react.useEffect)(() => {
    p.current = u;
  }, [u]);
  const { onWheel: d, onScroll: I2 } = hn({
    listRef: o,
    scrollTopCell$: me,
    scrollToSignal$: an,
    scrollableRef: p
  }), b = import_react.default.useCallback(
    (f) => {
      if (f) {
        const m2 = p.current;
        r.pub(ye, m2), i.current = f, m2 && (m2.addEventListener("scroll", I2), m2.addEventListener("wheel", d), a && r.pubIn({
          [Pe]: m2.clientHeight,
          [D2]: f.getBoundingClientRect().height,
          [me]: 0
        }), s == null || s.observe(m2, { box: "border-box" })), s == null || s.observe(f, { box: "border-box" });
      } else {
        const m2 = p.current;
        m2 && (m2.removeEventListener("scroll", I2), m2.removeEventListener("wheel", d), r.pub(ye, null), s == null || s.unobserve(m2)), i.current && (s == null || s.unobserve(i.current)), i.current = null;
      }
    },
    [s, r, I2, d, a, i]
  );
  return dn(() => {
    var f;
    return (f = i.current) == null ? void 0 : f.getBoundingClientRect().height;
  }), (0, import_jsx_runtime2.jsx)("div", { ref: b, ...l, children: n });
};
function hn({ scrollToSignal$: e, scrollableRef: t, listRef: n, scrollTopCell$: o }) {
  const i = C(), s = import_react.default.useRef(null), l = pi(t, n, s), r = import_react.default.useCallback(
    (p) => {
      t.current && (t.current.scrollTop += p);
    },
    [t]
  ), a = import_react.default.useCallback(() => {
    const p = t.current;
    if (p !== null && (i.pub(o, p.scrollTop), s.current !== null)) {
      const d = p.scrollHeight - p.clientHeight;
      Bn(p.scrollTop, Math.min(d, s.current)) && (s.current = null, i.pub(un, false), i.pub(ot, p.scrollTop));
    }
  }, [i, t, o]), u = import_react.default.useCallback(
    (p) => {
      i.pub(pn, p.deltaY > 0 ? "down" : "up");
    },
    [i]
  );
  return import_react.default.useLayoutEffect(() => i.sub(e, l), [l, i, e]), import_react.default.useLayoutEffect(() => i.sub(X, r), [r, i]), {
    onScroll: a,
    onWheel: u
  };
}
function dn(e) {
  const t = U(D2);
  (0, import_react.useLayoutEffect)(() => {
    if (!_n())
      return;
    const n = setInterval(() => {
      t(e() ?? 0);
    }, 1e3);
    return () => {
      clearInterval(n);
    };
  }, [t, e]);
}
export {
  Wi as ScrollModifierOption,
  Ci as VirtuosoMessageList,
  Ri as VirtuosoMessageListLicense,
  Ot as VirtuosoMessageListTestingContext,
  Hi as useCurrentlyRenderedData,
  Fi as useVirtuosoLocation,
  Pi as useVirtuosoMethods
};
//# sourceMappingURL=@virtuoso__dev_message-list.js.map
