import {
  __commonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/rfc6902/pointer.js
var require_pointer = __commonJS({
  "node_modules/rfc6902/pointer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pointer = exports.escapeToken = exports.unescapeToken = void 0;
    function unescapeToken(token) {
      return token.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeToken = unescapeToken;
    function escapeToken(token) {
      return token.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeToken = escapeToken;
    var Pointer = (
      /** @class */
      function() {
        function Pointer2(tokens) {
          if (tokens === void 0) {
            tokens = [""];
          }
          this.tokens = tokens;
        }
        Pointer2.fromJSON = function(path) {
          var tokens = path.split("/").map(unescapeToken);
          if (tokens[0] !== "")
            throw new Error("Invalid JSON Pointer: ".concat(path));
          return new Pointer2(tokens);
        };
        Pointer2.prototype.toString = function() {
          return this.tokens.map(escapeToken).join("/");
        };
        Pointer2.prototype.evaluate = function(object) {
          var parent = null;
          var key = "";
          var value = object;
          for (var i = 1, l = this.tokens.length; i < l; i++) {
            parent = value;
            key = this.tokens[i];
            if (key == "__proto__" || key == "constructor" || key == "prototype") {
              continue;
            }
            value = (parent || {})[key];
          }
          return { parent, key, value };
        };
        Pointer2.prototype.get = function(object) {
          return this.evaluate(object).value;
        };
        Pointer2.prototype.set = function(object, value) {
          var endpoint = this.evaluate(object);
          if (endpoint.parent) {
            endpoint.parent[endpoint.key] = value;
          }
        };
        Pointer2.prototype.push = function(token) {
          this.tokens.push(token);
        };
        Pointer2.prototype.add = function(token) {
          var tokens = this.tokens.concat(String(token));
          return new Pointer2(tokens);
        };
        return Pointer2;
      }()
    );
    exports.Pointer = Pointer;
  }
});

// node_modules/rfc6902/util.js
var require_util = __commonJS({
  "node_modules/rfc6902/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = exports.objectType = exports.hasOwnProperty = void 0;
    exports.hasOwnProperty = Object.prototype.hasOwnProperty;
    function objectType(object) {
      if (object === void 0) {
        return "undefined";
      }
      if (object === null) {
        return "null";
      }
      if (Array.isArray(object)) {
        return "array";
      }
      return typeof object;
    }
    exports.objectType = objectType;
    function isNonPrimitive(value) {
      return value != null && typeof value == "object";
    }
    function clone(source) {
      if (!isNonPrimitive(source)) {
        return source;
      }
      if (source.constructor == Array) {
        var length_1 = source.length;
        var arrayTarget = new Array(length_1);
        for (var i = 0; i < length_1; i++) {
          arrayTarget[i] = clone(source[i]);
        }
        return arrayTarget;
      }
      if (source.constructor == Date) {
        var dateTarget = /* @__PURE__ */ new Date(+source);
        return dateTarget;
      }
      var objectTarget = {};
      for (var key in source) {
        if (exports.hasOwnProperty.call(source, key)) {
          objectTarget[key] = clone(source[key]);
        }
      }
      return objectTarget;
    }
    exports.clone = clone;
  }
});

// node_modules/rfc6902/diff.js
var require_diff = __commonJS({
  "node_modules/rfc6902/diff.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.diffAny = exports.diffObjects = exports.diffArrays = exports.intersection = exports.subtract = exports.isDestructive = void 0;
    var util_1 = require_util();
    function isDestructive(_a) {
      var op = _a.op;
      return op === "remove" || op === "replace" || op === "copy" || op === "move";
    }
    exports.isDestructive = isDestructive;
    function subtract(minuend, subtrahend) {
      var obj = {};
      for (var add_key in minuend) {
        if (util_1.hasOwnProperty.call(minuend, add_key) && minuend[add_key] !== void 0) {
          obj[add_key] = 1;
        }
      }
      for (var del_key in subtrahend) {
        if (util_1.hasOwnProperty.call(subtrahend, del_key) && subtrahend[del_key] !== void 0) {
          delete obj[del_key];
        }
      }
      return Object.keys(obj);
    }
    exports.subtract = subtract;
    function intersection(objects) {
      var length = objects.length;
      var counter = {};
      for (var i = 0; i < length; i++) {
        var object = objects[i];
        for (var key in object) {
          if (util_1.hasOwnProperty.call(object, key) && object[key] !== void 0) {
            counter[key] = (counter[key] || 0) + 1;
          }
        }
      }
      for (var key in counter) {
        if (counter[key] < length) {
          delete counter[key];
        }
      }
      return Object.keys(counter);
    }
    exports.intersection = intersection;
    function isArrayAdd(array_operation) {
      return array_operation.op === "add";
    }
    function isArrayRemove(array_operation) {
      return array_operation.op === "remove";
    }
    function appendArrayOperation(base, operation) {
      return {
        // the new operation must be pushed on the end
        operations: base.operations.concat(operation),
        cost: base.cost + 1
      };
    }
    function diffArrays(input, output, ptr, diff) {
      if (diff === void 0) {
        diff = diffAny;
      }
      var memo = {
        "0,0": { operations: [], cost: 0 }
      };
      function dist(i, j) {
        var memo_key = "".concat(i, ",").concat(j);
        var memoized = memo[memo_key];
        if (memoized === void 0) {
          if (i > 0 && j > 0 && !diff(input[i - 1], output[j - 1], ptr.add(String(i - 1))).length) {
            memoized = dist(i - 1, j - 1);
          } else {
            var alternatives = [];
            if (i > 0) {
              var remove_base = dist(i - 1, j);
              var remove_operation = {
                op: "remove",
                index: i - 1
              };
              alternatives.push(appendArrayOperation(remove_base, remove_operation));
            }
            if (j > 0) {
              var add_base = dist(i, j - 1);
              var add_operation = {
                op: "add",
                index: i - 1,
                value: output[j - 1]
              };
              alternatives.push(appendArrayOperation(add_base, add_operation));
            }
            if (i > 0 && j > 0) {
              var replace_base = dist(i - 1, j - 1);
              var replace_operation = {
                op: "replace",
                index: i - 1,
                original: input[i - 1],
                value: output[j - 1]
              };
              alternatives.push(appendArrayOperation(replace_base, replace_operation));
            }
            var best = alternatives.sort(function(a, b) {
              return a.cost - b.cost;
            })[0];
            memoized = best;
          }
          memo[memo_key] = memoized;
        }
        return memoized;
      }
      var input_length = isNaN(input.length) || input.length <= 0 ? 0 : input.length;
      var output_length = isNaN(output.length) || output.length <= 0 ? 0 : output.length;
      var array_operations = dist(input_length, output_length).operations;
      var padded_operations = array_operations.reduce(function(_a, array_operation) {
        var operations = _a[0], padding = _a[1];
        if (isArrayAdd(array_operation)) {
          var padded_index = array_operation.index + 1 + padding;
          var index_token = padded_index < input_length + padding ? String(padded_index) : "-";
          var operation = {
            op: array_operation.op,
            path: ptr.add(index_token).toString(),
            value: array_operation.value
          };
          return [operations.concat(operation), padding + 1];
        } else if (isArrayRemove(array_operation)) {
          var operation = {
            op: array_operation.op,
            path: ptr.add(String(array_operation.index + padding)).toString()
          };
          return [operations.concat(operation), padding - 1];
        } else {
          var replace_ptr = ptr.add(String(array_operation.index + padding));
          var replace_operations = diff(array_operation.original, array_operation.value, replace_ptr);
          return [operations.concat.apply(operations, replace_operations), padding];
        }
      }, [[], 0])[0];
      return padded_operations;
    }
    exports.diffArrays = diffArrays;
    function diffObjects(input, output, ptr, diff) {
      if (diff === void 0) {
        diff = diffAny;
      }
      var operations = [];
      subtract(input, output).forEach(function(key) {
        operations.push({ op: "remove", path: ptr.add(key).toString() });
      });
      subtract(output, input).forEach(function(key) {
        operations.push({ op: "add", path: ptr.add(key).toString(), value: output[key] });
      });
      intersection([input, output]).forEach(function(key) {
        operations.push.apply(operations, diff(input[key], output[key], ptr.add(key)));
      });
      return operations;
    }
    exports.diffObjects = diffObjects;
    function diffAny(input, output, ptr, diff) {
      if (diff === void 0) {
        diff = diffAny;
      }
      if (input === output) {
        return [];
      }
      var input_type = (0, util_1.objectType)(input);
      var output_type = (0, util_1.objectType)(output);
      if (input_type == "array" && output_type == "array") {
        return diffArrays(input, output, ptr, diff);
      }
      if (input_type == "object" && output_type == "object") {
        return diffObjects(input, output, ptr, diff);
      }
      return [{ op: "replace", path: ptr.toString(), value: output }];
    }
    exports.diffAny = diffAny;
  }
});

// node_modules/rfc6902/patch.js
var require_patch = __commonJS({
  "node_modules/rfc6902/patch.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apply = exports.InvalidOperationError = exports.test = exports.copy = exports.move = exports.replace = exports.remove = exports.add = exports.TestError = exports.MissingError = void 0;
    var pointer_1 = require_pointer();
    var util_1 = require_util();
    var diff_1 = require_diff();
    var MissingError = (
      /** @class */
      function(_super) {
        __extends(MissingError2, _super);
        function MissingError2(path) {
          var _this = _super.call(this, "Value required at path: ".concat(path)) || this;
          _this.path = path;
          _this.name = "MissingError";
          return _this;
        }
        return MissingError2;
      }(Error)
    );
    exports.MissingError = MissingError;
    var TestError = (
      /** @class */
      function(_super) {
        __extends(TestError2, _super);
        function TestError2(actual, expected) {
          var _this = _super.call(this, "Test failed: ".concat(actual, " != ").concat(expected)) || this;
          _this.actual = actual;
          _this.expected = expected;
          _this.name = "TestError";
          return _this;
        }
        return TestError2;
      }(Error)
    );
    exports.TestError = TestError;
    function _add(object, key, value) {
      if (Array.isArray(object)) {
        if (key == "-") {
          object.push(value);
        } else {
          var index = parseInt(key, 10);
          object.splice(index, 0, value);
        }
      } else {
        object[key] = value;
      }
    }
    function _remove(object, key) {
      if (Array.isArray(object)) {
        var index = parseInt(key, 10);
        object.splice(index, 1);
      } else {
        delete object[key];
      }
    }
    function add(object, operation) {
      var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);
      if (endpoint.parent === void 0) {
        return new MissingError(operation.path);
      }
      _add(endpoint.parent, endpoint.key, (0, util_1.clone)(operation.value));
      return null;
    }
    exports.add = add;
    function remove(object, operation) {
      var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);
      if (endpoint.value === void 0) {
        return new MissingError(operation.path);
      }
      _remove(endpoint.parent, endpoint.key);
      return null;
    }
    exports.remove = remove;
    function replace(object, operation) {
      var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);
      if (endpoint.parent === null) {
        return new MissingError(operation.path);
      }
      if (Array.isArray(endpoint.parent)) {
        if (parseInt(endpoint.key, 10) >= endpoint.parent.length) {
          return new MissingError(operation.path);
        }
      } else if (endpoint.value === void 0) {
        return new MissingError(operation.path);
      }
      endpoint.parent[endpoint.key] = (0, util_1.clone)(operation.value);
      return null;
    }
    exports.replace = replace;
    function move(object, operation) {
      var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);
      if (from_endpoint.value === void 0) {
        return new MissingError(operation.from);
      }
      var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);
      if (endpoint.parent === void 0) {
        return new MissingError(operation.path);
      }
      _remove(from_endpoint.parent, from_endpoint.key);
      _add(endpoint.parent, endpoint.key, from_endpoint.value);
      return null;
    }
    exports.move = move;
    function copy(object, operation) {
      var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);
      if (from_endpoint.value === void 0) {
        return new MissingError(operation.from);
      }
      var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);
      if (endpoint.parent === void 0) {
        return new MissingError(operation.path);
      }
      _add(endpoint.parent, endpoint.key, (0, util_1.clone)(from_endpoint.value));
      return null;
    }
    exports.copy = copy;
    function test(object, operation) {
      var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);
      if ((0, diff_1.diffAny)(endpoint.value, operation.value, new pointer_1.Pointer()).length) {
        return new TestError(endpoint.value, operation.value);
      }
      return null;
    }
    exports.test = test;
    var InvalidOperationError = (
      /** @class */
      function(_super) {
        __extends(InvalidOperationError2, _super);
        function InvalidOperationError2(operation) {
          var _this = _super.call(this, "Invalid operation: ".concat(operation.op)) || this;
          _this.operation = operation;
          _this.name = "InvalidOperationError";
          return _this;
        }
        return InvalidOperationError2;
      }(Error)
    );
    exports.InvalidOperationError = InvalidOperationError;
    function apply(object, operation) {
      switch (operation.op) {
        case "add":
          return add(object, operation);
        case "remove":
          return remove(object, operation);
        case "replace":
          return replace(object, operation);
        case "move":
          return move(object, operation);
        case "copy":
          return copy(object, operation);
        case "test":
          return test(object, operation);
      }
      return new InvalidOperationError(operation);
    }
    exports.apply = apply;
  }
});

// node_modules/rfc6902/index.js
var require_rfc6902 = __commonJS({
  "node_modules/rfc6902/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTests = exports.createPatch = exports.applyPatch = exports.Pointer = void 0;
    var pointer_1 = require_pointer();
    Object.defineProperty(exports, "Pointer", { enumerable: true, get: function() {
      return pointer_1.Pointer;
    } });
    var patch_1 = require_patch();
    var diff_1 = require_diff();
    function applyPatch(object, patch) {
      return patch.map(function(operation) {
        return (0, patch_1.apply)(object, operation);
      });
    }
    exports.applyPatch = applyPatch;
    function wrapVoidableDiff(diff) {
      function wrappedDiff(input, output, ptr) {
        var custom_patch = diff(input, output, ptr);
        return Array.isArray(custom_patch) ? custom_patch : (0, diff_1.diffAny)(input, output, ptr, wrappedDiff);
      }
      return wrappedDiff;
    }
    function createPatch(input, output, diff) {
      var ptr = new pointer_1.Pointer();
      return (diff ? wrapVoidableDiff(diff) : diff_1.diffAny)(input, output, ptr);
    }
    exports.createPatch = createPatch;
    function createTest(input, path) {
      var endpoint = pointer_1.Pointer.fromJSON(path).evaluate(input);
      if (endpoint !== void 0) {
        return { op: "test", path, value: endpoint.value };
      }
    }
    function createTests(input, patch) {
      var tests = new Array();
      patch.filter(diff_1.isDestructive).forEach(function(operation) {
        var pathTest = createTest(input, operation.path);
        if (pathTest)
          tests.push(pathTest);
        if ("from" in operation) {
          var fromTest = createTest(input, operation.from);
          if (fromTest)
            tests.push(fromTest);
        }
      });
      return tests;
    }
    exports.createTests = createTests;
  }
});
export default require_rfc6902();
//# sourceMappingURL=rfc6902.js.map
