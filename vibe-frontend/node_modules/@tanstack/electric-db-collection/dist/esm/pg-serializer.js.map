{"version":3,"file":"pg-serializer.js","sources":["../../src/pg-serializer.ts"],"sourcesContent":["/**\n * Serialize values for Electric SQL subset parameters.\n *\n * IMPORTANT: Electric expects RAW values, NOT SQL-formatted literals.\n * Electric handles all type casting and escaping on the server side.\n * The params Record<string, string> contains the actual values as strings,\n * and Electric will parse/cast them based on the column type in the WHERE clause.\n *\n * @param value - The value to serialize\n * @returns The raw value as a string (no SQL formatting/quoting)\n */\nexport function serialize(value: unknown): string {\n  // Handle null/undefined - return empty string\n  // Electric interprets empty string as NULL in typed column context\n  if (value === null || value === undefined) {\n    return ``\n  }\n\n  // Handle strings - return as-is (NO quotes, Electric handles escaping)\n  if (typeof value === `string`) {\n    return value\n  }\n\n  // Handle numbers - convert to string\n  if (typeof value === `number`) {\n    return value.toString()\n  }\n\n  // Handle bigints - convert to string\n  if (typeof value === `bigint`) {\n    return value.toString()\n  }\n\n  // Handle booleans - return as lowercase string\n  if (typeof value === `boolean`) {\n    return value ? `true` : `false`\n  }\n\n  // Handle dates - return ISO format (NO quotes)\n  if (value instanceof Date) {\n    return value.toISOString()\n  }\n\n  // Handle arrays - for = ANY() operator, serialize as Postgres array literal\n  // Format: {val1,val2,val3} with proper escaping\n  if (Array.isArray(value)) {\n    // Postgres array literal format uses curly braces\n    const elements = value.map((item) => {\n      if (item === null || item === undefined) {\n        return `NULL`\n      }\n      if (typeof item === `string`) {\n        // Escape quotes and backslashes for Postgres array literals\n        const escaped = item.replace(/\\\\/g, `\\\\\\\\`).replace(/\"/g, `\\\\\"`)\n        return `\"${escaped}\"`\n      }\n      return serialize(item)\n    })\n    return `{${elements.join(`,`)}}`\n  }\n\n  // Safely stringify the value for the error message\n  // JSON.stringify can't handle BigInt and other types, so we use a try-catch\n  let valueStr: string\n  try {\n    valueStr = JSON.stringify(value)\n  } catch {\n    valueStr = String(value)\n  }\n  throw new Error(`Cannot serialize value: ${valueStr}`)\n}\n"],"names":[],"mappings":"AAWO,SAAS,UAAU,OAAwB;AAGhD,MAAI,UAAU,QAAQ,UAAU,QAAW;AACzC,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO,MAAM,SAAA;AAAA,EACf;AAGA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO,MAAM,SAAA;AAAA,EACf;AAGA,MAAI,OAAO,UAAU,WAAW;AAC9B,WAAO,QAAQ,SAAS;AAAA,EAC1B;AAGA,MAAI,iBAAiB,MAAM;AACzB,WAAO,MAAM,YAAA;AAAA,EACf;AAIA,MAAI,MAAM,QAAQ,KAAK,GAAG;AAExB,UAAM,WAAW,MAAM,IAAI,CAAC,SAAS;AACnC,UAAI,SAAS,QAAQ,SAAS,QAAW;AACvC,eAAO;AAAA,MACT;AACA,UAAI,OAAO,SAAS,UAAU;AAE5B,cAAM,UAAU,KAAK,QAAQ,OAAO,MAAM,EAAE,QAAQ,MAAM,KAAK;AAC/D,eAAO,IAAI,OAAO;AAAA,MACpB;AACA,aAAO,UAAU,IAAI;AAAA,IACvB,CAAC;AACD,WAAO,IAAI,SAAS,KAAK,GAAG,CAAC;AAAA,EAC/B;AAIA,MAAI;AACJ,MAAI;AACF,eAAW,KAAK,UAAU,KAAK;AAAA,EACjC,QAAQ;AACN,eAAW,OAAO,KAAK;AAAA,EACzB;AACA,QAAM,IAAI,MAAM,2BAA2B,QAAQ,EAAE;AACvD;"}