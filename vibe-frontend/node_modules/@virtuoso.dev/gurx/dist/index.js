var T = Object.defineProperty;
var L = (s, t, e) => t in s ? T(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var g = (s, t, e) => L(s, typeof t != "symbol" ? t + "" : t, e);
import * as p from "react";
import { jsx as A } from "react/jsx-runtime";
class x {
  constructor(t = /* @__PURE__ */ new Map()) {
    this.map = t;
  }
  clone() {
    return new x(new Map(this.map));
  }
  decrement(t, e) {
    let n = this.map.get(t);
    n !== void 0 && (n -= 1, this.map.set(t, n), n === 0 && e());
  }
  increment(t) {
    const e = this.map.get(t) ?? 0;
    this.map.set(t, e + 1);
  }
}
class C {
  constructor() {
    g(this, "map", /* @__PURE__ */ new Map());
  }
  delete(t) {
    return this.map.delete(t);
  }
  get(t) {
    return this.map.get(t);
  }
  getOrCreate(t) {
    let e = this.map.get(t);
    return e === void 0 && (e = /* @__PURE__ */ new Set(), this.map.set(t, e)), e;
  }
  use(t, e) {
    const n = this.get(t);
    n !== void 0 && e(n);
  }
}
function m(s, t) {
  return t(s), s;
}
function E() {
}
const V = "cell", j = "signal", W = "pipe";
function R(s, t) {
  return s === t;
}
const w = /* @__PURE__ */ new Map();
let M;
class K {
  /**
   * Creates a new realm.
   * @param initialValues - the initial cell values that will populate the realm.
   * Those values will not trigger a recomputation cycle, and will overwrite the initial values specified for each cell.
   */
  constructor(t = {}) {
    g(this, "definitionRegistry", /* @__PURE__ */ new Set());
    g(this, "distinctNodes", /* @__PURE__ */ new Map());
    g(this, "executionMaps", /* @__PURE__ */ new Map());
    g(this, "graph", new C());
    g(this, "pipeMap", /* @__PURE__ */ new Map());
    g(this, "singletonSubscriptions", /* @__PURE__ */ new Map());
    g(this, "state", /* @__PURE__ */ new Map());
    g(this, "subscriptions", new C());
    for (const e of Object.getOwnPropertySymbols(t))
      this.state.set(e, t[e]);
  }
  /**
   * Creates or resolves an existing cell instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the cell.
   * @param value - the initial value of the cell
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a cell. If the cell has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  cellInstance(t, e = !0, n = Symbol()) {
    return this.state.has(n) || this.state.set(n, t), e !== !1 && !this.distinctNodes.has(n) && this.distinctNodes.set(n, e === !0 ? R : e), n;
  }
  /**
   * Convenient for mutation of cells that contian non-primitive values (e.g. arrays, or objects).
   * Specifies that the cell value should be changed when source emits, with the result of the map callback parameter.
   * the map parameter gets called with the current value of the cell and the value published through the source.
   * @typeParam T - the type of the cell value.
   * @typeParam K - the type of the value published through the source.
   * @example
   * ```ts
   * const items$ = Cell<string[]([])
   * const addItem$ = Signal<string>(false, (r) => {
   *   r.changeWith(items$, addItem$, (items, item) => [...items, item])
   * })
   * const r = new Realm()
   * r.pub(addItem$, 'foo')
   * r.pub(addItem$, 'bar')
   * r.getValue(items$) // ['foo', 'bar']
   * ```
   */
  changeWith(t, e, n) {
    this.connect({
      map: (i) => (r, o) => {
        i(n(o, r));
      },
      pulls: [t],
      sink: t,
      sources: [e]
    });
  }
  // prettier-ignore
  combine(...t) {
    return m(this.signalInstance(), (e) => {
      this.connect({
        map: (n) => (...i) => {
          n(i);
        },
        sink: e,
        sources: t
      });
    });
  }
  // prettier-ignore
  combineCells(...t) {
    return m(
      this.cellInstance(
        t.map((e) => this.getValue(e)),
        !0
      ),
      (e) => {
        this.connect({
          map: (n) => (...i) => {
            n(i);
          },
          sink: e,
          sources: t
        });
      }
    );
  }
  /**
   * A low-level utility that connects multiple nodes to a sink node with a map function. Used as a foundation for the higher-level operators.
   * The nodes can be active (sources) or passive (pulls).
   */
  connect({
    map: t,
    pulls: e = [],
    sink: n,
    sources: i
  }) {
    const r = {
      map: t,
      pulls: new Set(e),
      sink: this.register(n),
      sources: new Set(i)
    };
    for (const o of [...i, ...e])
      this.register(o), this.graph.getOrCreate(o).add(r);
    this.executionMaps.clear();
  }
  /**
   * Gets the current value of a node. The node must be stateful.
   * @remark if possible, use {@link withLatestFrom} or {@link combine}, as getValue will not create a dependency to the passed node,
   * which means that if you call it within a computational cycle, you may not get the correct value.
   * @param node - the node instance.
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   *
   * const r = new Realm()
   * r.getValue(foo$) // 'foo'
   * r.pub(foo$, 'bar')
   * //...
   * r.getValue(foo$) // 'bar'
   * ```
   */
  getValue(t) {
    return this.register(t), this.state.get(t);
  }
  getValues(t) {
    return t.map((e) => this.getValue(e));
  }
  inContext(t) {
    const e = M;
    M = this;
    const n = t();
    return M = e, n;
  }
  /**
   * Links the output of a node to the input of another node.
   */
  link(t, e) {
    this.connect({
      map: (n) => (i) => {
        n(i);
      },
      sink: e,
      sources: [t]
    });
  }
  pipe(t, ...e) {
    return this.combineOperators(...e)(t);
  }
  pub(t, e) {
    this.pubIn({ [t]: e });
  }
  /**
   * Publishes into multiple nodes simultaneously, triggering a single re-computation cycle.
   * @param values - a record of node references and their values.
   *
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   * const bar$ = Cell('bar')
   *
   * const r = new Realm()
   * r.pubIn({[foo$]: 'foo1', [bar$]: 'bar1'})
   * ```
   */
  pubIn(t) {
    var y;
    const e = Reflect.ownKeys(t).map((a) => this.pipeMap.get(a) ?? a), n = Reflect.ownKeys(t).reduce((a, u) => {
      const h = u, S = t[h], f = this.pipeMap.get(h) ?? h;
      return a[f] = S, a;
    }, {}), i = this.getExecutionMap(e), r = i.refCount.clone(), o = i.participatingNodes.slice(), c = new Map(this.state), l = (a) => {
      this.graph.use(a, (u) => {
        for (const { sink: h, sources: S } of u)
          S.has(a) && r.decrement(h, () => {
            o.splice(o.indexOf(h), 1), l(h);
          });
      });
    };
    for (; ; ) {
      const a = o.shift();
      if (a === void 0)
        break;
      const u = a;
      let h = !1;
      const S = (f) => {
        const b = this.distinctNodes.get(u);
        if (b != null && b(c.get(u), f)) {
          h = !1;
          return;
        }
        h = !0, c.set(u, f), this.state.has(u) && this.state.set(u, f);
      };
      if (Object.hasOwn(n, u) ? S(n[u]) : i.projections.use(u, (f) => {
        for (const b of f) {
          const k = [...Array.from(b.sources), ...Array.from(b.pulls)].map((v) => c.get(v));
          b.map(S)(...k);
        }
      }), h) {
        const f = c.get(u);
        this.inContext(() => {
          this.subscriptions.use(u, (b) => {
            for (const k of b)
              k(f);
          });
        }), (y = this.singletonSubscriptions.get(u)) == null || y(f);
      } else
        l(u);
    }
  }
  /**
   * Explicitly includes the specified cell/signal/pipe reference in the realm.
   * Most of the time you don't need to do that, since any interaction with the node through a realm will register it.
   * The only exception of that rule should be when the interaction is conditional, and the node definition includes an init function that needs to be eagerly evaluated.
   */
  register(t) {
    const e = w.get(t);
    if (e === void 0)
      return t;
    if (!this.definitionRegistry.has(t)) {
      if (this.definitionRegistry.add(t), e.type === V)
        return m(this.cellInstance(e.initial, e.distinct, t), (o) => {
          this.inContext(() => {
            e.init(this, o);
          });
        });
      if (e.type === j)
        return m(this.signalInstance(e.distinct, t), (o) => {
          this.inContext(() => {
            e.init(this, o);
          });
        });
      const n = this.signalInstance(e.distinct), i = this.cellInstance(e.initial, !0), r = this.cellInstance(e.initial, e.distinct, t);
      return this.link(i, r), this.pipeMap.set(r, n), this.inContext(() => {
        e.init(this, n, i);
      }), r;
    }
    return t;
  }
  /**
   * Clears all exclusive subscriptions.
   */
  resetSingletonSubs() {
    this.singletonSubscriptions.clear();
  }
  /**
   * Creates or resolves an existing signal instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the signal.
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a signal. If the signal has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  signalInstance(t = !0, e = Symbol()) {
    return t !== !1 && this.distinctNodes.set(e, t === !0 ? R : t), e;
  }
  /**
   * Subscribes exclusively to values in the referred node.
   * Calling this multiple times on a single node will remove the previous subscription created through `singletonSub`.
   * Subscriptions created through `sub` are not affected.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * // console.log will run only once.
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.pub(signal$, 2)
   * ```
   */
  singletonSub(t, e) {
    return this.register(t), e === void 0 ? this.singletonSubscriptions.delete(t) : this.singletonSubscriptions.set(t, e), () => this.singletonSubscriptions.delete(t);
  }
  /**
   * Subscribes to the values published in the referred node.
   * @param node - the cell/signal to subscribe to.
   * @param subscription - the callback to execute when the node receives a new value.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * const unsub = r.sub(signal$, console.log)
   * r.pub(signal$, 2)
   * unsub()
   * r.pub(signal$, 3)
   * ```
   */
  sub(t, e) {
    this.register(t);
    const n = this.subscriptions.getOrCreate(t);
    return n.add(e), () => n.delete(e);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  subMultiple(t, e) {
    const n = this.signalInstance();
    return this.connect({
      map: (i) => (...r) => {
        i(r);
      },
      sink: n,
      sources: t
    }), this.sub(n, e);
  }
  transformer(...t) {
    return (e) => m(this.signalInstance(), (n) => (this.link(this.pipe(n, ...t), e), n));
  }
  calculateExecutionMap(t) {
    const e = [], n = /* @__PURE__ */ new Set(), i = new C(), r = new x(), o = new C(), c = (l, y = 0) => {
      r.increment(l), !n.has(l) && (this.register(l), i.use(l, (a) => {
        y = Math.max(...Array.from(a).map((u) => e.indexOf(u))) + 1;
      }), this.graph.use(l, (a) => {
        for (const u of a)
          u.sources.has(l) ? (o.getOrCreate(u.sink).add(u), c(u.sink, y)) : i.getOrCreate(u.sink).add(l);
      }), n.add(l), e.splice(y, 0, l));
    };
    return t.forEach(c), { participatingNodes: e, pendingPulls: i, projections: o, refCount: r };
  }
  combineOperators(...t) {
    return (e) => {
      for (const n of t)
        e = n(e, this);
      return e;
    };
  }
  getExecutionMap(t) {
    let e = t;
    if (t.length === 1) {
      e = t[0];
      const i = this.executionMaps.get(e);
      if (i !== void 0)
        return i;
    } else
      for (const [i, r] of this.executionMaps.entries())
        if (Array.isArray(i) && i.length === t.length && i.every((o) => t.includes(o)))
          return r;
    const n = this.calculateExecutionMap(t);
    return this.executionMaps.set(e, n), n;
  }
}
function G(s, t = E, e = !0) {
  return m(Symbol(), (n) => {
    w.set(n, { distinct: e, init: t, initial: s, type: V });
  });
}
function Y(s, t, e = !0) {
  return m(Symbol(), (n) => {
    w.set(n, { distinct: e, init: t, initial: s, type: W });
  });
}
function z(s, t, e = !0) {
  return m(Symbol(), (n) => {
    w.set(n, {
      distinct: e,
      init: (i, r) => {
        i.link(t(i, r), r);
      },
      initial: s,
      type: V
    });
  });
}
function B(s = E, t = !1) {
  return m(Symbol(), (e) => {
    w.set(e, { distinct: t, init: s, type: "signal" });
  });
}
function H(s = E) {
  return m(Symbol(), (t) => {
    w.set(t, { distinct: !1, init: s, type: "signal" });
  });
}
function d() {
  if (!M)
    throw new Error("This function must be called within a realm instance");
  return M;
}
const J = (s, t) => {
  d().link(s, t);
}, X = (...s) => {
  d().pub(...s);
}, Z = (...s) => d().sub(...s), $ = (...s) => {
  d().pubIn(...s);
}, tt = (...s) => d().pipe(...s), et = (...s) => {
  d().changeWith(...s);
}, nt = (...s) => d().combine(...s), st = (s) => d().getValue(s), N = { data: null, error: null, isLoading: !0, type: "loading" };
function it(s, t) {
  return Y(N, (e, n, i) => {
    function r(o) {
      e.pub(i, N), s(o).then((c) => {
        e.pub(i, { data: c, error: null, isLoading: !1, type: "success" });
      }).catch((c) => {
        e.pub(i, { data: null, error: c, isLoading: !1, type: "error" });
      });
    }
    r(t), e.sub(n, r);
  });
}
const O = p.createContext(null);
function rt({
  children: s,
  initWith: t,
  updateWith: e = {}
}) {
  const n = p.useMemo(() => new K(t), []);
  return p.useEffect(() => {
    n.pubIn(e);
  }, [e, n]), /* @__PURE__ */ A(O.Provider, { value: n, children: s });
}
const _ = typeof document < "u" ? p.useLayoutEffect : p.useEffect;
function I() {
  const s = p.useContext(O);
  if (s === null)
    throw new Error("useRealm must be used within a RealmContextProvider");
  return s;
}
function Q(s) {
  const t = I();
  t.register(s);
  const e = p.useCallback((n) => t.sub(s, n), [t, s]);
  return p.useSyncExternalStore(
    e,
    () => t.getValue(s),
    () => t.getValue(s)
  );
}
function D(s) {
  const t = I();
  t.register(s);
  const [e, n] = p.useState(() => t.getValue(s));
  return _(() => {
    const i = t.sub(s, () => {
      n(() => t.getValue(s));
    });
    return () => {
      i();
    };
  }, [t, s]), e;
}
const P = "useSyncExternalStore" in p ? Q : D;
function ot(...s) {
  const t = I(), e = p.useMemo(() => t.combineCells(...s), [t, ...s]);
  return P(e);
}
function U(s) {
  const t = I();
  return t.register(s), p.useCallback(
    (e) => {
      t.pub(s, e);
    },
    [t, s]
  );
}
function ut(s) {
  return [P(s), U(s)];
}
function ct(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (r) => {
        i(s(r));
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function at(...s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (...r) => {
        i(r);
      },
      pulls: s,
      sink: n,
      sources: [t]
    }), n;
  };
}
function lt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => () => {
        i(s);
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function pt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (r) => {
        s(r) && i(r);
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function ht() {
  return (s, t) => {
    const e = t.signalInstance();
    let n = !1;
    return t.connect({
      map: (i) => (r) => {
        n || (n = !0, i(r));
      },
      sink: e,
      sources: [s]
    }), e;
  };
}
function ft(s, t) {
  return (e, n) => {
    const i = n.signalInstance();
    return n.connect({
      map: (r) => (o) => {
        r(t = s(t, o));
      },
      sink: i,
      sources: [e]
    }), i;
  };
}
function gt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    let i, r = null;
    return e.sub(t, (o) => {
      i = o, r === null && (r = setTimeout(() => {
        r = null, e.pub(n, i);
      }, s));
    }), n;
  };
}
function mt(s) {
  return (t, e) => {
    const n = e.signalInstance();
    let i, r = null;
    return e.sub(t, (o) => {
      i = o, r !== null && clearTimeout(r), r = setTimeout(() => {
        e.pub(n, i);
      }, s);
    }), n;
  };
}
function bt() {
  return (s, t) => {
    const e = t.signalInstance();
    return t.sub(s, (n) => {
      queueMicrotask(() => {
        t.pub(e, n);
      });
    }), e;
  };
}
function dt(s) {
  return (t, e) => {
    const n = e.signalInstance(), i = Symbol();
    let r = i;
    return e.connect({
      map: (o) => (c) => {
        r !== i && (o([r, c]), r = i);
      },
      sink: n,
      sources: [s]
    }), e.sub(t, (o) => {
      r = o;
    }), n;
  };
}
function yt(s, t, e) {
  return (n, i) => {
    const r = i.signalInstance();
    return i.sub(n, (o) => {
      o !== null && typeof o == "object" && "then" in o ? (i.pub(r, s()), o.then((c) => {
        i.pub(r, t(c));
      }).catch((c) => {
        i.pub(r, e(c));
      })) : i.pub(r, t(o));
    }), r;
  };
}
export {
  H as Action,
  it as AsyncQuery,
  G as Cell,
  z as DerivedCell,
  Y as Pipe,
  K as Realm,
  O as RealmContext,
  rt as RealmProvider,
  B as Signal,
  et as changeWith,
  nt as combine,
  mt as debounceTime,
  R as defaultComparator,
  bt as delayWithMicrotask,
  pt as filter,
  st as getValue,
  yt as handlePromise,
  J as link,
  ct as map,
  lt as mapTo,
  dt as onNext,
  ht as once,
  tt as pipe,
  X as pub,
  $ as pubIn,
  ft as scan,
  Z as sub,
  gt as throttleTime,
  ut as useCell,
  P as useCellValue,
  ot as useCellValues,
  U as usePublisher,
  I as useRealm,
  at as withLatestFrom
};
