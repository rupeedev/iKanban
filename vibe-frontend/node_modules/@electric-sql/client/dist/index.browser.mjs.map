{"version":3,"sources":["../src/error.ts","../src/parser.ts","../src/column-mapper.ts","../src/helpers.ts","../src/constants.ts","../src/fetch.ts","../src/expression-compiler.ts","../src/client.ts","../src/expired-shapes-cache.ts","../src/up-to-date-tracker.ts","../src/snapshot-tracker.ts","../src/shape.ts"],"sourcesContent":["export class FetchError extends Error {\n  status: number\n  text?: string\n  json?: object\n  headers: Record<string, string>\n\n  constructor(\n    status: number,\n    text: string | undefined,\n    json: object | undefined,\n    headers: Record<string, string>,\n    public url: string,\n    message?: string\n  ) {\n    super(\n      message ||\n        `HTTP Error ${status} at ${url}: ${text ?? JSON.stringify(json)}`\n    )\n    this.name = `FetchError`\n    this.status = status\n    this.text = text\n    this.json = json\n    this.headers = headers\n  }\n\n  static async fromResponse(\n    response: Response,\n    url: string\n  ): Promise<FetchError> {\n    const status = response.status\n    const headers = Object.fromEntries([...response.headers.entries()])\n    let text: string | undefined = undefined\n    let json: object | undefined = undefined\n\n    const contentType = response.headers.get(`content-type`)\n    if (!response.bodyUsed) {\n      if (contentType && contentType.includes(`application/json`)) {\n        json = (await response.json()) as object\n      } else {\n        text = await response.text()\n      }\n    }\n\n    return new FetchError(status, text, json, headers, url)\n  }\n}\n\nexport class FetchBackoffAbortError extends Error {\n  constructor() {\n    super(`Fetch with backoff aborted`)\n    this.name = `FetchBackoffAbortError`\n  }\n}\n\nexport class InvalidShapeOptionsError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = `InvalidShapeOptionsError`\n  }\n}\n\nexport class MissingShapeUrlError extends Error {\n  constructor() {\n    super(`Invalid shape options: missing required url parameter`)\n    this.name = `MissingShapeUrlError`\n  }\n}\n\nexport class InvalidSignalError extends Error {\n  constructor() {\n    super(`Invalid signal option. It must be an instance of AbortSignal.`)\n    this.name = `InvalidSignalError`\n  }\n}\n\nexport class MissingShapeHandleError extends Error {\n  constructor() {\n    super(\n      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`\n    )\n    this.name = `MissingShapeHandleError`\n  }\n}\n\nexport class ReservedParamError extends Error {\n  constructor(reservedParams: string[]) {\n    super(\n      `Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`\n    )\n    this.name = `ReservedParamError`\n  }\n}\n\nexport class ParserNullValueError extends Error {\n  constructor(columnName: string) {\n    super(`Column \"${columnName ?? `unknown`}\" does not allow NULL values`)\n    this.name = `ParserNullValueError`\n  }\n}\n\nexport class ShapeStreamAlreadyRunningError extends Error {\n  constructor() {\n    super(`ShapeStream is already running`)\n    this.name = `ShapeStreamAlreadyRunningError`\n  }\n}\n\nexport class MissingHeadersError extends Error {\n  constructor(url: string, missingHeaders: Array<string>) {\n    let msg = `The response for the shape request to ${url} didn't include the following required headers:\\n`\n    missingHeaders.forEach((h) => {\n      msg += `- ${h}\\n`\n    })\n    msg += `\\nThis is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`\n    msg += `\\nFor more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`\n    super(msg)\n  }\n}\n","import { ColumnInfo, GetExtensions, Row, Schema, Value } from './types'\nimport { ParserNullValueError } from './error'\n\ntype Token = string\ntype NullableToken = Token | null\nexport type ParseFunction<Extensions = never> = (\n  value: Token,\n  additionalInfo?: Omit<ColumnInfo, `type` | `dims`>\n) => Value<Extensions>\ntype NullableParseFunction<Extensions = never> = (\n  value: NullableToken,\n  additionalInfo?: Omit<ColumnInfo, `type` | `dims`>\n) => Value<Extensions>\n/**\n * @typeParam Extensions - Additional types that can be parsed by this parser beyond the standard SQL types.\n *                         Defaults to no additional types.\n */\nexport type Parser<Extensions = never> = {\n  [key: string]: ParseFunction<Extensions>\n}\n\nexport type TransformFunction<Extensions = never> = (\n  message: Row<Extensions>\n) => Row<Extensions>\n\nconst parseNumber = (value: string) => Number(value)\nconst parseBool = (value: string) => value === `true` || value === `t`\nconst parseBigInt = (value: string) => BigInt(value)\nconst parseJson = (value: string) => JSON.parse(value)\nconst identityParser: ParseFunction = (v: string) => v\n\nexport const defaultParser: Parser = {\n  int2: parseNumber,\n  int4: parseNumber,\n  int8: parseBigInt,\n  bool: parseBool,\n  float4: parseNumber,\n  float8: parseNumber,\n  json: parseJson,\n  jsonb: parseJson,\n}\n\n// Taken from: https://github.com/electric-sql/pglite/blob/main/packages/pglite/src/types.ts#L233-L279\nexport function pgArrayParser<Extensions>(\n  value: Token,\n  parser?: NullableParseFunction<Extensions>\n): Value<Extensions> {\n  let i = 0\n  let char = null\n  let str = ``\n  let quoted = false\n  let last = 0\n  let p: string | undefined = undefined\n\n  function extractValue(x: Token, start: number, end: number) {\n    let val: Token | null = x.slice(start, end)\n    val = val === `NULL` ? null : val\n    return parser ? parser(val) : val\n  }\n\n  function loop(x: string): Array<Value<Extensions>> {\n    const xs = []\n    for (; i < x.length; i++) {\n      char = x[i]\n      if (quoted) {\n        if (char === `\\\\`) {\n          str += x[++i]\n        } else if (char === `\"`) {\n          xs.push(parser ? parser(str) : str)\n          str = ``\n          quoted = x[i + 1] === `\"`\n          last = i + 2\n        } else {\n          str += char\n        }\n      } else if (char === `\"`) {\n        quoted = true\n      } else if (char === `{`) {\n        last = ++i\n        xs.push(loop(x))\n      } else if (char === `}`) {\n        quoted = false\n        last < i && xs.push(extractValue(x, last, i))\n        last = i + 1\n        break\n      } else if (char === `,` && p !== `}` && p !== `\"`) {\n        xs.push(extractValue(x, last, i))\n        last = i + 1\n      }\n      p = char\n    }\n    last < i && xs.push(xs.push(extractValue(x, last, i + 1)))\n    return xs\n  }\n\n  return loop(value)[0]\n}\n\nexport class MessageParser<T extends Row<unknown>> {\n  private parser: Parser<GetExtensions<T>>\n  private transformer?: TransformFunction<GetExtensions<T>>\n  constructor(\n    parser?: Parser<GetExtensions<T>>,\n    transformer?: TransformFunction<GetExtensions<T>>\n  ) {\n    // Merge the provided parser with the default parser\n    // to use the provided parser whenever defined\n    // and otherwise fall back to the default parser\n    this.parser = { ...defaultParser, ...parser }\n    this.transformer = transformer\n  }\n\n  parse<Result>(messages: string, schema: Schema): Result {\n    return JSON.parse(messages, (key, value) => {\n      // typeof value === `object` && value !== null\n      // is needed because there could be a column named `value`\n      // and the value associated to that column will be a string or null.\n      // But `typeof null === 'object'` so we need to make an explicit check.\n      // We also parse the `old_value`, which appears on updates when `replica=full`.\n      if (\n        (key === `value` || key === `old_value`) &&\n        typeof value === `object` &&\n        value !== null\n      ) {\n        return this.transformMessageValue(value, schema)\n      }\n      return value\n    }) as Result\n  }\n\n  /**\n   * Parse an array of ChangeMessages from a snapshot response.\n   * Applies type parsing and transformations to the value and old_value properties.\n   */\n  parseSnapshotData<Result>(\n    messages: Array<unknown>,\n    schema: Schema\n  ): Array<Result> {\n    return messages.map((message) => {\n      const msg = message as Record<string, unknown>\n\n      // Transform the value property if it exists\n      if (msg.value && typeof msg.value === `object` && msg.value !== null) {\n        msg.value = this.transformMessageValue(msg.value, schema)\n      }\n\n      // Transform the old_value property if it exists\n      if (\n        msg.old_value &&\n        typeof msg.old_value === `object` &&\n        msg.old_value !== null\n      ) {\n        msg.old_value = this.transformMessageValue(msg.old_value, schema)\n      }\n\n      return msg as Result\n    })\n  }\n\n  /**\n   * Transform a message value or old_value object by parsing its columns.\n   */\n  private transformMessageValue(\n    value: unknown,\n    schema: Schema\n  ): Row<GetExtensions<T>> {\n    const row = value as Record<string, Value<GetExtensions<T>>>\n    Object.keys(row).forEach((key) => {\n      row[key] = this.parseRow(key, row[key] as NullableToken, schema)\n    })\n\n    return this.transformer ? this.transformer(row) : row\n  }\n\n  // Parses the message values using the provided parser based on the schema information\n  private parseRow(\n    key: string,\n    value: NullableToken,\n    schema: Schema\n  ): Value<GetExtensions<T>> {\n    const columnInfo = schema[key]\n    if (!columnInfo) {\n      // We don't have information about the value\n      // so we just return it\n      return value\n    }\n\n    // Copy the object but don't include `dimensions` and `type`\n    const { type: typ, dims: dimensions, ...additionalInfo } = columnInfo\n\n    // Pick the right parser for the type\n    // and support parsing null values if needed\n    // if no parser is provided for the given type, just return the value as is\n    const typeParser = this.parser[typ] ?? identityParser\n    const parser = makeNullableParser(typeParser, columnInfo, key)\n\n    if (dimensions && dimensions > 0) {\n      // It's an array\n      const nullablePgArrayParser = makeNullableParser(\n        (value, _) => pgArrayParser(value, parser),\n        columnInfo,\n        key\n      )\n      return nullablePgArrayParser(value)\n    }\n\n    return parser(value, additionalInfo)\n  }\n}\n\nfunction makeNullableParser<Extensions>(\n  parser: ParseFunction<Extensions>,\n  columnInfo: ColumnInfo,\n  columnName?: string\n): NullableParseFunction<Extensions> {\n  const isNullable = !(columnInfo.not_null ?? false)\n  // The sync service contains `null` value for a column whose value is NULL\n  // but if the column value is an array that contains a NULL value\n  // then it will be included in the array string as `NULL`, e.g.: `\"{1,NULL,3}\"`\n  return (value: NullableToken) => {\n    if (value === null) {\n      if (!isNullable) {\n        throw new ParserNullValueError(columnName ?? `unknown`)\n      }\n      return null\n    }\n    return parser(value, columnInfo)\n  }\n}\n","import { Schema } from './types'\n\ntype DbColumnName = string\ntype AppColumnName = string\n\n/**\n * Quote a PostgreSQL identifier for safe use in query parameters.\n *\n * Wraps the identifier in double quotes and escapes any internal\n * double quotes by doubling them. This ensures identifiers with\n * special characters (commas, spaces, etc.) are handled correctly.\n *\n * @param identifier - The identifier to quote\n * @returns The quoted identifier\n *\n * @example\n * ```typescript\n * quoteIdentifier('user_id')        // '\"user_id\"'\n * quoteIdentifier('foo,bar')        // '\"foo,bar\"'\n * quoteIdentifier('has\"quote')      // '\"has\"\"quote\"'\n * ```\n *\n * @internal\n */\nexport function quoteIdentifier(identifier: string): string {\n  // Escape internal double quotes by doubling them\n  const escaped = identifier.replace(/\"/g, `\"\"`)\n  return `\"${escaped}\"`\n}\n\n/**\n * A bidirectional column mapper that handles transforming column **names**\n * between database format (e.g., snake_case) and application format (e.g., camelCase).\n *\n * **Important**: ColumnMapper only transforms column names, not column values or types.\n * For type conversions (e.g., string → Date), use the `parser` option.\n * For value transformations (e.g., encryption), use the `transformer` option.\n *\n * @example\n * ```typescript\n * const mapper = snakeCamelMapper()\n * mapper.decode('user_id') // 'userId'\n * mapper.encode('userId') // 'user_id'\n * ```\n */\nexport interface ColumnMapper {\n  /**\n   * Transform a column name from database format to application format.\n   * Applied to column names in query results.\n   */\n  decode: (dbColumnName: DbColumnName) => AppColumnName\n\n  /**\n   * Transform a column name from application format to database format.\n   * Applied to column names in WHERE clauses and other query parameters.\n   */\n  encode: (appColumnName: AppColumnName) => DbColumnName\n}\n\n/**\n * Converts a snake_case string to camelCase.\n *\n * Handles edge cases:\n * - Preserves leading underscores: `_user_id` → `_userId`\n * - Preserves trailing underscores: `user_id_` → `userId_`\n * - Collapses multiple underscores: `user__id` → `userId`\n * - Normalizes to lowercase first: `user_Column` → `userColumn`\n *\n * @example\n * snakeToCamel('user_id') // 'userId'\n * snakeToCamel('project_id') // 'projectId'\n * snakeToCamel('created_at') // 'createdAt'\n * snakeToCamel('_private') // '_private'\n * snakeToCamel('user__id') // 'userId'\n * snakeToCamel('user_id_') // 'userId_'\n */\nexport function snakeToCamel(str: string): string {\n  // Preserve leading underscores\n  const leadingUnderscores = str.match(/^_+/)?.[0] ?? ``\n  const withoutLeading = str.slice(leadingUnderscores.length)\n\n  // Preserve trailing underscores for round-trip safety\n  const trailingUnderscores = withoutLeading.match(/_+$/)?.[0] ?? ``\n  const core = trailingUnderscores\n    ? withoutLeading.slice(\n        0,\n        withoutLeading.length - trailingUnderscores.length\n      )\n    : withoutLeading\n\n  // Convert to lowercase\n  const normalized = core.toLowerCase()\n\n  // Convert snake_case to camelCase (handling multiple underscores)\n  const camelCased = normalized.replace(/_+([a-z])/g, (_, letter) =>\n    letter.toUpperCase()\n  )\n\n  return leadingUnderscores + camelCased + trailingUnderscores\n}\n\n/**\n * Converts a camelCase string to snake_case.\n *\n * Handles consecutive capitals (acronyms) properly:\n * - `userID` → `user_id`\n * - `userHTTPSURL` → `user_https_url`\n *\n * @example\n * camelToSnake('userId') // 'user_id'\n * camelToSnake('projectId') // 'project_id'\n * camelToSnake('createdAt') // 'created_at'\n * camelToSnake('userID') // 'user_id'\n * camelToSnake('parseHTMLString') // 'parse_html_string'\n */\nexport function camelToSnake(str: string): string {\n  return (\n    str\n      // Insert underscore before uppercase letters that follow lowercase letters\n      // e.g., userId -> user_Id\n      .replace(/([a-z])([A-Z])/g, `$1_$2`)\n      // Insert underscore before uppercase letters that are followed by lowercase letters\n      // This handles acronyms: userID -> user_ID, but parseHTMLString -> parse_HTML_String\n      .replace(/([A-Z]+)([A-Z][a-z])/g, `$1_$2`)\n      .toLowerCase()\n  )\n}\n\n/**\n * Creates a column mapper from an explicit mapping of database columns to application columns.\n *\n * @param mapping - Object mapping database column names (keys) to application column names (values)\n * @returns A ColumnMapper that can encode and decode column names bidirectionally\n *\n * @example\n * const mapper = createColumnMapper({\n *   user_id: 'userId',\n *   project_id: 'projectId',\n *   created_at: 'createdAt'\n * })\n *\n * // Use with ShapeStream\n * const stream = new ShapeStream({\n *   url: 'http://localhost:3000/v1/shape',\n *   params: { table: 'todos' },\n *   columnMapper: mapper\n * })\n */\nexport function createColumnMapper(\n  mapping: Record<string, string>\n): ColumnMapper {\n  // Build reverse mapping: app name -> db name\n  const reverseMapping: Record<string, string> = {}\n  for (const [dbName, appName] of Object.entries(mapping)) {\n    reverseMapping[appName] = dbName\n  }\n\n  return {\n    decode: (dbColumnName: string) => {\n      return mapping[dbColumnName] ?? dbColumnName\n    },\n\n    encode: (appColumnName: string) => {\n      return reverseMapping[appColumnName] ?? appColumnName\n    },\n  }\n}\n\n/**\n * Encodes column names in a WHERE clause using the provided encoder function.\n * Uses regex to identify column references and replace them.\n *\n * Handles common SQL patterns:\n * - Simple comparisons: columnName = $1\n * - Function calls: LOWER(columnName)\n * - Qualified names: table.columnName\n * - Operators: columnName IS NULL, columnName IN (...)\n * - Quoted strings: Preserves string literals unchanged\n *\n * Note: This uses regex-based replacement which works for most common cases\n * but may not handle all complex SQL expressions perfectly. For complex queries,\n * test thoroughly or use database column names directly in WHERE clauses.\n *\n * @param whereClause - The WHERE clause string to encode\n * @param encode - Optional encoder function. If undefined, returns whereClause unchanged.\n * @returns The encoded WHERE clause\n *\n * @internal\n */\nexport function encodeWhereClause(\n  whereClause: string | undefined,\n  encode?: (columnName: string) => string\n): string {\n  if (!whereClause || !encode) return whereClause ?? ``\n\n  // SQL keywords that should not be transformed (common ones)\n  const sqlKeywords = new Set([\n    `SELECT`,\n    `FROM`,\n    `WHERE`,\n    `AND`,\n    `OR`,\n    `NOT`,\n    `IN`,\n    `IS`,\n    `NULL`,\n    `NULLS`,\n    `FIRST`,\n    `LAST`,\n    `TRUE`,\n    `FALSE`,\n    `LIKE`,\n    `ILIKE`,\n    `BETWEEN`,\n    `ASC`,\n    `DESC`,\n    `LIMIT`,\n    `OFFSET`,\n    `ORDER`,\n    `BY`,\n    `GROUP`,\n    `HAVING`,\n    `DISTINCT`,\n    `AS`,\n    `ON`,\n    `JOIN`,\n    `LEFT`,\n    `RIGHT`,\n    `INNER`,\n    `OUTER`,\n    `CROSS`,\n    `CASE`,\n    `WHEN`,\n    `THEN`,\n    `ELSE`,\n    `END`,\n    `CAST`,\n    `LOWER`,\n    `UPPER`,\n    `COALESCE`,\n    `NULLIF`,\n  ])\n\n  // Track positions of quoted strings and double-quoted identifiers to skip them\n  const quotedRanges: Array<{ start: number; end: number }> = []\n\n  // Find all single-quoted strings and double-quoted identifiers\n  let pos = 0\n  while (pos < whereClause.length) {\n    const ch = whereClause[pos]\n    if (ch === `'` || ch === `\"`) {\n      const start = pos\n      const quoteChar = ch\n      pos++ // Skip opening quote\n      // Find closing quote, handling escaped quotes ('' or \"\")\n      while (pos < whereClause.length) {\n        if (whereClause[pos] === quoteChar) {\n          if (whereClause[pos + 1] === quoteChar) {\n            pos += 2 // Skip escaped quote\n          } else {\n            pos++ // Skip closing quote\n            break\n          }\n        } else {\n          pos++\n        }\n      }\n      quotedRanges.push({ start, end: pos })\n    } else {\n      pos++\n    }\n  }\n\n  // Helper to check if position is within a quoted string or double-quoted identifier\n  const isInQuotedString = (pos: number): boolean => {\n    return quotedRanges.some((range) => pos >= range.start && pos < range.end)\n  }\n\n  // Pattern explanation:\n  // (?<![a-zA-Z0-9_]) - negative lookbehind: not preceded by identifier char\n  // ([a-zA-Z_][a-zA-Z0-9_]*) - capture: valid SQL identifier\n  // (?![a-zA-Z0-9_]) - negative lookahead: not followed by identifier char\n  //\n  // This avoids matching:\n  // - Parts of longer identifiers\n  // - SQL keywords (handled by checking if result differs from input)\n  const identifierPattern =\n    /(?<![a-zA-Z0-9_])([a-zA-Z_][a-zA-Z0-9_]*)(?![a-zA-Z0-9_])/g\n\n  return whereClause.replace(identifierPattern, (match, _p1, offset) => {\n    // Don't transform if inside quoted string\n    if (isInQuotedString(offset)) {\n      return match\n    }\n\n    // Don't transform SQL keywords\n    if (sqlKeywords.has(match.toUpperCase())) {\n      return match\n    }\n\n    // Don't transform parameter placeholders ($1, $2, etc.)\n    // This regex won't match them anyway, but being explicit\n    if (match.startsWith(`$`)) {\n      return match\n    }\n\n    // Apply encoding\n    const encoded = encode(match)\n    return encoded\n  })\n}\n\n/**\n * Creates a column mapper that automatically converts between snake_case and camelCase.\n * This is the most common use case for column mapping.\n *\n * When a schema is provided, it will only map columns that exist in the schema.\n * Otherwise, it will map any column name it encounters.\n *\n * **⚠️ Limitations and Edge Cases:**\n * - **WHERE clause encoding**: Uses regex-based parsing which may not handle all complex\n *   SQL expressions. Test thoroughly with your queries, especially those with:\n *   - Complex nested expressions\n *   - Custom operators or functions\n *   - Column names that conflict with SQL keywords\n *   - Quoted identifiers (e.g., `\"$price\"`, `\"user-id\"`) - not supported\n *   - Column names with special characters (non-alphanumeric except underscore)\n * - **Acronym ambiguity**: `userID` → `user_id` → `userId` (ID becomes Id after roundtrip)\n *   Use `createColumnMapper()` with explicit mapping if you need exact control\n * - **Type conversion**: This only renames columns, not values. Use `parser` for type conversion\n *\n * **When to use explicit mapping instead:**\n * - You have column names that don't follow snake_case/camelCase patterns\n * - You need exact control over mappings (e.g., `id` → `identifier`)\n * - Your WHERE clauses are complex and automatic encoding fails\n * - You have quoted identifiers or column names with special characters\n *\n * @param schema - Optional database schema to constrain mapping to known columns\n * @returns A ColumnMapper for snake_case ↔ camelCase conversion\n *\n * @example\n * // Basic usage\n * const mapper = snakeCamelMapper()\n *\n * // With schema - only maps columns in schema (recommended)\n * const mapper = snakeCamelMapper(schema)\n *\n * // Use with ShapeStream\n * const stream = new ShapeStream({\n *   url: 'http://localhost:3000/v1/shape',\n *   params: { table: 'todos' },\n *   columnMapper: snakeCamelMapper()\n * })\n *\n * @example\n * // If automatic encoding fails, fall back to manual column names in WHERE clauses:\n * stream.requestSnapshot({\n *   where: \"user_id = $1\", // Use database column names directly if needed\n *   params: { \"1\": \"123\" }\n * })\n */\nexport function snakeCamelMapper(schema?: Schema): ColumnMapper {\n  // If schema provided, build explicit mapping\n  if (schema) {\n    const mapping: Record<string, string> = {}\n    for (const dbColumn of Object.keys(schema)) {\n      mapping[dbColumn] = snakeToCamel(dbColumn)\n    }\n    return createColumnMapper(mapping)\n  }\n\n  // Otherwise, map dynamically\n  return {\n    decode: (dbColumnName: string) => {\n      return snakeToCamel(dbColumnName)\n    },\n\n    encode: (appColumnName: string) => {\n      return camelToSnake(appColumnName)\n    },\n  }\n}\n","import {\n  ChangeMessage,\n  ControlMessage,\n  Message,\n  NormalizedPgSnapshot,\n  Offset,\n  PostgresSnapshot,\n  Row,\n} from './types'\n\n/**\n * Type guard for checking {@link Message} is {@link ChangeMessage}.\n *\n * See [TS docs](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)\n * for information on how to use type guards.\n *\n * @param message - the message to check\n * @returns true if the message is a {@link ChangeMessage}\n *\n * @example\n * ```ts\n * if (isChangeMessage(message)) {\n *   const msgChng: ChangeMessage = message // Ok\n *   const msgCtrl: ControlMessage = message // Err, type mismatch\n * }\n * ```\n */\nexport function isChangeMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ChangeMessage<T> {\n  return `key` in message\n}\n\n/**\n * Type guard for checking {@link Message} is {@link ControlMessage}.\n *\n * See [TS docs](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)\n * for information on how to use type guards.\n *\n * @param message - the message to check\n * @returns true if the message is a {@link ControlMessage}\n *\n *  * @example\n * ```ts\n * if (isControlMessage(message)) {\n *   const msgChng: ChangeMessage = message // Err, type mismatch\n *   const msgCtrl: ControlMessage = message // Ok\n * }\n * ```\n */\nexport function isControlMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ControlMessage {\n  return !isChangeMessage(message)\n}\n\nexport function isUpToDateMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ControlMessage & { up_to_date: true } {\n  return isControlMessage(message) && message.headers.control === `up-to-date`\n}\n\n/**\n * Parses the LSN from the up-to-date message and turns it into an offset.\n * The LSN is only present in the up-to-date control message when in SSE mode.\n * If we are not in SSE mode this function will return undefined.\n */\nexport function getOffset(message: ControlMessage): Offset | undefined {\n  if (message.headers.control != `up-to-date`) return\n  const lsn = message.headers.global_last_seen_lsn\n  return lsn ? (`${lsn}_0` as Offset) : undefined\n}\n\n/**\n * Checks if a transaction is visible in a snapshot.\n *\n * @param txid - the transaction id to check\n * @param snapshot - the information about the snapshot\n * @returns true if the transaction is visible in the snapshot\n */\nexport function isVisibleInSnapshot(\n  txid: number | bigint | `${bigint}`,\n  snapshot: PostgresSnapshot | NormalizedPgSnapshot\n): boolean {\n  const xid = BigInt(txid)\n  const xmin = BigInt(snapshot.xmin)\n  const xmax = BigInt(snapshot.xmax)\n  const xip = snapshot.xip_list.map(BigInt)\n\n  // If the transaction id is less than the minimum transaction id, it is visible in the snapshot.\n  // If the transaction id is less than the maximum transaction id and not in the list of active\n  //   transactions at the time of the snapshot, it has been committed before the snapshot was taken\n  //   and is therefore visible in the snapshot.\n  // Otherwise, it is not visible in the snapshot.\n\n  return xid < xmin || (xid < xmax && !xip.includes(xid))\n}\n","export const LIVE_CACHE_BUSTER_HEADER = `electric-cursor`\nexport const SHAPE_HANDLE_HEADER = `electric-handle`\nexport const CHUNK_LAST_OFFSET_HEADER = `electric-offset`\nexport const SHAPE_SCHEMA_HEADER = `electric-schema`\nexport const CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`\nexport const COLUMNS_QUERY_PARAM = `columns`\nexport const LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`\nexport const EXPIRED_HANDLE_QUERY_PARAM = `expired_handle`\nexport const SHAPE_HANDLE_QUERY_PARAM = `handle`\nexport const LIVE_QUERY_PARAM = `live`\nexport const OFFSET_QUERY_PARAM = `offset`\nexport const TABLE_QUERY_PARAM = `table`\nexport const WHERE_QUERY_PARAM = `where`\nexport const REPLICA_PARAM = `replica`\nexport const WHERE_PARAMS_PARAM = `params`\n/**\n * @deprecated Use {@link LIVE_SSE_QUERY_PARAM} instead.\n */\nexport const EXPERIMENTAL_LIVE_SSE_QUERY_PARAM = `experimental_live_sse`\nexport const LIVE_SSE_QUERY_PARAM = `live_sse`\nexport const FORCE_DISCONNECT_AND_REFRESH = `force-disconnect-and-refresh`\nexport const PAUSE_STREAM = `pause-stream`\nexport const LOG_MODE_QUERY_PARAM = `log`\nexport const SUBSET_PARAM_WHERE = `subset__where`\nexport const SUBSET_PARAM_LIMIT = `subset__limit`\nexport const SUBSET_PARAM_OFFSET = `subset__offset`\nexport const SUBSET_PARAM_ORDER_BY = `subset__order_by`\nexport const SUBSET_PARAM_WHERE_PARAMS = `subset__params`\nexport const SUBSET_PARAM_WHERE_EXPR = `subset__where_expr`\nexport const SUBSET_PARAM_ORDER_BY_EXPR = `subset__order_by_expr`\n\n// Query parameters that should be passed through when proxying Electric requests\nexport const ELECTRIC_PROTOCOL_QUERY_PARAMS: Array<string> = [\n  LIVE_QUERY_PARAM,\n  LIVE_SSE_QUERY_PARAM,\n  SHAPE_HANDLE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n  LIVE_CACHE_BUSTER_QUERY_PARAM,\n  EXPIRED_HANDLE_QUERY_PARAM,\n  LOG_MODE_QUERY_PARAM,\n  SUBSET_PARAM_WHERE,\n  SUBSET_PARAM_LIMIT,\n  SUBSET_PARAM_OFFSET,\n  SUBSET_PARAM_ORDER_BY,\n  SUBSET_PARAM_WHERE_PARAMS,\n  SUBSET_PARAM_WHERE_EXPR,\n  SUBSET_PARAM_ORDER_BY_EXPR,\n]\n","import {\n  CHUNK_LAST_OFFSET_HEADER,\n  CHUNK_UP_TO_DATE_HEADER,\n  EXPIRED_HANDLE_QUERY_PARAM,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n  SHAPE_HANDLE_HEADER,\n  SHAPE_HANDLE_QUERY_PARAM,\n  SUBSET_PARAM_LIMIT,\n  SUBSET_PARAM_OFFSET,\n  SUBSET_PARAM_ORDER_BY,\n  SUBSET_PARAM_WHERE,\n  SUBSET_PARAM_WHERE_PARAMS,\n} from './constants'\nimport {\n  FetchError,\n  FetchBackoffAbortError,\n  MissingHeadersError,\n} from './error'\n\n// Some specific 4xx and 5xx HTTP status codes that we definitely\n// want to retry\nconst HTTP_RETRY_STATUS_CODES = [429]\n\nexport interface BackoffOptions {\n  /**\n   * Initial delay before retrying in milliseconds\n   */\n  initialDelay: number\n  /**\n   * Maximum retry delay in milliseconds\n   * After reaching this, delay stays constant (e.g., retry every 60s)\n   */\n  maxDelay: number\n  multiplier: number\n  onFailedAttempt?: () => void\n  debug?: boolean\n  /**\n   * Maximum number of retry attempts before giving up.\n   * Set to Infinity (default) for indefinite retries - needed for offline scenarios\n   * where clients may go offline and come back later.\n   */\n  maxRetries?: number\n}\n\nexport const BackoffDefaults = {\n  initialDelay: 100,\n  maxDelay: 60_000, // Cap at 60s - reasonable for long-lived connections\n  multiplier: 1.3,\n  maxRetries: Infinity, // Retry forever - clients may go offline and come back\n}\n\n/**\n * Parse Retry-After header value and return delay in milliseconds\n * Supports both delta-seconds format and HTTP-date format\n * Returns 0 if header is not present or invalid\n */\nexport function parseRetryAfterHeader(retryAfter: string | undefined): number {\n  if (!retryAfter) return 0\n\n  // Try parsing as seconds (delta-seconds format)\n  const retryAfterSec = Number(retryAfter)\n  if (Number.isFinite(retryAfterSec) && retryAfterSec > 0) {\n    return retryAfterSec * 1000\n  }\n\n  // Try parsing as HTTP-date\n  const retryDate = Date.parse(retryAfter)\n  if (!isNaN(retryDate)) {\n    // Handle clock skew: clamp to non-negative, cap at reasonable max\n    const deltaMs = retryDate - Date.now()\n    return Math.max(0, Math.min(deltaMs, 3600_000)) // Cap at 1 hour\n  }\n\n  return 0\n}\n\nexport function createFetchWithBackoff(\n  fetchClient: typeof fetch,\n  backoffOptions: BackoffOptions = BackoffDefaults\n): typeof fetch {\n  const {\n    initialDelay,\n    maxDelay,\n    multiplier,\n    debug = false,\n    onFailedAttempt,\n    maxRetries = Infinity,\n  } = backoffOptions\n  return async (...args: Parameters<typeof fetch>): Promise<Response> => {\n    const url = args[0]\n    const options = args[1]\n\n    let delay = initialDelay\n    let attempt = 0\n\n    while (true) {\n      try {\n        const result = await fetchClient(...args)\n        if (result.ok) {\n          return result\n        }\n\n        const err = await FetchError.fromResponse(result, url.toString())\n\n        throw err\n      } catch (e) {\n        onFailedAttempt?.()\n        if (options?.signal?.aborted) {\n          throw new FetchBackoffAbortError()\n        } else if (\n          e instanceof FetchError &&\n          !HTTP_RETRY_STATUS_CODES.includes(e.status) &&\n          e.status >= 400 &&\n          e.status < 500\n        ) {\n          // Any client errors cannot be backed off on, leave it to the caller to handle.\n          throw e\n        } else {\n          // Check max retries\n          attempt++\n          if (attempt > maxRetries) {\n            if (debug) {\n              console.log(\n                `Max retries reached (${attempt}/${maxRetries}), giving up`\n              )\n            }\n            throw e\n          }\n\n          // Calculate wait time honoring server-driven backoff as a floor\n          // Precedence: max(serverMinimum, min(clientMaxDelay, backoffWithJitter))\n\n          // 1. Parse server-provided Retry-After (if present)\n          const serverMinimumMs =\n            e instanceof FetchError && e.headers\n              ? parseRetryAfterHeader(e.headers[`retry-after`])\n              : 0\n\n          // 2. Calculate client backoff with full jitter strategy\n          // Full jitter: random_between(0, min(cap, exponential_backoff))\n          // See: https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n          const jitter = Math.random() * delay // random value between 0 and current delay\n          const clientBackoffMs = Math.min(jitter, maxDelay) // cap at maxDelay\n\n          // 3. Server minimum is the floor, client cap is the ceiling\n          const waitMs = Math.max(serverMinimumMs, clientBackoffMs)\n\n          if (debug) {\n            const source = serverMinimumMs > 0 ? `server+client` : `client`\n            console.log(\n              `Retry attempt #${attempt} after ${waitMs}ms (${source}, serverMin=${serverMinimumMs}ms, clientBackoff=${clientBackoffMs}ms)`\n            )\n          }\n\n          // Wait for the calculated duration\n          await new Promise((resolve) => setTimeout(resolve, waitMs))\n\n          // Increase the delay for the next attempt (capped at maxDelay)\n          delay = Math.min(delay * multiplier, maxDelay)\n        }\n      }\n    }\n  }\n}\n\nconst NO_BODY_STATUS_CODES = [201, 204, 205]\n\n// Ensure body can actually be read in its entirety\nexport function createFetchWithConsumedMessages(fetchClient: typeof fetch) {\n  return async (...args: Parameters<typeof fetch>): Promise<Response> => {\n    const url = args[0]\n    const res = await fetchClient(...args)\n    try {\n      if (res.status < 200 || NO_BODY_STATUS_CODES.includes(res.status)) {\n        return res\n      }\n\n      const text = await res.text()\n      return new Response(text, res)\n    } catch (err) {\n      if (args[1]?.signal?.aborted) {\n        throw new FetchBackoffAbortError()\n      }\n\n      throw new FetchError(\n        res.status,\n        undefined,\n        undefined,\n        Object.fromEntries([...res.headers.entries()]),\n        url.toString(),\n        err instanceof Error\n          ? err.message\n          : typeof err === `string`\n            ? err\n            : `failed to read body`\n      )\n    }\n  }\n}\n\ninterface ChunkPrefetchOptions {\n  maxChunksToPrefetch: number\n}\n\nconst ChunkPrefetchDefaults = {\n  maxChunksToPrefetch: 2,\n}\n\n/**\n * Creates a fetch client that prefetches subsequent log chunks for\n * consumption by the shape stream without waiting for the chunk bodies\n * themselves to be loaded.\n *\n * @param fetchClient the client to wrap\n * @param prefetchOptions options to configure prefetching\n * @returns wrapped client with prefetch capabilities\n */\nexport function createFetchWithChunkBuffer(\n  fetchClient: typeof fetch,\n  prefetchOptions: ChunkPrefetchOptions = ChunkPrefetchDefaults\n): typeof fetch {\n  const { maxChunksToPrefetch } = prefetchOptions\n\n  let prefetchQueue: PrefetchQueue | undefined\n\n  const prefetchClient = async (...args: Parameters<typeof fetchClient>) => {\n    const url = args[0].toString()\n\n    // try to consume from the prefetch queue first, and if request is\n    // not present abort the prefetch queue as it must no longer be valid\n    const prefetchedRequest = prefetchQueue?.consume(...args)\n    if (prefetchedRequest) {\n      return prefetchedRequest\n    }\n\n    // Clear the prefetch queue after aborting to prevent returning\n    // stale/aborted requests on future calls with the same URL\n    prefetchQueue?.abort()\n    prefetchQueue = undefined\n\n    // perform request and fire off prefetch queue if request is eligible\n    const response = await fetchClient(...args)\n    const nextUrl = getNextChunkUrl(url, response)\n    if (nextUrl) {\n      prefetchQueue = new PrefetchQueue({\n        fetchClient,\n        maxPrefetchedRequests: maxChunksToPrefetch,\n        url: nextUrl,\n        requestInit: args[1],\n      })\n    }\n\n    return response\n  }\n\n  return prefetchClient\n}\n\nexport const requiredElectricResponseHeaders = [\n  `electric-offset`,\n  `electric-handle`,\n]\n\nexport const requiredLiveResponseHeaders = [`electric-cursor`]\n\nexport const requiredNonLiveResponseHeaders = [`electric-schema`]\n\nexport function createFetchWithResponseHeadersCheck(\n  fetchClient: typeof fetch\n): typeof fetch {\n  return async (...args: Parameters<typeof fetchClient>) => {\n    const response = await fetchClient(...args)\n\n    if (response.ok) {\n      // Check that the necessary Electric headers are present on the response\n      const headers = response.headers\n      const missingHeaders: Array<string> = []\n\n      const addMissingHeaders = (requiredHeaders: Array<string>) =>\n        missingHeaders.push(...requiredHeaders.filter((h) => !headers.has(h)))\n\n      const input = args[0]\n      const urlString = input.toString()\n      const url = new URL(urlString)\n\n      // Snapshot responses (subset params) return a JSON object and do not include Electric chunk headers\n      const isSnapshotRequest = [\n        SUBSET_PARAM_WHERE,\n        SUBSET_PARAM_WHERE_PARAMS,\n        SUBSET_PARAM_LIMIT,\n        SUBSET_PARAM_OFFSET,\n        SUBSET_PARAM_ORDER_BY,\n      ].some((p) => url.searchParams.has(p))\n      if (isSnapshotRequest) {\n        return response\n      }\n\n      addMissingHeaders(requiredElectricResponseHeaders)\n      if (url.searchParams.get(LIVE_QUERY_PARAM) === `true`) {\n        addMissingHeaders(requiredLiveResponseHeaders)\n      }\n\n      if (\n        !url.searchParams.has(LIVE_QUERY_PARAM) ||\n        url.searchParams.get(LIVE_QUERY_PARAM) === `false`\n      ) {\n        addMissingHeaders(requiredNonLiveResponseHeaders)\n      }\n\n      if (missingHeaders.length > 0) {\n        throw new MissingHeadersError(urlString, missingHeaders)\n      }\n    }\n\n    return response\n  }\n}\n\nclass PrefetchQueue {\n  readonly #fetchClient: typeof fetch\n  readonly #maxPrefetchedRequests: number\n  readonly #prefetchQueue = new Map<\n    string,\n    [Promise<Response>, AbortController]\n  >()\n  #queueHeadUrl: string | void\n  #queueTailUrl: string | void\n\n  constructor(options: {\n    url: Parameters<typeof fetch>[0]\n    requestInit: Parameters<typeof fetch>[1]\n    maxPrefetchedRequests: number\n    fetchClient?: typeof fetch\n  }) {\n    this.#fetchClient =\n      options.fetchClient ??\n      ((...args: Parameters<typeof fetch>) => fetch(...args))\n    this.#maxPrefetchedRequests = options.maxPrefetchedRequests\n    this.#queueHeadUrl = options.url.toString()\n    this.#queueTailUrl = this.#queueHeadUrl\n    this.#prefetch(options.url, options.requestInit)\n  }\n\n  abort(): void {\n    this.#prefetchQueue.forEach(([_, aborter]) => aborter.abort())\n    this.#prefetchQueue.clear()\n  }\n\n  consume(...args: Parameters<typeof fetch>): Promise<Response> | void {\n    const url = args[0].toString()\n\n    const entry = this.#prefetchQueue.get(url)\n    // only consume if request is in queue and is the queue \"head\"\n    // if request is in the queue but not the head, the queue is being\n    // consumed out of order and should be restarted\n    if (!entry || url !== this.#queueHeadUrl) return\n\n    const [request, aborter] = entry\n    // Don't return aborted requests - they will reject with AbortError\n    if (aborter.signal.aborted) {\n      this.#prefetchQueue.delete(url)\n      return\n    }\n    this.#prefetchQueue.delete(url)\n\n    // fire off new prefetch since request has been consumed\n    request\n      .then((response) => {\n        const nextUrl = getNextChunkUrl(url, response)\n        this.#queueHeadUrl = nextUrl\n        if (\n          this.#queueTailUrl &&\n          !this.#prefetchQueue.has(this.#queueTailUrl)\n        ) {\n          this.#prefetch(this.#queueTailUrl, args[1])\n        }\n      })\n      .catch(() => {})\n\n    return request\n  }\n\n  #prefetch(...args: Parameters<typeof fetch>): void {\n    const url = args[0].toString()\n\n    // only prefetch when queue is not full\n    if (this.#prefetchQueue.size >= this.#maxPrefetchedRequests) return\n\n    // initialize aborter per request, to avoid aborting consumed requests that\n    // are still streaming their bodies to the consumer\n    const aborter = new AbortController()\n\n    try {\n      const { signal, cleanup } = chainAborter(aborter, args[1]?.signal)\n      const request = this.#fetchClient(url, { ...(args[1] ?? {}), signal })\n      this.#prefetchQueue.set(url, [request, aborter])\n      request\n        .then((response) => {\n          // only keep prefetching if response chain is uninterrupted\n          if (!response.ok || aborter.signal.aborted) return\n\n          const nextUrl = getNextChunkUrl(url, response)\n\n          // only prefetch when there is a next URL\n          if (!nextUrl || nextUrl === url) {\n            this.#queueTailUrl = undefined\n            return\n          }\n\n          this.#queueTailUrl = nextUrl\n          return this.#prefetch(nextUrl, args[1])\n        })\n        .catch(() => {})\n        .finally(cleanup)\n    } catch (_) {\n      // ignore prefetch errors\n    }\n  }\n}\n\n/**\n * Generate the next chunk's URL if the url and response are valid\n */\nfunction getNextChunkUrl(url: string, res: Response): string | void {\n  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER)\n  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER)\n  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER)\n\n  // only prefetch if shape handle and offset for next chunk are available, and\n  // response is not already up-to-date\n  if (!shapeHandle || !lastOffset || isUpToDate) return\n\n  const nextUrl = new URL(url)\n\n  // don't prefetch live requests, rushing them will only\n  // potentially miss more recent data\n  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return\n\n  // don't prefetch if the response handle is the expired handle from the request\n  // this can happen when a proxy serves a stale cached response despite the\n  // expired_handle cache buster parameter\n  const expiredHandle = nextUrl.searchParams.get(EXPIRED_HANDLE_QUERY_PARAM)\n  if (expiredHandle && shapeHandle === expiredHandle) {\n    console.warn(\n      `[Electric] Received stale cached response with expired shape handle. ` +\n        `This should not happen and indicates a proxy/CDN caching misconfiguration. ` +\n        `The response contained handle \"${shapeHandle}\" which was previously marked as expired. ` +\n        `Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. ` +\n        `Skipping prefetch to prevent infinite 409 loop.`\n    )\n    return\n  }\n\n  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle)\n  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset)\n  nextUrl.searchParams.sort()\n  return nextUrl.toString()\n}\n\n/**\n * Chains an abort controller on an optional source signal's\n * aborted state - if the source signal is aborted, the provided abort\n * controller will also abort\n */\nfunction chainAborter(\n  aborter: AbortController,\n  sourceSignal?: AbortSignal | null\n): {\n  signal: AbortSignal\n  cleanup: () => void\n} {\n  let cleanup = noop\n  if (!sourceSignal) {\n    // no-op, nothing to chain to\n  } else if (sourceSignal.aborted) {\n    // source signal is already aborted, abort immediately\n    aborter.abort()\n  } else {\n    // chain to source signal abort event, and add callback to unlink\n    // the aborter to avoid memory leaks\n    const abortParent = () => aborter.abort()\n    sourceSignal.addEventListener(`abort`, abortParent, {\n      once: true,\n      signal: aborter.signal,\n    })\n    cleanup = () => sourceSignal.removeEventListener(`abort`, abortParent)\n  }\n\n  return {\n    signal: aborter.signal,\n    cleanup,\n  }\n}\n\nfunction noop() {}\n","import { SerializedExpression, SerializedOrderByClause } from './types'\nimport { quoteIdentifier } from './column-mapper'\n\n/**\n * Compiles a serialized expression into a SQL string.\n * Applies columnMapper transformations to column references.\n *\n * @param expr - The serialized expression to compile\n * @param columnMapper - Optional function to transform column names (e.g., camelCase to snake_case)\n * @returns The compiled SQL string\n *\n * @example\n * ```typescript\n * const expr = { type: 'ref', column: 'userId' }\n * compileExpression(expr, camelToSnake) // '\"user_id\"'\n * ```\n */\nexport function compileExpression(\n  expr: SerializedExpression,\n  columnMapper?: (col: string) => string\n): string {\n  switch (expr.type) {\n    case `ref`: {\n      // Apply columnMapper, then quote\n      const mappedColumn = columnMapper\n        ? columnMapper(expr.column)\n        : expr.column\n      return quoteIdentifier(mappedColumn)\n    }\n    case `val`:\n      return `$${expr.paramIndex}`\n    case `func`:\n      return compileFunction(expr, columnMapper)\n    default: {\n      // TypeScript exhaustiveness check\n      const _exhaustive: never = expr\n      throw new Error(`Unknown expression type: ${JSON.stringify(_exhaustive)}`)\n    }\n  }\n}\n\n/**\n * Compiles a function expression into SQL.\n */\nfunction compileFunction(\n  expr: { type: `func`; name: string; args: SerializedExpression[] },\n  columnMapper?: (col: string) => string\n): string {\n  const args = expr.args.map((arg) => compileExpression(arg, columnMapper))\n\n  switch (expr.name) {\n    // Binary comparison operators\n    case `eq`:\n      return `${args[0]} = ${args[1]}`\n    case `gt`:\n      return `${args[0]} > ${args[1]}`\n    case `gte`:\n      return `${args[0]} >= ${args[1]}`\n    case `lt`:\n      return `${args[0]} < ${args[1]}`\n    case `lte`:\n      return `${args[0]} <= ${args[1]}`\n\n    // Logical operators\n    case `and`:\n      return args.map((a) => `(${a})`).join(` AND `)\n    case `or`:\n      return args.map((a) => `(${a})`).join(` OR `)\n    case `not`:\n      return `NOT (${args[0]})`\n\n    // Special operators\n    case `in`:\n      return `${args[0]} = ANY(${args[1]})`\n    case `like`:\n      return `${args[0]} LIKE ${args[1]}`\n    case `ilike`:\n      return `${args[0]} ILIKE ${args[1]}`\n    case `isNull`:\n    case `isUndefined`:\n      return `${args[0]} IS NULL`\n\n    // String functions\n    case `upper`:\n      return `UPPER(${args[0]})`\n    case `lower`:\n      return `LOWER(${args[0]})`\n    case `length`:\n      return `LENGTH(${args[0]})`\n    case `concat`:\n      return `CONCAT(${args.join(`, `)})`\n\n    // Other functions\n    case `coalesce`:\n      return `COALESCE(${args.join(`, `)})`\n\n    default:\n      throw new Error(`Unknown function: ${expr.name}`)\n  }\n}\n\n/**\n * Compiles serialized ORDER BY clauses into a SQL string.\n * Applies columnMapper transformations to column references.\n *\n * @param clauses - The serialized ORDER BY clauses to compile\n * @param columnMapper - Optional function to transform column names\n * @returns The compiled SQL ORDER BY string\n *\n * @example\n * ```typescript\n * const clauses = [{ column: 'createdAt', direction: 'desc', nulls: 'first' }]\n * compileOrderBy(clauses, camelToSnake) // '\"created_at\" DESC NULLS FIRST'\n * ```\n */\nexport function compileOrderBy(\n  clauses: SerializedOrderByClause[],\n  columnMapper?: (col: string) => string\n): string {\n  return clauses\n    .map((clause) => {\n      const mappedColumn = columnMapper\n        ? columnMapper(clause.column)\n        : clause.column\n      let sql = quoteIdentifier(mappedColumn)\n      if (clause.direction === `desc`) sql += ` DESC`\n      if (clause.nulls === `first`) sql += ` NULLS FIRST`\n      if (clause.nulls === `last`) sql += ` NULLS LAST`\n      return sql\n    })\n    .join(`, `)\n}\n","import {\n  Message,\n  Offset,\n  Schema,\n  Row,\n  MaybePromise,\n  GetExtensions,\n  ChangeMessage,\n  SnapshotMetadata,\n  SubsetParams,\n} from './types'\nimport { MessageParser, Parser, TransformFunction } from './parser'\nimport {\n  ColumnMapper,\n  encodeWhereClause,\n  quoteIdentifier,\n} from './column-mapper'\nimport { getOffset, isUpToDateMessage, isChangeMessage } from './helpers'\nimport {\n  FetchError,\n  FetchBackoffAbortError,\n  MissingShapeUrlError,\n  InvalidSignalError,\n  MissingShapeHandleError,\n  ReservedParamError,\n  MissingHeadersError,\n} from './error'\nimport {\n  BackoffDefaults,\n  BackoffOptions,\n  createFetchWithBackoff,\n  createFetchWithChunkBuffer,\n  createFetchWithConsumedMessages,\n  createFetchWithResponseHeadersCheck,\n} from './fetch'\nimport {\n  CHUNK_LAST_OFFSET_HEADER,\n  LIVE_CACHE_BUSTER_HEADER,\n  LIVE_CACHE_BUSTER_QUERY_PARAM,\n  EXPIRED_HANDLE_QUERY_PARAM,\n  COLUMNS_QUERY_PARAM,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n  SHAPE_HANDLE_HEADER,\n  SHAPE_HANDLE_QUERY_PARAM,\n  SHAPE_SCHEMA_HEADER,\n  WHERE_QUERY_PARAM,\n  WHERE_PARAMS_PARAM,\n  TABLE_QUERY_PARAM,\n  REPLICA_PARAM,\n  FORCE_DISCONNECT_AND_REFRESH,\n  PAUSE_STREAM,\n  EXPERIMENTAL_LIVE_SSE_QUERY_PARAM,\n  LIVE_SSE_QUERY_PARAM,\n  ELECTRIC_PROTOCOL_QUERY_PARAMS,\n  LOG_MODE_QUERY_PARAM,\n  SUBSET_PARAM_WHERE,\n  SUBSET_PARAM_WHERE_PARAMS,\n  SUBSET_PARAM_LIMIT,\n  SUBSET_PARAM_OFFSET,\n  SUBSET_PARAM_ORDER_BY,\n  SUBSET_PARAM_WHERE_EXPR,\n  SUBSET_PARAM_ORDER_BY_EXPR,\n} from './constants'\nimport { compileExpression, compileOrderBy } from './expression-compiler'\nimport {\n  EventSourceMessage,\n  fetchEventSource,\n} from '@microsoft/fetch-event-source'\nimport { expiredShapesCache } from './expired-shapes-cache'\nimport { upToDateTracker } from './up-to-date-tracker'\nimport { SnapshotTracker } from './snapshot-tracker'\n\nconst RESERVED_PARAMS: Set<ReservedParamKeys> = new Set([\n  LIVE_CACHE_BUSTER_QUERY_PARAM,\n  SHAPE_HANDLE_QUERY_PARAM,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n])\n\ntype Replica = `full` | `default`\nexport type LogMode = `changes_only` | `full`\n\n/**\n * PostgreSQL-specific shape parameters that can be provided externally\n */\nexport interface PostgresParams<T extends Row<unknown> = Row> {\n  /** The root table for the shape. Not required if you set the table in your proxy. */\n  table?: string\n\n  /**\n   * The columns to include in the shape.\n   * Must include primary keys, and can only include valid columns.\n   * Defaults to all columns of the type `T`. If provided, must include primary keys, and can only include valid columns.\n\n   */\n  columns?: (keyof T)[]\n\n  /** The where clauses for the shape */\n  where?: string\n\n  /**\n   * Positional where clause paramater values. These will be passed to the server\n   * and will substitute `$i` parameters in the where clause.\n   *\n   * It can be an array (note that positional arguments start at 1, the array will be mapped\n   * accordingly), or an object with keys matching the used positional parameters in the where clause.\n   *\n   * If where clause is `id = $1 or id = $2`, params must have keys `\"1\"` and `\"2\"`, or be an array with length 2.\n   */\n  params?: Record<`${number}`, string> | string[]\n\n  /**\n   * If `replica` is `default` (the default) then Electric will only send the\n   * changed columns in an update.\n   *\n   * If it's `full` Electric will send the entire row with both changed and\n   * unchanged values. `old_value` will also be present on update messages,\n   * containing the previous value for changed columns.\n   *\n   * Setting `replica` to `full` will result in higher bandwidth\n   * usage and so is not generally recommended.\n   */\n  replica?: Replica\n}\ntype SerializableParamValue = string | string[] | Record<string, string>\ntype ParamValue =\n  | SerializableParamValue\n  | (() => SerializableParamValue | Promise<SerializableParamValue>)\n\n/**\n * External params type - what users provide.\n * Excludes reserved parameters to prevent dynamic variations that could cause stream shape changes.\n */\nexport type ExternalParamsRecord<T extends Row<unknown> = Row> = {\n  [K in string]: ParamValue | undefined\n} & Partial<PostgresParams<T>> & { [K in ReservedParamKeys]?: never }\n\ntype ReservedParamKeys =\n  | typeof LIVE_CACHE_BUSTER_QUERY_PARAM\n  | typeof SHAPE_HANDLE_QUERY_PARAM\n  | typeof LIVE_QUERY_PARAM\n  | typeof OFFSET_QUERY_PARAM\n  | `subset__${string}`\n\n/**\n * External headers type - what users provide.\n * Allows string or function values for any header.\n */\nexport type ExternalHeadersRecord = {\n  [key: string]: string | (() => string | Promise<string>)\n}\n\n/**\n * Internal params type - used within the library.\n * All values are converted to strings.\n */\ntype InternalParamsRecord = {\n  [K in string as K extends ReservedParamKeys ? never : K]:\n    | string\n    | Record<string, string>\n}\n\n/**\n * Helper function to resolve a function or value to its final value\n */\nexport async function resolveValue<T>(\n  value: T | (() => T | Promise<T>)\n): Promise<T> {\n  if (typeof value === `function`) {\n    return (value as () => T | Promise<T>)()\n  }\n  return value\n}\n\n/**\n * Helper function to convert external params to internal format\n */\nasync function toInternalParams(\n  params: ExternalParamsRecord<Row>\n): Promise<InternalParamsRecord> {\n  const entries = Object.entries(params)\n  const resolvedEntries = await Promise.all(\n    entries.map(async ([key, value]) => {\n      if (value === undefined) return [key, undefined]\n      const resolvedValue = await resolveValue(value)\n      return [\n        key,\n        Array.isArray(resolvedValue) ? resolvedValue.join(`,`) : resolvedValue,\n      ]\n    })\n  )\n\n  return Object.fromEntries(\n    resolvedEntries.filter(([_, value]) => value !== undefined)\n  )\n}\n\n/**\n * Helper function to resolve headers\n */\nasync function resolveHeaders(\n  headers?: ExternalHeadersRecord\n): Promise<Record<string, string>> {\n  if (!headers) return {}\n\n  const entries = Object.entries(headers)\n  const resolvedEntries = await Promise.all(\n    entries.map(async ([key, value]) => [key, await resolveValue(value)])\n  )\n\n  return Object.fromEntries(resolvedEntries)\n}\n\ntype RetryOpts = {\n  params?: ExternalParamsRecord\n  headers?: ExternalHeadersRecord\n}\n\ntype ShapeStreamErrorHandler = (\n  error: Error\n) => void | RetryOpts | Promise<void | RetryOpts>\n\n/**\n * Options for constructing a ShapeStream.\n */\nexport interface ShapeStreamOptions<T = never> {\n  /**\n   * The full URL to where the Shape is served. This can either be the Electric server\n   * directly or a proxy. E.g. for a local Electric instance, you might set `http://localhost:3000/v1/shape`\n   */\n  url: string\n\n  /**\n   * The \"offset\" on the shape log. This is typically not set as the ShapeStream\n   * will handle this automatically. A common scenario where you might pass an offset\n   * is if you're maintaining a local cache of the log. If you've gone offline\n   * and are re-starting a ShapeStream to catch-up to the latest state of the Shape,\n   * you'd pass in the last offset and shapeHandle you'd seen from the Electric server\n   * so it knows at what point in the shape to catch you up from.\n   */\n  offset?: Offset\n\n  /**\n   * Similar to `offset`, this isn't typically used unless you're maintaining\n   * a cache of the shape log.\n   */\n  handle?: string\n\n  /**\n   * HTTP headers to attach to requests made by the client.\n   * Values can be strings or functions (sync or async) that return strings.\n   * Function values are resolved in parallel when needed, making this useful\n   * for authentication tokens or other dynamic headers.\n   */\n  headers?: ExternalHeadersRecord\n\n  /**\n   * Additional request parameters to attach to the URL.\n   * Values can be strings, string arrays, or functions (sync or async) that return these types.\n   * Function values are resolved in parallel when needed, making this useful\n   * for user-specific parameters or dynamic filters.\n   *\n   * These will be merged with Electric's standard parameters.\n   * Note: You cannot use Electric's reserved parameter names\n   * (offset, handle, live, cursor).\n   *\n   * PostgreSQL-specific options like table, where, columns, and replica\n   * should be specified here.\n   */\n  params?: ExternalParamsRecord\n\n  /**\n   * Automatically fetch updates to the Shape. If you just want to sync the current\n   * shape and stop, pass false.\n   */\n  subscribe?: boolean\n\n  /**\n   * @deprecated No longer experimental, use {@link liveSse} instead.\n   */\n  experimentalLiveSse?: boolean\n\n  /**\n   * Use Server-Sent Events (SSE) for live updates.\n   */\n  liveSse?: boolean\n\n  /**\n   * Initial data loading mode\n   */\n  log?: LogMode\n\n  signal?: AbortSignal\n  fetchClient?: typeof fetch\n  backoffOptions?: BackoffOptions\n  parser?: Parser<T>\n\n  /**\n   * Function to transform rows after parsing (e.g., for encryption, type coercion).\n   * Applied to data received from Electric.\n   *\n   * **Note**: If you're using `transformer` solely for column name transformation\n   * (e.g., snake_case → camelCase), consider using `columnMapper` instead, which\n   * provides bidirectional transformation and automatically encodes WHERE clauses.\n   *\n   * **Execution order** when both are provided:\n   * 1. `columnMapper.decode` runs first (renames columns)\n   * 2. `transformer` runs second (transforms values)\n   *\n   * @example\n   * ```typescript\n   * // For column renaming only - use columnMapper\n   * import { snakeCamelMapper } from '@electric-sql/client'\n   * const stream = new ShapeStream({ columnMapper: snakeCamelMapper() })\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // For value transformation (encryption, etc.) - use transformer\n   * const stream = new ShapeStream({\n   *   transformer: (row) => ({\n   *     ...row,\n   *     encrypted_field: decrypt(row.encrypted_field)\n   *   })\n   * })\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Use both together\n   * const stream = new ShapeStream({\n   *   columnMapper: snakeCamelMapper(), // Runs first: renames columns\n   *   transformer: (row) => ({         // Runs second: transforms values\n   *     ...row,\n   *     encryptedData: decrypt(row.encryptedData)\n   *   })\n   * })\n   * ```\n   */\n  transformer?: TransformFunction<T>\n\n  /**\n   * Bidirectional column name mapper for transforming between database column names\n   * (e.g., snake_case) and application column names (e.g., camelCase).\n   *\n   * The mapper handles both:\n   * - **Decoding**: Database → Application (applied to query results)\n   * - **Encoding**: Application → Database (applied to WHERE clauses)\n   *\n   * @example\n   * ```typescript\n   * // Most common case: snake_case ↔ camelCase\n   * import { snakeCamelMapper } from '@electric-sql/client'\n   *\n   * const stream = new ShapeStream({\n   *   url: 'http://localhost:3000/v1/shape',\n   *   params: { table: 'todos' },\n   *   columnMapper: snakeCamelMapper()\n   * })\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Custom mapping\n   * import { createColumnMapper } from '@electric-sql/client'\n   *\n   * const stream = new ShapeStream({\n   *   columnMapper: createColumnMapper({\n   *     user_id: 'userId',\n   *     project_id: 'projectId',\n   *     created_at: 'createdAt'\n   *   })\n   * })\n   * ```\n   */\n  columnMapper?: ColumnMapper\n\n  /**\n   * A function for handling shapestream errors.\n   *\n   * **Automatic retries**: The client automatically retries 5xx server errors, network\n   * errors, and 429 rate limits with exponential backoff. The `onError` callback is\n   * only invoked after these automatic retries are exhausted, or for non-retryable\n   * errors like 4xx client errors.\n   *\n   * When not provided, non-retryable errors will be thrown and syncing will stop.\n   *\n   * **Return value behavior**:\n   * - Return an **object** (RetryOpts or empty `{}`) to retry syncing:\n   *   - `{}` - Retry with the same params and headers\n   *   - `{ params }` - Retry with modified params\n   *   - `{ headers }` - Retry with modified headers (e.g., refreshed auth token)\n   *   - `{ params, headers }` - Retry with both modified\n   * - Return **void** or **undefined** to stop the stream permanently\n   *\n   * **Important**: If you want syncing to continue after an error (e.g., to retry\n   * on network failures), you MUST return at least an empty object `{}`. Simply\n   * logging the error and returning nothing will stop syncing.\n   *\n   * Supports async functions that return `Promise<void | RetryOpts>`.\n   *\n   * @example\n   * ```typescript\n   * // Retry on network errors, stop on others\n   * onError: (error) => {\n   *   console.error('Stream error:', error)\n   *   if (error instanceof FetchError && error.status >= 500) {\n   *     return {} // Retry with same params\n   *   }\n   *   // Return void to stop on other errors\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Refresh auth token on 401\n   * onError: async (error) => {\n   *   if (error instanceof FetchError && error.status === 401) {\n   *     const newToken = await refreshAuthToken()\n   *     return { headers: { Authorization: `Bearer ${newToken}` } }\n   *   }\n   *   return {} // Retry other errors\n   * }\n   * ```\n   */\n  onError?: ShapeStreamErrorHandler\n}\n\nexport interface ShapeStreamInterface<T extends Row<unknown> = Row> {\n  subscribe(\n    callback: (\n      messages: Message<T>[]\n    ) => MaybePromise<void> | { columns?: (keyof T)[] },\n    onError?: (error: FetchError | Error) => void\n  ): () => void\n  unsubscribeAll(): void\n\n  isLoading(): boolean\n  lastSyncedAt(): number | undefined\n  lastSynced(): number\n  isConnected(): boolean\n  hasStarted(): boolean\n\n  isUpToDate: boolean\n  lastOffset: Offset\n  shapeHandle?: string\n  error?: unknown\n  mode: LogMode\n\n  forceDisconnectAndRefresh(): Promise<void>\n\n  requestSnapshot(params: SubsetParams): Promise<{\n    metadata: SnapshotMetadata\n    data: Array<Message<T>>\n  }>\n\n  fetchSnapshot(opts: SubsetParams): Promise<{\n    metadata: SnapshotMetadata\n    data: Array<ChangeMessage<T>>\n  }>\n}\n\n/**\n * Creates a canonical shape key from a URL excluding only Electric protocol parameters\n */\nfunction canonicalShapeKey(url: URL): string {\n  const cleanUrl = new URL(url.origin + url.pathname)\n\n  // Copy all params except Electric protocol ones that vary between requests\n  for (const [key, value] of url.searchParams) {\n    if (!ELECTRIC_PROTOCOL_QUERY_PARAMS.includes(key)) {\n      cleanUrl.searchParams.set(key, value)\n    }\n  }\n\n  cleanUrl.searchParams.sort()\n  return cleanUrl.toString()\n}\n\n/**\n * Reads updates to a shape from Electric using HTTP requests and long polling or\n * Server-Sent Events (SSE).\n * Notifies subscribers when new messages come in. Doesn't maintain any history of the\n * log but does keep track of the offset position and is the best way\n * to consume the HTTP `GET /v1/shape` api.\n *\n * @constructor\n * @param {ShapeStreamOptions} options - configure the shape stream\n * @example\n * Register a callback function to subscribe to the messages.\n * ```\n * const stream = new ShapeStream(options)\n * stream.subscribe(messages => {\n *   // messages is 1 or more row updates\n * })\n * ```\n *\n * To use Server-Sent Events (SSE) for real-time updates:\n * ```\n * const stream = new ShapeStream({\n *   url: `http://localhost:3000/v1/shape`,\n *   liveSse: true\n * })\n * ```\n *\n * To abort the stream, abort the `signal`\n * passed in via the `ShapeStreamOptions`.\n * ```\n * const aborter = new AbortController()\n * const issueStream = new ShapeStream({\n *   url: `${BASE_URL}/${table}`\n *   subscribe: true,\n *   signal: aborter.signal,\n * })\n * // Later...\n * aborter.abort()\n * ```\n */\n\nexport class ShapeStream<T extends Row<unknown> = Row>\n  implements ShapeStreamInterface<T>\n{\n  static readonly Replica = {\n    FULL: `full` as Replica,\n    DEFAULT: `default` as Replica,\n  }\n\n  readonly options: ShapeStreamOptions<GetExtensions<T>>\n  #error: unknown = null\n\n  readonly #fetchClient: typeof fetch\n  readonly #sseFetchClient: typeof fetch\n  readonly #messageParser: MessageParser<T>\n\n  readonly #subscribers = new Map<\n    number,\n    [\n      (messages: Message<T>[]) => MaybePromise<void>,\n      ((error: Error) => void) | undefined,\n    ]\n  >()\n\n  #started = false\n  #state = `active` as `active` | `pause-requested` | `paused`\n  #lastOffset: Offset\n  #liveCacheBuster: string // Seconds since our Electric Epoch 😎\n  #lastSyncedAt?: number // unix time\n  #isUpToDate: boolean = false\n  #isMidStream: boolean = true\n  #connected: boolean = false\n  #shapeHandle?: string\n  #mode: LogMode\n  #schema?: Schema\n  #onError?: ShapeStreamErrorHandler\n  #requestAbortController?: AbortController\n  #isRefreshing = false\n  #tickPromise?: Promise<void>\n  #tickPromiseResolver?: () => void\n  #tickPromiseRejecter?: (reason?: unknown) => void\n  #messageChain = Promise.resolve<void[]>([]) // promise chain for incoming messages\n  #snapshotTracker = new SnapshotTracker()\n  #activeSnapshotRequests = 0 // counter for concurrent snapshot requests\n  #midStreamPromise?: Promise<void>\n  #midStreamPromiseResolver?: () => void\n  #lastSeenCursor?: string // Last seen cursor from previous session (used to detect cached responses)\n  #currentFetchUrl?: URL // Current fetch URL for computing shape key\n  #lastSseConnectionStartTime?: number\n  #minSseConnectionDuration = 1000 // Minimum expected SSE connection duration (1 second)\n  #consecutiveShortSseConnections = 0\n  #maxShortSseConnections = 3 // Fall back to long polling after this many short connections\n  #sseFallbackToLongPolling = false\n  #sseBackoffBaseDelay = 100 // Base delay for exponential backoff (ms)\n  #sseBackoffMaxDelay = 5000 // Maximum delay cap (ms)\n  #unsubscribeFromVisibilityChanges?: () => void\n\n  // Derived state: we're in replay mode if we have a last seen cursor\n  get #replayMode(): boolean {\n    return this.#lastSeenCursor !== undefined\n  }\n\n  constructor(options: ShapeStreamOptions<GetExtensions<T>>) {\n    this.options = { subscribe: true, ...options }\n    validateOptions(this.options)\n    this.#lastOffset = this.options.offset ?? `-1`\n    this.#liveCacheBuster = ``\n    this.#shapeHandle = this.options.handle\n\n    // Build transformer chain: columnMapper.decode -> transformer\n    // columnMapper transforms column names, transformer transforms values\n    let transformer: TransformFunction<GetExtensions<T>> | undefined\n\n    if (options.columnMapper) {\n      const applyColumnMapper = (\n        row: Row<GetExtensions<T>>\n      ): Row<GetExtensions<T>> => {\n        const result: Record<string, unknown> = {}\n        for (const [dbKey, value] of Object.entries(row)) {\n          const appKey = options.columnMapper!.decode(dbKey)\n          result[appKey] = value\n        }\n        return result as Row<GetExtensions<T>>\n      }\n\n      transformer = options.transformer\n        ? (row: Row<GetExtensions<T>>) =>\n            options.transformer!(applyColumnMapper(row))\n        : applyColumnMapper\n    } else {\n      transformer = options.transformer\n    }\n\n    this.#messageParser = new MessageParser<T>(options.parser, transformer)\n\n    this.#onError = this.options.onError\n    this.#mode = this.options.log ?? `full`\n\n    const baseFetchClient =\n      options.fetchClient ??\n      ((...args: Parameters<typeof fetch>) => fetch(...args))\n\n    const backOffOpts = {\n      ...(options.backoffOptions ?? BackoffDefaults),\n      onFailedAttempt: () => {\n        this.#connected = false\n        options.backoffOptions?.onFailedAttempt?.()\n      },\n    }\n    const fetchWithBackoffClient = createFetchWithBackoff(\n      baseFetchClient,\n      backOffOpts\n    )\n\n    this.#sseFetchClient = createFetchWithResponseHeadersCheck(\n      createFetchWithChunkBuffer(fetchWithBackoffClient)\n    )\n\n    this.#fetchClient = createFetchWithConsumedMessages(this.#sseFetchClient)\n\n    this.#subscribeToVisibilityChanges()\n  }\n\n  get shapeHandle() {\n    return this.#shapeHandle\n  }\n\n  get error() {\n    return this.#error\n  }\n\n  get isUpToDate() {\n    return this.#isUpToDate\n  }\n\n  get lastOffset() {\n    return this.#lastOffset\n  }\n\n  get mode() {\n    return this.#mode\n  }\n\n  async #start(): Promise<void> {\n    this.#started = true\n\n    try {\n      await this.#requestShape()\n    } catch (err) {\n      this.#error = err\n\n      // Check if onError handler wants to retry\n      if (this.#onError) {\n        const retryOpts = await this.#onError(err as Error)\n        // Guard against null (typeof null === \"object\" in JavaScript)\n        if (retryOpts && typeof retryOpts === `object`) {\n          // Update params/headers but don't reset offset\n          // We want to continue from where we left off, not refetch everything\n          if (retryOpts.params) {\n            // Merge new params with existing params to preserve other parameters\n            this.options.params = {\n              ...(this.options.params ?? {}),\n              ...retryOpts.params,\n            }\n          }\n\n          if (retryOpts.headers) {\n            // Merge new headers with existing headers to preserve other headers\n            this.options.headers = {\n              ...(this.options.headers ?? {}),\n              ...retryOpts.headers,\n            }\n          }\n\n          // Clear the error since we're retrying\n          this.#error = null\n\n          // Restart from current offset\n          this.#started = false\n          await this.#start()\n          return\n        }\n        // onError returned void, meaning it doesn't want to retry\n        // This is an unrecoverable error, notify subscribers\n        if (err instanceof Error) {\n          this.#sendErrorToSubscribers(err)\n        }\n        this.#connected = false\n        this.#tickPromiseRejecter?.()\n        return\n      }\n\n      // No onError handler provided, this is an unrecoverable error\n      // Notify subscribers and throw\n      if (err instanceof Error) {\n        this.#sendErrorToSubscribers(err)\n      }\n      this.#connected = false\n      this.#tickPromiseRejecter?.()\n      throw err\n    }\n\n    // Normal completion, clean up\n    this.#connected = false\n    this.#tickPromiseRejecter?.()\n  }\n\n  async #requestShape(): Promise<void> {\n    if (this.#state === `pause-requested`) {\n      this.#state = `paused`\n      return\n    }\n\n    if (\n      !this.options.subscribe &&\n      (this.options.signal?.aborted || this.#isUpToDate)\n    ) {\n      return\n    }\n\n    const resumingFromPause = this.#state === `paused`\n    this.#state = `active`\n\n    const { url, signal } = this.options\n    const { fetchUrl, requestHeaders } = await this.#constructUrl(\n      url,\n      resumingFromPause\n    )\n    const abortListener = await this.#createAbortListener(signal)\n    const requestAbortController = this.#requestAbortController! // we know that it is not undefined because it is set by `this.#createAbortListener`\n\n    try {\n      await this.#fetchShape({\n        fetchUrl,\n        requestAbortController,\n        headers: requestHeaders,\n        resumingFromPause,\n      })\n    } catch (e) {\n      // Handle abort error triggered by refresh\n      if (\n        (e instanceof FetchError || e instanceof FetchBackoffAbortError) &&\n        requestAbortController.signal.aborted &&\n        requestAbortController.signal.reason === FORCE_DISCONNECT_AND_REFRESH\n      ) {\n        // Start a new request\n        return this.#requestShape()\n      }\n\n      if (e instanceof FetchBackoffAbortError) {\n        // Check current state - it may have changed due to concurrent pause/resume calls\n        // from the visibility change handler during the async fetch operation.\n        // TypeScript's flow analysis doesn't account for concurrent state changes.\n        const currentState = this.#state as\n          | `active`\n          | `pause-requested`\n          | `paused`\n        if (\n          requestAbortController.signal.aborted &&\n          requestAbortController.signal.reason === PAUSE_STREAM &&\n          currentState === `pause-requested`\n        ) {\n          this.#state = `paused`\n        }\n        return // interrupted\n      }\n      if (!(e instanceof FetchError)) throw e // should never happen\n\n      if (e.status == 409) {\n        // Upon receiving a 409, we should start from scratch\n        // with the newly provided shape handle, or a fallback\n        // pseudo-handle based on the current one to act as a\n        // consistent cache buster\n\n        // Store the current shape URL as expired to avoid future 409s\n        if (this.#shapeHandle) {\n          const shapeKey = canonicalShapeKey(fetchUrl)\n          expiredShapesCache.markExpired(shapeKey, this.#shapeHandle)\n        }\n\n        const newShapeHandle =\n          e.headers[SHAPE_HANDLE_HEADER] || `${this.#shapeHandle!}-next`\n        this.#reset(newShapeHandle)\n\n        // must refetch control message might be in a list or not depending\n        // on whether it came from an SSE request or long poll - handle both\n        // cases for safety here but worth revisiting 409 handling\n        await this.#publish(\n          (Array.isArray(e.json) ? e.json : [e.json]) as Message<T>[]\n        )\n        return this.#requestShape()\n      } else {\n        // errors that have reached this point are not actionable without\n        // additional user input, such as 400s or failures to read the\n        // body of a response, so we exit the loop and let #start handle it\n        // Note: We don't notify subscribers here because onError might recover\n        throw e\n      }\n    } finally {\n      if (abortListener && signal) {\n        signal.removeEventListener(`abort`, abortListener)\n      }\n      this.#requestAbortController = undefined\n    }\n\n    this.#tickPromiseResolver?.()\n    return this.#requestShape()\n  }\n\n  async #constructUrl(\n    url: string,\n    resumingFromPause: boolean,\n    subsetParams?: SubsetParams\n  ) {\n    // Resolve headers and params in parallel\n    const [requestHeaders, params] = await Promise.all([\n      resolveHeaders(this.options.headers),\n      this.options.params\n        ? toInternalParams(convertWhereParamsToObj(this.options.params))\n        : undefined,\n    ])\n\n    // Validate params after resolution\n    if (params) validateParams(params)\n\n    const fetchUrl = new URL(url)\n\n    // Add PostgreSQL-specific parameters\n    if (params) {\n      if (params.table) setQueryParam(fetchUrl, TABLE_QUERY_PARAM, params.table)\n      if (params.where && typeof params.where === `string`) {\n        const encodedWhere = encodeWhereClause(\n          params.where,\n          this.options.columnMapper?.encode\n        )\n        setQueryParam(fetchUrl, WHERE_QUERY_PARAM, encodedWhere)\n      }\n      if (params.columns) {\n        // Get original columns array from options (before toInternalParams converted to string)\n        const originalColumns = await resolveValue(this.options.params?.columns)\n        if (Array.isArray(originalColumns)) {\n          // Apply columnMapper encoding if present\n          let encodedColumns = originalColumns.map(String)\n          if (this.options.columnMapper) {\n            encodedColumns = encodedColumns.map(\n              this.options.columnMapper.encode\n            )\n          }\n          // Quote each column name to handle special characters (commas, etc.)\n          const serializedColumns = encodedColumns\n            .map(quoteIdentifier)\n            .join(`,`)\n          setQueryParam(fetchUrl, COLUMNS_QUERY_PARAM, serializedColumns)\n        } else {\n          // Fallback: columns was already a string\n          setQueryParam(fetchUrl, COLUMNS_QUERY_PARAM, params.columns)\n        }\n      }\n      if (params.replica) setQueryParam(fetchUrl, REPLICA_PARAM, params.replica)\n      if (params.params)\n        setQueryParam(fetchUrl, WHERE_PARAMS_PARAM, params.params)\n\n      // Add any remaining custom parameters\n      const customParams = { ...params }\n      delete customParams.table\n      delete customParams.where\n      delete customParams.columns\n      delete customParams.replica\n      delete customParams.params\n\n      for (const [key, value] of Object.entries(customParams)) {\n        setQueryParam(fetchUrl, key, value)\n      }\n    }\n\n    if (subsetParams) {\n      // Prefer structured expressions when available (allows proper columnMapper application)\n      // Fall back to legacy string format for backwards compatibility\n      if (subsetParams.whereExpr) {\n        // Compile structured expression with columnMapper applied\n        const compiledWhere = compileExpression(\n          subsetParams.whereExpr,\n          this.options.columnMapper?.encode\n        )\n        setQueryParam(fetchUrl, SUBSET_PARAM_WHERE, compiledWhere)\n        // Also send the structured expression for servers that support it\n        fetchUrl.searchParams.set(\n          SUBSET_PARAM_WHERE_EXPR,\n          JSON.stringify(subsetParams.whereExpr)\n        )\n      } else if (subsetParams.where && typeof subsetParams.where === `string`) {\n        // Legacy string format (no columnMapper applied to already-compiled SQL)\n        const encodedWhere = encodeWhereClause(\n          subsetParams.where,\n          this.options.columnMapper?.encode\n        )\n        setQueryParam(fetchUrl, SUBSET_PARAM_WHERE, encodedWhere)\n      }\n\n      if (subsetParams.params)\n        // Serialize params as JSON to keep the parameter name constant for proxy configs\n        fetchUrl.searchParams.set(\n          SUBSET_PARAM_WHERE_PARAMS,\n          JSON.stringify(subsetParams.params)\n        )\n      if (subsetParams.limit)\n        setQueryParam(fetchUrl, SUBSET_PARAM_LIMIT, subsetParams.limit)\n      if (subsetParams.offset)\n        setQueryParam(fetchUrl, SUBSET_PARAM_OFFSET, subsetParams.offset)\n\n      // Prefer structured ORDER BY expressions when available\n      if (subsetParams.orderByExpr) {\n        // Compile structured ORDER BY with columnMapper applied\n        const compiledOrderBy = compileOrderBy(\n          subsetParams.orderByExpr,\n          this.options.columnMapper?.encode\n        )\n        setQueryParam(fetchUrl, SUBSET_PARAM_ORDER_BY, compiledOrderBy)\n        // Also send the structured expression for servers that support it\n        fetchUrl.searchParams.set(\n          SUBSET_PARAM_ORDER_BY_EXPR,\n          JSON.stringify(subsetParams.orderByExpr)\n        )\n      } else if (\n        subsetParams.orderBy &&\n        typeof subsetParams.orderBy === `string`\n      ) {\n        // Legacy string format\n        const encodedOrderBy = encodeWhereClause(\n          subsetParams.orderBy,\n          this.options.columnMapper?.encode\n        )\n        setQueryParam(fetchUrl, SUBSET_PARAM_ORDER_BY, encodedOrderBy)\n      }\n    }\n\n    // Add Electric's internal parameters\n    fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, this.#lastOffset)\n    fetchUrl.searchParams.set(LOG_MODE_QUERY_PARAM, this.#mode)\n\n    // Snapshot requests (with subsetParams) should never use live polling\n    const isSnapshotRequest = subsetParams !== undefined\n\n    if (this.#isUpToDate && !isSnapshotRequest) {\n      // If we are resuming from a paused state, we don't want to perform a live request\n      // because it could be a long poll that holds for 20sec\n      // and during all that time `isConnected` will be false\n      if (!this.#isRefreshing && !resumingFromPause) {\n        fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`)\n      }\n      fetchUrl.searchParams.set(\n        LIVE_CACHE_BUSTER_QUERY_PARAM,\n        this.#liveCacheBuster\n      )\n    }\n\n    if (this.#shapeHandle) {\n      // This should probably be a header for better cache breaking?\n      fetchUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, this.#shapeHandle!)\n    }\n\n    // Add cache buster for shapes known to be expired to prevent 409s\n    const shapeKey = canonicalShapeKey(fetchUrl)\n    const expiredHandle = expiredShapesCache.getExpiredHandle(shapeKey)\n    if (expiredHandle) {\n      fetchUrl.searchParams.set(EXPIRED_HANDLE_QUERY_PARAM, expiredHandle)\n    }\n\n    // sort query params in-place for stable URLs and improved cache hits\n    fetchUrl.searchParams.sort()\n\n    return {\n      fetchUrl,\n      requestHeaders,\n    }\n  }\n\n  async #createAbortListener(signal?: AbortSignal) {\n    // Create a new AbortController for this request\n    this.#requestAbortController = new AbortController()\n\n    // If user provided a signal, listen to it and pass on the reason for the abort\n    if (signal) {\n      const abortListener = () => {\n        this.#requestAbortController?.abort(signal.reason)\n      }\n\n      signal.addEventListener(`abort`, abortListener, { once: true })\n\n      if (signal.aborted) {\n        // If the signal is already aborted, abort the request immediately\n        this.#requestAbortController?.abort(signal.reason)\n      }\n\n      return abortListener\n    }\n  }\n\n  async #onInitialResponse(response: Response) {\n    const { headers, status } = response\n    const shapeHandle = headers.get(SHAPE_HANDLE_HEADER)\n    if (shapeHandle) {\n      // Don't accept a handle we know is expired - this can happen if a\n      // proxy serves a stale cached response despite the expired_handle\n      // cache buster parameter\n      const shapeKey = this.#currentFetchUrl\n        ? canonicalShapeKey(this.#currentFetchUrl)\n        : null\n      const expiredHandle = shapeKey\n        ? expiredShapesCache.getExpiredHandle(shapeKey)\n        : null\n      if (shapeHandle !== expiredHandle) {\n        this.#shapeHandle = shapeHandle\n      } else {\n        console.warn(\n          `[Electric] Received stale cached response with expired shape handle. ` +\n            `This should not happen and indicates a proxy/CDN caching misconfiguration. ` +\n            `The response contained handle \"${shapeHandle}\" which was previously marked as expired. ` +\n            `Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. ` +\n            `Ignoring the stale handle and continuing with handle \"${this.#shapeHandle}\".`\n        )\n      }\n    }\n\n    const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER)\n    if (lastOffset) {\n      this.#lastOffset = lastOffset as Offset\n    }\n\n    const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER)\n    if (liveCacheBuster) {\n      this.#liveCacheBuster = liveCacheBuster\n    }\n\n    this.#schema = this.#schema ?? getSchemaFromHeaders(headers)\n\n    // NOTE: 204s are deprecated, the Electric server should not\n    // send these in latest versions but this is here for backwards\n    // compatibility\n    if (status === 204) {\n      // There's no content so we are live and up to date\n      this.#lastSyncedAt = Date.now()\n    }\n  }\n\n  async #onMessages(batch: Array<Message<T>>, isSseMessage = false) {\n    // Update isUpToDate\n    if (batch.length > 0) {\n      // Set isMidStream to true when we receive any data\n      this.#isMidStream = true\n\n      const lastMessage = batch[batch.length - 1]\n      if (isUpToDateMessage(lastMessage)) {\n        if (isSseMessage) {\n          // Only use the offset from the up-to-date message if this was an SSE message.\n          // If we would use this offset from a regular fetch, then it will be wrong\n          // and we will get an \"offset is out of bounds for this shape\" error\n          const offset = getOffset(lastMessage)\n          if (offset) {\n            this.#lastOffset = offset\n          }\n        }\n        this.#lastSyncedAt = Date.now()\n        this.#isUpToDate = true\n        // Set isMidStream to false when we see an up-to-date message\n        this.#isMidStream = false\n        // Resolve the promise waiting for mid-stream to end\n        this.#midStreamPromiseResolver?.()\n\n        // Check if we should suppress this up-to-date notification\n        // to prevent multiple renders from cached responses\n        if (this.#replayMode && !isSseMessage) {\n          // We're in replay mode (replaying cached responses during initial sync).\n          // Check if the cursor has changed - cursors are time-based and always\n          // increment, so a new cursor means fresh data from the server.\n          const currentCursor = this.#liveCacheBuster\n\n          if (currentCursor === this.#lastSeenCursor) {\n            // Same cursor = still replaying cached responses\n            // Suppress this up-to-date notification\n            return\n          }\n        }\n\n        // We're either:\n        // 1. Not in replay mode (normal operation), or\n        // 2. This is a live/SSE message (always fresh), or\n        // 3. Cursor has changed (exited replay mode with fresh data)\n        // In all cases, notify subscribers and record the up-to-date.\n        this.#lastSeenCursor = undefined // Exit replay mode\n\n        if (this.#currentFetchUrl) {\n          const shapeKey = canonicalShapeKey(this.#currentFetchUrl)\n          upToDateTracker.recordUpToDate(shapeKey, this.#liveCacheBuster)\n        }\n      }\n\n      // Filter messages using snapshot tracker\n      const messagesToProcess = batch.filter((message) => {\n        if (isChangeMessage(message)) {\n          return !this.#snapshotTracker.shouldRejectMessage(message)\n        }\n        return true // Always process control messages\n      })\n\n      await this.#publish(messagesToProcess)\n    }\n  }\n\n  /**\n   * Fetches the shape from the server using either long polling or SSE.\n   * Upon receiving a successfull response, the #onInitialResponse method is called.\n   * Afterwards, the #onMessages method is called for all the incoming updates.\n   * @param opts - The options for the request.\n   * @returns A promise that resolves when the request is complete (i.e. the long poll receives a response or the SSE connection is closed).\n   */\n  async #fetchShape(opts: {\n    fetchUrl: URL\n    requestAbortController: AbortController\n    headers: Record<string, string>\n    resumingFromPause?: boolean\n  }): Promise<void> {\n    // Store current fetch URL for shape key computation\n    this.#currentFetchUrl = opts.fetchUrl\n\n    // Check if we should enter replay mode (replaying cached responses)\n    // This happens when we're starting fresh (offset=-1 or before first up-to-date)\n    // and there's a recent up-to-date in localStorage (< 60s)\n    if (!this.#isUpToDate && !this.#replayMode) {\n      const shapeKey = canonicalShapeKey(opts.fetchUrl)\n      const lastSeenCursor = upToDateTracker.shouldEnterReplayMode(shapeKey)\n      if (lastSeenCursor) {\n        // Enter replay mode and store the last seen cursor\n        this.#lastSeenCursor = lastSeenCursor\n      }\n    }\n\n    const useSse = this.options.liveSse ?? this.options.experimentalLiveSse\n    if (\n      this.#isUpToDate &&\n      useSse &&\n      !this.#isRefreshing &&\n      !opts.resumingFromPause &&\n      !this.#sseFallbackToLongPolling\n    ) {\n      opts.fetchUrl.searchParams.set(EXPERIMENTAL_LIVE_SSE_QUERY_PARAM, `true`)\n      opts.fetchUrl.searchParams.set(LIVE_SSE_QUERY_PARAM, `true`)\n      return this.#requestShapeSSE(opts)\n    }\n\n    return this.#requestShapeLongPoll(opts)\n  }\n\n  async #requestShapeLongPoll(opts: {\n    fetchUrl: URL\n    requestAbortController: AbortController\n    headers: Record<string, string>\n  }): Promise<void> {\n    const { fetchUrl, requestAbortController, headers } = opts\n    const response = await this.#fetchClient(fetchUrl.toString(), {\n      signal: requestAbortController.signal,\n      headers,\n    })\n\n    this.#connected = true\n    await this.#onInitialResponse(response)\n\n    const schema = this.#schema! // we know that it is not undefined because it is set by `this.#onInitialResponse`\n    const res = await response.text()\n    const messages = res || `[]`\n    const batch = this.#messageParser.parse<Array<Message<T>>>(messages, schema)\n\n    await this.#onMessages(batch)\n  }\n\n  async #requestShapeSSE(opts: {\n    fetchUrl: URL\n    requestAbortController: AbortController\n    headers: Record<string, string>\n  }): Promise<void> {\n    const { fetchUrl, requestAbortController, headers } = opts\n    const fetch = this.#sseFetchClient\n\n    // Track when the SSE connection starts\n    this.#lastSseConnectionStartTime = Date.now()\n\n    // Add Accept header for SSE requests\n    const sseHeaders = {\n      ...headers,\n      Accept: `text/event-stream`,\n    }\n\n    try {\n      let buffer: Array<Message<T>> = []\n      await fetchEventSource(fetchUrl.toString(), {\n        headers: sseHeaders,\n        fetch,\n        onopen: async (response: Response) => {\n          this.#connected = true\n          await this.#onInitialResponse(response)\n        },\n        onmessage: (event: EventSourceMessage) => {\n          if (event.data) {\n            // event.data is a single JSON object\n            const schema = this.#schema! // we know that it is not undefined because it is set in onopen when we call this.#onInitialResponse\n            const message = this.#messageParser.parse<Message<T>>(\n              event.data,\n              schema\n            )\n            buffer.push(message)\n\n            if (isUpToDateMessage(message)) {\n              // Flush the buffer on up-to-date message.\n              // Ensures that we only process complete batches of operations.\n              this.#onMessages(buffer, true)\n              buffer = []\n            }\n          }\n        },\n        onerror: (error: Error) => {\n          // rethrow to close the SSE connection\n          throw error\n        },\n        signal: requestAbortController.signal,\n      })\n    } catch (error) {\n      if (requestAbortController.signal.aborted) {\n        // During an SSE request, the fetch might have succeeded\n        // and we are parsing the incoming stream.\n        // If the abort happens while we're parsing the stream,\n        // then it won't be caught by our `createFetchWithBackoff` wrapper\n        // and instead we will get a raw AbortError here\n        // which we need to turn into a `FetchBackoffAbortError`\n        // such that #start handles it correctly.`\n        throw new FetchBackoffAbortError()\n      }\n      throw error\n    } finally {\n      // Check if the SSE connection closed too quickly\n      // This can happen when responses are cached or when the proxy/server\n      // is misconfigured for SSE and closes the connection immediately\n      const connectionDuration = Date.now() - this.#lastSseConnectionStartTime!\n      const wasAborted = requestAbortController.signal.aborted\n\n      if (connectionDuration < this.#minSseConnectionDuration && !wasAborted) {\n        // Connection was too short - likely a cached response or misconfiguration\n        this.#consecutiveShortSseConnections++\n\n        if (\n          this.#consecutiveShortSseConnections >= this.#maxShortSseConnections\n        ) {\n          // Too many short connections - fall back to long polling\n          this.#sseFallbackToLongPolling = true\n          console.warn(\n            `[Electric] SSE connections are closing immediately (possibly due to proxy buffering or misconfiguration). ` +\n              `Falling back to long polling. ` +\n              `Your proxy must support streaming SSE responses (not buffer the complete response). ` +\n              `Configuration: Nginx add 'X-Accel-Buffering: no', Caddy add 'flush_interval -1' to reverse_proxy. ` +\n              `Note: Do NOT disable caching entirely - Electric uses cache headers to enable request collapsing for efficiency.`\n          )\n        } else {\n          // Add exponential backoff with full jitter to prevent tight infinite loop\n          // Formula: random(0, min(cap, base * 2^attempt))\n          const maxDelay = Math.min(\n            this.#sseBackoffMaxDelay,\n            this.#sseBackoffBaseDelay *\n              Math.pow(2, this.#consecutiveShortSseConnections)\n          )\n          const delayMs = Math.floor(Math.random() * maxDelay)\n          await new Promise((resolve) => setTimeout(resolve, delayMs))\n        }\n      } else if (connectionDuration >= this.#minSseConnectionDuration) {\n        // Connection was healthy - reset counter\n        this.#consecutiveShortSseConnections = 0\n      }\n    }\n  }\n\n  #pause() {\n    if (this.#started && this.#state === `active`) {\n      this.#state = `pause-requested`\n      this.#requestAbortController?.abort(PAUSE_STREAM)\n    }\n  }\n\n  #resume() {\n    if (\n      this.#started &&\n      (this.#state === `paused` || this.#state === `pause-requested`)\n    ) {\n      // Don't resume if the user's signal is already aborted\n      // This can happen if the signal was aborted while we were paused\n      // (e.g., TanStack DB collection was GC'd)\n      if (this.options.signal?.aborted) {\n        return\n      }\n\n      // If we're resuming from pause-requested state, we need to set state back to active\n      // to prevent the pause from completing\n      if (this.#state === `pause-requested`) {\n        this.#state = `active`\n      }\n      this.#start()\n    }\n  }\n\n  subscribe(\n    callback: (messages: Message<T>[]) => MaybePromise<void>,\n    onError: (error: Error) => void = () => {}\n  ) {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, [callback, onError])\n    if (!this.#started) this.#start()\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n    this.#unsubscribeFromVisibilityChanges?.()\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    return this.#lastSyncedAt\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced(): number {\n    if (this.#lastSyncedAt === undefined) return Infinity\n    return Date.now() - this.#lastSyncedAt\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.#connected\n  }\n\n  /** True during initial fetch. False afterwise.  */\n  isLoading(): boolean {\n    return !this.#isUpToDate\n  }\n\n  hasStarted(): boolean {\n    return this.#started\n  }\n\n  isPaused(): boolean {\n    return this.#state === `paused`\n  }\n\n  /** Await the next tick of the request loop */\n  async #nextTick() {\n    if (this.#tickPromise) {\n      return this.#tickPromise\n    }\n    this.#tickPromise = new Promise((resolve, reject) => {\n      this.#tickPromiseResolver = resolve\n      this.#tickPromiseRejecter = reject\n    })\n    this.#tickPromise.finally(() => {\n      this.#tickPromise = undefined\n      this.#tickPromiseResolver = undefined\n      this.#tickPromiseRejecter = undefined\n    })\n    return this.#tickPromise\n  }\n\n  /** Await until we're not in the middle of a stream (i.e., until we see an up-to-date message) */\n  async #waitForStreamEnd() {\n    if (!this.#isMidStream) {\n      return\n    }\n    if (this.#midStreamPromise) {\n      return this.#midStreamPromise\n    }\n    this.#midStreamPromise = new Promise((resolve) => {\n      this.#midStreamPromiseResolver = resolve\n    })\n    this.#midStreamPromise.finally(() => {\n      this.#midStreamPromise = undefined\n      this.#midStreamPromiseResolver = undefined\n    })\n    return this.#midStreamPromise\n  }\n\n  /**\n   * Refreshes the shape stream.\n   * This preemptively aborts any ongoing long poll and reconnects without\n   * long polling, ensuring that the stream receives an up to date message with the\n   * latest LSN from Postgres at that point in time.\n   */\n  async forceDisconnectAndRefresh(): Promise<void> {\n    this.#isRefreshing = true\n    if (this.#isUpToDate && !this.#requestAbortController?.signal.aborted) {\n      // If we are \"up to date\", any current request will be a \"live\" request\n      // and needs to be aborted\n      this.#requestAbortController?.abort(FORCE_DISCONNECT_AND_REFRESH)\n    }\n    await this.#nextTick()\n    this.#isRefreshing = false\n  }\n\n  async #publish(messages: Message<T>[]): Promise<void[]> {\n    // We process messages asynchronously\n    // but SSE's `onmessage` handler is synchronous.\n    // We use a promise chain to ensure that the handlers\n    // execute sequentially in the order the messages were received.\n    this.#messageChain = this.#messageChain.then(() =>\n      Promise.all(\n        Array.from(this.#subscribers.values()).map(async ([callback, __]) => {\n          try {\n            await callback(messages)\n          } catch (err) {\n            queueMicrotask(() => {\n              throw err\n            })\n          }\n        })\n      )\n    )\n\n    return this.#messageChain\n  }\n\n  #sendErrorToSubscribers(error: Error) {\n    this.#subscribers.forEach(([_, errorFn]) => {\n      errorFn?.(error)\n    })\n  }\n\n  #subscribeToVisibilityChanges() {\n    if (\n      typeof document === `object` &&\n      typeof document.hidden === `boolean` &&\n      typeof document.addEventListener === `function`\n    ) {\n      const visibilityHandler = () => {\n        if (document.hidden) {\n          this.#pause()\n        } else {\n          this.#resume()\n        }\n      }\n\n      document.addEventListener(`visibilitychange`, visibilityHandler)\n\n      // Store cleanup function to remove the event listener\n      this.#unsubscribeFromVisibilityChanges = () => {\n        document.removeEventListener(`visibilitychange`, visibilityHandler)\n      }\n    }\n  }\n\n  /**\n   * Resets the state of the stream, optionally with a provided\n   * shape handle\n   */\n  #reset(handle?: string) {\n    this.#lastOffset = `-1`\n    this.#liveCacheBuster = ``\n    this.#shapeHandle = handle\n    this.#isUpToDate = false\n    this.#isMidStream = true\n    this.#connected = false\n    this.#schema = undefined\n    this.#activeSnapshotRequests = 0\n    // Reset SSE fallback state to try SSE again after reset\n    this.#consecutiveShortSseConnections = 0\n    this.#sseFallbackToLongPolling = false\n  }\n\n  /**\n   * Request a snapshot for subset of data and inject it into the subscribed data stream.\n   *\n   * Only available when mode is `changes_only`.\n   * Returns the insertion point & the data, but more importantly injects the data\n   * into the subscribed data stream. Returned value is unlikely to be useful for the caller,\n   * unless the caller has complicated additional logic.\n   *\n   * Data will be injected in a way that's also tracking further incoming changes, and it'll\n   * skip the ones that are already in the snapshot.\n   *\n   * @param opts - The options for the snapshot request.\n   * @returns The metadata and the data for the snapshot.\n   */\n  async requestSnapshot(opts: SubsetParams): Promise<{\n    metadata: SnapshotMetadata\n    data: Array<ChangeMessage<T>>\n  }> {\n    if (this.#mode === `full`) {\n      throw new Error(\n        `Snapshot requests are not supported in ${this.#mode} mode, as the consumer is guaranteed to observe all data`\n      )\n    }\n    // We shouldn't be getting a snapshot on a shape that's not started\n    if (!this.#started) await this.#start()\n\n    // Wait until we're not mid-stream before pausing\n    // This ensures we don't pause in the middle of a transaction\n    await this.#waitForStreamEnd()\n\n    // Pause the stream if this is the first snapshot request\n    this.#activeSnapshotRequests++\n\n    try {\n      if (this.#activeSnapshotRequests === 1) {\n        // Currently this cannot throw, but in case it can later it's in this try block to not have a stuck counter\n        this.#pause()\n      }\n\n      const { metadata, data } = await this.fetchSnapshot(opts)\n\n      const dataWithEndBoundary = (data as Array<Message<T>>).concat([\n        { headers: { control: `snapshot-end`, ...metadata } },\n        { headers: { control: `subset-end`, ...opts } },\n      ])\n\n      this.#snapshotTracker.addSnapshot(\n        metadata,\n        new Set(data.map((message) => message.key))\n      )\n      this.#onMessages(dataWithEndBoundary, false)\n\n      return {\n        metadata,\n        data,\n      }\n    } finally {\n      // Resume the stream if this was the last snapshot request\n      this.#activeSnapshotRequests--\n      if (this.#activeSnapshotRequests === 0) {\n        this.#resume()\n      }\n    }\n  }\n\n  /**\n   * Fetch a snapshot for subset of data.\n   * Returns the metadata and the data, but does not inject it into the subscribed data stream.\n   *\n   * @param opts - The options for the snapshot request.\n   * @returns The metadata and the data for the snapshot.\n   */\n  async fetchSnapshot(opts: SubsetParams): Promise<{\n    metadata: SnapshotMetadata\n    data: Array<ChangeMessage<T>>\n  }> {\n    const { fetchUrl, requestHeaders } = await this.#constructUrl(\n      this.options.url,\n      true,\n      opts\n    )\n\n    const response = await this.#fetchClient(fetchUrl.toString(), {\n      headers: requestHeaders,\n    })\n\n    if (!response.ok) {\n      throw new FetchError(\n        response.status,\n        undefined,\n        undefined,\n        Object.fromEntries([...response.headers.entries()]),\n        fetchUrl.toString()\n      )\n    }\n\n    // Use schema from stream if available, otherwise extract from response header\n    const schema: Schema =\n      this.#schema ??\n      getSchemaFromHeaders(response.headers, {\n        required: true,\n        url: fetchUrl.toString(),\n      })\n\n    const { metadata, data: rawData } = await response.json()\n    const data = this.#messageParser.parseSnapshotData<ChangeMessage<T>>(\n      rawData,\n      schema\n    )\n\n    return {\n      metadata,\n      data,\n    }\n  }\n}\n\n/**\n * Extracts the schema from response headers.\n * @param headers - The response headers\n * @param options - Options for schema extraction\n * @param options.required - If true, throws MissingHeadersError when header is missing. Defaults to false.\n * @param options.url - The URL to include in the error message if required is true\n * @returns The parsed schema, or an empty object if not required and header is missing\n * @throws {MissingHeadersError} if required is true and the header is missing\n */\nfunction getSchemaFromHeaders(\n  headers: Headers,\n  options?: { required?: boolean; url?: string }\n): Schema {\n  const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER)\n  if (!schemaHeader) {\n    if (options?.required && options?.url) {\n      throw new MissingHeadersError(options.url, [SHAPE_SCHEMA_HEADER])\n    }\n    return {}\n  }\n  return JSON.parse(schemaHeader)\n}\n\n/**\n * Validates that no reserved parameter names are used in the provided params object\n * @throws {ReservedParamError} if any reserved parameter names are found\n */\nfunction validateParams(params: Record<string, unknown> | undefined): void {\n  if (!params) return\n\n  const reservedParams = Object.keys(params).filter((key) =>\n    RESERVED_PARAMS.has(key as ReservedParamKeys)\n  )\n  if (reservedParams.length > 0) {\n    throw new ReservedParamError(reservedParams)\n  }\n}\n\nfunction validateOptions<T>(options: Partial<ShapeStreamOptions<T>>): void {\n  if (!options.url) {\n    throw new MissingShapeUrlError()\n  }\n  if (options.signal && !(options.signal instanceof AbortSignal)) {\n    throw new InvalidSignalError()\n  }\n\n  if (\n    options.offset !== undefined &&\n    options.offset !== `-1` &&\n    options.offset !== `now` &&\n    !options.handle\n  ) {\n    throw new MissingShapeHandleError()\n  }\n\n  validateParams(options.params)\n\n  return\n}\n\n// `unknown` being in the value is a bit of defensive programming if user doesn't use TS\nfunction setQueryParam(\n  url: URL,\n  key: string,\n  value: Record<string, string> | string | unknown\n): void {\n  if (value === undefined || value == null) {\n    return\n  } else if (typeof value === `string`) {\n    url.searchParams.set(key, value)\n  } else if (typeof value === `object`) {\n    for (const [k, v] of Object.entries(value)) {\n      url.searchParams.set(`${key}[${k}]`, v)\n    }\n  } else {\n    url.searchParams.set(key, value.toString())\n  }\n}\n\nfunction convertWhereParamsToObj(\n  allPgParams: ExternalParamsRecord<Row>\n): ExternalParamsRecord<Row> {\n  if (Array.isArray(allPgParams.params)) {\n    return {\n      ...allPgParams,\n      params: Object.fromEntries(allPgParams.params.map((v, i) => [i + 1, v])),\n    }\n  }\n  return allPgParams\n}\n","interface ExpiredShapeCacheEntry {\n  expiredHandle: string\n  lastUsed: number\n}\n\n/**\n * LRU cache for tracking expired shapes with automatic cleanup\n */\nexport class ExpiredShapesCache {\n  private data: Record<string, ExpiredShapeCacheEntry> = {}\n  private max: number = 250\n  private readonly storageKey = `electric_expired_shapes`\n\n  getExpiredHandle(shapeUrl: string): string | null {\n    const entry = this.data[shapeUrl]\n    if (entry) {\n      // Update last used time when accessed\n      entry.lastUsed = Date.now()\n      this.save()\n      return entry.expiredHandle\n    }\n    return null\n  }\n\n  markExpired(shapeUrl: string, handle: string): void {\n    this.data[shapeUrl] = { expiredHandle: handle, lastUsed: Date.now() }\n\n    const keys = Object.keys(this.data)\n    if (keys.length > this.max) {\n      const oldest = keys.reduce((min, k) =>\n        this.data[k].lastUsed < this.data[min].lastUsed ? k : min\n      )\n      delete this.data[oldest]\n    }\n\n    this.save()\n  }\n\n  private save(): void {\n    if (typeof localStorage === `undefined`) return\n    try {\n      localStorage.setItem(this.storageKey, JSON.stringify(this.data))\n    } catch {\n      // Ignore localStorage errors\n    }\n  }\n\n  private load(): void {\n    if (typeof localStorage === `undefined`) return\n    try {\n      const stored = localStorage.getItem(this.storageKey)\n      if (stored) {\n        this.data = JSON.parse(stored)\n      }\n    } catch {\n      // Ignore localStorage errors, start fresh\n      this.data = {}\n    }\n  }\n\n  constructor() {\n    this.load()\n  }\n\n  clear(): void {\n    this.data = {}\n    this.save()\n  }\n}\n\n// Module-level singleton instance\nexport const expiredShapesCache = new ExpiredShapesCache()\n","interface UpToDateEntry {\n  timestamp: number\n  cursor: string\n}\n\n/**\n * Tracks up-to-date messages to detect when we're replaying cached responses.\n *\n * When a shape receives an up-to-date, we record the timestamp and cursor in localStorage.\n * On page refresh, if we find a recent timestamp (< 60s), we know we'll be replaying\n * cached responses. We suppress their up-to-date notifications until we see a NEW cursor\n * (different from the last recorded one), which indicates fresh data from the server.\n *\n * localStorage writes are throttled to once per 60 seconds to avoid performance issues\n * with frequent updates. In-memory data is always kept current.\n */\nexport class UpToDateTracker {\n  private data: Record<string, UpToDateEntry> = {}\n  private readonly storageKey = `electric_up_to_date_tracker`\n  private readonly cacheTTL = 60_000 // 60s to match typical CDN s-maxage cache duration\n  private readonly maxEntries = 250\n  private readonly writeThrottleMs = 60_000 // Throttle localStorage writes to once per 60s\n  private lastWriteTime = 0\n  private pendingSaveTimer?: ReturnType<typeof setTimeout>\n\n  constructor() {\n    this.load()\n    this.cleanup()\n  }\n\n  /**\n   * Records that a shape received an up-to-date message with a specific cursor.\n   * This timestamp and cursor are used to detect cache replay scenarios.\n   * Updates in-memory immediately, but throttles localStorage writes.\n   */\n  recordUpToDate(shapeKey: string, cursor: string): void {\n    this.data[shapeKey] = {\n      timestamp: Date.now(),\n      cursor,\n    }\n\n    // Implement LRU eviction if we exceed max entries\n    const keys = Object.keys(this.data)\n    if (keys.length > this.maxEntries) {\n      const oldest = keys.reduce((min, k) =>\n        this.data[k].timestamp < this.data[min].timestamp ? k : min\n      )\n      delete this.data[oldest]\n    }\n\n    this.scheduleSave()\n  }\n\n  /**\n   * Schedules a throttled save to localStorage.\n   * Writes immediately if enough time has passed, otherwise schedules for later.\n   */\n  private scheduleSave(): void {\n    const now = Date.now()\n    const timeSinceLastWrite = now - this.lastWriteTime\n\n    if (timeSinceLastWrite >= this.writeThrottleMs) {\n      // Enough time has passed, write immediately\n      this.lastWriteTime = now\n      this.save()\n    } else if (!this.pendingSaveTimer) {\n      // Schedule a write for when the throttle period expires\n      const delay = this.writeThrottleMs - timeSinceLastWrite\n      this.pendingSaveTimer = setTimeout(() => {\n        this.lastWriteTime = Date.now()\n        this.pendingSaveTimer = undefined\n        this.save()\n      }, delay)\n    }\n    // else: a save is already scheduled, no need to do anything\n  }\n\n  /**\n   * Checks if we should enter replay mode for this shape.\n   * Returns the last seen cursor if there's a recent up-to-date (< 60s),\n   * which means we'll likely be replaying cached responses.\n   * Returns null if no recent up-to-date exists.\n   */\n  shouldEnterReplayMode(shapeKey: string): string | null {\n    const entry = this.data[shapeKey]\n    if (!entry) {\n      return null\n    }\n\n    const age = Date.now() - entry.timestamp\n    if (age >= this.cacheTTL) {\n      return null\n    }\n\n    return entry.cursor\n  }\n\n  /**\n   * Cleans up expired entries from the cache.\n   * Called on initialization and can be called periodically.\n   */\n  private cleanup(): void {\n    const now = Date.now()\n    const keys = Object.keys(this.data)\n    let modified = false\n\n    for (const key of keys) {\n      const age = now - this.data[key].timestamp\n      if (age > this.cacheTTL) {\n        delete this.data[key]\n        modified = true\n      }\n    }\n\n    if (modified) {\n      this.save()\n    }\n  }\n\n  private save(): void {\n    if (typeof localStorage === `undefined`) return\n    try {\n      localStorage.setItem(this.storageKey, JSON.stringify(this.data))\n    } catch {\n      // Ignore localStorage errors (quota exceeded, etc.)\n    }\n  }\n\n  private load(): void {\n    if (typeof localStorage === `undefined`) return\n    try {\n      const stored = localStorage.getItem(this.storageKey)\n      if (stored) {\n        this.data = JSON.parse(stored)\n      }\n    } catch {\n      // Ignore localStorage errors, start fresh\n      this.data = {}\n    }\n  }\n\n  /**\n   * Clears all tracked up-to-date timestamps.\n   * Useful for testing or manual cache invalidation.\n   */\n  clear(): void {\n    this.data = {}\n    if (this.pendingSaveTimer) {\n      clearTimeout(this.pendingSaveTimer)\n      this.pendingSaveTimer = undefined\n    }\n    this.save()\n  }\n}\n\n// Module-level singleton instance\nexport const upToDateTracker = new UpToDateTracker()\n","import { isVisibleInSnapshot } from './helpers'\nimport { Row, SnapshotMetadata } from './types'\nimport { ChangeMessage } from './types'\n\n/**\n * Tracks active snapshots and filters out duplicate change messages that are already included in snapshots.\n *\n * When requesting a snapshot in changes_only mode, we need to track which transactions were included in the\n * snapshot to avoid processing duplicate changes that arrive via the live stream. This class maintains that\n * tracking state and provides methods to:\n *\n * - Add new snapshots for tracking via addSnapshot()\n * - Remove completed snapshots via removeSnapshot()\n * - Check if incoming changes should be filtered via shouldRejectMessage()\n */\nexport class SnapshotTracker {\n  private activeSnapshots: Map<\n    number,\n    { xmin: bigint; xmax: bigint; xip_list: bigint[]; keys: Set<string> }\n  > = new Map()\n  private xmaxSnapshots: Map<bigint, Set<number>> = new Map()\n  private snapshotsByDatabaseLsn: Map<bigint, Set<number>> = new Map()\n\n  /**\n   * Add a new snapshot for tracking\n   */\n  addSnapshot(metadata: SnapshotMetadata, keys: Set<string>): void {\n    this.activeSnapshots.set(metadata.snapshot_mark, {\n      xmin: BigInt(metadata.xmin),\n      xmax: BigInt(metadata.xmax),\n      xip_list: metadata.xip_list.map(BigInt),\n      keys,\n    })\n    const xmaxSet =\n      this.xmaxSnapshots\n        .get(BigInt(metadata.xmax))\n        ?.add(metadata.snapshot_mark) ?? new Set([metadata.snapshot_mark])\n    this.xmaxSnapshots.set(BigInt(metadata.xmax), xmaxSet)\n    const databaseLsnSet =\n      this.snapshotsByDatabaseLsn\n        .get(BigInt(metadata.database_lsn))\n        ?.add(metadata.snapshot_mark) ?? new Set([metadata.snapshot_mark])\n    this.snapshotsByDatabaseLsn.set(\n      BigInt(metadata.database_lsn),\n      databaseLsnSet\n    )\n  }\n\n  /**\n   * Remove a snapshot from tracking\n   */\n  removeSnapshot(snapshotMark: number): void {\n    this.activeSnapshots.delete(snapshotMark)\n  }\n\n  /**\n   * Check if a change message should be filtered because its already in an active snapshot\n   * Returns true if the message should be filtered out (not processed)\n   */\n  shouldRejectMessage(message: ChangeMessage<Row<unknown>>): boolean {\n    const txids = message.headers.txids || []\n    if (txids.length === 0) return false\n\n    const xid = Math.max(...txids) // Use the maximum transaction ID\n\n    for (const [xmax, snapshots] of this.xmaxSnapshots.entries()) {\n      if (xid >= xmax) {\n        for (const snapshot of snapshots) {\n          this.removeSnapshot(snapshot)\n        }\n      }\n    }\n\n    return [...this.activeSnapshots.values()].some(\n      (x) => x.keys.has(message.key) && isVisibleInSnapshot(xid, x)\n    )\n  }\n\n  lastSeenUpdate(newDatabaseLsn: bigint): void {\n    for (const [dbLsn, snapshots] of this.snapshotsByDatabaseLsn.entries()) {\n      if (dbLsn <= newDatabaseLsn) {\n        for (const snapshot of snapshots) {\n          this.removeSnapshot(snapshot)\n        }\n      }\n    }\n  }\n}\n","import { Message, Offset, Row } from './types'\nimport { isChangeMessage, isControlMessage } from './helpers'\nimport { FetchError } from './error'\nimport { LogMode, ShapeStreamInterface } from './client'\n\nexport type ShapeData<T extends Row<unknown> = Row> = Map<string, T>\nexport type ShapeChangedCallback<T extends Row<unknown> = Row> = (data: {\n  value: ShapeData<T>\n  rows: T[]\n}) => void\n\ntype ShapeStatus = `syncing` | `up-to-date`\n\n/**\n * A Shape is an object that subscribes to a shape log,\n * keeps a materialised shape `.rows` in memory and\n * notifies subscribers when the value has changed.\n *\n * It can be used without a framework and as a primitive\n * to simplify developing framework hooks.\n *\n * @constructor\n * @param {ShapeStream<T extends Row>} - the underlying shape stream\n * @example\n * ```\n * const shapeStream = new ShapeStream<{ foo: number }>({\n *   url: `http://localhost:3000/v1/shape`,\n *   params: {\n *     table: `foo`\n *   }\n * })\n * const shape = new Shape(shapeStream)\n * ```\n *\n * `rows` returns a promise that resolves the Shape data once the Shape has been\n * fully loaded (and when resuming from being offline):\n *\n *     const rows = await shape.rows\n *\n * `currentRows` returns the current data synchronously:\n *\n *     const rows = shape.currentRows\n *\n *  Subscribe to updates. Called whenever the shape updates in Postgres.\n *\n *     shape.subscribe(({ rows }) => {\n *       console.log(rows)\n *     })\n */\nexport class Shape<T extends Row<unknown> = Row> {\n  readonly stream: ShapeStreamInterface<T>\n\n  readonly #data: ShapeData<T> = new Map()\n  readonly #subscribers = new Map<number, ShapeChangedCallback<T>>()\n  readonly #insertedKeys = new Set<string>()\n  readonly #requestedSubSnapshots = new Set<string>()\n  #reexecuteSnapshotsPending = false\n  #status: ShapeStatus = `syncing`\n  #error: FetchError | false = false\n\n  constructor(stream: ShapeStreamInterface<T>) {\n    this.stream = stream\n    this.stream.subscribe(\n      this.#process.bind(this),\n      this.#handleError.bind(this)\n    )\n  }\n\n  get isUpToDate(): boolean {\n    return this.#status === `up-to-date`\n  }\n\n  get lastOffset(): Offset {\n    return this.stream.lastOffset\n  }\n\n  get handle(): string | undefined {\n    return this.stream.shapeHandle\n  }\n\n  get rows(): Promise<T[]> {\n    return this.value.then((v) => Array.from(v.values()))\n  }\n\n  get currentRows(): T[] {\n    return Array.from(this.currentValue.values())\n  }\n\n  get value(): Promise<ShapeData<T>> {\n    return new Promise((resolve, reject) => {\n      if (this.stream.isUpToDate) {\n        resolve(this.currentValue)\n      } else {\n        const unsubscribe = this.subscribe(({ value }) => {\n          unsubscribe()\n          if (this.#error) reject(this.#error)\n          resolve(value)\n        })\n      }\n    })\n  }\n\n  get currentValue() {\n    return this.#data\n  }\n\n  get error() {\n    return this.#error\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    return this.stream.lastSyncedAt()\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced() {\n    return this.stream.lastSynced()\n  }\n\n  /** True during initial fetch. False afterwise.  */\n  isLoading() {\n    return this.stream.isLoading()\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.stream.isConnected()\n  }\n\n  /** Current log mode of the underlying stream */\n  get mode(): LogMode {\n    return this.stream.mode\n  }\n\n  /**\n   * Request a snapshot for subset of data. Only available when mode is changes_only.\n   * Returns void; data will be emitted via the stream and processed by this Shape.\n   */\n  async requestSnapshot(\n    params: Parameters<ShapeStreamInterface<T>[`requestSnapshot`]>[0]\n  ): Promise<void> {\n    // Track this snapshot request for future re-execution on shape rotation\n    const key = JSON.stringify(params)\n    this.#requestedSubSnapshots.add(key)\n    // Ensure the stream is up-to-date so schema is available for parsing\n    await this.#awaitUpToDate()\n    await this.stream.requestSnapshot(params)\n  }\n\n  subscribe(callback: ShapeChangedCallback<T>): () => void {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, callback)\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n  }\n\n  get numSubscribers() {\n    return this.#subscribers.size\n  }\n\n  #process(messages: Message<T>[]): void {\n    let shouldNotify = false\n\n    messages.forEach((message) => {\n      if (isChangeMessage(message)) {\n        shouldNotify = this.#updateShapeStatus(`syncing`)\n        if (this.mode === `full`) {\n          switch (message.headers.operation) {\n            case `insert`:\n              this.#data.set(message.key, message.value)\n              break\n            case `update`:\n              this.#data.set(message.key, {\n                ...this.#data.get(message.key)!,\n                ...message.value,\n              })\n              break\n            case `delete`:\n              this.#data.delete(message.key)\n              break\n          }\n        } else {\n          // changes_only: only apply updates/deletes for keys for which we observed an insert\n          switch (message.headers.operation) {\n            case `insert`:\n              this.#insertedKeys.add(message.key)\n              this.#data.set(message.key, message.value)\n              break\n            case `update`:\n              if (this.#insertedKeys.has(message.key)) {\n                this.#data.set(message.key, {\n                  ...this.#data.get(message.key)!,\n                  ...message.value,\n                })\n              }\n              break\n            case `delete`:\n              if (this.#insertedKeys.has(message.key)) {\n                this.#data.delete(message.key)\n                this.#insertedKeys.delete(message.key)\n              }\n              break\n          }\n        }\n      }\n\n      if (isControlMessage(message)) {\n        switch (message.headers.control) {\n          case `up-to-date`:\n            shouldNotify = this.#updateShapeStatus(`up-to-date`)\n            if (this.#reexecuteSnapshotsPending) {\n              this.#reexecuteSnapshotsPending = false\n              void this.#reexecuteSnapshots()\n            }\n            break\n          case `must-refetch`:\n            this.#data.clear()\n            this.#insertedKeys.clear()\n            this.#error = false\n            shouldNotify = this.#updateShapeStatus(`syncing`)\n            // Flag to re-execute sub-snapshots once the new shape is up-to-date\n            this.#reexecuteSnapshotsPending = true\n            break\n        }\n      }\n    })\n\n    if (shouldNotify) this.#notify()\n  }\n\n  async #reexecuteSnapshots(): Promise<void> {\n    // Wait until stream is up-to-date again (ensures schema is available)\n    await this.#awaitUpToDate()\n\n    // Re-execute all snapshots concurrently\n    await Promise.all(\n      Array.from(this.#requestedSubSnapshots).map(async (jsonParams) => {\n        try {\n          const snapshot = JSON.parse(jsonParams)\n          await this.stream.requestSnapshot(snapshot)\n        } catch (_) {\n          // Ignore and continue; errors will be surfaced via stream onError\n        }\n      })\n    )\n  }\n\n  async #awaitUpToDate(): Promise<void> {\n    if (this.stream.isUpToDate) return\n    await new Promise<void>((resolve) => {\n      const check = () => {\n        if (this.stream.isUpToDate) {\n          clearInterval(interval)\n          unsub()\n          resolve()\n        }\n      }\n      const interval = setInterval(check, 10)\n      const unsub = this.stream.subscribe(\n        () => check(),\n        () => check()\n      )\n      check()\n    })\n  }\n\n  #updateShapeStatus(status: ShapeStatus): boolean {\n    const stateChanged = this.#status !== status\n    this.#status = status\n    return stateChanged && status === `up-to-date`\n  }\n\n  #handleError(e: Error): void {\n    if (e instanceof FetchError) {\n      this.#error = e\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    this.#subscribers.forEach((callback) => {\n      callback({ value: this.currentValue, rows: this.currentRows })\n    })\n  }\n}\n"],"mappings":"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","names":["FetchError","_FetchError","status","text","json","headers","url","message","response","contentType","FetchBackoffAbortError","MissingShapeUrlError","InvalidSignalError","MissingShapeHandleError","ReservedParamError","reservedParams","ParserNullValueError","columnName","MissingHeadersError","url","missingHeaders","msg","h","parseNumber","value","parseBool","parseBigInt","parseJson","identityParser","v","defaultParser","pgArrayParser","parser","i","char","str","quoted","last","p","extractValue","x","start","end","val","loop","xs","MessageParser","transformer","__spreadValues","messages","schema","key","message","msg","row","_b","columnInfo","_a","typ","dimensions","additionalInfo","__objRest","typeParser","makeNullableParser","_","columnName","isNullable","ParserNullValueError","quoteIdentifier","identifier","snakeToCamel","str","_a","_b","_c","_d","leadingUnderscores","withoutLeading","trailingUnderscores","camelCased","_","letter","camelToSnake","createColumnMapper","mapping","reverseMapping","dbName","appName","dbColumnName","appColumnName","encodeWhereClause","whereClause","encode","sqlKeywords","quotedRanges","pos","ch","start","quoteChar","isInQuotedString","range","identifierPattern","match","_p1","offset","snakeCamelMapper","schema","dbColumn","isChangeMessage","message","isControlMessage","isUpToDateMessage","getOffset","lsn","isVisibleInSnapshot","txid","snapshot","xid","xmin","xmax","xip","LIVE_CACHE_BUSTER_HEADER","SHAPE_HANDLE_HEADER","CHUNK_LAST_OFFSET_HEADER","SHAPE_SCHEMA_HEADER","CHUNK_UP_TO_DATE_HEADER","COLUMNS_QUERY_PARAM","LIVE_CACHE_BUSTER_QUERY_PARAM","EXPIRED_HANDLE_QUERY_PARAM","SHAPE_HANDLE_QUERY_PARAM","LIVE_QUERY_PARAM","OFFSET_QUERY_PARAM","TABLE_QUERY_PARAM","WHERE_QUERY_PARAM","REPLICA_PARAM","WHERE_PARAMS_PARAM","EXPERIMENTAL_LIVE_SSE_QUERY_PARAM","LIVE_SSE_QUERY_PARAM","FORCE_DISCONNECT_AND_REFRESH","PAUSE_STREAM","LOG_MODE_QUERY_PARAM","SUBSET_PARAM_WHERE","SUBSET_PARAM_LIMIT","SUBSET_PARAM_OFFSET","SUBSET_PARAM_ORDER_BY","SUBSET_PARAM_WHERE_PARAMS","SUBSET_PARAM_WHERE_EXPR","SUBSET_PARAM_ORDER_BY_EXPR","ELECTRIC_PROTOCOL_QUERY_PARAMS","HTTP_RETRY_STATUS_CODES","BackoffDefaults","parseRetryAfterHeader","retryAfter","retryAfterSec","retryDate","deltaMs","createFetchWithBackoff","fetchClient","backoffOptions","initialDelay","maxDelay","multiplier","debug","onFailedAttempt","maxRetries","args","_a","url","options","delay","attempt","result","FetchError","e","FetchBackoffAbortError","serverMinimumMs","jitter","clientBackoffMs","waitMs","source","resolve","NO_BODY_STATUS_CODES","createFetchWithConsumedMessages","_b","res","text","err","ChunkPrefetchDefaults","createFetchWithChunkBuffer","prefetchOptions","maxChunksToPrefetch","prefetchQueue","prefetchedRequest","response","nextUrl","getNextChunkUrl","PrefetchQueue","requiredElectricResponseHeaders","requiredLiveResponseHeaders","requiredNonLiveResponseHeaders","createFetchWithResponseHeadersCheck","headers","missingHeaders","addMissingHeaders","requiredHeaders","h","urlString","SUBSET_PARAM_WHERE","SUBSET_PARAM_WHERE_PARAMS","SUBSET_PARAM_LIMIT","SUBSET_PARAM_OFFSET","SUBSET_PARAM_ORDER_BY","p","LIVE_QUERY_PARAM","MissingHeadersError","_fetchClient","_maxPrefetchedRequests","_prefetchQueue","_queueHeadUrl","_queueTailUrl","_PrefetchQueue_instances","prefetch_fn","__privateAdd","__privateSet","__privateGet","__privateMethod","_","aborter","entry","request","signal","cleanup","chainAborter","__spreadProps","__spreadValues","shapeHandle","SHAPE_HANDLE_HEADER","lastOffset","CHUNK_LAST_OFFSET_HEADER","isUpToDate","CHUNK_UP_TO_DATE_HEADER","expiredHandle","EXPIRED_HANDLE_QUERY_PARAM","SHAPE_HANDLE_QUERY_PARAM","OFFSET_QUERY_PARAM","sourceSignal","noop","abortParent","compileExpression","expr","columnMapper","mappedColumn","quoteIdentifier","compileFunction","_exhaustive","args","arg","a","compileOrderBy","clauses","clause","sql","fetchEventSource","ExpiredShapesCache","shapeUrl","entry","handle","keys","oldest","min","k","stored","expiredShapesCache","UpToDateTracker","shapeKey","cursor","keys","oldest","min","k","now","timeSinceLastWrite","delay","entry","modified","key","stored","upToDateTracker","SnapshotTracker","metadata","keys","_a","_b","_c","_d","xmaxSet","databaseLsnSet","snapshotMark","message","txids","xid","xmax","snapshots","snapshot","x","isVisibleInSnapshot","newDatabaseLsn","dbLsn","RESERVED_PARAMS","LIVE_CACHE_BUSTER_QUERY_PARAM","SHAPE_HANDLE_QUERY_PARAM","LIVE_QUERY_PARAM","OFFSET_QUERY_PARAM","resolveValue","value","toInternalParams","params","entries","resolvedEntries","key","resolvedValue","_","resolveHeaders","headers","canonicalShapeKey","url","cleanUrl","ELECTRIC_PROTOCOL_QUERY_PARAMS","_error","_fetchClient","_sseFetchClient","_messageParser","_subscribers","_started","_state","_lastOffset","_liveCacheBuster","_lastSyncedAt","_isUpToDate","_isMidStream","_connected","_shapeHandle","_mode","_schema","_onError","_requestAbortController","_isRefreshing","_tickPromise","_tickPromiseResolver","_tickPromiseRejecter","_messageChain","_snapshotTracker","_activeSnapshotRequests","_midStreamPromise","_midStreamPromiseResolver","_lastSeenCursor","_currentFetchUrl","_lastSseConnectionStartTime","_minSseConnectionDuration","_consecutiveShortSseConnections","_maxShortSseConnections","_sseFallbackToLongPolling","_sseBackoffBaseDelay","_sseBackoffMaxDelay","_unsubscribeFromVisibilityChanges","_ShapeStream_instances","replayMode_get","start_fn","requestShape_fn","constructUrl_fn","createAbortListener_fn","onInitialResponse_fn","onMessages_fn","fetchShape_fn","requestShapeLongPoll_fn","requestShapeSSE_fn","pause_fn","resume_fn","nextTick_fn","waitForStreamEnd_fn","publish_fn","sendErrorToSubscribers_fn","subscribeToVisibilityChanges_fn","reset_fn","ShapeStream","options","__privateAdd","SnapshotTracker","_a","_b","_c","_d","__spreadValues","validateOptions","__privateSet","transformer","applyColumnMapper","row","result","dbKey","appKey","MessageParser","baseFetchClient","args","backOffOpts","__spreadProps","BackoffDefaults","fetchWithBackoffClient","createFetchWithBackoff","createFetchWithResponseHeadersCheck","createFetchWithChunkBuffer","createFetchWithConsumedMessages","__privateGet","__privateMethod","callback","onError","subscriptionId","FORCE_DISCONNECT_AND_REFRESH","opts","__privateWrapper","metadata","data","dataWithEndBoundary","message","fetchUrl","requestHeaders","response","FetchError","schema","getSchemaFromHeaders","rawData","_e","err","retryOpts","resumingFromPause","signal","abortListener","requestAbortController","e","FetchBackoffAbortError","currentState","PAUSE_STREAM","shapeKey","expiredShapesCache","newShapeHandle","SHAPE_HANDLE_HEADER","subsetParams","_f","convertWhereParamsToObj","validateParams","setQueryParam","TABLE_QUERY_PARAM","encodedWhere","encodeWhereClause","WHERE_QUERY_PARAM","originalColumns","encodedColumns","serializedColumns","quoteIdentifier","COLUMNS_QUERY_PARAM","REPLICA_PARAM","WHERE_PARAMS_PARAM","customParams","compiledWhere","compileExpression","SUBSET_PARAM_WHERE","SUBSET_PARAM_WHERE_EXPR","SUBSET_PARAM_WHERE_PARAMS","SUBSET_PARAM_LIMIT","SUBSET_PARAM_OFFSET","compiledOrderBy","compileOrderBy","SUBSET_PARAM_ORDER_BY","SUBSET_PARAM_ORDER_BY_EXPR","encodedOrderBy","LOG_MODE_QUERY_PARAM","isSnapshotRequest","expiredHandle","EXPIRED_HANDLE_QUERY_PARAM","status","shapeHandle","lastOffset","CHUNK_LAST_OFFSET_HEADER","liveCacheBuster","LIVE_CACHE_BUSTER_HEADER","batch","isSseMessage","lastMessage","isUpToDateMessage","offset","getOffset","upToDateTracker","messagesToProcess","isChangeMessage","lastSeenCursor","useSse","EXPERIMENTAL_LIVE_SSE_QUERY_PARAM","LIVE_SSE_QUERY_PARAM","messages","fetch","sseHeaders","buffer","fetchEventSource","event","error","connectionDuration","wasAborted","maxDelay","delayMs","resolve","reject","__","errorFn","visibilityHandler","handle","schemaHeader","SHAPE_SCHEMA_HEADER","MissingHeadersError","reservedParams","ReservedParamError","MissingShapeUrlError","InvalidSignalError","MissingShapeHandleError","k","v","allPgParams","i","_data","_subscribers","_insertedKeys","_requestedSubSnapshots","_reexecuteSnapshotsPending","_status","_error","_Shape_instances","process_fn","reexecuteSnapshots_fn","awaitUpToDate_fn","updateShapeStatus_fn","handleError_fn","notify_fn","Shape","stream","__privateAdd","__privateMethod","__privateGet","v","resolve","reject","unsubscribe","value","params","key","callback","subscriptionId","messages","shouldNotify","message","isChangeMessage","__spreadValues","isControlMessage","__privateSet","jsonParams","snapshot","_","check","interval","unsub","status","stateChanged","FetchError"]}