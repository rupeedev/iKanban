var Rs=Object.defineProperty,bs=Object.defineProperties;var As=Object.getOwnPropertyDescriptors;var Fe=Object.getOwnPropertySymbols;var Ft=Object.prototype.hasOwnProperty,qt=Object.prototype.propertyIsEnumerable;var $t=r=>{throw TypeError(r)};var Bt=(r,e,t)=>e in r?Rs(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,E=(r,e)=>{for(var t in e||(e={}))Ft.call(e,t)&&Bt(r,t,e[t]);if(Fe)for(var t of Fe(e))qt.call(e,t)&&Bt(r,t,e[t]);return r},ie=(r,e)=>bs(r,As(e));var jt=(r,e)=>{var t={};for(var s in r)Ft.call(r,s)&&e.indexOf(s)<0&&(t[s]=r[s]);if(r!=null&&Fe)for(var s of Fe(r))e.indexOf(s)<0&&qt.call(r,s)&&(t[s]=r[s]);return t};var ht=(r,e,t)=>e.has(r)||$t("Cannot "+t);var n=(r,e,t)=>(ht(r,e,"read from private field"),t?t.call(r):e.get(r)),d=(r,e,t)=>e.has(r)?$t("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),c=(r,e,t,s)=>(ht(r,e,"write to private field"),s?s.call(r,t):e.set(r,t),t),p=(r,e,t)=>(ht(r,e,"access private method"),t);var qe=(r,e,t,s)=>({set _(i){c(r,e,i,t)},get _(){return n(r,e,s)}});var x=class r extends Error{constructor(t,s,i,o,a,h){super(h||`HTTP Error ${t} at ${a}: ${s!=null?s:JSON.stringify(i)}`);this.url=a;this.name="FetchError",this.status=t,this.text=s,this.json=i,this.headers=o}static async fromResponse(t,s){let i=t.status,o=Object.fromEntries([...t.headers.entries()]),a,h,u=t.headers.get("content-type");return t.bodyUsed||(u&&u.includes("application/json")?h=await t.json():a=await t.text()),new r(i,a,h,o,s)}},D=class extends Error{constructor(){super("Fetch with backoff aborted"),this.name="FetchBackoffAbortError"}};var $e=class extends Error{constructor(){super("Invalid shape options: missing required url parameter"),this.name="MissingShapeUrlError"}},je=class extends Error{constructor(){super("Invalid signal option. It must be an instance of AbortSignal."),this.name="InvalidSignalError"}},Ve=class extends Error{constructor(){super("shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)"),this.name="MissingShapeHandleError"}},Ye=class extends Error{constructor(e){super(`Cannot use reserved Electric parameter names in custom params: ${e.join(", ")}`),this.name="ReservedParamError"}},We=class extends Error{constructor(e){super(`Column "${e!=null?e:"unknown"}" does not allow NULL values`),this.name="ParserNullValueError"}};var ae=class extends Error{constructor(e,t){let s=`The response for the shape request to ${e} didn't include the following required headers:
`;t.forEach(i=>{s+=`- ${i}
`}),s+=`
This is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`,s+=`
For more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`,super(s)}};var Ke=r=>Number(r),_s=r=>r==="true"||r==="t",xs=r=>BigInt(r),Vt=r=>JSON.parse(r),Ps=r=>r,Ts={int2:Ke,int4:Ke,int8:xs,bool:_s,float4:Ke,float8:Ke,json:Vt,jsonb:Vt};function ws(r,e){let t=0,s=null,i="",o=!1,a=0,h;function u(l,g,R){let _=l.slice(g,R);return _=_==="NULL"?null:_,e?e(_):_}function m(l){let g=[];for(;t<l.length;t++){if(s=l[t],o)s==="\\"?i+=l[++t]:s==='"'?(g.push(e?e(i):i),i="",o=l[t+1]==='"',a=t+2):i+=s;else if(s==='"')o=!0;else if(s==="{")a=++t,g.push(m(l));else if(s==="}"){o=!1,a<t&&g.push(u(l,a,t)),a=t+1;break}else s===","&&h!=="}"&&h!=='"'&&(g.push(u(l,a,t)),a=t+1);h=s}return a<t&&g.push(g.push(u(l,a,t+1))),g}return m(r)[0]}var Qe=class{constructor(e,t){this.parser=E(E({},Ts),e),this.transformer=t}parse(e,t){return JSON.parse(e,(s,i)=>(s==="value"||s==="old_value")&&typeof i=="object"&&i!==null?this.transformMessageValue(i,t):i)}parseSnapshotData(e,t){return e.map(s=>{let i=s;return i.value&&typeof i.value=="object"&&i.value!==null&&(i.value=this.transformMessageValue(i.value,t)),i.old_value&&typeof i.old_value=="object"&&i.old_value!==null&&(i.old_value=this.transformMessageValue(i.old_value,t)),i})}transformMessageValue(e,t){let s=e;return Object.keys(s).forEach(i=>{s[i]=this.parseRow(i,s[i],t)}),this.transformer?this.transformer(s):s}parseRow(e,t,s){var g;let i=s[e];if(!i)return t;let l=i,{type:o,dims:a}=l,h=jt(l,["type","dims"]),u=(g=this.parser[o])!=null?g:Ps,m=Yt(u,i,e);return a&&a>0?Yt((_,S)=>ws(_,m),i,e)(t):m(t,h)}};function Yt(r,e,t){var i;let s=!((i=e.not_null)!=null&&i);return o=>{if(o===null){if(!s)throw new We(t!=null?t:"unknown");return null}return r(o,e)}}function xe(r){return`"${r.replace(/"/g,'""')}"`}function lt(r){var h,u,m,l;let e=(u=(h=r.match(/^_+/))==null?void 0:h[0])!=null?u:"",t=r.slice(e.length),s=(l=(m=t.match(/_+$/))==null?void 0:m[0])!=null?l:"",a=(s?t.slice(0,t.length-s.length):t).toLowerCase().replace(/_+([a-z])/g,(g,R)=>R.toUpperCase());return e+a+s}function Wt(r){return r.replace(/([a-z])([A-Z])/g,"$1_$2").replace(/([A-Z]+)([A-Z][a-z])/g,"$1_$2").toLowerCase()}function Kt(r){let e={};for(let[t,s]of Object.entries(r))e[s]=t;return{decode:t=>{var s;return(s=r[t])!=null?s:t},encode:t=>{var s;return(s=e[t])!=null?s:t}}}function ze(r,e){if(!r||!e)return r!=null?r:"";let t=new Set(["SELECT","FROM","WHERE","AND","OR","NOT","IN","IS","NULL","NULLS","FIRST","LAST","TRUE","FALSE","LIKE","ILIKE","BETWEEN","ASC","DESC","LIMIT","OFFSET","ORDER","BY","GROUP","HAVING","DISTINCT","AS","ON","JOIN","LEFT","RIGHT","INNER","OUTER","CROSS","CASE","WHEN","THEN","ELSE","END","CAST","LOWER","UPPER","COALESCE","NULLIF"]),s=[],i=0;for(;i<r.length;){let h=r[i];if(h==="'"||h==='"'){let u=i,m=h;for(i++;i<r.length;)if(r[i]===m)if(r[i+1]===m)i+=2;else{i++;break}else i++;s.push({start:u,end:i})}else i++}let o=h=>s.some(u=>h>=u.start&&h<u.end),a=new RegExp("(?<![a-zA-Z0-9_])([a-zA-Z_][a-zA-Z0-9_]*)(?![a-zA-Z0-9_])","g");return r.replace(a,(h,u,m)=>o(m)||t.has(h.toUpperCase())||h.startsWith("$")?h:e(h))}function Ms(r){if(r){let e={};for(let t of Object.keys(r))e[t]=lt(t);return Kt(e)}return{decode:e=>lt(e),encode:e=>Wt(e)}}function oe(r){return"key"in r}function Ge(r){return!oe(r)}function ut(r){return Ge(r)&&r.headers.control==="up-to-date"}function Qt(r){if(r.headers.control!="up-to-date")return;let e=r.headers.global_last_seen_lsn;return e?`${e}_0`:void 0}function dt(r,e){let t=BigInt(r),s=BigInt(e.xmin),i=BigInt(e.xmax),o=e.xip_list.map(BigInt);return t<s||t<i&&!o.includes(t)}var zt="electric-cursor",Pe="electric-handle",Je="electric-offset",ft="electric-schema",Gt="electric-up-to-date",pt="columns",Xe="cursor",Te="expired_handle",ce="handle",H="live",he="offset",Jt="table",Xt="where",Zt="replica",es="params",ts="experimental_live_sse",mt="live_sse",gt="force-disconnect-and-refresh",Et="pause-stream",St="log",le="subset__where",we="subset__limit",Me="subset__offset",ue="subset__order_by",ve="subset__params",yt="subset__where_expr",Rt="subset__order_by_expr",bt=[H,mt,ce,he,Xe,Te,St,le,we,Me,ue,ve,yt,Rt];var vs=[429],et={initialDelay:100,maxDelay:6e4,multiplier:1.3,maxRetries:1/0};function Cs(r){if(!r)return 0;let e=Number(r);if(Number.isFinite(e)&&e>0)return e*1e3;let t=Date.parse(r);if(!isNaN(t)){let s=t-Date.now();return Math.max(0,Math.min(s,36e5))}return 0}function ss(r,e=et){let{initialDelay:t,maxDelay:s,multiplier:i,debug:o=!1,onFailedAttempt:a,maxRetries:h=1/0}=e;return async(...u)=>{var _;let m=u[0],l=u[1],g=t,R=0;for(;;)try{let S=await r(...u);if(S.ok)return S;throw await x.fromResponse(S,m.toString())}catch(S){if(a==null||a(),(_=l==null?void 0:l.signal)!=null&&_.aborted)throw new D;if(S instanceof x&&!vs.includes(S.status)&&S.status>=400&&S.status<500)throw S;{if(R++,R>h)throw o&&console.log(`Max retries reached (${R}/${h}), giving up`),S;let O=S instanceof x&&S.headers?Cs(S.headers["retry-after"]):0,b=Math.random()*g,L=Math.min(b,s),j=Math.max(O,L);if(o){let _e=O>0?"server+client":"client";console.log(`Retry attempt #${R} after ${j}ms (${_e}, serverMin=${O}ms, clientBackoff=${L}ms)`)}await new Promise(_e=>setTimeout(_e,j)),g=Math.min(g*i,s)}}}}var ks=[201,204,205];function rs(r){return async(...e)=>{var i,o;let t=e[0],s=await r(...e);try{if(s.status<200||ks.includes(s.status))return s;let a=await s.text();return new Response(a,s)}catch(a){throw(o=(i=e[1])==null?void 0:i.signal)!=null&&o.aborted?new D:new x(s.status,void 0,void 0,Object.fromEntries([...s.headers.entries()]),t.toString(),a instanceof Error?a.message:typeof a=="string"?a:"failed to read body")}}}var Us={maxChunksToPrefetch:2};function ns(r,e=Us){let{maxChunksToPrefetch:t}=e,s;return async(...o)=>{let a=o[0].toString(),h=s==null?void 0:s.consume(...o);if(h)return h;s==null||s.abort(),s=void 0;let u=await r(...o),m=_t(a,u);return m&&(s=new At({fetchClient:r,maxPrefetchedRequests:t,url:m,requestInit:o[1]})),u}}var Os=["electric-offset","electric-handle"],Ls=["electric-cursor"],Ds=["electric-schema"];function is(r){return async(...e)=>{let t=await r(...e);if(t.ok){let s=t.headers,i=[],o=l=>i.push(...l.filter(g=>!s.has(g))),h=e[0].toString(),u=new URL(h);if([le,ve,we,Me,ue].some(l=>u.searchParams.has(l)))return t;if(o(Os),u.searchParams.get(H)==="true"&&o(Ls),(!u.searchParams.has(H)||u.searchParams.get(H)==="false")&&o(Ds),i.length>0)throw new ae(h,i)}return t}}var Ce,ke,v,ee,I,de,Ze,At=class{constructor(e){d(this,de);d(this,Ce);d(this,ke);d(this,v,new Map);d(this,ee);d(this,I);var t;c(this,Ce,(t=e.fetchClient)!=null?t:(...s)=>fetch(...s)),c(this,ke,e.maxPrefetchedRequests),c(this,ee,e.url.toString()),c(this,I,n(this,ee)),p(this,de,Ze).call(this,e.url,e.requestInit)}abort(){n(this,v).forEach(([e,t])=>t.abort()),n(this,v).clear()}consume(...e){let t=e[0].toString(),s=n(this,v).get(t);if(!s||t!==n(this,ee))return;let[i,o]=s;if(o.signal.aborted){n(this,v).delete(t);return}return n(this,v).delete(t),i.then(a=>{let h=_t(t,a);c(this,ee,h),n(this,I)&&!n(this,v).has(n(this,I))&&p(this,de,Ze).call(this,n(this,I),e[1])}).catch(()=>{}),i}};Ce=new WeakMap,ke=new WeakMap,v=new WeakMap,ee=new WeakMap,I=new WeakMap,de=new WeakSet,Ze=function(...e){var i,o;let t=e[0].toString();if(n(this,v).size>=n(this,ke))return;let s=new AbortController;try{let{signal:a,cleanup:h}=Hs(s,(i=e[1])==null?void 0:i.signal),u=n(this,Ce).call(this,t,ie(E({},(o=e[1])!=null?o:{}),{signal:a}));n(this,v).set(t,[u,s]),u.then(m=>{if(!m.ok||s.signal.aborted)return;let l=_t(t,m);if(!l||l===t){c(this,I,void 0);return}return c(this,I,l),p(this,de,Ze).call(this,l,e[1])}).catch(()=>{}).finally(h)}catch(a){}};function _t(r,e){let t=e.headers.get(Pe),s=e.headers.get(Je),i=e.headers.has(Gt);if(!t||!s||i)return;let o=new URL(r);if(o.searchParams.has(H))return;let a=o.searchParams.get(Te);if(a&&t===a){console.warn(`[Electric] Received stale cached response with expired shape handle. This should not happen and indicates a proxy/CDN caching misconfiguration. The response contained handle "${t}" which was previously marked as expired. Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. Skipping prefetch to prevent infinite 409 loop.`);return}return o.searchParams.set(ce,t),o.searchParams.set(he,s),o.searchParams.sort(),o.toString()}function Hs(r,e){let t=Is;if(e)if(e.aborted)r.abort();else{let s=()=>r.abort();e.addEventListener("abort",s,{once:!0,signal:r.signal}),t=()=>e.removeEventListener("abort",s)}return{signal:r.signal,cleanup:t}}function Is(){}function tt(r,e){switch(r.type){case"ref":{let t=e?e(r.column):r.column;return xe(t)}case"val":return`$${r.paramIndex}`;case"func":return Ns(r,e);default:{let t=r;throw new Error(`Unknown expression type: ${JSON.stringify(t)}`)}}}function Ns(r,e){let t=r.args.map(s=>tt(s,e));switch(r.name){case"eq":return`${t[0]} = ${t[1]}`;case"gt":return`${t[0]} > ${t[1]}`;case"gte":return`${t[0]} >= ${t[1]}`;case"lt":return`${t[0]} < ${t[1]}`;case"lte":return`${t[0]} <= ${t[1]}`;case"and":return t.map(s=>`(${s})`).join(" AND ");case"or":return t.map(s=>`(${s})`).join(" OR ");case"not":return`NOT (${t[0]})`;case"in":return`${t[0]} = ANY(${t[1]})`;case"like":return`${t[0]} LIKE ${t[1]}`;case"ilike":return`${t[0]} ILIKE ${t[1]}`;case"isNull":case"isUndefined":return`${t[0]} IS NULL`;case"upper":return`UPPER(${t[0]})`;case"lower":return`LOWER(${t[0]})`;case"length":return`LENGTH(${t[0]})`;case"concat":return`CONCAT(${t.join(", ")})`;case"coalesce":return`COALESCE(${t.join(", ")})`;default:throw new Error(`Unknown function: ${r.name}`)}}function xt(r,e){return r.map(t=>{let s=e?e(t.column):t.column,i=xe(s);return t.direction==="desc"&&(i+=" DESC"),t.nulls==="first"&&(i+=" NULLS FIRST"),t.nulls==="last"&&(i+=" NULLS LAST"),i}).join(", ")}import{fetchEventSource as Bs}from"@microsoft/fetch-event-source";var Pt=class{constructor(){this.data={};this.max=250;this.storageKey="electric_expired_shapes";this.load()}getExpiredHandle(e){let t=this.data[e];return t?(t.lastUsed=Date.now(),this.save(),t.expiredHandle):null}markExpired(e,t){this.data[e]={expiredHandle:t,lastUsed:Date.now()};let s=Object.keys(this.data);if(s.length>this.max){let i=s.reduce((o,a)=>this.data[a].lastUsed<this.data[o].lastUsed?a:o);delete this.data[i]}this.save()}save(){if(typeof localStorage!="undefined")try{localStorage.setItem(this.storageKey,JSON.stringify(this.data))}catch(e){}}load(){if(typeof localStorage!="undefined")try{let e=localStorage.getItem(this.storageKey);e&&(this.data=JSON.parse(e))}catch(e){this.data={}}}clear(){this.data={},this.save()}},st=new Pt;var Tt=class{constructor(){this.data={};this.storageKey="electric_up_to_date_tracker";this.cacheTTL=6e4;this.maxEntries=250;this.writeThrottleMs=6e4;this.lastWriteTime=0;this.load(),this.cleanup()}recordUpToDate(e,t){this.data[e]={timestamp:Date.now(),cursor:t};let s=Object.keys(this.data);if(s.length>this.maxEntries){let i=s.reduce((o,a)=>this.data[a].timestamp<this.data[o].timestamp?a:o);delete this.data[i]}this.scheduleSave()}scheduleSave(){let e=Date.now(),t=e-this.lastWriteTime;if(t>=this.writeThrottleMs)this.lastWriteTime=e,this.save();else if(!this.pendingSaveTimer){let s=this.writeThrottleMs-t;this.pendingSaveTimer=setTimeout(()=>{this.lastWriteTime=Date.now(),this.pendingSaveTimer=void 0,this.save()},s)}}shouldEnterReplayMode(e){let t=this.data[e];return!t||Date.now()-t.timestamp>=this.cacheTTL?null:t.cursor}cleanup(){let e=Date.now(),t=Object.keys(this.data),s=!1;for(let i of t)e-this.data[i].timestamp>this.cacheTTL&&(delete this.data[i],s=!0);s&&this.save()}save(){if(typeof localStorage!="undefined")try{localStorage.setItem(this.storageKey,JSON.stringify(this.data))}catch(e){}}load(){if(typeof localStorage!="undefined")try{let e=localStorage.getItem(this.storageKey);e&&(this.data=JSON.parse(e))}catch(e){this.data={}}}clear(){this.data={},this.pendingSaveTimer&&(clearTimeout(this.pendingSaveTimer),this.pendingSaveTimer=void 0),this.save()}},wt=new Tt;var rt=class{constructor(){this.activeSnapshots=new Map;this.xmaxSnapshots=new Map;this.snapshotsByDatabaseLsn=new Map}addSnapshot(e,t){var o,a,h,u;this.activeSnapshots.set(e.snapshot_mark,{xmin:BigInt(e.xmin),xmax:BigInt(e.xmax),xip_list:e.xip_list.map(BigInt),keys:t});let s=(a=(o=this.xmaxSnapshots.get(BigInt(e.xmax)))==null?void 0:o.add(e.snapshot_mark))!=null?a:new Set([e.snapshot_mark]);this.xmaxSnapshots.set(BigInt(e.xmax),s);let i=(u=(h=this.snapshotsByDatabaseLsn.get(BigInt(e.database_lsn)))==null?void 0:h.add(e.snapshot_mark))!=null?u:new Set([e.snapshot_mark]);this.snapshotsByDatabaseLsn.set(BigInt(e.database_lsn),i)}removeSnapshot(e){this.activeSnapshots.delete(e)}shouldRejectMessage(e){let t=e.headers.txids||[];if(t.length===0)return!1;let s=Math.max(...t);for(let[i,o]of this.xmaxSnapshots.entries())if(s>=i)for(let a of o)this.removeSnapshot(a);return[...this.activeSnapshots.values()].some(i=>i.keys.has(e.key)&&dt(s,i))}lastSeenUpdate(e){for(let[t,s]of this.snapshotsByDatabaseLsn.entries())if(t<=e)for(let i of s)this.removeSnapshot(i)}};var Fs=new Set([Xe,ce,H,he]);async function Ht(r){return typeof r=="function"?r():r}async function qs(r){let e=Object.entries(r),t=await Promise.all(e.map(async([s,i])=>{if(i===void 0)return[s,void 0];let o=await Ht(i);return[s,Array.isArray(o)?o.join(","):o]}));return Object.fromEntries(t.filter(([s,i])=>i!==void 0))}async function $s(r){if(!r)return{};let e=Object.entries(r),t=await Promise.all(e.map(async([s,i])=>[s,await Ht(i)]));return Object.fromEntries(t)}function Ue(r){let e=new URL(r.origin+r.pathname);for(let[t,s]of r.searchParams)bt.includes(t)||e.searchParams.set(t,s);return e.searchParams.sort(),e.toString()}var fe,pe,me,te,V,U,A,N,B,Y,M,se,C,T,W,F,ge,k,re,q,Ee,K,Se,De,Q,$,ye,ne,z,He,Ie,G,it,Re,at,ot,Ne,f,vt,Oe,Le,Ct,os,kt,nt,cs,hs,ls,Ut,Ot,us,ds,Lt,Dt,fs,ps,Mt=class{constructor(e){d(this,f);d(this,fe,null);d(this,pe);d(this,me);d(this,te);d(this,V,new Map);d(this,U,!1);d(this,A,"active");d(this,N);d(this,B);d(this,Y);d(this,M,!1);d(this,se,!0);d(this,C,!1);d(this,T);d(this,W);d(this,F);d(this,ge);d(this,k);d(this,re,!1);d(this,q);d(this,Ee);d(this,K);d(this,Se,Promise.resolve([]));d(this,De,new rt);d(this,Q,0);d(this,$);d(this,ye);d(this,ne);d(this,z);d(this,He);d(this,Ie,1e3);d(this,G,0);d(this,it,3);d(this,Re,!1);d(this,at,100);d(this,ot,5e3);d(this,Ne);var a,h,u,m;this.options=E({subscribe:!0},e),js(this.options),c(this,N,(a=this.options.offset)!=null?a:"-1"),c(this,B,""),c(this,T,this.options.handle);let t;if(e.columnMapper){let l=g=>{let R={};for(let[_,S]of Object.entries(g)){let O=e.columnMapper.decode(_);R[O]=S}return R};t=e.transformer?g=>e.transformer(l(g)):l}else t=e.transformer;c(this,te,new Qe(e.parser,t)),c(this,ge,this.options.onError),c(this,W,(h=this.options.log)!=null?h:"full");let s=(u=e.fetchClient)!=null?u:(...l)=>fetch(...l),i=ie(E({},(m=e.backoffOptions)!=null?m:et),{onFailedAttempt:()=>{var l,g;c(this,C,!1),(g=(l=e.backoffOptions)==null?void 0:l.onFailedAttempt)==null||g.call(l)}}),o=ss(s,i);c(this,me,is(ns(o))),c(this,pe,rs(n(this,me))),p(this,f,fs).call(this)}get shapeHandle(){return n(this,T)}get error(){return n(this,fe)}get isUpToDate(){return n(this,M)}get lastOffset(){return n(this,N)}get mode(){return n(this,W)}subscribe(e,t=()=>{}){let s=Math.random();return n(this,V).set(s,[e,t]),n(this,U)||p(this,f,Oe).call(this),()=>{n(this,V).delete(s)}}unsubscribeAll(){var e;n(this,V).clear(),(e=n(this,Ne))==null||e.call(this)}lastSyncedAt(){return n(this,Y)}lastSynced(){return n(this,Y)===void 0?1/0:Date.now()-n(this,Y)}isConnected(){return n(this,C)}isLoading(){return!n(this,M)}hasStarted(){return n(this,U)}isPaused(){return n(this,A)==="paused"}async forceDisconnectAndRefresh(){var e,t;c(this,re,!0),n(this,M)&&!((e=n(this,k))!=null&&e.signal.aborted)&&((t=n(this,k))==null||t.abort(gt)),await p(this,f,us).call(this),c(this,re,!1)}async requestSnapshot(e){if(n(this,W)==="full")throw new Error(`Snapshot requests are not supported in ${n(this,W)} mode, as the consumer is guaranteed to observe all data`);n(this,U)||await p(this,f,Oe).call(this),await p(this,f,ds).call(this),qe(this,Q)._++;try{n(this,Q)===1&&p(this,f,Ut).call(this);let{metadata:t,data:s}=await this.fetchSnapshot(e),i=s.concat([{headers:E({control:"snapshot-end"},t)},{headers:E({control:"subset-end"},e)}]);return n(this,De).addSnapshot(t,new Set(s.map(o=>o.key))),p(this,f,nt).call(this,i,!1),{metadata:t,data:s}}finally{qe(this,Q)._--,n(this,Q)===0&&p(this,f,Ot).call(this)}}async fetchSnapshot(e){var m;let{fetchUrl:t,requestHeaders:s}=await p(this,f,Ct).call(this,this.options.url,!0,e),i=await n(this,pe).call(this,t.toString(),{headers:s});if(!i.ok)throw new x(i.status,void 0,void 0,Object.fromEntries([...i.headers.entries()]),t.toString());let o=(m=n(this,F))!=null?m:as(i.headers,{required:!0,url:t.toString()}),{metadata:a,data:h}=await i.json(),u=n(this,te).parseSnapshotData(h,o);return{metadata:a,data:u}}};fe=new WeakMap,pe=new WeakMap,me=new WeakMap,te=new WeakMap,V=new WeakMap,U=new WeakMap,A=new WeakMap,N=new WeakMap,B=new WeakMap,Y=new WeakMap,M=new WeakMap,se=new WeakMap,C=new WeakMap,T=new WeakMap,W=new WeakMap,F=new WeakMap,ge=new WeakMap,k=new WeakMap,re=new WeakMap,q=new WeakMap,Ee=new WeakMap,K=new WeakMap,Se=new WeakMap,De=new WeakMap,Q=new WeakMap,$=new WeakMap,ye=new WeakMap,ne=new WeakMap,z=new WeakMap,He=new WeakMap,Ie=new WeakMap,G=new WeakMap,it=new WeakMap,Re=new WeakMap,at=new WeakMap,ot=new WeakMap,Ne=new WeakMap,f=new WeakSet,vt=function(){return n(this,ne)!==void 0},Oe=async function(){var e,t,s,i,o;c(this,U,!0);try{await p(this,f,Le).call(this)}catch(a){if(c(this,fe,a),n(this,ge)){let h=await n(this,ge).call(this,a);if(h&&typeof h=="object"){h.params&&(this.options.params=E(E({},(e=this.options.params)!=null?e:{}),h.params)),h.headers&&(this.options.headers=E(E({},(t=this.options.headers)!=null?t:{}),h.headers)),c(this,fe,null),c(this,U,!1),await p(this,f,Oe).call(this);return}a instanceof Error&&p(this,f,Dt).call(this,a),c(this,C,!1),(s=n(this,K))==null||s.call(this);return}throw a instanceof Error&&p(this,f,Dt).call(this,a),c(this,C,!1),(i=n(this,K))==null||i.call(this),a}c(this,C,!1),(o=n(this,K))==null||o.call(this)},Le=async function(){var u,m;if(n(this,A)==="pause-requested"){c(this,A,"paused");return}if(!this.options.subscribe&&((u=this.options.signal)!=null&&u.aborted||n(this,M)))return;let e=n(this,A)==="paused";c(this,A,"active");let{url:t,signal:s}=this.options,{fetchUrl:i,requestHeaders:o}=await p(this,f,Ct).call(this,t,e),a=await p(this,f,os).call(this,s),h=n(this,k);try{await p(this,f,cs).call(this,{fetchUrl:i,requestAbortController:h,headers:o,resumingFromPause:e})}catch(l){if((l instanceof x||l instanceof D)&&h.signal.aborted&&h.signal.reason===gt)return p(this,f,Le).call(this);if(l instanceof D){let g=n(this,A);h.signal.aborted&&h.signal.reason===Et&&g==="pause-requested"&&c(this,A,"paused");return}if(!(l instanceof x))throw l;if(l.status==409){if(n(this,T)){let R=Ue(i);st.markExpired(R,n(this,T))}let g=l.headers[Pe]||`${n(this,T)}-next`;return p(this,f,ps).call(this,g),await p(this,f,Lt).call(this,Array.isArray(l.json)?l.json:[l.json]),p(this,f,Le).call(this)}else throw l}finally{a&&s&&s.removeEventListener("abort",a),c(this,k,void 0)}return(m=n(this,Ee))==null||m.call(this),p(this,f,Le).call(this)},Ct=async function(e,t,s){var l,g,R,_,S,O;let[i,o]=await Promise.all([$s(this.options.headers),this.options.params?qs(Vs(this.options.params)):void 0]);o&&ms(o);let a=new URL(e);if(o){if(o.table&&P(a,Jt,o.table),o.where&&typeof o.where=="string"){let L=ze(o.where,(l=this.options.columnMapper)==null?void 0:l.encode);P(a,Xt,L)}if(o.columns){let L=await Ht((g=this.options.params)==null?void 0:g.columns);if(Array.isArray(L)){let j=L.map(String);this.options.columnMapper&&(j=j.map(this.options.columnMapper.encode));let _e=j.map(xe).join(",");P(a,pt,_e)}else P(a,pt,o.columns)}o.replica&&P(a,Zt,o.replica),o.params&&P(a,es,o.params);let b=E({},o);delete b.table,delete b.where,delete b.columns,delete b.replica,delete b.params;for(let[L,j]of Object.entries(b))P(a,L,j)}if(s){if(s.whereExpr){let b=tt(s.whereExpr,(R=this.options.columnMapper)==null?void 0:R.encode);P(a,le,b),a.searchParams.set(yt,JSON.stringify(s.whereExpr))}else if(s.where&&typeof s.where=="string"){let b=ze(s.where,(_=this.options.columnMapper)==null?void 0:_.encode);P(a,le,b)}if(s.params&&a.searchParams.set(ve,JSON.stringify(s.params)),s.limit&&P(a,we,s.limit),s.offset&&P(a,Me,s.offset),s.orderByExpr){let b=xt(s.orderByExpr,(S=this.options.columnMapper)==null?void 0:S.encode);P(a,ue,b),a.searchParams.set(Rt,JSON.stringify(s.orderByExpr))}else if(s.orderBy&&typeof s.orderBy=="string"){let b=ze(s.orderBy,(O=this.options.columnMapper)==null?void 0:O.encode);P(a,ue,b)}}a.searchParams.set(he,n(this,N)),a.searchParams.set(St,n(this,W));let h=s!==void 0;n(this,M)&&!h&&(!n(this,re)&&!t&&a.searchParams.set(H,"true"),a.searchParams.set(Xe,n(this,B))),n(this,T)&&a.searchParams.set(ce,n(this,T));let u=Ue(a),m=st.getExpiredHandle(u);return m&&a.searchParams.set(Te,m),a.searchParams.sort(),{fetchUrl:a,requestHeaders:i}},os=async function(e){var t;if(c(this,k,new AbortController),e){let s=()=>{var i;(i=n(this,k))==null||i.abort(e.reason)};return e.addEventListener("abort",s,{once:!0}),e.aborted&&((t=n(this,k))==null||t.abort(e.reason)),s}},kt=async function(e){var h;let{headers:t,status:s}=e,i=t.get(Pe);if(i){let u=n(this,z)?Ue(n(this,z)):null,m=u?st.getExpiredHandle(u):null;i!==m?c(this,T,i):console.warn(`[Electric] Received stale cached response with expired shape handle. This should not happen and indicates a proxy/CDN caching misconfiguration. The response contained handle "${i}" which was previously marked as expired. Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. Ignoring the stale handle and continuing with handle "${n(this,T)}".`)}let o=t.get(Je);o&&c(this,N,o);let a=t.get(zt);a&&c(this,B,a),c(this,F,(h=n(this,F))!=null?h:as(t)),s===204&&c(this,Y,Date.now())},nt=async function(e,t=!1){var s;if(e.length>0){c(this,se,!0);let i=e[e.length-1];if(ut(i)){if(t){let a=Qt(i);a&&c(this,N,a)}if(c(this,Y,Date.now()),c(this,M,!0),c(this,se,!1),(s=n(this,ye))==null||s.call(this),n(this,f,vt)&&!t&&n(this,B)===n(this,ne))return;if(c(this,ne,void 0),n(this,z)){let a=Ue(n(this,z));wt.recordUpToDate(a,n(this,B))}}let o=e.filter(a=>oe(a)?!n(this,De).shouldRejectMessage(a):!0);await p(this,f,Lt).call(this,o)}},cs=async function(e){var s;if(c(this,z,e.fetchUrl),!n(this,M)&&!n(this,f,vt)){let i=Ue(e.fetchUrl),o=wt.shouldEnterReplayMode(i);o&&c(this,ne,o)}let t=(s=this.options.liveSse)!=null?s:this.options.experimentalLiveSse;return n(this,M)&&t&&!n(this,re)&&!e.resumingFromPause&&!n(this,Re)?(e.fetchUrl.searchParams.set(ts,"true"),e.fetchUrl.searchParams.set(mt,"true"),p(this,f,ls).call(this,e)):p(this,f,hs).call(this,e)},hs=async function(e){let{fetchUrl:t,requestAbortController:s,headers:i}=e,o=await n(this,pe).call(this,t.toString(),{signal:s.signal,headers:i});c(this,C,!0),await p(this,f,kt).call(this,o);let a=n(this,F),u=await o.text()||"[]",m=n(this,te).parse(u,a);await p(this,f,nt).call(this,m)},ls=async function(e){let{fetchUrl:t,requestAbortController:s,headers:i}=e,o=n(this,me);c(this,He,Date.now());let a=ie(E({},i),{Accept:"text/event-stream"});try{let h=[];await Bs(t.toString(),{headers:a,fetch:o,onopen:async u=>{c(this,C,!0),await p(this,f,kt).call(this,u)},onmessage:u=>{if(u.data){let m=n(this,F),l=n(this,te).parse(u.data,m);h.push(l),ut(l)&&(p(this,f,nt).call(this,h,!0),h=[])}},onerror:u=>{throw u},signal:s.signal})}catch(h){throw s.signal.aborted?new D:h}finally{let h=Date.now()-n(this,He),u=s.signal.aborted;if(h<n(this,Ie)&&!u)if(qe(this,G)._++,n(this,G)>=n(this,it))c(this,Re,!0),console.warn("[Electric] SSE connections are closing immediately (possibly due to proxy buffering or misconfiguration). Falling back to long polling. Your proxy must support streaming SSE responses (not buffer the complete response). Configuration: Nginx add 'X-Accel-Buffering: no', Caddy add 'flush_interval -1' to reverse_proxy. Note: Do NOT disable caching entirely - Electric uses cache headers to enable request collapsing for efficiency.");else{let m=Math.min(n(this,ot),n(this,at)*Math.pow(2,n(this,G))),l=Math.floor(Math.random()*m);await new Promise(g=>setTimeout(g,l))}else h>=n(this,Ie)&&c(this,G,0)}},Ut=function(){var e;n(this,U)&&n(this,A)==="active"&&(c(this,A,"pause-requested"),(e=n(this,k))==null||e.abort(Et))},Ot=function(){var e;if(n(this,U)&&(n(this,A)==="paused"||n(this,A)==="pause-requested")){if((e=this.options.signal)!=null&&e.aborted)return;n(this,A)==="pause-requested"&&c(this,A,"active"),p(this,f,Oe).call(this)}},us=async function(){return n(this,q)?n(this,q):(c(this,q,new Promise((e,t)=>{c(this,Ee,e),c(this,K,t)})),n(this,q).finally(()=>{c(this,q,void 0),c(this,Ee,void 0),c(this,K,void 0)}),n(this,q))},ds=async function(){if(n(this,se))return n(this,$)?n(this,$):(c(this,$,new Promise(e=>{c(this,ye,e)})),n(this,$).finally(()=>{c(this,$,void 0),c(this,ye,void 0)}),n(this,$))},Lt=async function(e){return c(this,Se,n(this,Se).then(()=>Promise.all(Array.from(n(this,V).values()).map(async([t,s])=>{try{await t(e)}catch(i){queueMicrotask(()=>{throw i})}})))),n(this,Se)},Dt=function(e){n(this,V).forEach(([t,s])=>{s==null||s(e)})},fs=function(){if(typeof document=="object"&&typeof document.hidden=="boolean"&&typeof document.addEventListener=="function"){let e=()=>{document.hidden?p(this,f,Ut).call(this):p(this,f,Ot).call(this)};document.addEventListener("visibilitychange",e),c(this,Ne,()=>{document.removeEventListener("visibilitychange",e)})}},ps=function(e){c(this,N,"-1"),c(this,B,""),c(this,T,e),c(this,M,!1),c(this,se,!0),c(this,C,!1),c(this,F,void 0),c(this,Q,0),c(this,G,0),c(this,Re,!1)},Mt.Replica={FULL:"full",DEFAULT:"default"};function as(r,e){let t=r.get(ft);if(!t){if(e!=null&&e.required&&(e!=null&&e.url))throw new ae(e.url,[ft]);return{}}return JSON.parse(t)}function ms(r){if(!r)return;let e=Object.keys(r).filter(t=>Fs.has(t));if(e.length>0)throw new Ye(e)}function js(r){if(!r.url)throw new $e;if(r.signal&&!(r.signal instanceof AbortSignal))throw new je;if(r.offset!==void 0&&r.offset!=="-1"&&r.offset!=="now"&&!r.handle)throw new Ve;ms(r.params)}function P(r,e,t){if(!(t===void 0||t==null))if(typeof t=="string")r.searchParams.set(e,t);else if(typeof t=="object")for(let[s,i]of Object.entries(t))r.searchParams.set(`${e}[${s}]`,i);else r.searchParams.set(e,t.toString())}function Vs(r){return Array.isArray(r.params)?ie(E({},r),{params:Object.fromEntries(r.params.map((e,t)=>[t+1,e]))}):r}var w,J,X,Be,be,Ae,Z,y,Es,Ss,It,ct,ys,Nt,gs=class{constructor(e){d(this,y);d(this,w,new Map);d(this,J,new Map);d(this,X,new Set);d(this,Be,new Set);d(this,be,!1);d(this,Ae,"syncing");d(this,Z,!1);this.stream=e,this.stream.subscribe(p(this,y,Es).bind(this),p(this,y,ys).bind(this))}get isUpToDate(){return n(this,Ae)==="up-to-date"}get lastOffset(){return this.stream.lastOffset}get handle(){return this.stream.shapeHandle}get rows(){return this.value.then(e=>Array.from(e.values()))}get currentRows(){return Array.from(this.currentValue.values())}get value(){return new Promise((e,t)=>{if(this.stream.isUpToDate)e(this.currentValue);else{let s=this.subscribe(({value:i})=>{s(),n(this,Z)&&t(n(this,Z)),e(i)})}})}get currentValue(){return n(this,w)}get error(){return n(this,Z)}lastSyncedAt(){return this.stream.lastSyncedAt()}lastSynced(){return this.stream.lastSynced()}isLoading(){return this.stream.isLoading()}isConnected(){return this.stream.isConnected()}get mode(){return this.stream.mode}async requestSnapshot(e){let t=JSON.stringify(e);n(this,Be).add(t),await p(this,y,It).call(this),await this.stream.requestSnapshot(e)}subscribe(e){let t=Math.random();return n(this,J).set(t,e),()=>{n(this,J).delete(t)}}unsubscribeAll(){n(this,J).clear()}get numSubscribers(){return n(this,J).size}};w=new WeakMap,J=new WeakMap,X=new WeakMap,Be=new WeakMap,be=new WeakMap,Ae=new WeakMap,Z=new WeakMap,y=new WeakSet,Es=function(e){let t=!1;e.forEach(s=>{if(oe(s))if(t=p(this,y,ct).call(this,"syncing"),this.mode==="full")switch(s.headers.operation){case"insert":n(this,w).set(s.key,s.value);break;case"update":n(this,w).set(s.key,E(E({},n(this,w).get(s.key)),s.value));break;case"delete":n(this,w).delete(s.key);break}else switch(s.headers.operation){case"insert":n(this,X).add(s.key),n(this,w).set(s.key,s.value);break;case"update":n(this,X).has(s.key)&&n(this,w).set(s.key,E(E({},n(this,w).get(s.key)),s.value));break;case"delete":n(this,X).has(s.key)&&(n(this,w).delete(s.key),n(this,X).delete(s.key));break}if(Ge(s))switch(s.headers.control){case"up-to-date":t=p(this,y,ct).call(this,"up-to-date"),n(this,be)&&(c(this,be,!1),p(this,y,Ss).call(this));break;case"must-refetch":n(this,w).clear(),n(this,X).clear(),c(this,Z,!1),t=p(this,y,ct).call(this,"syncing"),c(this,be,!0);break}}),t&&p(this,y,Nt).call(this)},Ss=async function(){await p(this,y,It).call(this),await Promise.all(Array.from(n(this,Be)).map(async e=>{try{let t=JSON.parse(e);await this.stream.requestSnapshot(t)}catch(t){}}))},It=async function(){this.stream.isUpToDate||await new Promise(e=>{let t=()=>{this.stream.isUpToDate&&(clearInterval(s),i(),e())},s=setInterval(t,10),i=this.stream.subscribe(()=>t(),()=>t());t()})},ct=function(e){let t=n(this,Ae)!==e;return c(this,Ae,e),t&&e==="up-to-date"},ys=function(e){e instanceof x&&(c(this,Z,e),p(this,y,Nt).call(this))},Nt=function(){n(this,J).forEach(e=>{e({value:this.currentValue,rows:this.currentRows})})};export{et as BackoffDefaults,bt as ELECTRIC_PROTOCOL_QUERY_PARAMS,x as FetchError,gs as Shape,Mt as ShapeStream,Wt as camelToSnake,tt as compileExpression,xt as compileOrderBy,Kt as createColumnMapper,oe as isChangeMessage,Ge as isControlMessage,dt as isVisibleInSnapshot,Ht as resolveValue,Ms as snakeCamelMapper,lt as snakeToCamel};
//# sourceMappingURL=index.browser.mjs.map