var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// src/error.ts
var FetchError = class _FetchError extends Error {
  constructor(status, text, json, headers, url, message) {
    super(
      message || `HTTP Error ${status} at ${url}: ${text != null ? text : JSON.stringify(json)}`
    );
    this.url = url;
    this.name = `FetchError`;
    this.status = status;
    this.text = text;
    this.json = json;
    this.headers = headers;
  }
  static async fromResponse(response, url) {
    const status = response.status;
    const headers = Object.fromEntries([...response.headers.entries()]);
    let text = void 0;
    let json = void 0;
    const contentType = response.headers.get(`content-type`);
    if (!response.bodyUsed) {
      if (contentType && contentType.includes(`application/json`)) {
        json = await response.json();
      } else {
        text = await response.text();
      }
    }
    return new _FetchError(status, text, json, headers, url);
  }
};
var FetchBackoffAbortError = class extends Error {
  constructor() {
    super(`Fetch with backoff aborted`);
    this.name = `FetchBackoffAbortError`;
  }
};
var MissingShapeUrlError = class extends Error {
  constructor() {
    super(`Invalid shape options: missing required url parameter`);
    this.name = `MissingShapeUrlError`;
  }
};
var InvalidSignalError = class extends Error {
  constructor() {
    super(`Invalid signal option. It must be an instance of AbortSignal.`);
    this.name = `InvalidSignalError`;
  }
};
var MissingShapeHandleError = class extends Error {
  constructor() {
    super(
      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`
    );
    this.name = `MissingShapeHandleError`;
  }
};
var ReservedParamError = class extends Error {
  constructor(reservedParams) {
    super(
      `Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`
    );
    this.name = `ReservedParamError`;
  }
};
var ParserNullValueError = class extends Error {
  constructor(columnName) {
    super(`Column "${columnName != null ? columnName : `unknown`}" does not allow NULL values`);
    this.name = `ParserNullValueError`;
  }
};
var MissingHeadersError = class extends Error {
  constructor(url, missingHeaders) {
    let msg = `The response for the shape request to ${url} didn't include the following required headers:
`;
    missingHeaders.forEach((h) => {
      msg += `- ${h}
`;
    });
    msg += `
This is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`;
    msg += `
For more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`;
    super(msg);
  }
};

// src/parser.ts
var parseNumber = (value) => Number(value);
var parseBool = (value) => value === `true` || value === `t`;
var parseBigInt = (value) => BigInt(value);
var parseJson = (value) => JSON.parse(value);
var identityParser = (v) => v;
var defaultParser = {
  int2: parseNumber,
  int4: parseNumber,
  int8: parseBigInt,
  bool: parseBool,
  float4: parseNumber,
  float8: parseNumber,
  json: parseJson,
  jsonb: parseJson
};
function pgArrayParser(value, parser) {
  let i = 0;
  let char = null;
  let str = ``;
  let quoted = false;
  let last = 0;
  let p = void 0;
  function extractValue(x, start, end) {
    let val = x.slice(start, end);
    val = val === `NULL` ? null : val;
    return parser ? parser(val) : val;
  }
  function loop(x) {
    const xs = [];
    for (; i < x.length; i++) {
      char = x[i];
      if (quoted) {
        if (char === `\\`) {
          str += x[++i];
        } else if (char === `"`) {
          xs.push(parser ? parser(str) : str);
          str = ``;
          quoted = x[i + 1] === `"`;
          last = i + 2;
        } else {
          str += char;
        }
      } else if (char === `"`) {
        quoted = true;
      } else if (char === `{`) {
        last = ++i;
        xs.push(loop(x));
      } else if (char === `}`) {
        quoted = false;
        last < i && xs.push(extractValue(x, last, i));
        last = i + 1;
        break;
      } else if (char === `,` && p !== `}` && p !== `"`) {
        xs.push(extractValue(x, last, i));
        last = i + 1;
      }
      p = char;
    }
    last < i && xs.push(xs.push(extractValue(x, last, i + 1)));
    return xs;
  }
  return loop(value)[0];
}
var MessageParser = class {
  constructor(parser, transformer) {
    this.parser = __spreadValues(__spreadValues({}, defaultParser), parser);
    this.transformer = transformer;
  }
  parse(messages, schema) {
    return JSON.parse(messages, (key, value) => {
      if ((key === `value` || key === `old_value`) && typeof value === `object` && value !== null) {
        return this.transformMessageValue(value, schema);
      }
      return value;
    });
  }
  /**
   * Parse an array of ChangeMessages from a snapshot response.
   * Applies type parsing and transformations to the value and old_value properties.
   */
  parseSnapshotData(messages, schema) {
    return messages.map((message) => {
      const msg = message;
      if (msg.value && typeof msg.value === `object` && msg.value !== null) {
        msg.value = this.transformMessageValue(msg.value, schema);
      }
      if (msg.old_value && typeof msg.old_value === `object` && msg.old_value !== null) {
        msg.old_value = this.transformMessageValue(msg.old_value, schema);
      }
      return msg;
    });
  }
  /**
   * Transform a message value or old_value object by parsing its columns.
   */
  transformMessageValue(value, schema) {
    const row = value;
    Object.keys(row).forEach((key) => {
      row[key] = this.parseRow(key, row[key], schema);
    });
    return this.transformer ? this.transformer(row) : row;
  }
  // Parses the message values using the provided parser based on the schema information
  parseRow(key, value, schema) {
    var _b;
    const columnInfo = schema[key];
    if (!columnInfo) {
      return value;
    }
    const _a = columnInfo, { type: typ, dims: dimensions } = _a, additionalInfo = __objRest(_a, ["type", "dims"]);
    const typeParser = (_b = this.parser[typ]) != null ? _b : identityParser;
    const parser = makeNullableParser(typeParser, columnInfo, key);
    if (dimensions && dimensions > 0) {
      const nullablePgArrayParser = makeNullableParser(
        (value2, _) => pgArrayParser(value2, parser),
        columnInfo,
        key
      );
      return nullablePgArrayParser(value);
    }
    return parser(value, additionalInfo);
  }
};
function makeNullableParser(parser, columnInfo, columnName) {
  var _a;
  const isNullable = !((_a = columnInfo.not_null) != null ? _a : false);
  return (value) => {
    if (value === null) {
      if (!isNullable) {
        throw new ParserNullValueError(columnName != null ? columnName : `unknown`);
      }
      return null;
    }
    return parser(value, columnInfo);
  };
}

// src/column-mapper.ts
function quoteIdentifier(identifier) {
  const escaped = identifier.replace(/"/g, `""`);
  return `"${escaped}"`;
}
function snakeToCamel(str) {
  var _a, _b, _c, _d;
  const leadingUnderscores = (_b = (_a = str.match(/^_+/)) == null ? void 0 : _a[0]) != null ? _b : ``;
  const withoutLeading = str.slice(leadingUnderscores.length);
  const trailingUnderscores = (_d = (_c = withoutLeading.match(/_+$/)) == null ? void 0 : _c[0]) != null ? _d : ``;
  const core = trailingUnderscores ? withoutLeading.slice(
    0,
    withoutLeading.length - trailingUnderscores.length
  ) : withoutLeading;
  const normalized = core.toLowerCase();
  const camelCased = normalized.replace(
    /_+([a-z])/g,
    (_, letter) => letter.toUpperCase()
  );
  return leadingUnderscores + camelCased + trailingUnderscores;
}
function camelToSnake(str) {
  return str.replace(/([a-z])([A-Z])/g, `$1_$2`).replace(/([A-Z]+)([A-Z][a-z])/g, `$1_$2`).toLowerCase();
}
function createColumnMapper(mapping) {
  const reverseMapping = {};
  for (const [dbName, appName] of Object.entries(mapping)) {
    reverseMapping[appName] = dbName;
  }
  return {
    decode: (dbColumnName) => {
      var _a;
      return (_a = mapping[dbColumnName]) != null ? _a : dbColumnName;
    },
    encode: (appColumnName) => {
      var _a;
      return (_a = reverseMapping[appColumnName]) != null ? _a : appColumnName;
    }
  };
}
function encodeWhereClause(whereClause, encode) {
  if (!whereClause || !encode) return whereClause != null ? whereClause : ``;
  const sqlKeywords = /* @__PURE__ */ new Set([
    `SELECT`,
    `FROM`,
    `WHERE`,
    `AND`,
    `OR`,
    `NOT`,
    `IN`,
    `IS`,
    `NULL`,
    `NULLS`,
    `FIRST`,
    `LAST`,
    `TRUE`,
    `FALSE`,
    `LIKE`,
    `ILIKE`,
    `BETWEEN`,
    `ASC`,
    `DESC`,
    `LIMIT`,
    `OFFSET`,
    `ORDER`,
    `BY`,
    `GROUP`,
    `HAVING`,
    `DISTINCT`,
    `AS`,
    `ON`,
    `JOIN`,
    `LEFT`,
    `RIGHT`,
    `INNER`,
    `OUTER`,
    `CROSS`,
    `CASE`,
    `WHEN`,
    `THEN`,
    `ELSE`,
    `END`,
    `CAST`,
    `LOWER`,
    `UPPER`,
    `COALESCE`,
    `NULLIF`
  ]);
  const quotedRanges = [];
  let pos = 0;
  while (pos < whereClause.length) {
    const ch = whereClause[pos];
    if (ch === `'` || ch === `"`) {
      const start = pos;
      const quoteChar = ch;
      pos++;
      while (pos < whereClause.length) {
        if (whereClause[pos] === quoteChar) {
          if (whereClause[pos + 1] === quoteChar) {
            pos += 2;
          } else {
            pos++;
            break;
          }
        } else {
          pos++;
        }
      }
      quotedRanges.push({ start, end: pos });
    } else {
      pos++;
    }
  }
  const isInQuotedString = (pos2) => {
    return quotedRanges.some((range) => pos2 >= range.start && pos2 < range.end);
  };
  const identifierPattern = new RegExp("(?<![a-zA-Z0-9_])([a-zA-Z_][a-zA-Z0-9_]*)(?![a-zA-Z0-9_])", "g");
  return whereClause.replace(identifierPattern, (match, _p1, offset) => {
    if (isInQuotedString(offset)) {
      return match;
    }
    if (sqlKeywords.has(match.toUpperCase())) {
      return match;
    }
    if (match.startsWith(`$`)) {
      return match;
    }
    const encoded = encode(match);
    return encoded;
  });
}
function snakeCamelMapper(schema) {
  if (schema) {
    const mapping = {};
    for (const dbColumn of Object.keys(schema)) {
      mapping[dbColumn] = snakeToCamel(dbColumn);
    }
    return createColumnMapper(mapping);
  }
  return {
    decode: (dbColumnName) => {
      return snakeToCamel(dbColumnName);
    },
    encode: (appColumnName) => {
      return camelToSnake(appColumnName);
    }
  };
}

// src/helpers.ts
function isChangeMessage(message) {
  return `key` in message;
}
function isControlMessage(message) {
  return !isChangeMessage(message);
}
function isUpToDateMessage(message) {
  return isControlMessage(message) && message.headers.control === `up-to-date`;
}
function getOffset(message) {
  if (message.headers.control != `up-to-date`) return;
  const lsn = message.headers.global_last_seen_lsn;
  return lsn ? `${lsn}_0` : void 0;
}
function isVisibleInSnapshot(txid, snapshot) {
  const xid = BigInt(txid);
  const xmin = BigInt(snapshot.xmin);
  const xmax = BigInt(snapshot.xmax);
  const xip = snapshot.xip_list.map(BigInt);
  return xid < xmin || xid < xmax && !xip.includes(xid);
}

// src/constants.ts
var LIVE_CACHE_BUSTER_HEADER = `electric-cursor`;
var SHAPE_HANDLE_HEADER = `electric-handle`;
var CHUNK_LAST_OFFSET_HEADER = `electric-offset`;
var SHAPE_SCHEMA_HEADER = `electric-schema`;
var CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`;
var COLUMNS_QUERY_PARAM = `columns`;
var LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`;
var EXPIRED_HANDLE_QUERY_PARAM = `expired_handle`;
var SHAPE_HANDLE_QUERY_PARAM = `handle`;
var LIVE_QUERY_PARAM = `live`;
var OFFSET_QUERY_PARAM = `offset`;
var TABLE_QUERY_PARAM = `table`;
var WHERE_QUERY_PARAM = `where`;
var REPLICA_PARAM = `replica`;
var WHERE_PARAMS_PARAM = `params`;
var EXPERIMENTAL_LIVE_SSE_QUERY_PARAM = `experimental_live_sse`;
var LIVE_SSE_QUERY_PARAM = `live_sse`;
var FORCE_DISCONNECT_AND_REFRESH = `force-disconnect-and-refresh`;
var PAUSE_STREAM = `pause-stream`;
var LOG_MODE_QUERY_PARAM = `log`;
var SUBSET_PARAM_WHERE = `subset__where`;
var SUBSET_PARAM_LIMIT = `subset__limit`;
var SUBSET_PARAM_OFFSET = `subset__offset`;
var SUBSET_PARAM_ORDER_BY = `subset__order_by`;
var SUBSET_PARAM_WHERE_PARAMS = `subset__params`;
var SUBSET_PARAM_WHERE_EXPR = `subset__where_expr`;
var SUBSET_PARAM_ORDER_BY_EXPR = `subset__order_by_expr`;
var ELECTRIC_PROTOCOL_QUERY_PARAMS = [
  LIVE_QUERY_PARAM,
  LIVE_SSE_QUERY_PARAM,
  SHAPE_HANDLE_QUERY_PARAM,
  OFFSET_QUERY_PARAM,
  LIVE_CACHE_BUSTER_QUERY_PARAM,
  EXPIRED_HANDLE_QUERY_PARAM,
  LOG_MODE_QUERY_PARAM,
  SUBSET_PARAM_WHERE,
  SUBSET_PARAM_LIMIT,
  SUBSET_PARAM_OFFSET,
  SUBSET_PARAM_ORDER_BY,
  SUBSET_PARAM_WHERE_PARAMS,
  SUBSET_PARAM_WHERE_EXPR,
  SUBSET_PARAM_ORDER_BY_EXPR
];

// src/fetch.ts
var HTTP_RETRY_STATUS_CODES = [429];
var BackoffDefaults = {
  initialDelay: 100,
  maxDelay: 6e4,
  // Cap at 60s - reasonable for long-lived connections
  multiplier: 1.3,
  maxRetries: Infinity
  // Retry forever - clients may go offline and come back
};
function parseRetryAfterHeader(retryAfter) {
  if (!retryAfter) return 0;
  const retryAfterSec = Number(retryAfter);
  if (Number.isFinite(retryAfterSec) && retryAfterSec > 0) {
    return retryAfterSec * 1e3;
  }
  const retryDate = Date.parse(retryAfter);
  if (!isNaN(retryDate)) {
    const deltaMs = retryDate - Date.now();
    return Math.max(0, Math.min(deltaMs, 36e5));
  }
  return 0;
}
function createFetchWithBackoff(fetchClient, backoffOptions = BackoffDefaults) {
  const {
    initialDelay,
    maxDelay,
    multiplier,
    debug = false,
    onFailedAttempt,
    maxRetries = Infinity
  } = backoffOptions;
  return async (...args) => {
    var _a;
    const url = args[0];
    const options = args[1];
    let delay = initialDelay;
    let attempt = 0;
    while (true) {
      try {
        const result = await fetchClient(...args);
        if (result.ok) {
          return result;
        }
        const err = await FetchError.fromResponse(result, url.toString());
        throw err;
      } catch (e) {
        onFailedAttempt == null ? void 0 : onFailedAttempt();
        if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {
          throw new FetchBackoffAbortError();
        } else if (e instanceof FetchError && !HTTP_RETRY_STATUS_CODES.includes(e.status) && e.status >= 400 && e.status < 500) {
          throw e;
        } else {
          attempt++;
          if (attempt > maxRetries) {
            if (debug) {
              console.log(
                `Max retries reached (${attempt}/${maxRetries}), giving up`
              );
            }
            throw e;
          }
          const serverMinimumMs = e instanceof FetchError && e.headers ? parseRetryAfterHeader(e.headers[`retry-after`]) : 0;
          const jitter = Math.random() * delay;
          const clientBackoffMs = Math.min(jitter, maxDelay);
          const waitMs = Math.max(serverMinimumMs, clientBackoffMs);
          if (debug) {
            const source = serverMinimumMs > 0 ? `server+client` : `client`;
            console.log(
              `Retry attempt #${attempt} after ${waitMs}ms (${source}, serverMin=${serverMinimumMs}ms, clientBackoff=${clientBackoffMs}ms)`
            );
          }
          await new Promise((resolve) => setTimeout(resolve, waitMs));
          delay = Math.min(delay * multiplier, maxDelay);
        }
      }
    }
  };
}
var NO_BODY_STATUS_CODES = [201, 204, 205];
function createFetchWithConsumedMessages(fetchClient) {
  return async (...args) => {
    var _a, _b;
    const url = args[0];
    const res = await fetchClient(...args);
    try {
      if (res.status < 200 || NO_BODY_STATUS_CODES.includes(res.status)) {
        return res;
      }
      const text = await res.text();
      return new Response(text, res);
    } catch (err) {
      if ((_b = (_a = args[1]) == null ? void 0 : _a.signal) == null ? void 0 : _b.aborted) {
        throw new FetchBackoffAbortError();
      }
      throw new FetchError(
        res.status,
        void 0,
        void 0,
        Object.fromEntries([...res.headers.entries()]),
        url.toString(),
        err instanceof Error ? err.message : typeof err === `string` ? err : `failed to read body`
      );
    }
  };
}
var ChunkPrefetchDefaults = {
  maxChunksToPrefetch: 2
};
function createFetchWithChunkBuffer(fetchClient, prefetchOptions = ChunkPrefetchDefaults) {
  const { maxChunksToPrefetch } = prefetchOptions;
  let prefetchQueue;
  const prefetchClient = async (...args) => {
    const url = args[0].toString();
    const prefetchedRequest = prefetchQueue == null ? void 0 : prefetchQueue.consume(...args);
    if (prefetchedRequest) {
      return prefetchedRequest;
    }
    prefetchQueue == null ? void 0 : prefetchQueue.abort();
    prefetchQueue = void 0;
    const response = await fetchClient(...args);
    const nextUrl = getNextChunkUrl(url, response);
    if (nextUrl) {
      prefetchQueue = new PrefetchQueue({
        fetchClient,
        maxPrefetchedRequests: maxChunksToPrefetch,
        url: nextUrl,
        requestInit: args[1]
      });
    }
    return response;
  };
  return prefetchClient;
}
var requiredElectricResponseHeaders = [
  `electric-offset`,
  `electric-handle`
];
var requiredLiveResponseHeaders = [`electric-cursor`];
var requiredNonLiveResponseHeaders = [`electric-schema`];
function createFetchWithResponseHeadersCheck(fetchClient) {
  return async (...args) => {
    const response = await fetchClient(...args);
    if (response.ok) {
      const headers = response.headers;
      const missingHeaders = [];
      const addMissingHeaders = (requiredHeaders) => missingHeaders.push(...requiredHeaders.filter((h) => !headers.has(h)));
      const input = args[0];
      const urlString = input.toString();
      const url = new URL(urlString);
      const isSnapshotRequest = [
        SUBSET_PARAM_WHERE,
        SUBSET_PARAM_WHERE_PARAMS,
        SUBSET_PARAM_LIMIT,
        SUBSET_PARAM_OFFSET,
        SUBSET_PARAM_ORDER_BY
      ].some((p) => url.searchParams.has(p));
      if (isSnapshotRequest) {
        return response;
      }
      addMissingHeaders(requiredElectricResponseHeaders);
      if (url.searchParams.get(LIVE_QUERY_PARAM) === `true`) {
        addMissingHeaders(requiredLiveResponseHeaders);
      }
      if (!url.searchParams.has(LIVE_QUERY_PARAM) || url.searchParams.get(LIVE_QUERY_PARAM) === `false`) {
        addMissingHeaders(requiredNonLiveResponseHeaders);
      }
      if (missingHeaders.length > 0) {
        throw new MissingHeadersError(urlString, missingHeaders);
      }
    }
    return response;
  };
}
var _fetchClient, _maxPrefetchedRequests, _prefetchQueue, _queueHeadUrl, _queueTailUrl, _PrefetchQueue_instances, prefetch_fn;
var PrefetchQueue = class {
  constructor(options) {
    __privateAdd(this, _PrefetchQueue_instances);
    __privateAdd(this, _fetchClient);
    __privateAdd(this, _maxPrefetchedRequests);
    __privateAdd(this, _prefetchQueue, /* @__PURE__ */ new Map());
    __privateAdd(this, _queueHeadUrl);
    __privateAdd(this, _queueTailUrl);
    var _a;
    __privateSet(this, _fetchClient, (_a = options.fetchClient) != null ? _a : (...args) => fetch(...args));
    __privateSet(this, _maxPrefetchedRequests, options.maxPrefetchedRequests);
    __privateSet(this, _queueHeadUrl, options.url.toString());
    __privateSet(this, _queueTailUrl, __privateGet(this, _queueHeadUrl));
    __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, options.url, options.requestInit);
  }
  abort() {
    __privateGet(this, _prefetchQueue).forEach(([_, aborter]) => aborter.abort());
    __privateGet(this, _prefetchQueue).clear();
  }
  consume(...args) {
    const url = args[0].toString();
    const entry = __privateGet(this, _prefetchQueue).get(url);
    if (!entry || url !== __privateGet(this, _queueHeadUrl)) return;
    const [request, aborter] = entry;
    if (aborter.signal.aborted) {
      __privateGet(this, _prefetchQueue).delete(url);
      return;
    }
    __privateGet(this, _prefetchQueue).delete(url);
    request.then((response) => {
      const nextUrl = getNextChunkUrl(url, response);
      __privateSet(this, _queueHeadUrl, nextUrl);
      if (__privateGet(this, _queueTailUrl) && !__privateGet(this, _prefetchQueue).has(__privateGet(this, _queueTailUrl))) {
        __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, __privateGet(this, _queueTailUrl), args[1]);
      }
    }).catch(() => {
    });
    return request;
  }
};
_fetchClient = new WeakMap();
_maxPrefetchedRequests = new WeakMap();
_prefetchQueue = new WeakMap();
_queueHeadUrl = new WeakMap();
_queueTailUrl = new WeakMap();
_PrefetchQueue_instances = new WeakSet();
prefetch_fn = function(...args) {
  var _a, _b;
  const url = args[0].toString();
  if (__privateGet(this, _prefetchQueue).size >= __privateGet(this, _maxPrefetchedRequests)) return;
  const aborter = new AbortController();
  try {
    const { signal, cleanup } = chainAborter(aborter, (_a = args[1]) == null ? void 0 : _a.signal);
    const request = __privateGet(this, _fetchClient).call(this, url, __spreadProps(__spreadValues({}, (_b = args[1]) != null ? _b : {}), { signal }));
    __privateGet(this, _prefetchQueue).set(url, [request, aborter]);
    request.then((response) => {
      if (!response.ok || aborter.signal.aborted) return;
      const nextUrl = getNextChunkUrl(url, response);
      if (!nextUrl || nextUrl === url) {
        __privateSet(this, _queueTailUrl, void 0);
        return;
      }
      __privateSet(this, _queueTailUrl, nextUrl);
      return __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, nextUrl, args[1]);
    }).catch(() => {
    }).finally(cleanup);
  } catch (_) {
  }
};
function getNextChunkUrl(url, res) {
  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER);
  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER);
  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER);
  if (!shapeHandle || !lastOffset || isUpToDate) return;
  const nextUrl = new URL(url);
  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return;
  const expiredHandle = nextUrl.searchParams.get(EXPIRED_HANDLE_QUERY_PARAM);
  if (expiredHandle && shapeHandle === expiredHandle) {
    console.warn(
      `[Electric] Received stale cached response with expired shape handle. This should not happen and indicates a proxy/CDN caching misconfiguration. The response contained handle "${shapeHandle}" which was previously marked as expired. Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. Skipping prefetch to prevent infinite 409 loop.`
    );
    return;
  }
  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle);
  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset);
  nextUrl.searchParams.sort();
  return nextUrl.toString();
}
function chainAborter(aborter, sourceSignal) {
  let cleanup = noop;
  if (!sourceSignal) {
  } else if (sourceSignal.aborted) {
    aborter.abort();
  } else {
    const abortParent = () => aborter.abort();
    sourceSignal.addEventListener(`abort`, abortParent, {
      once: true,
      signal: aborter.signal
    });
    cleanup = () => sourceSignal.removeEventListener(`abort`, abortParent);
  }
  return {
    signal: aborter.signal,
    cleanup
  };
}
function noop() {
}

// src/expression-compiler.ts
function compileExpression(expr, columnMapper) {
  switch (expr.type) {
    case `ref`: {
      const mappedColumn = columnMapper ? columnMapper(expr.column) : expr.column;
      return quoteIdentifier(mappedColumn);
    }
    case `val`:
      return `$${expr.paramIndex}`;
    case `func`:
      return compileFunction(expr, columnMapper);
    default: {
      const _exhaustive = expr;
      throw new Error(`Unknown expression type: ${JSON.stringify(_exhaustive)}`);
    }
  }
}
function compileFunction(expr, columnMapper) {
  const args = expr.args.map((arg) => compileExpression(arg, columnMapper));
  switch (expr.name) {
    // Binary comparison operators
    case `eq`:
      return `${args[0]} = ${args[1]}`;
    case `gt`:
      return `${args[0]} > ${args[1]}`;
    case `gte`:
      return `${args[0]} >= ${args[1]}`;
    case `lt`:
      return `${args[0]} < ${args[1]}`;
    case `lte`:
      return `${args[0]} <= ${args[1]}`;
    // Logical operators
    case `and`:
      return args.map((a) => `(${a})`).join(` AND `);
    case `or`:
      return args.map((a) => `(${a})`).join(` OR `);
    case `not`:
      return `NOT (${args[0]})`;
    // Special operators
    case `in`:
      return `${args[0]} = ANY(${args[1]})`;
    case `like`:
      return `${args[0]} LIKE ${args[1]}`;
    case `ilike`:
      return `${args[0]} ILIKE ${args[1]}`;
    case `isNull`:
    case `isUndefined`:
      return `${args[0]} IS NULL`;
    // String functions
    case `upper`:
      return `UPPER(${args[0]})`;
    case `lower`:
      return `LOWER(${args[0]})`;
    case `length`:
      return `LENGTH(${args[0]})`;
    case `concat`:
      return `CONCAT(${args.join(`, `)})`;
    // Other functions
    case `coalesce`:
      return `COALESCE(${args.join(`, `)})`;
    default:
      throw new Error(`Unknown function: ${expr.name}`);
  }
}
function compileOrderBy(clauses, columnMapper) {
  return clauses.map((clause) => {
    const mappedColumn = columnMapper ? columnMapper(clause.column) : clause.column;
    let sql = quoteIdentifier(mappedColumn);
    if (clause.direction === `desc`) sql += ` DESC`;
    if (clause.nulls === `first`) sql += ` NULLS FIRST`;
    if (clause.nulls === `last`) sql += ` NULLS LAST`;
    return sql;
  }).join(`, `);
}

// src/client.ts
import {
  fetchEventSource
} from "@microsoft/fetch-event-source";

// src/expired-shapes-cache.ts
var ExpiredShapesCache = class {
  constructor() {
    this.data = {};
    this.max = 250;
    this.storageKey = `electric_expired_shapes`;
    this.load();
  }
  getExpiredHandle(shapeUrl) {
    const entry = this.data[shapeUrl];
    if (entry) {
      entry.lastUsed = Date.now();
      this.save();
      return entry.expiredHandle;
    }
    return null;
  }
  markExpired(shapeUrl, handle) {
    this.data[shapeUrl] = { expiredHandle: handle, lastUsed: Date.now() };
    const keys = Object.keys(this.data);
    if (keys.length > this.max) {
      const oldest = keys.reduce(
        (min, k) => this.data[k].lastUsed < this.data[min].lastUsed ? k : min
      );
      delete this.data[oldest];
    }
    this.save();
  }
  save() {
    if (typeof localStorage === `undefined`) return;
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.data));
    } catch (e) {
    }
  }
  load() {
    if (typeof localStorage === `undefined`) return;
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        this.data = JSON.parse(stored);
      }
    } catch (e) {
      this.data = {};
    }
  }
  clear() {
    this.data = {};
    this.save();
  }
};
var expiredShapesCache = new ExpiredShapesCache();

// src/up-to-date-tracker.ts
var UpToDateTracker = class {
  constructor() {
    this.data = {};
    this.storageKey = `electric_up_to_date_tracker`;
    this.cacheTTL = 6e4;
    // 60s to match typical CDN s-maxage cache duration
    this.maxEntries = 250;
    this.writeThrottleMs = 6e4;
    // Throttle localStorage writes to once per 60s
    this.lastWriteTime = 0;
    this.load();
    this.cleanup();
  }
  /**
   * Records that a shape received an up-to-date message with a specific cursor.
   * This timestamp and cursor are used to detect cache replay scenarios.
   * Updates in-memory immediately, but throttles localStorage writes.
   */
  recordUpToDate(shapeKey, cursor) {
    this.data[shapeKey] = {
      timestamp: Date.now(),
      cursor
    };
    const keys = Object.keys(this.data);
    if (keys.length > this.maxEntries) {
      const oldest = keys.reduce(
        (min, k) => this.data[k].timestamp < this.data[min].timestamp ? k : min
      );
      delete this.data[oldest];
    }
    this.scheduleSave();
  }
  /**
   * Schedules a throttled save to localStorage.
   * Writes immediately if enough time has passed, otherwise schedules for later.
   */
  scheduleSave() {
    const now = Date.now();
    const timeSinceLastWrite = now - this.lastWriteTime;
    if (timeSinceLastWrite >= this.writeThrottleMs) {
      this.lastWriteTime = now;
      this.save();
    } else if (!this.pendingSaveTimer) {
      const delay = this.writeThrottleMs - timeSinceLastWrite;
      this.pendingSaveTimer = setTimeout(() => {
        this.lastWriteTime = Date.now();
        this.pendingSaveTimer = void 0;
        this.save();
      }, delay);
    }
  }
  /**
   * Checks if we should enter replay mode for this shape.
   * Returns the last seen cursor if there's a recent up-to-date (< 60s),
   * which means we'll likely be replaying cached responses.
   * Returns null if no recent up-to-date exists.
   */
  shouldEnterReplayMode(shapeKey) {
    const entry = this.data[shapeKey];
    if (!entry) {
      return null;
    }
    const age = Date.now() - entry.timestamp;
    if (age >= this.cacheTTL) {
      return null;
    }
    return entry.cursor;
  }
  /**
   * Cleans up expired entries from the cache.
   * Called on initialization and can be called periodically.
   */
  cleanup() {
    const now = Date.now();
    const keys = Object.keys(this.data);
    let modified = false;
    for (const key of keys) {
      const age = now - this.data[key].timestamp;
      if (age > this.cacheTTL) {
        delete this.data[key];
        modified = true;
      }
    }
    if (modified) {
      this.save();
    }
  }
  save() {
    if (typeof localStorage === `undefined`) return;
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.data));
    } catch (e) {
    }
  }
  load() {
    if (typeof localStorage === `undefined`) return;
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        this.data = JSON.parse(stored);
      }
    } catch (e) {
      this.data = {};
    }
  }
  /**
   * Clears all tracked up-to-date timestamps.
   * Useful for testing or manual cache invalidation.
   */
  clear() {
    this.data = {};
    if (this.pendingSaveTimer) {
      clearTimeout(this.pendingSaveTimer);
      this.pendingSaveTimer = void 0;
    }
    this.save();
  }
};
var upToDateTracker = new UpToDateTracker();

// src/snapshot-tracker.ts
var SnapshotTracker = class {
  constructor() {
    this.activeSnapshots = /* @__PURE__ */ new Map();
    this.xmaxSnapshots = /* @__PURE__ */ new Map();
    this.snapshotsByDatabaseLsn = /* @__PURE__ */ new Map();
  }
  /**
   * Add a new snapshot for tracking
   */
  addSnapshot(metadata, keys) {
    var _a, _b, _c, _d;
    this.activeSnapshots.set(metadata.snapshot_mark, {
      xmin: BigInt(metadata.xmin),
      xmax: BigInt(metadata.xmax),
      xip_list: metadata.xip_list.map(BigInt),
      keys
    });
    const xmaxSet = (_b = (_a = this.xmaxSnapshots.get(BigInt(metadata.xmax))) == null ? void 0 : _a.add(metadata.snapshot_mark)) != null ? _b : /* @__PURE__ */ new Set([metadata.snapshot_mark]);
    this.xmaxSnapshots.set(BigInt(metadata.xmax), xmaxSet);
    const databaseLsnSet = (_d = (_c = this.snapshotsByDatabaseLsn.get(BigInt(metadata.database_lsn))) == null ? void 0 : _c.add(metadata.snapshot_mark)) != null ? _d : /* @__PURE__ */ new Set([metadata.snapshot_mark]);
    this.snapshotsByDatabaseLsn.set(
      BigInt(metadata.database_lsn),
      databaseLsnSet
    );
  }
  /**
   * Remove a snapshot from tracking
   */
  removeSnapshot(snapshotMark) {
    this.activeSnapshots.delete(snapshotMark);
  }
  /**
   * Check if a change message should be filtered because its already in an active snapshot
   * Returns true if the message should be filtered out (not processed)
   */
  shouldRejectMessage(message) {
    const txids = message.headers.txids || [];
    if (txids.length === 0) return false;
    const xid = Math.max(...txids);
    for (const [xmax, snapshots] of this.xmaxSnapshots.entries()) {
      if (xid >= xmax) {
        for (const snapshot of snapshots) {
          this.removeSnapshot(snapshot);
        }
      }
    }
    return [...this.activeSnapshots.values()].some(
      (x) => x.keys.has(message.key) && isVisibleInSnapshot(xid, x)
    );
  }
  lastSeenUpdate(newDatabaseLsn) {
    for (const [dbLsn, snapshots] of this.snapshotsByDatabaseLsn.entries()) {
      if (dbLsn <= newDatabaseLsn) {
        for (const snapshot of snapshots) {
          this.removeSnapshot(snapshot);
        }
      }
    }
  }
};

// src/client.ts
var RESERVED_PARAMS = /* @__PURE__ */ new Set([
  LIVE_CACHE_BUSTER_QUERY_PARAM,
  SHAPE_HANDLE_QUERY_PARAM,
  LIVE_QUERY_PARAM,
  OFFSET_QUERY_PARAM
]);
async function resolveValue(value) {
  if (typeof value === `function`) {
    return value();
  }
  return value;
}
async function toInternalParams(params) {
  const entries = Object.entries(params);
  const resolvedEntries = await Promise.all(
    entries.map(async ([key, value]) => {
      if (value === void 0) return [key, void 0];
      const resolvedValue = await resolveValue(value);
      return [
        key,
        Array.isArray(resolvedValue) ? resolvedValue.join(`,`) : resolvedValue
      ];
    })
  );
  return Object.fromEntries(
    resolvedEntries.filter(([_, value]) => value !== void 0)
  );
}
async function resolveHeaders(headers) {
  if (!headers) return {};
  const entries = Object.entries(headers);
  const resolvedEntries = await Promise.all(
    entries.map(async ([key, value]) => [key, await resolveValue(value)])
  );
  return Object.fromEntries(resolvedEntries);
}
function canonicalShapeKey(url) {
  const cleanUrl = new URL(url.origin + url.pathname);
  for (const [key, value] of url.searchParams) {
    if (!ELECTRIC_PROTOCOL_QUERY_PARAMS.includes(key)) {
      cleanUrl.searchParams.set(key, value);
    }
  }
  cleanUrl.searchParams.sort();
  return cleanUrl.toString();
}
var _error, _fetchClient2, _sseFetchClient, _messageParser, _subscribers, _started, _state, _lastOffset, _liveCacheBuster, _lastSyncedAt, _isUpToDate, _isMidStream, _connected, _shapeHandle, _mode, _schema, _onError, _requestAbortController, _isRefreshing, _tickPromise, _tickPromiseResolver, _tickPromiseRejecter, _messageChain, _snapshotTracker, _activeSnapshotRequests, _midStreamPromise, _midStreamPromiseResolver, _lastSeenCursor, _currentFetchUrl, _lastSseConnectionStartTime, _minSseConnectionDuration, _consecutiveShortSseConnections, _maxShortSseConnections, _sseFallbackToLongPolling, _sseBackoffBaseDelay, _sseBackoffMaxDelay, _unsubscribeFromVisibilityChanges, _ShapeStream_instances, replayMode_get, start_fn, requestShape_fn, constructUrl_fn, createAbortListener_fn, onInitialResponse_fn, onMessages_fn, fetchShape_fn, requestShapeLongPoll_fn, requestShapeSSE_fn, pause_fn, resume_fn, nextTick_fn, waitForStreamEnd_fn, publish_fn, sendErrorToSubscribers_fn, subscribeToVisibilityChanges_fn, reset_fn;
var ShapeStream = class {
  constructor(options) {
    __privateAdd(this, _ShapeStream_instances);
    __privateAdd(this, _error, null);
    __privateAdd(this, _fetchClient2);
    __privateAdd(this, _sseFetchClient);
    __privateAdd(this, _messageParser);
    __privateAdd(this, _subscribers, /* @__PURE__ */ new Map());
    __privateAdd(this, _started, false);
    __privateAdd(this, _state, `active`);
    __privateAdd(this, _lastOffset);
    __privateAdd(this, _liveCacheBuster);
    // Seconds since our Electric Epoch ðŸ˜Ž
    __privateAdd(this, _lastSyncedAt);
    // unix time
    __privateAdd(this, _isUpToDate, false);
    __privateAdd(this, _isMidStream, true);
    __privateAdd(this, _connected, false);
    __privateAdd(this, _shapeHandle);
    __privateAdd(this, _mode);
    __privateAdd(this, _schema);
    __privateAdd(this, _onError);
    __privateAdd(this, _requestAbortController);
    __privateAdd(this, _isRefreshing, false);
    __privateAdd(this, _tickPromise);
    __privateAdd(this, _tickPromiseResolver);
    __privateAdd(this, _tickPromiseRejecter);
    __privateAdd(this, _messageChain, Promise.resolve([]));
    // promise chain for incoming messages
    __privateAdd(this, _snapshotTracker, new SnapshotTracker());
    __privateAdd(this, _activeSnapshotRequests, 0);
    // counter for concurrent snapshot requests
    __privateAdd(this, _midStreamPromise);
    __privateAdd(this, _midStreamPromiseResolver);
    __privateAdd(this, _lastSeenCursor);
    // Last seen cursor from previous session (used to detect cached responses)
    __privateAdd(this, _currentFetchUrl);
    // Current fetch URL for computing shape key
    __privateAdd(this, _lastSseConnectionStartTime);
    __privateAdd(this, _minSseConnectionDuration, 1e3);
    // Minimum expected SSE connection duration (1 second)
    __privateAdd(this, _consecutiveShortSseConnections, 0);
    __privateAdd(this, _maxShortSseConnections, 3);
    // Fall back to long polling after this many short connections
    __privateAdd(this, _sseFallbackToLongPolling, false);
    __privateAdd(this, _sseBackoffBaseDelay, 100);
    // Base delay for exponential backoff (ms)
    __privateAdd(this, _sseBackoffMaxDelay, 5e3);
    // Maximum delay cap (ms)
    __privateAdd(this, _unsubscribeFromVisibilityChanges);
    var _a, _b, _c, _d;
    this.options = __spreadValues({ subscribe: true }, options);
    validateOptions(this.options);
    __privateSet(this, _lastOffset, (_a = this.options.offset) != null ? _a : `-1`);
    __privateSet(this, _liveCacheBuster, ``);
    __privateSet(this, _shapeHandle, this.options.handle);
    let transformer;
    if (options.columnMapper) {
      const applyColumnMapper = (row) => {
        const result = {};
        for (const [dbKey, value] of Object.entries(row)) {
          const appKey = options.columnMapper.decode(dbKey);
          result[appKey] = value;
        }
        return result;
      };
      transformer = options.transformer ? (row) => options.transformer(applyColumnMapper(row)) : applyColumnMapper;
    } else {
      transformer = options.transformer;
    }
    __privateSet(this, _messageParser, new MessageParser(options.parser, transformer));
    __privateSet(this, _onError, this.options.onError);
    __privateSet(this, _mode, (_b = this.options.log) != null ? _b : `full`);
    const baseFetchClient = (_c = options.fetchClient) != null ? _c : (...args) => fetch(...args);
    const backOffOpts = __spreadProps(__spreadValues({}, (_d = options.backoffOptions) != null ? _d : BackoffDefaults), {
      onFailedAttempt: () => {
        var _a2, _b2;
        __privateSet(this, _connected, false);
        (_b2 = (_a2 = options.backoffOptions) == null ? void 0 : _a2.onFailedAttempt) == null ? void 0 : _b2.call(_a2);
      }
    });
    const fetchWithBackoffClient = createFetchWithBackoff(
      baseFetchClient,
      backOffOpts
    );
    __privateSet(this, _sseFetchClient, createFetchWithResponseHeadersCheck(
      createFetchWithChunkBuffer(fetchWithBackoffClient)
    ));
    __privateSet(this, _fetchClient2, createFetchWithConsumedMessages(__privateGet(this, _sseFetchClient)));
    __privateMethod(this, _ShapeStream_instances, subscribeToVisibilityChanges_fn).call(this);
  }
  get shapeHandle() {
    return __privateGet(this, _shapeHandle);
  }
  get error() {
    return __privateGet(this, _error);
  }
  get isUpToDate() {
    return __privateGet(this, _isUpToDate);
  }
  get lastOffset() {
    return __privateGet(this, _lastOffset);
  }
  get mode() {
    return __privateGet(this, _mode);
  }
  subscribe(callback, onError = () => {
  }) {
    const subscriptionId = Math.random();
    __privateGet(this, _subscribers).set(subscriptionId, [callback, onError]);
    if (!__privateGet(this, _started)) __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
    return () => {
      __privateGet(this, _subscribers).delete(subscriptionId);
    };
  }
  unsubscribeAll() {
    var _a;
    __privateGet(this, _subscribers).clear();
    (_a = __privateGet(this, _unsubscribeFromVisibilityChanges)) == null ? void 0 : _a.call(this);
  }
  /** Unix time at which we last synced. Undefined when `isLoading` is true. */
  lastSyncedAt() {
    return __privateGet(this, _lastSyncedAt);
  }
  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */
  lastSynced() {
    if (__privateGet(this, _lastSyncedAt) === void 0) return Infinity;
    return Date.now() - __privateGet(this, _lastSyncedAt);
  }
  /** Indicates if we are connected to the Electric sync service. */
  isConnected() {
    return __privateGet(this, _connected);
  }
  /** True during initial fetch. False afterwise.  */
  isLoading() {
    return !__privateGet(this, _isUpToDate);
  }
  hasStarted() {
    return __privateGet(this, _started);
  }
  isPaused() {
    return __privateGet(this, _state) === `paused`;
  }
  /**
   * Refreshes the shape stream.
   * This preemptively aborts any ongoing long poll and reconnects without
   * long polling, ensuring that the stream receives an up to date message with the
   * latest LSN from Postgres at that point in time.
   */
  async forceDisconnectAndRefresh() {
    var _a, _b;
    __privateSet(this, _isRefreshing, true);
    if (__privateGet(this, _isUpToDate) && !((_a = __privateGet(this, _requestAbortController)) == null ? void 0 : _a.signal.aborted)) {
      (_b = __privateGet(this, _requestAbortController)) == null ? void 0 : _b.abort(FORCE_DISCONNECT_AND_REFRESH);
    }
    await __privateMethod(this, _ShapeStream_instances, nextTick_fn).call(this);
    __privateSet(this, _isRefreshing, false);
  }
  /**
   * Request a snapshot for subset of data and inject it into the subscribed data stream.
   *
   * Only available when mode is `changes_only`.
   * Returns the insertion point & the data, but more importantly injects the data
   * into the subscribed data stream. Returned value is unlikely to be useful for the caller,
   * unless the caller has complicated additional logic.
   *
   * Data will be injected in a way that's also tracking further incoming changes, and it'll
   * skip the ones that are already in the snapshot.
   *
   * @param opts - The options for the snapshot request.
   * @returns The metadata and the data for the snapshot.
   */
  async requestSnapshot(opts) {
    if (__privateGet(this, _mode) === `full`) {
      throw new Error(
        `Snapshot requests are not supported in ${__privateGet(this, _mode)} mode, as the consumer is guaranteed to observe all data`
      );
    }
    if (!__privateGet(this, _started)) await __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
    await __privateMethod(this, _ShapeStream_instances, waitForStreamEnd_fn).call(this);
    __privateWrapper(this, _activeSnapshotRequests)._++;
    try {
      if (__privateGet(this, _activeSnapshotRequests) === 1) {
        __privateMethod(this, _ShapeStream_instances, pause_fn).call(this);
      }
      const { metadata, data } = await this.fetchSnapshot(opts);
      const dataWithEndBoundary = data.concat([
        { headers: __spreadValues({ control: `snapshot-end` }, metadata) },
        { headers: __spreadValues({ control: `subset-end` }, opts) }
      ]);
      __privateGet(this, _snapshotTracker).addSnapshot(
        metadata,
        new Set(data.map((message) => message.key))
      );
      __privateMethod(this, _ShapeStream_instances, onMessages_fn).call(this, dataWithEndBoundary, false);
      return {
        metadata,
        data
      };
    } finally {
      __privateWrapper(this, _activeSnapshotRequests)._--;
      if (__privateGet(this, _activeSnapshotRequests) === 0) {
        __privateMethod(this, _ShapeStream_instances, resume_fn).call(this);
      }
    }
  }
  /**
   * Fetch a snapshot for subset of data.
   * Returns the metadata and the data, but does not inject it into the subscribed data stream.
   *
   * @param opts - The options for the snapshot request.
   * @returns The metadata and the data for the snapshot.
   */
  async fetchSnapshot(opts) {
    var _a;
    const { fetchUrl, requestHeaders } = await __privateMethod(this, _ShapeStream_instances, constructUrl_fn).call(this, this.options.url, true, opts);
    const response = await __privateGet(this, _fetchClient2).call(this, fetchUrl.toString(), {
      headers: requestHeaders
    });
    if (!response.ok) {
      throw new FetchError(
        response.status,
        void 0,
        void 0,
        Object.fromEntries([...response.headers.entries()]),
        fetchUrl.toString()
      );
    }
    const schema = (_a = __privateGet(this, _schema)) != null ? _a : getSchemaFromHeaders(response.headers, {
      required: true,
      url: fetchUrl.toString()
    });
    const { metadata, data: rawData } = await response.json();
    const data = __privateGet(this, _messageParser).parseSnapshotData(
      rawData,
      schema
    );
    return {
      metadata,
      data
    };
  }
};
_error = new WeakMap();
_fetchClient2 = new WeakMap();
_sseFetchClient = new WeakMap();
_messageParser = new WeakMap();
_subscribers = new WeakMap();
_started = new WeakMap();
_state = new WeakMap();
_lastOffset = new WeakMap();
_liveCacheBuster = new WeakMap();
_lastSyncedAt = new WeakMap();
_isUpToDate = new WeakMap();
_isMidStream = new WeakMap();
_connected = new WeakMap();
_shapeHandle = new WeakMap();
_mode = new WeakMap();
_schema = new WeakMap();
_onError = new WeakMap();
_requestAbortController = new WeakMap();
_isRefreshing = new WeakMap();
_tickPromise = new WeakMap();
_tickPromiseResolver = new WeakMap();
_tickPromiseRejecter = new WeakMap();
_messageChain = new WeakMap();
_snapshotTracker = new WeakMap();
_activeSnapshotRequests = new WeakMap();
_midStreamPromise = new WeakMap();
_midStreamPromiseResolver = new WeakMap();
_lastSeenCursor = new WeakMap();
_currentFetchUrl = new WeakMap();
_lastSseConnectionStartTime = new WeakMap();
_minSseConnectionDuration = new WeakMap();
_consecutiveShortSseConnections = new WeakMap();
_maxShortSseConnections = new WeakMap();
_sseFallbackToLongPolling = new WeakMap();
_sseBackoffBaseDelay = new WeakMap();
_sseBackoffMaxDelay = new WeakMap();
_unsubscribeFromVisibilityChanges = new WeakMap();
_ShapeStream_instances = new WeakSet();
replayMode_get = function() {
  return __privateGet(this, _lastSeenCursor) !== void 0;
};
start_fn = async function() {
  var _a, _b, _c, _d, _e;
  __privateSet(this, _started, true);
  try {
    await __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
  } catch (err) {
    __privateSet(this, _error, err);
    if (__privateGet(this, _onError)) {
      const retryOpts = await __privateGet(this, _onError).call(this, err);
      if (retryOpts && typeof retryOpts === `object`) {
        if (retryOpts.params) {
          this.options.params = __spreadValues(__spreadValues({}, (_a = this.options.params) != null ? _a : {}), retryOpts.params);
        }
        if (retryOpts.headers) {
          this.options.headers = __spreadValues(__spreadValues({}, (_b = this.options.headers) != null ? _b : {}), retryOpts.headers);
        }
        __privateSet(this, _error, null);
        __privateSet(this, _started, false);
        await __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
        return;
      }
      if (err instanceof Error) {
        __privateMethod(this, _ShapeStream_instances, sendErrorToSubscribers_fn).call(this, err);
      }
      __privateSet(this, _connected, false);
      (_c = __privateGet(this, _tickPromiseRejecter)) == null ? void 0 : _c.call(this);
      return;
    }
    if (err instanceof Error) {
      __privateMethod(this, _ShapeStream_instances, sendErrorToSubscribers_fn).call(this, err);
    }
    __privateSet(this, _connected, false);
    (_d = __privateGet(this, _tickPromiseRejecter)) == null ? void 0 : _d.call(this);
    throw err;
  }
  __privateSet(this, _connected, false);
  (_e = __privateGet(this, _tickPromiseRejecter)) == null ? void 0 : _e.call(this);
};
requestShape_fn = async function() {
  var _a, _b;
  if (__privateGet(this, _state) === `pause-requested`) {
    __privateSet(this, _state, `paused`);
    return;
  }
  if (!this.options.subscribe && (((_a = this.options.signal) == null ? void 0 : _a.aborted) || __privateGet(this, _isUpToDate))) {
    return;
  }
  const resumingFromPause = __privateGet(this, _state) === `paused`;
  __privateSet(this, _state, `active`);
  const { url, signal } = this.options;
  const { fetchUrl, requestHeaders } = await __privateMethod(this, _ShapeStream_instances, constructUrl_fn).call(this, url, resumingFromPause);
  const abortListener = await __privateMethod(this, _ShapeStream_instances, createAbortListener_fn).call(this, signal);
  const requestAbortController = __privateGet(this, _requestAbortController);
  try {
    await __privateMethod(this, _ShapeStream_instances, fetchShape_fn).call(this, {
      fetchUrl,
      requestAbortController,
      headers: requestHeaders,
      resumingFromPause
    });
  } catch (e) {
    if ((e instanceof FetchError || e instanceof FetchBackoffAbortError) && requestAbortController.signal.aborted && requestAbortController.signal.reason === FORCE_DISCONNECT_AND_REFRESH) {
      return __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
    }
    if (e instanceof FetchBackoffAbortError) {
      const currentState = __privateGet(this, _state);
      if (requestAbortController.signal.aborted && requestAbortController.signal.reason === PAUSE_STREAM && currentState === `pause-requested`) {
        __privateSet(this, _state, `paused`);
      }
      return;
    }
    if (!(e instanceof FetchError)) throw e;
    if (e.status == 409) {
      if (__privateGet(this, _shapeHandle)) {
        const shapeKey = canonicalShapeKey(fetchUrl);
        expiredShapesCache.markExpired(shapeKey, __privateGet(this, _shapeHandle));
      }
      const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER] || `${__privateGet(this, _shapeHandle)}-next`;
      __privateMethod(this, _ShapeStream_instances, reset_fn).call(this, newShapeHandle);
      await __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, Array.isArray(e.json) ? e.json : [e.json]);
      return __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
    } else {
      throw e;
    }
  } finally {
    if (abortListener && signal) {
      signal.removeEventListener(`abort`, abortListener);
    }
    __privateSet(this, _requestAbortController, void 0);
  }
  (_b = __privateGet(this, _tickPromiseResolver)) == null ? void 0 : _b.call(this);
  return __privateMethod(this, _ShapeStream_instances, requestShape_fn).call(this);
};
constructUrl_fn = async function(url, resumingFromPause, subsetParams) {
  var _a, _b, _c, _d, _e, _f;
  const [requestHeaders, params] = await Promise.all([
    resolveHeaders(this.options.headers),
    this.options.params ? toInternalParams(convertWhereParamsToObj(this.options.params)) : void 0
  ]);
  if (params) validateParams(params);
  const fetchUrl = new URL(url);
  if (params) {
    if (params.table) setQueryParam(fetchUrl, TABLE_QUERY_PARAM, params.table);
    if (params.where && typeof params.where === `string`) {
      const encodedWhere = encodeWhereClause(
        params.where,
        (_a = this.options.columnMapper) == null ? void 0 : _a.encode
      );
      setQueryParam(fetchUrl, WHERE_QUERY_PARAM, encodedWhere);
    }
    if (params.columns) {
      const originalColumns = await resolveValue((_b = this.options.params) == null ? void 0 : _b.columns);
      if (Array.isArray(originalColumns)) {
        let encodedColumns = originalColumns.map(String);
        if (this.options.columnMapper) {
          encodedColumns = encodedColumns.map(
            this.options.columnMapper.encode
          );
        }
        const serializedColumns = encodedColumns.map(quoteIdentifier).join(`,`);
        setQueryParam(fetchUrl, COLUMNS_QUERY_PARAM, serializedColumns);
      } else {
        setQueryParam(fetchUrl, COLUMNS_QUERY_PARAM, params.columns);
      }
    }
    if (params.replica) setQueryParam(fetchUrl, REPLICA_PARAM, params.replica);
    if (params.params)
      setQueryParam(fetchUrl, WHERE_PARAMS_PARAM, params.params);
    const customParams = __spreadValues({}, params);
    delete customParams.table;
    delete customParams.where;
    delete customParams.columns;
    delete customParams.replica;
    delete customParams.params;
    for (const [key, value] of Object.entries(customParams)) {
      setQueryParam(fetchUrl, key, value);
    }
  }
  if (subsetParams) {
    if (subsetParams.whereExpr) {
      const compiledWhere = compileExpression(
        subsetParams.whereExpr,
        (_c = this.options.columnMapper) == null ? void 0 : _c.encode
      );
      setQueryParam(fetchUrl, SUBSET_PARAM_WHERE, compiledWhere);
      fetchUrl.searchParams.set(
        SUBSET_PARAM_WHERE_EXPR,
        JSON.stringify(subsetParams.whereExpr)
      );
    } else if (subsetParams.where && typeof subsetParams.where === `string`) {
      const encodedWhere = encodeWhereClause(
        subsetParams.where,
        (_d = this.options.columnMapper) == null ? void 0 : _d.encode
      );
      setQueryParam(fetchUrl, SUBSET_PARAM_WHERE, encodedWhere);
    }
    if (subsetParams.params)
      fetchUrl.searchParams.set(
        SUBSET_PARAM_WHERE_PARAMS,
        JSON.stringify(subsetParams.params)
      );
    if (subsetParams.limit)
      setQueryParam(fetchUrl, SUBSET_PARAM_LIMIT, subsetParams.limit);
    if (subsetParams.offset)
      setQueryParam(fetchUrl, SUBSET_PARAM_OFFSET, subsetParams.offset);
    if (subsetParams.orderByExpr) {
      const compiledOrderBy = compileOrderBy(
        subsetParams.orderByExpr,
        (_e = this.options.columnMapper) == null ? void 0 : _e.encode
      );
      setQueryParam(fetchUrl, SUBSET_PARAM_ORDER_BY, compiledOrderBy);
      fetchUrl.searchParams.set(
        SUBSET_PARAM_ORDER_BY_EXPR,
        JSON.stringify(subsetParams.orderByExpr)
      );
    } else if (subsetParams.orderBy && typeof subsetParams.orderBy === `string`) {
      const encodedOrderBy = encodeWhereClause(
        subsetParams.orderBy,
        (_f = this.options.columnMapper) == null ? void 0 : _f.encode
      );
      setQueryParam(fetchUrl, SUBSET_PARAM_ORDER_BY, encodedOrderBy);
    }
  }
  fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, __privateGet(this, _lastOffset));
  fetchUrl.searchParams.set(LOG_MODE_QUERY_PARAM, __privateGet(this, _mode));
  const isSnapshotRequest = subsetParams !== void 0;
  if (__privateGet(this, _isUpToDate) && !isSnapshotRequest) {
    if (!__privateGet(this, _isRefreshing) && !resumingFromPause) {
      fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`);
    }
    fetchUrl.searchParams.set(
      LIVE_CACHE_BUSTER_QUERY_PARAM,
      __privateGet(this, _liveCacheBuster)
    );
  }
  if (__privateGet(this, _shapeHandle)) {
    fetchUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, __privateGet(this, _shapeHandle));
  }
  const shapeKey = canonicalShapeKey(fetchUrl);
  const expiredHandle = expiredShapesCache.getExpiredHandle(shapeKey);
  if (expiredHandle) {
    fetchUrl.searchParams.set(EXPIRED_HANDLE_QUERY_PARAM, expiredHandle);
  }
  fetchUrl.searchParams.sort();
  return {
    fetchUrl,
    requestHeaders
  };
};
createAbortListener_fn = async function(signal) {
  var _a;
  __privateSet(this, _requestAbortController, new AbortController());
  if (signal) {
    const abortListener = () => {
      var _a2;
      (_a2 = __privateGet(this, _requestAbortController)) == null ? void 0 : _a2.abort(signal.reason);
    };
    signal.addEventListener(`abort`, abortListener, { once: true });
    if (signal.aborted) {
      (_a = __privateGet(this, _requestAbortController)) == null ? void 0 : _a.abort(signal.reason);
    }
    return abortListener;
  }
};
onInitialResponse_fn = async function(response) {
  var _a;
  const { headers, status } = response;
  const shapeHandle = headers.get(SHAPE_HANDLE_HEADER);
  if (shapeHandle) {
    const shapeKey = __privateGet(this, _currentFetchUrl) ? canonicalShapeKey(__privateGet(this, _currentFetchUrl)) : null;
    const expiredHandle = shapeKey ? expiredShapesCache.getExpiredHandle(shapeKey) : null;
    if (shapeHandle !== expiredHandle) {
      __privateSet(this, _shapeHandle, shapeHandle);
    } else {
      console.warn(
        `[Electric] Received stale cached response with expired shape handle. This should not happen and indicates a proxy/CDN caching misconfiguration. The response contained handle "${shapeHandle}" which was previously marked as expired. Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. Ignoring the stale handle and continuing with handle "${__privateGet(this, _shapeHandle)}".`
      );
    }
  }
  const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER);
  if (lastOffset) {
    __privateSet(this, _lastOffset, lastOffset);
  }
  const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER);
  if (liveCacheBuster) {
    __privateSet(this, _liveCacheBuster, liveCacheBuster);
  }
  __privateSet(this, _schema, (_a = __privateGet(this, _schema)) != null ? _a : getSchemaFromHeaders(headers));
  if (status === 204) {
    __privateSet(this, _lastSyncedAt, Date.now());
  }
};
onMessages_fn = async function(batch, isSseMessage = false) {
  var _a;
  if (batch.length > 0) {
    __privateSet(this, _isMidStream, true);
    const lastMessage = batch[batch.length - 1];
    if (isUpToDateMessage(lastMessage)) {
      if (isSseMessage) {
        const offset = getOffset(lastMessage);
        if (offset) {
          __privateSet(this, _lastOffset, offset);
        }
      }
      __privateSet(this, _lastSyncedAt, Date.now());
      __privateSet(this, _isUpToDate, true);
      __privateSet(this, _isMidStream, false);
      (_a = __privateGet(this, _midStreamPromiseResolver)) == null ? void 0 : _a.call(this);
      if (__privateGet(this, _ShapeStream_instances, replayMode_get) && !isSseMessage) {
        const currentCursor = __privateGet(this, _liveCacheBuster);
        if (currentCursor === __privateGet(this, _lastSeenCursor)) {
          return;
        }
      }
      __privateSet(this, _lastSeenCursor, void 0);
      if (__privateGet(this, _currentFetchUrl)) {
        const shapeKey = canonicalShapeKey(__privateGet(this, _currentFetchUrl));
        upToDateTracker.recordUpToDate(shapeKey, __privateGet(this, _liveCacheBuster));
      }
    }
    const messagesToProcess = batch.filter((message) => {
      if (isChangeMessage(message)) {
        return !__privateGet(this, _snapshotTracker).shouldRejectMessage(message);
      }
      return true;
    });
    await __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, messagesToProcess);
  }
};
fetchShape_fn = async function(opts) {
  var _a;
  __privateSet(this, _currentFetchUrl, opts.fetchUrl);
  if (!__privateGet(this, _isUpToDate) && !__privateGet(this, _ShapeStream_instances, replayMode_get)) {
    const shapeKey = canonicalShapeKey(opts.fetchUrl);
    const lastSeenCursor = upToDateTracker.shouldEnterReplayMode(shapeKey);
    if (lastSeenCursor) {
      __privateSet(this, _lastSeenCursor, lastSeenCursor);
    }
  }
  const useSse = (_a = this.options.liveSse) != null ? _a : this.options.experimentalLiveSse;
  if (__privateGet(this, _isUpToDate) && useSse && !__privateGet(this, _isRefreshing) && !opts.resumingFromPause && !__privateGet(this, _sseFallbackToLongPolling)) {
    opts.fetchUrl.searchParams.set(EXPERIMENTAL_LIVE_SSE_QUERY_PARAM, `true`);
    opts.fetchUrl.searchParams.set(LIVE_SSE_QUERY_PARAM, `true`);
    return __privateMethod(this, _ShapeStream_instances, requestShapeSSE_fn).call(this, opts);
  }
  return __privateMethod(this, _ShapeStream_instances, requestShapeLongPoll_fn).call(this, opts);
};
requestShapeLongPoll_fn = async function(opts) {
  const { fetchUrl, requestAbortController, headers } = opts;
  const response = await __privateGet(this, _fetchClient2).call(this, fetchUrl.toString(), {
    signal: requestAbortController.signal,
    headers
  });
  __privateSet(this, _connected, true);
  await __privateMethod(this, _ShapeStream_instances, onInitialResponse_fn).call(this, response);
  const schema = __privateGet(this, _schema);
  const res = await response.text();
  const messages = res || `[]`;
  const batch = __privateGet(this, _messageParser).parse(messages, schema);
  await __privateMethod(this, _ShapeStream_instances, onMessages_fn).call(this, batch);
};
requestShapeSSE_fn = async function(opts) {
  const { fetchUrl, requestAbortController, headers } = opts;
  const fetch2 = __privateGet(this, _sseFetchClient);
  __privateSet(this, _lastSseConnectionStartTime, Date.now());
  const sseHeaders = __spreadProps(__spreadValues({}, headers), {
    Accept: `text/event-stream`
  });
  try {
    let buffer = [];
    await fetchEventSource(fetchUrl.toString(), {
      headers: sseHeaders,
      fetch: fetch2,
      onopen: async (response) => {
        __privateSet(this, _connected, true);
        await __privateMethod(this, _ShapeStream_instances, onInitialResponse_fn).call(this, response);
      },
      onmessage: (event) => {
        if (event.data) {
          const schema = __privateGet(this, _schema);
          const message = __privateGet(this, _messageParser).parse(
            event.data,
            schema
          );
          buffer.push(message);
          if (isUpToDateMessage(message)) {
            __privateMethod(this, _ShapeStream_instances, onMessages_fn).call(this, buffer, true);
            buffer = [];
          }
        }
      },
      onerror: (error) => {
        throw error;
      },
      signal: requestAbortController.signal
    });
  } catch (error) {
    if (requestAbortController.signal.aborted) {
      throw new FetchBackoffAbortError();
    }
    throw error;
  } finally {
    const connectionDuration = Date.now() - __privateGet(this, _lastSseConnectionStartTime);
    const wasAborted = requestAbortController.signal.aborted;
    if (connectionDuration < __privateGet(this, _minSseConnectionDuration) && !wasAborted) {
      __privateWrapper(this, _consecutiveShortSseConnections)._++;
      if (__privateGet(this, _consecutiveShortSseConnections) >= __privateGet(this, _maxShortSseConnections)) {
        __privateSet(this, _sseFallbackToLongPolling, true);
        console.warn(
          `[Electric] SSE connections are closing immediately (possibly due to proxy buffering or misconfiguration). Falling back to long polling. Your proxy must support streaming SSE responses (not buffer the complete response). Configuration: Nginx add 'X-Accel-Buffering: no', Caddy add 'flush_interval -1' to reverse_proxy. Note: Do NOT disable caching entirely - Electric uses cache headers to enable request collapsing for efficiency.`
        );
      } else {
        const maxDelay = Math.min(
          __privateGet(this, _sseBackoffMaxDelay),
          __privateGet(this, _sseBackoffBaseDelay) * Math.pow(2, __privateGet(this, _consecutiveShortSseConnections))
        );
        const delayMs = Math.floor(Math.random() * maxDelay);
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
    } else if (connectionDuration >= __privateGet(this, _minSseConnectionDuration)) {
      __privateSet(this, _consecutiveShortSseConnections, 0);
    }
  }
};
pause_fn = function() {
  var _a;
  if (__privateGet(this, _started) && __privateGet(this, _state) === `active`) {
    __privateSet(this, _state, `pause-requested`);
    (_a = __privateGet(this, _requestAbortController)) == null ? void 0 : _a.abort(PAUSE_STREAM);
  }
};
resume_fn = function() {
  var _a;
  if (__privateGet(this, _started) && (__privateGet(this, _state) === `paused` || __privateGet(this, _state) === `pause-requested`)) {
    if ((_a = this.options.signal) == null ? void 0 : _a.aborted) {
      return;
    }
    if (__privateGet(this, _state) === `pause-requested`) {
      __privateSet(this, _state, `active`);
    }
    __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
  }
};
nextTick_fn = async function() {
  if (__privateGet(this, _tickPromise)) {
    return __privateGet(this, _tickPromise);
  }
  __privateSet(this, _tickPromise, new Promise((resolve, reject) => {
    __privateSet(this, _tickPromiseResolver, resolve);
    __privateSet(this, _tickPromiseRejecter, reject);
  }));
  __privateGet(this, _tickPromise).finally(() => {
    __privateSet(this, _tickPromise, void 0);
    __privateSet(this, _tickPromiseResolver, void 0);
    __privateSet(this, _tickPromiseRejecter, void 0);
  });
  return __privateGet(this, _tickPromise);
};
waitForStreamEnd_fn = async function() {
  if (!__privateGet(this, _isMidStream)) {
    return;
  }
  if (__privateGet(this, _midStreamPromise)) {
    return __privateGet(this, _midStreamPromise);
  }
  __privateSet(this, _midStreamPromise, new Promise((resolve) => {
    __privateSet(this, _midStreamPromiseResolver, resolve);
  }));
  __privateGet(this, _midStreamPromise).finally(() => {
    __privateSet(this, _midStreamPromise, void 0);
    __privateSet(this, _midStreamPromiseResolver, void 0);
  });
  return __privateGet(this, _midStreamPromise);
};
publish_fn = async function(messages) {
  __privateSet(this, _messageChain, __privateGet(this, _messageChain).then(
    () => Promise.all(
      Array.from(__privateGet(this, _subscribers).values()).map(async ([callback, __]) => {
        try {
          await callback(messages);
        } catch (err) {
          queueMicrotask(() => {
            throw err;
          });
        }
      })
    )
  ));
  return __privateGet(this, _messageChain);
};
sendErrorToSubscribers_fn = function(error) {
  __privateGet(this, _subscribers).forEach(([_, errorFn]) => {
    errorFn == null ? void 0 : errorFn(error);
  });
};
subscribeToVisibilityChanges_fn = function() {
  if (typeof document === `object` && typeof document.hidden === `boolean` && typeof document.addEventListener === `function`) {
    const visibilityHandler = () => {
      if (document.hidden) {
        __privateMethod(this, _ShapeStream_instances, pause_fn).call(this);
      } else {
        __privateMethod(this, _ShapeStream_instances, resume_fn).call(this);
      }
    };
    document.addEventListener(`visibilitychange`, visibilityHandler);
    __privateSet(this, _unsubscribeFromVisibilityChanges, () => {
      document.removeEventListener(`visibilitychange`, visibilityHandler);
    });
  }
};
/**
 * Resets the state of the stream, optionally with a provided
 * shape handle
 */
reset_fn = function(handle) {
  __privateSet(this, _lastOffset, `-1`);
  __privateSet(this, _liveCacheBuster, ``);
  __privateSet(this, _shapeHandle, handle);
  __privateSet(this, _isUpToDate, false);
  __privateSet(this, _isMidStream, true);
  __privateSet(this, _connected, false);
  __privateSet(this, _schema, void 0);
  __privateSet(this, _activeSnapshotRequests, 0);
  __privateSet(this, _consecutiveShortSseConnections, 0);
  __privateSet(this, _sseFallbackToLongPolling, false);
};
ShapeStream.Replica = {
  FULL: `full`,
  DEFAULT: `default`
};
function getSchemaFromHeaders(headers, options) {
  const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER);
  if (!schemaHeader) {
    if ((options == null ? void 0 : options.required) && (options == null ? void 0 : options.url)) {
      throw new MissingHeadersError(options.url, [SHAPE_SCHEMA_HEADER]);
    }
    return {};
  }
  return JSON.parse(schemaHeader);
}
function validateParams(params) {
  if (!params) return;
  const reservedParams = Object.keys(params).filter(
    (key) => RESERVED_PARAMS.has(key)
  );
  if (reservedParams.length > 0) {
    throw new ReservedParamError(reservedParams);
  }
}
function validateOptions(options) {
  if (!options.url) {
    throw new MissingShapeUrlError();
  }
  if (options.signal && !(options.signal instanceof AbortSignal)) {
    throw new InvalidSignalError();
  }
  if (options.offset !== void 0 && options.offset !== `-1` && options.offset !== `now` && !options.handle) {
    throw new MissingShapeHandleError();
  }
  validateParams(options.params);
  return;
}
function setQueryParam(url, key, value) {
  if (value === void 0 || value == null) {
    return;
  } else if (typeof value === `string`) {
    url.searchParams.set(key, value);
  } else if (typeof value === `object`) {
    for (const [k, v] of Object.entries(value)) {
      url.searchParams.set(`${key}[${k}]`, v);
    }
  } else {
    url.searchParams.set(key, value.toString());
  }
}
function convertWhereParamsToObj(allPgParams) {
  if (Array.isArray(allPgParams.params)) {
    return __spreadProps(__spreadValues({}, allPgParams), {
      params: Object.fromEntries(allPgParams.params.map((v, i) => [i + 1, v]))
    });
  }
  return allPgParams;
}

// src/shape.ts
var _data, _subscribers2, _insertedKeys, _requestedSubSnapshots, _reexecuteSnapshotsPending, _status, _error2, _Shape_instances, process_fn, reexecuteSnapshots_fn, awaitUpToDate_fn, updateShapeStatus_fn, handleError_fn, notify_fn;
var Shape = class {
  constructor(stream) {
    __privateAdd(this, _Shape_instances);
    __privateAdd(this, _data, /* @__PURE__ */ new Map());
    __privateAdd(this, _subscribers2, /* @__PURE__ */ new Map());
    __privateAdd(this, _insertedKeys, /* @__PURE__ */ new Set());
    __privateAdd(this, _requestedSubSnapshots, /* @__PURE__ */ new Set());
    __privateAdd(this, _reexecuteSnapshotsPending, false);
    __privateAdd(this, _status, `syncing`);
    __privateAdd(this, _error2, false);
    this.stream = stream;
    this.stream.subscribe(
      __privateMethod(this, _Shape_instances, process_fn).bind(this),
      __privateMethod(this, _Shape_instances, handleError_fn).bind(this)
    );
  }
  get isUpToDate() {
    return __privateGet(this, _status) === `up-to-date`;
  }
  get lastOffset() {
    return this.stream.lastOffset;
  }
  get handle() {
    return this.stream.shapeHandle;
  }
  get rows() {
    return this.value.then((v) => Array.from(v.values()));
  }
  get currentRows() {
    return Array.from(this.currentValue.values());
  }
  get value() {
    return new Promise((resolve, reject) => {
      if (this.stream.isUpToDate) {
        resolve(this.currentValue);
      } else {
        const unsubscribe = this.subscribe(({ value }) => {
          unsubscribe();
          if (__privateGet(this, _error2)) reject(__privateGet(this, _error2));
          resolve(value);
        });
      }
    });
  }
  get currentValue() {
    return __privateGet(this, _data);
  }
  get error() {
    return __privateGet(this, _error2);
  }
  /** Unix time at which we last synced. Undefined when `isLoading` is true. */
  lastSyncedAt() {
    return this.stream.lastSyncedAt();
  }
  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */
  lastSynced() {
    return this.stream.lastSynced();
  }
  /** True during initial fetch. False afterwise.  */
  isLoading() {
    return this.stream.isLoading();
  }
  /** Indicates if we are connected to the Electric sync service. */
  isConnected() {
    return this.stream.isConnected();
  }
  /** Current log mode of the underlying stream */
  get mode() {
    return this.stream.mode;
  }
  /**
   * Request a snapshot for subset of data. Only available when mode is changes_only.
   * Returns void; data will be emitted via the stream and processed by this Shape.
   */
  async requestSnapshot(params) {
    const key = JSON.stringify(params);
    __privateGet(this, _requestedSubSnapshots).add(key);
    await __privateMethod(this, _Shape_instances, awaitUpToDate_fn).call(this);
    await this.stream.requestSnapshot(params);
  }
  subscribe(callback) {
    const subscriptionId = Math.random();
    __privateGet(this, _subscribers2).set(subscriptionId, callback);
    return () => {
      __privateGet(this, _subscribers2).delete(subscriptionId);
    };
  }
  unsubscribeAll() {
    __privateGet(this, _subscribers2).clear();
  }
  get numSubscribers() {
    return __privateGet(this, _subscribers2).size;
  }
};
_data = new WeakMap();
_subscribers2 = new WeakMap();
_insertedKeys = new WeakMap();
_requestedSubSnapshots = new WeakMap();
_reexecuteSnapshotsPending = new WeakMap();
_status = new WeakMap();
_error2 = new WeakMap();
_Shape_instances = new WeakSet();
process_fn = function(messages) {
  let shouldNotify = false;
  messages.forEach((message) => {
    if (isChangeMessage(message)) {
      shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `syncing`);
      if (this.mode === `full`) {
        switch (message.headers.operation) {
          case `insert`:
            __privateGet(this, _data).set(message.key, message.value);
            break;
          case `update`:
            __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));
            break;
          case `delete`:
            __privateGet(this, _data).delete(message.key);
            break;
        }
      } else {
        switch (message.headers.operation) {
          case `insert`:
            __privateGet(this, _insertedKeys).add(message.key);
            __privateGet(this, _data).set(message.key, message.value);
            break;
          case `update`:
            if (__privateGet(this, _insertedKeys).has(message.key)) {
              __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));
            }
            break;
          case `delete`:
            if (__privateGet(this, _insertedKeys).has(message.key)) {
              __privateGet(this, _data).delete(message.key);
              __privateGet(this, _insertedKeys).delete(message.key);
            }
            break;
        }
      }
    }
    if (isControlMessage(message)) {
      switch (message.headers.control) {
        case `up-to-date`:
          shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `up-to-date`);
          if (__privateGet(this, _reexecuteSnapshotsPending)) {
            __privateSet(this, _reexecuteSnapshotsPending, false);
            void __privateMethod(this, _Shape_instances, reexecuteSnapshots_fn).call(this);
          }
          break;
        case `must-refetch`:
          __privateGet(this, _data).clear();
          __privateGet(this, _insertedKeys).clear();
          __privateSet(this, _error2, false);
          shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `syncing`);
          __privateSet(this, _reexecuteSnapshotsPending, true);
          break;
      }
    }
  });
  if (shouldNotify) __privateMethod(this, _Shape_instances, notify_fn).call(this);
};
reexecuteSnapshots_fn = async function() {
  await __privateMethod(this, _Shape_instances, awaitUpToDate_fn).call(this);
  await Promise.all(
    Array.from(__privateGet(this, _requestedSubSnapshots)).map(async (jsonParams) => {
      try {
        const snapshot = JSON.parse(jsonParams);
        await this.stream.requestSnapshot(snapshot);
      } catch (_) {
      }
    })
  );
};
awaitUpToDate_fn = async function() {
  if (this.stream.isUpToDate) return;
  await new Promise((resolve) => {
    const check = () => {
      if (this.stream.isUpToDate) {
        clearInterval(interval);
        unsub();
        resolve();
      }
    };
    const interval = setInterval(check, 10);
    const unsub = this.stream.subscribe(
      () => check(),
      () => check()
    );
    check();
  });
};
updateShapeStatus_fn = function(status) {
  const stateChanged = __privateGet(this, _status) !== status;
  __privateSet(this, _status, status);
  return stateChanged && status === `up-to-date`;
};
handleError_fn = function(e) {
  if (e instanceof FetchError) {
    __privateSet(this, _error2, e);
    __privateMethod(this, _Shape_instances, notify_fn).call(this);
  }
};
notify_fn = function() {
  __privateGet(this, _subscribers2).forEach((callback) => {
    callback({ value: this.currentValue, rows: this.currentRows });
  });
};
export {
  BackoffDefaults,
  ELECTRIC_PROTOCOL_QUERY_PARAMS,
  FetchError,
  Shape,
  ShapeStream,
  camelToSnake,
  compileExpression,
  compileOrderBy,
  createColumnMapper,
  isChangeMessage,
  isControlMessage,
  isVisibleInSnapshot,
  resolveValue,
  snakeCamelMapper,
  snakeToCamel
};
//# sourceMappingURL=index.legacy-esm.js.map