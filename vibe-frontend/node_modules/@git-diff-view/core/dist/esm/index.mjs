import fastDiff from 'fast-diff';
import { highlighter } from '@git-diff-view/lowlight';
export * from '@git-diff-view/lowlight';

var DiffHunkExpansionType;
(function (DiffHunkExpansionType) {
    /** The hunk header cannot be expanded at all. */
    DiffHunkExpansionType["None"] = "None";
    /**
     * The hunk header can be expanded up exclusively. Only the first hunk can be
     * expanded up exclusively.
     */
    DiffHunkExpansionType["Up"] = "Up";
    /**
     * The hunk header can be expanded down exclusively. Only the last hunk (if
     * it's the dummy hunk with only one line) can be expanded down exclusively.
     */
    DiffHunkExpansionType["Down"] = "Down";
    /** The hunk header can be expanded both up and down. */
    DiffHunkExpansionType["Both"] = "Both";
    /**
     * The hunk header represents a short gap that, when expanded, will
     * result in merging this hunk and the hunk above.
     */
    DiffHunkExpansionType["Short"] = "Short";
})(DiffHunkExpansionType || (DiffHunkExpansionType = {}));
/** each diff is made up of a number of hunks */
class DiffHunk {
    /**
     * @param header The details from the diff hunk header about the line start and patch length.
     * @param lines The contents - context and changes - of the diff section.
     * @param unifiedDiffStart The diff hunk's start position in the overall file diff.
     * @param unifiedDiffEnd The diff hunk's end position in the overall file diff.
     */
    constructor(header, lines, unifiedDiffStart, unifiedDiffEnd, expansionType) {
        this.header = header;
        this.lines = lines;
        this.unifiedDiffStart = unifiedDiffStart;
        this.unifiedDiffEnd = unifiedDiffEnd;
        this.expansionType = expansionType;
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        return (this.header.equals(other.header) &&
            this.unifiedDiffStart === other.unifiedDiffStart &&
            this.unifiedDiffEnd === other.unifiedDiffEnd &&
            this.expansionType === other.expansionType &&
            this.lines.length === other.lines.length &&
            this.lines.every((xLine, ix) => xLine.equals(other.lines[ix])));
    }
}
/** details about the start and end of a diff hunk */
class DiffHunkHeader {
    /**
     * @param oldStartLine The line in the old (or original) file where this diff hunk starts.
     * @param oldLineCount The number of lines in the old (or original) file that this diff hunk covers
     * @param newStartLine The line in the new file where this diff hunk starts.
     * @param newLineCount The number of lines in the new file that this diff hunk covers.
     */
    constructor(oldStartLine, oldLineCount, newStartLine, newLineCount) {
        this.oldStartLine = oldStartLine;
        this.oldLineCount = oldLineCount;
        this.newStartLine = newStartLine;
        this.newLineCount = newLineCount;
    }
    toDiffLineRepresentation() {
        return `@@ -${this.oldStartLine},${this.oldLineCount} +${this.newStartLine},${this.newLineCount} @@`;
    }
    equals(other) {
        return (this.oldStartLine === other.oldStartLine &&
            this.oldLineCount === other.oldLineCount &&
            this.newStartLine === other.newStartLine &&
            this.oldStartLine === other.oldStartLine);
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
const addContentHighlightBGName = "--diff-add-content-highlight--";
const delContentHighlightBGName = "--diff-del-content-highlight--";

var NewLineSymbol;
(function (NewLineSymbol) {
    NewLineSymbol[NewLineSymbol["CRLF"] = 1] = "CRLF";
    NewLineSymbol[NewLineSymbol["CR"] = 2] = "CR";
    NewLineSymbol[NewLineSymbol["LF"] = 3] = "LF";
    NewLineSymbol[NewLineSymbol["NEWLINE"] = 4] = "NEWLINE";
    NewLineSymbol[NewLineSymbol["NORMAL"] = 5] = "NORMAL";
    NewLineSymbol[NewLineSymbol["NULL"] = 6] = "NULL";
})(NewLineSymbol || (NewLineSymbol = {}));
const getSymbol = (symbol) => {
    switch (symbol) {
        case NewLineSymbol.LF:
            return "␊";
        case NewLineSymbol.CR:
            return "␍";
        case NewLineSymbol.CRLF:
            return "␍␊";
        default:
            return "";
    }
};
var DiffModeEnum;
(function (DiffModeEnum) {
    // github like
    DiffModeEnum[DiffModeEnum["SplitGitHub"] = 1] = "SplitGitHub";
    // gitlab like
    DiffModeEnum[DiffModeEnum["SplitGitLab"] = 2] = "SplitGitLab";
    DiffModeEnum[DiffModeEnum["Split"] = 3] = "Split";
    DiffModeEnum[DiffModeEnum["Unified"] = 4] = "Unified";
})(DiffModeEnum || (DiffModeEnum = {}));

const maxLength = 1000;
/** Get the maximum position in the range. */
function rangeMax(range) {
    return range.location + range.length;
}
/** Get the length of the common substring between the two strings. */
function commonLength(stringA, rangeA, stringB, rangeB, reverse) {
    const max = Math.min(rangeA.length, rangeB.length);
    const startA = reverse ? rangeMax(rangeA) - 1 : rangeA.location;
    const startB = reverse ? rangeMax(rangeB) - 1 : rangeB.location;
    const stride = reverse ? -1 : 1;
    let length = 0;
    while (Math.abs(length) < max) {
        if (stringA[startA + length] !== stringB[startB + length]) {
            break;
        }
        length += stride;
    }
    return Math.abs(length);
}
function isInValidString(s) {
    return s.trim().length === 0 || s.length >= maxLength;
}
function checkNewLineSymbolChange(addition, deletion) {
    const stringA = addition.text;
    const stringB = deletion.text;
    const aEndStr = stringA.slice(-2);
    const bEndStr = stringB.slice(-2);
    const aSymbol = aEndStr === "\r\n"
        ? NewLineSymbol.CRLF
        : aEndStr.endsWith("\r")
            ? NewLineSymbol.CR
            : aEndStr.endsWith("\n")
                ? NewLineSymbol.LF
                : NewLineSymbol.NULL;
    const bSymbol = bEndStr === "\r\n"
        ? NewLineSymbol.CRLF
        : bEndStr.endsWith("\r")
            ? NewLineSymbol.CR
            : bEndStr.endsWith("\n")
                ? NewLineSymbol.LF
                : NewLineSymbol.NULL;
    const hasNewLineChanged = addition.noTrailingNewLine !== deletion.noTrailingNewLine;
    if (aSymbol === bSymbol && !hasNewLineChanged) {
        return { addSymbol: undefined, addString: stringA, delSymbol: undefined, delString: stringB };
    }
    return {
        addSymbol: hasNewLineChanged
            ? addition.noTrailingNewLine
                ? NewLineSymbol.NEWLINE
                : NewLineSymbol.NORMAL
            : aSymbol,
        addString: aSymbol === NewLineSymbol.CRLF
            ? stringA.slice(0, -2)
            : aSymbol === NewLineSymbol.CR || aSymbol === NewLineSymbol.LF
                ? stringA.slice(0, -1)
                : stringA,
        delSymbol: hasNewLineChanged
            ? deletion.noTrailingNewLine
                ? NewLineSymbol.NEWLINE
                : NewLineSymbol.NORMAL
            : bSymbol,
        delString: bSymbol === NewLineSymbol.CRLF
            ? stringB.slice(0, -2)
            : bSymbol === NewLineSymbol.CR || bSymbol === NewLineSymbol.LF
                ? stringB.slice(0, -1)
                : stringB,
    };
}
// TODO maybe could use the original content line.  fixed
/** Get the changed ranges in the strings, relative to each other. */
function relativeChanges(addition, deletion) {
    const stringA = addition.text;
    const stringB = deletion.text;
    const { addString, delString, addSymbol, delSymbol } = checkNewLineSymbolChange(addition, deletion);
    if (addString === delString && addSymbol && delSymbol) {
        return {
            addRange: {
                range: {
                    location: addString.length,
                    length: stringA.length - addString.length,
                },
                hasLineChange: true,
                newLineSymbol: addSymbol,
            },
            delRange: {
                range: {
                    location: delString.length,
                    length: stringB.length - delString.length,
                },
                hasLineChange: true,
                newLineSymbol: delSymbol,
            },
        };
    }
    let delRange = { location: 0, length: delString.length };
    let addRange = { location: 0, length: addString.length };
    if (isInValidString(stringA) || isInValidString(stringB)) {
        addRange.length = 0;
        delRange.length = 0;
        return {
            addRange: { range: addRange },
            delRange: { range: delRange },
        };
    }
    const prefixLength = commonLength(delString, delRange, addString, addRange, false);
    delRange = {
        location: delRange.location + prefixLength,
        length: delRange.length - prefixLength,
    };
    addRange = {
        location: addRange.location + prefixLength,
        length: addRange.length - prefixLength,
    };
    const suffixLength = commonLength(delString, delRange, addString, addRange, true);
    delRange.length -= suffixLength;
    addRange.length -= suffixLength;
    return {
        addRange: {
            range: addRange,
            hasLineChange: (addString.slice(0, addRange.location) + addString.slice(addRange.location + addRange.length)).trim().length >
                0,
        },
        delRange: {
            range: delRange,
            hasLineChange: (delString.slice(0, delRange.location) + delString.slice(delRange.location + delRange.length)).trim().length >
                0,
        },
    };
}
function diffChanges(addition, deletion) {
    const { addString, addSymbol, delString, delSymbol } = checkNewLineSymbolChange(addition, deletion);
    if (isInValidString(addString) || isInValidString(delString)) {
        return {
            addRange: { range: [], hasLineChange: !!addSymbol, newLineSymbol: addSymbol },
            delRange: { range: [], hasLineChange: !!delSymbol, newLineSymbol: delSymbol },
        };
    }
    const diffRange = fastDiff(delString, addString, 0, true);
    let aStart = 0;
    let bStart = 0;
    const aRange = diffRange
        .filter((i) => i[0] !== -1)
        .map((i) => ({ type: i[0], str: i[1], location: aStart, length: ((aStart += i[1].length), i[1].length) }));
    const bRange = diffRange
        .filter((i) => i[0] !== 1)
        .map((i) => ({ type: i[0], str: i[1], location: bStart, length: ((bStart += i[1].length), i[1].length) }));
    return {
        addRange: {
            range: aRange,
            hasLineChange: aRange.some((i) => i.type === 0 && i.str.trim().length > 0),
            newLineSymbol: addSymbol,
        },
        delRange: {
            range: bRange,
            hasLineChange: aRange.some((i) => i.type === 0 && i.str.trim().length > 0),
            newLineSymbol: delSymbol,
        },
    };
}

/** indicate what a line in the diff represents */
var DiffLineType;
(function (DiffLineType) {
    DiffLineType[DiffLineType["Context"] = 0] = "Context";
    DiffLineType[DiffLineType["Add"] = 1] = "Add";
    DiffLineType[DiffLineType["Delete"] = 2] = "Delete";
    DiffLineType[DiffLineType["Hunk"] = 3] = "Hunk";
})(DiffLineType || (DiffLineType = {}));
/** track details related to each line in the diff */
class DiffLine {
    constructor(text, type, 
    // Line number in the original diff patch (before expanding it), or null if
    // it was added as part of a diff expansion action.
    originalLineNumber, oldLineNumber, newLineNumber, noTrailingNewLine = false, changes, diffChanges, plainTemplate, syntaxTemplate) {
        this.text = text;
        this.type = type;
        this.originalLineNumber = originalLineNumber;
        this.oldLineNumber = oldLineNumber;
        this.newLineNumber = newLineNumber;
        this.noTrailingNewLine = noTrailingNewLine;
        this.changes = changes;
        this.diffChanges = diffChanges;
        this.plainTemplate = plainTemplate;
        this.syntaxTemplate = syntaxTemplate;
    }
    withNoTrailingNewLine(noTrailingNewLine) {
        return new DiffLine(this.text, this.type, this.originalLineNumber, this.oldLineNumber, this.newLineNumber, noTrailingNewLine);
    }
    isIncludeableLine() {
        return this.type === DiffLineType.Add || this.type === DiffLineType.Delete;
    }
    equals(other) {
        return (this.text === other.text &&
            this.type === other.type &&
            this.originalLineNumber === other.originalLineNumber &&
            this.oldLineNumber === other.oldLineNumber &&
            this.newLineNumber === other.newLineNumber &&
            this.noTrailingNewLine === other.noTrailingNewLine);
    }
    clone(text) {
        return new DiffLine(text, this.type, this.originalLineNumber, this.oldLineNumber, this.newLineNumber, this.noTrailingNewLine);
    }
}
const checkDiffLineIncludeChange = (diffLine) => {
    if (!diffLine)
        return false;
    return diffLine.type === DiffLineType.Add || diffLine.type === DiffLineType.Delete;
};

// copy from https://github.com/vuejs/core/blob/main/packages/shared/src/escapeHtml.ts
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = "&quot;";
                break;
            case 38: // &
                escaped = "&amp;";
                break;
            case 39: // '
                escaped = "&#39;";
                break;
            case 60: // <
                escaped = "&lt;";
                break;
            case 62: // >
                escaped = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}

let enableTransform = false;
const temp = (f) => f;
let transformContent = temp;
let transformFile = temp;
/**
 * ⚠️ **WARNING: DANGEROUS OPERATION** ⚠️
 *
 * This function modifies global state and may cause unexpected side effects.
 * You may also need escapeHTML for the content.
 *
 * @param fn - The transformation function to help transform template content
 * @throws {Error} Throws an error if the provided parameter is not a function
 *
 * @example
 * ```typescript
 * // Use with caution - this affects global behavior
 * setTransformForTemplateContent((content) => content.trim());
 * ```
 */
const setTransformForTemplateContent = (fn) => {
    if (typeof fn !== "function") {
        throw new Error("Transform must be a function");
    }
    transformContent = fn;
    enableTransform = true;
};
/**
 * ⚠️ **WARNING: DANGEROUS OPERATION** ⚠️
 *
 * @param fn - The transformation function to apply to file content
 * @throws {Error} Throws an error if the provided parameter is not a function
 *
 * @example
 * ```typescript
 * // Use with caution - this affects global behavior
 * setTransformFile((content) => content.toUpperCase());
 * ```
 */
const setTransformForFile = (fn) => {
    if (typeof fn !== "function") {
        throw new Error("Transform must be a function");
    }
    transformFile = fn;
    enableTransform = true;
};
/**
 * Resets all transformation functions to their default state and disables transformation.
 *
 * @example
 * ```typescript
 * resetTransform(); // Clears all transformations
 * ```
 */
const resetTransform = () => {
    enableTransform = false;
    transformContent = temp;
    transformFile = temp;
};
/**
 * Checks whether content transformation is currently enabled.
 *
 * @returns {boolean} True if transformation is enabled, false otherwise
 *
 * @example
 * ```typescript
 * if (isTransformEnabled()) {
 *   console.log('Transformations are active');
 * }
 * ```
 */
const isTransformEnabled = () => enableTransform;
/**
 * Applies the transformation function to the provided content if transformation is enabled.
 *
 * @param content - The content string to transform
 * @returns {string} The transformed content if transformation is enabled and configured, otherwise the original content
 *
 * @example
 * ```typescript
 * const transformed = processTransformTemplateContent('  hello world  ');
 * ```
 */
const processTransformTemplateContent = (content) => {
    if (enableTransform && temp !== transformContent) {
        return transformContent(content);
    }
    return content;
};
/**
 * Applies the file transformation function to the provided content if transformation is enabled.
 *
 * @param content - The content string to transform
 * @returns {string} The transformed content if transformation is enabled and configured, otherwise the original content
 *
 * @example
 * ```typescript
 * const transformed = doTransformFile('some file content');
 * ```
 */
const processTransformForFile = (content) => {
    if (enableTransform && temp !== transformFile) {
        return transformFile(content);
    }
    return content;
};

const defaultTransform = (content) => escapeHtml(content).replace(/\n/g, "").replace(/\r/g, "");
const getPlainDiffTemplate = ({ diffLine, rawLine, operator, }) => {
    if (diffLine.plainTemplate)
        return;
    const changes = diffLine.changes;
    if (!changes || !changes.hasLineChange || !rawLine)
        return;
    const transform = isTransformEnabled() ? processTransformTemplateContent : defaultTransform;
    const range = changes.range;
    const str1 = rawLine.slice(0, range.location);
    const str2 = rawLine.slice(range.location, range.location + range.length);
    const str3 = rawLine.slice(range.location + range.length);
    const isLast = str2.includes("\n");
    const _str2 = isLast ? str2.replace("\n", "").replace("\r", "") : str2;
    const isNewLineSymbolChanged = changes.newLineSymbol;
    const template = `<span data-range-start="${range.location}" data-range-end="${range.location + range.length}">${transform(str1)}<span data-diff-highlight style="background-color: var(${operator === "add" ? addContentHighlightBGName : delContentHighlightBGName});border-radius: 0.2em;">${isLast
        ? `${transform(_str2)}<span data-newline-symbol>${getSymbol(isNewLineSymbolChanged)}</span>`
        : transform(str2)}</span>${transform(str3)}</span>`;
    diffLine.plainTemplate = template;
};
const getSyntaxDiffTemplate = ({ diffLine, syntaxLine, operator, }) => {
    var _a;
    if (diffLine.syntaxTemplate || !syntaxLine)
        return;
    const changes = diffLine.changes;
    if (!changes || !changes.hasLineChange)
        return;
    const transform = isTransformEnabled() ? processTransformTemplateContent : defaultTransform;
    const range = changes.range;
    let template = `<span data-range-start="${range.location}" data-range-end="${range.location + range.length}">`;
    (_a = syntaxLine === null || syntaxLine === void 0 ? void 0 : syntaxLine.nodeList) === null || _a === void 0 ? void 0 : _a.forEach(({ node, wrapper }) => {
        var _a, _b, _c, _d, _e, _f;
        if (node.endIndex < range.location || range.location + range.length < node.startIndex) {
            template += `<span data-start="${node.startIndex}" data-end="${node.endIndex}" class="${(_b = (((_a = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _a === void 0 ? void 0 : _a.className) || [])) === null || _b === void 0 ? void 0 : _b.join(" ")}" style="${((_c = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _c === void 0 ? void 0 : _c.style) || ""}">${transform(node.value)}</span>`;
        }
        else {
            const index1 = range.location - node.startIndex;
            const index2 = index1 < 0 ? 0 : index1;
            const str1 = node.value.slice(0, index2);
            const str2 = node.value.slice(index2, index1 + range.length);
            const str3 = node.value.slice(index1 + range.length);
            const isStart = str1.length || range.location === node.startIndex;
            const isEnd = str3.length || node.endIndex === range.location + range.length - 1;
            const isLast = str2.includes("\n");
            const _str2 = isLast ? str2.replace("\n", "").replace("\r", "") : str2;
            template += `<span data-start="${node.startIndex}" data-end="${node.endIndex}" class="${(_e = (((_d = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _d === void 0 ? void 0 : _d.className) || [])) === null || _e === void 0 ? void 0 : _e.join(" ")}" style="${((_f = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _f === void 0 ? void 0 : _f.style) || ""}">${transform(str1)}<span data-diff-highlight style="background-color: var(${operator === "add" ? addContentHighlightBGName : delContentHighlightBGName});border-top-left-radius: ${isStart ? "0.2em" : "0"};border-bottom-left-radius: ${isStart ? "0.2em" : "0"};border-top-right-radius: ${isEnd || isLast ? "0.2em" : "0"};border-bottom-right-radius: ${isEnd || isLast ? "0.2em" : "0"}">${isLast
                ? `${transform(_str2)}<span data-newline-symbol>${getSymbol(changes.newLineSymbol)}</span>`
                : transform(str2)}</span>${transform(str3)}</span>`;
        }
    });
    template += "</span>";
    diffLine.syntaxTemplate = template;
};
const getSyntaxLineTemplate = (line) => {
    var _a;
    let template = "";
    const transform = isTransformEnabled() ? processTransformTemplateContent : defaultTransform;
    (_a = line === null || line === void 0 ? void 0 : line.nodeList) === null || _a === void 0 ? void 0 : _a.forEach(({ node, wrapper }) => {
        var _a, _b, _c;
        template += `<span data-start="${node.startIndex}" data-end="${node.endIndex}" class="${(_b = (((_a = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _a === void 0 ? void 0 : _a.className) || [])) === null || _b === void 0 ? void 0 : _b.join(" ")}" style="${((_c = wrapper === null || wrapper === void 0 ? void 0 : wrapper.properties) === null || _c === void 0 ? void 0 : _c.style) || ""}">${transform(node.value)}</span>`;
    });
    return template;
};
const getPlainLineTemplate = (line) => {
    if (!line)
        return "";
    const transform = isTransformEnabled() ? processTransformTemplateContent : defaultTransform;
    const template = transform(line);
    return template;
};

/** How many new lines will be added to a diff hunk by default. */
const DefaultDiffExpansionStep = 40;
function assertNever(_, message) {
    throw new Error(message);
}
/** Utility function for getting the digit count of the largest line number in an array of diff hunks */
function getLargestLineNumber(hunks) {
    var _a, _b;
    if (hunks.length === 0) {
        return 0;
    }
    for (let i = hunks.length - 1; i >= 0; i--) {
        const hunk = hunks[i];
        for (let j = hunk.lines.length - 1; j >= 0; j--) {
            const line = hunk.lines[j];
            if (line.type === DiffLineType.Hunk) {
                continue;
            }
            const newLineNumber = (_a = line.newLineNumber) !== null && _a !== void 0 ? _a : 0;
            const oldLineNumber = (_b = line.oldLineNumber) !== null && _b !== void 0 ? _b : 0;
            return newLineNumber > oldLineNumber ? newLineNumber : oldLineNumber;
        }
    }
    return 0;
}
/**
 * Calculates whether or not a hunk header can be expanded up, down, both, or if
 * the space represented by the hunk header is short and expansion there would
 * mean merging with the hunk above.
 *
 * @param hunkIndex     Index of the hunk to evaluate within the whole diff.
 * @param hunkHeader    Header of the hunk to evaluate.
 * @param previousHunk  Hunk previous to the one to evaluate. Null if the
 *                      evaluated hunk is the first one.
 */
function getHunkHeaderExpansionType(hunkIndex, hunkHeader, previousHunk) {
    const distanceToPrevious = previousHunk === null
        ? Infinity
        : hunkHeader.oldStartLine - previousHunk.header.oldStartLine - previousHunk.header.oldLineCount;
    // In order to simplify the whole logic around expansion, only the hunk at the
    // top can be expanded up exclusively, and only the hunk at the bottom (the
    // dummy one, see getTextDiffWithBottomDummyHunk) can be expanded down
    // exclusively.
    // The rest of the hunks can be expanded both ways, except those which are too
    // short and therefore the direction of expansion doesn't matter.
    if (hunkIndex === 0) {
        // The top hunk can only be expanded if there is content above it
        if (hunkHeader.oldStartLine > 1 && hunkHeader.newStartLine > 1) {
            return DiffHunkExpansionType.Up;
        }
        else {
            return DiffHunkExpansionType.None;
        }
    }
    else if (distanceToPrevious <= DefaultDiffExpansionStep) {
        return DiffHunkExpansionType.Short;
    }
    else {
        return DiffHunkExpansionType.Both;
    }
}
const numIterator = (num, cb) => {
    const re = [];
    for (let i = 0; i < num; i++) {
        re.push(cb(i));
    }
    return re;
};
const getLang = (fileName) => {
    const dotIndex = fileName.lastIndexOf(".");
    const extension = fileName.slice(dotIndex + 1);
    return extension;
};
const getDiffRange = (additions, deletions, { getAdditionRaw, getDeletionRaw, getAdditionSyntax, getDeletionSyntax, }) => {
    if (additions.length === deletions.length) {
        const len = additions.length;
        for (let i = 0; i < len; i++) {
            const addition = additions[i];
            const deletion = deletions[i];
            if (!addition.changes || !deletion.changes) {
                // use the original text content to computed diff range
                // fix: get diff with ignoreWhiteSpace config
                const _addition = addition.clone(getAdditionRaw(addition.newLineNumber) || addition.text || "");
                const _deletion = deletion.clone(getDeletionRaw(deletion.oldLineNumber) || deletion.text || "");
                const { addRange, delRange } = relativeChanges(_addition, _deletion);
                addition.changes = addRange;
                deletion.changes = delRange;
            }
            if (!addition.plainTemplate || !deletion.plainTemplate) {
                getPlainDiffTemplate({ diffLine: addition, rawLine: getAdditionRaw(addition.newLineNumber), operator: "add" });
                getPlainDiffTemplate({ diffLine: deletion, rawLine: getDeletionRaw(deletion.oldLineNumber), operator: "del" });
            }
            if (!addition.syntaxTemplate || !deletion.syntaxTemplate) {
                getSyntaxDiffTemplate({
                    diffLine: addition,
                    syntaxLine: getAdditionSyntax(addition.newLineNumber),
                    operator: "add",
                });
                getSyntaxDiffTemplate({
                    diffLine: deletion,
                    syntaxLine: getDeletionSyntax(deletion.oldLineNumber),
                    operator: "del",
                });
            }
            // TODO! support word diff
            // const { addRange: _addRange, delRange: _delRange } = diffChanges(_addition, _deletion);
            // addition.diffChanges = _addRange;
            // deletion.diffChanges = _delRange;
        }
    }
};

/* eslint-disable max-lines */
// !NOTE: ALL of the diff parse logic copy from desktop, SEE https://github.com/desktop/desktop
// With mirror change
// https://en.wikipedia.org/wiki/Diff_utility
//
// @@ -l,s +l,s @@ optional section heading
//
// The hunk range information contains two hunk ranges. The range for the hunk of the original
// file is preceded by a minus symbol, and the range for the new file is preceded by a plus
// symbol. Each hunk range is of the format l,s where l is the starting line number and s is
// the number of lines the change hunk applies to for each respective file.
//
// In many versions of GNU diff, each range can omit the comma and trailing value s,
// in which case s defaults to 1
const diffHeaderRe = /^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/;
/**
 * Regular expression matching invisible bidirectional Unicode characters that
 * may be interpreted or compiled differently than what it appears. More info:
 * https://github.co/hiddenchars
 */
const HiddenBidiCharsRegex = /[\u202A-\u202E]|[\u2066-\u2069]/;
const DiffPrefixAdd = "+";
const DiffPrefixDelete = "-";
const DiffPrefixContext = " ";
const DiffPrefixNoNewline = "\\";
const DiffLinePrefixChars = new Set([
    DiffPrefixAdd,
    DiffPrefixDelete,
    DiffPrefixContext,
    DiffPrefixNoNewline,
]);
/**
 * A parser for the GNU unified diff format
 *
 * See https://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html
 */
class DiffParser {
    constructor() {
        Object.defineProperty(this, "__v_skip", { value: true });
        this.reset();
    }
    /**
     * Resets the internal parser state so that it can be reused.
     *
     * This is done automatically at the end of each parse run.
     */
    reset() {
        this.ls = 0;
        this.le = -1;
        this.text = "";
    }
    /**
     * Aligns the internal character pointers at the boundaries of
     * the next line.
     *
     * Returns true if successful or false if the end of the diff
     * has been reached.
     */
    nextLine() {
        this.ls = this.le + 1;
        // We've reached the end of the diff
        if (this.ls >= this.text.length) {
            return false;
        }
        this.le = this.text.indexOf("\n", this.ls);
        // If we can't find the next newline character we'll put our
        // end pointer at the end of the diff string
        if (this.le === -1) {
            this.le = this.text.length;
        }
        // We've succeeded if there's anything to read in between the
        // start and the end
        return this.ls !== this.le;
    }
    /**
     * Advances to the next line and returns it as a substring
     * of the raw diff text. Returns null if end of diff was
     * reached.
     */
    readLine(header) {
        if (header) {
            return this.nextLine() ? this.text.substring(this.ls, this.le) : null;
        }
        else {
            return this.nextLine() ? this.text.substring(this.ls + 1, this.le + 1) : null;
        }
    }
    /** Tests if the current line starts with the given search text */
    lineStartsWith(searchString) {
        return this.text.startsWith(searchString, this.ls);
    }
    /** Tests if the current line ends with the given search text */
    lineEndsWith(searchString) {
        return this.text.endsWith(searchString, this.le);
    }
    /**
     * Returns the starting character of the next line without
     * advancing the internal state. Returns null if advancing
     * would mean reaching the end of the diff.
     */
    peek() {
        const p = this.le + 1;
        return p < this.text.length ? this.text[p] : null;
    }
    /**
     * Parse the diff header, meaning everything from the
     * start of the diff output to the end of the line beginning
     * with +++
     *
     * Example diff header:
     *
     *   diff --git a/app/src/lib/diff-parser.ts b/app/src/lib/diff-parser.ts
     *   index e1d4871..3bd3ee0 100644
     *   --- a/app/src/lib/diff-parser.ts
     *   +++ b/app/src/lib/diff-parser.ts
     *
     * Returns an object with information extracted from the diff
     * header (currently whether it's a binary patch) or null if
     * the end of the diff was reached before the +++ line could be
     * found (which is a valid state).
     */
    parseDiffHeader() {
        // TODO: There's information in here that we might want to
        // capture, such as mode changes
        while (this.nextLine()) {
            if (this.lineStartsWith("Binary files ") && this.lineEndsWith("differ")) {
                return { isBinary: true };
            }
            if (this.lineStartsWith("+++")) {
                return { isBinary: false };
            }
        }
        // It's not an error to not find the +++ line, see the
        // 'parses diff of empty file' test in diff-parser-tests.ts
        return null;
    }
    /**
     * Attempts to convert a RegExp capture group into a number.
     * If the group doesn't exist or wasn't captured the function
     * will return the value of the defaultValue parameter or throw
     * an error if no default value was provided. If the captured
     * string can't be converted to a number an error will be thrown.
     */
    numberFromGroup(m, group, defaultValue = null) {
        const str = m[group];
        if (!str) {
            if (!defaultValue) {
                throw new Error(`Group ${group} missing from regexp match and no defaultValue was provided`);
            }
            return defaultValue;
        }
        const num = parseInt(str, 10);
        if (isNaN(num)) {
            throw new Error(`Could not parse capture group ${group} into number: ${str}`);
        }
        return num;
    }
    /**
     * Parses a hunk header or throws an error if the given line isn't
     * a well-formed hunk header.
     *
     * We currently only extract the line number information and
     * ignore any hunk headings.
     *
     * Example hunk header (text within ``):
     *
     * `@@ -84,10 +82,8 @@ export function parseRawDiff(lines: ReadonlyArray<string>): Diff {`
     *
     * Where everything after the last @@ is what's known as the hunk, or section, heading
     */
    parseHunkHeader(line) {
        const m = diffHeaderRe.exec(line);
        if (!m) {
            throw new Error(`Invalid hunk header format`);
        }
        // If endLines are missing default to 1, see diffHeaderRe docs
        const oldStartLine = this.numberFromGroup(m, 1);
        const oldLineCount = this.numberFromGroup(m, 2, 1);
        const newStartLine = this.numberFromGroup(m, 3);
        const newLineCount = this.numberFromGroup(m, 4, 1);
        return new DiffHunkHeader(oldStartLine, oldLineCount, newStartLine, newLineCount);
    }
    /**
     * Convenience function which lets us leverage the type system to
     * prove exhaustive checks in parseHunk.
     *
     * Takes an arbitrary string and checks to see if the first character
     * of that string is one of the allowed prefix characters for diff
     * lines (ie lines in between hunk headers).
     */
    parseLinePrefix(c) {
        // Since we know that DiffLinePrefixChars and the DiffLinePrefix type
        // include the same characters we can tell the type system that we
        // now know that c[0] is one of the characters in the DifflinePrefix set
        if (c && c.length && DiffLinePrefixChars.has(c[0])) {
            return c[0];
        }
        return null;
    }
    /**
     * Parses a hunk, including its header or throws an error if the diff doesn't
     * contain a well-formed diff hunk at the current position.
     *
     * Expects that the position has been advanced to the beginning of a presumed
     * diff hunk header.
     *
     * @param linesConsumed The number of unified diff lines consumed up until
     *                      this point by the diff parser. Used to give the
     *                      position and length (in lines) of the parsed hunk
     *                      relative to the overall parsed diff. These numbers
     *                      have no real meaning in the context of a diff and
     *                      are only used to aid the app in line-selections.
     */
    parseHunk(linesConsumed, hunkIndex, previousHunk) {
        const headerLine = this.readLine(true);
        if (!headerLine) {
            throw new Error("Expected hunk header but reached end of diff");
        }
        const header = this.parseHunkHeader(headerLine);
        const lines = new Array();
        lines.push(new DiffLine(headerLine, DiffLineType.Hunk, 1, null, null));
        let c;
        let rollingDiffBeforeCounter = header.oldStartLine;
        let rollingDiffAfterCounter = header.newStartLine;
        let diffLineNumber = linesConsumed;
        while ((c = this.parseLinePrefix(this.peek()))) {
            const line = this.readLine(false);
            if (!line) {
                throw new Error("Expected unified diff line but reached end of diff");
            }
            // A marker indicating that the last line in the original or the new file
            // is missing a trailing newline. In other words, the presence of this marker
            // means that the new and/or original file lacks a trailing newline.
            //
            // When we find it we have to look up the previous line and set the
            // noTrailingNewLine flag
            if (c === DiffPrefixNoNewline) {
                // See https://github.com/git/git/blob/21f862b498925194f8f1ebe8203b7a7df756555b/apply.c#L1725-L1732
                if (line.length < 12) {
                    throw new Error(`Expected "no newline at end of file" marker to be at least 12 bytes long`);
                }
                const previousLineIndex = lines.length - 1;
                const previousLine = lines[previousLineIndex];
                lines[previousLineIndex] = previousLine.withNoTrailingNewLine(true);
                continue;
            }
            // We must increase `diffLineNumber` only when we're certain that the line
            // is not a "no newline" marker. Otherwise, we'll end up with a wrong
            // `diffLineNumber` for the next line. This could happen if the last line
            // in the file doesn't have a newline before the change.
            diffLineNumber++;
            let diffLine;
            if (c === DiffPrefixAdd) {
                diffLine = new DiffLine(line, DiffLineType.Add, diffLineNumber, null, rollingDiffAfterCounter++);
            }
            else if (c === DiffPrefixDelete) {
                diffLine = new DiffLine(line, DiffLineType.Delete, diffLineNumber, rollingDiffBeforeCounter++, null);
            }
            else if (c === DiffPrefixContext) {
                diffLine = new DiffLine(line, DiffLineType.Context, diffLineNumber, rollingDiffBeforeCounter++, rollingDiffAfterCounter++);
            }
            else {
                return assertNever(c, `Unknown DiffLinePrefix: ${c}`);
            }
            lines.push(diffLine);
        }
        if (lines.length === 1) {
            throw new Error("Malformed diff, empty hunk");
        }
        return new DiffHunk(header, lines, linesConsumed, linesConsumed + lines.length - 1, getHunkHeaderExpansionType(hunkIndex, header, previousHunk));
    }
    /**
     * Parse a well-formed unified diff into hunks and lines.
     *
     * @param text A unified diff produced by git diff, git log --patch
     *             or any other git plumbing command that produces unified
     *             diffs.
     */
    parse(text) {
        this.text = text;
        try {
            const headerInfo = this.parseDiffHeader();
            const headerEnd = this.le;
            const header = this.text.substring(0, headerEnd);
            // empty diff
            if (!headerInfo) {
                return {
                    header,
                    contents: "",
                    hunks: [],
                    isBinary: false,
                    maxLineNumber: 0,
                    hasHiddenBidiChars: false,
                };
            }
            if (headerInfo.isBinary) {
                return {
                    header,
                    contents: "",
                    hunks: [],
                    isBinary: true,
                    maxLineNumber: 0,
                    hasHiddenBidiChars: false,
                };
            }
            const hunks = new Array();
            let linesConsumed = 0;
            let previousHunk = null;
            do {
                const hunk = this.parseHunk(linesConsumed, hunks.length, previousHunk);
                hunks.push(hunk);
                previousHunk = hunk;
                linesConsumed += hunk.lines.length;
            } while (this.peek());
            const contents = this.text
                .substring(headerEnd + 1, this.le)
                // Note that this simply returns a reference to the
                // substring if no match is found, it does not create
                // a new string instance.
                .replace(/\n\\ No newline at end of file/g, "");
            return {
                header,
                contents,
                hunks,
                isBinary: headerInfo.isBinary,
                maxLineNumber: getLargestLineNumber(hunks),
                hasHiddenBidiChars: HiddenBidiCharsRegex.test(text),
            };
        }
        finally {
            this.reset();
        }
    }
}
const parseInstance = new DiffParser();

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var _Cache_instances, _Cache_keyArray, _Cache_maxLength, _Cache_checkLength;
class Cache extends Map {
    constructor() {
        super(...arguments);
        _Cache_instances.add(this);
        _Cache_keyArray.set(this, []);
        _Cache_maxLength.set(this, 30);
    }
    get maxLength() {
        return __classPrivateFieldGet(this, _Cache_maxLength, "f");
    }
    setMaxLength(length) {
        __classPrivateFieldSet(this, _Cache_maxLength, length, "f");
        __classPrivateFieldGet(this, _Cache_instances, "m", _Cache_checkLength).call(this);
    }
    set(key, value) {
        if (__classPrivateFieldGet(this, _Cache_maxLength, "f") <= 0)
            return this;
        if (this.has(key))
            return this;
        __classPrivateFieldGet(this, _Cache_keyArray, "f").push(key);
        __classPrivateFieldGet(this, _Cache_instances, "m", _Cache_checkLength).call(this);
        return super.set(key, value);
    }
}
_Cache_keyArray = new WeakMap(), _Cache_maxLength = new WeakMap(), _Cache_instances = new WeakSet(), _Cache_checkLength = function _Cache_checkLength() {
    while (__classPrivateFieldGet(this, _Cache_keyArray, "f").length > __classPrivateFieldGet(this, _Cache_maxLength, "f")) {
        const key = __classPrivateFieldGet(this, _Cache_keyArray, "f").shift();
        this.delete(key);
    }
};

var _File_instances, _File_doCheck;
const map = new Cache();
const devKey = "@git-diff-cache";
map.setMaxLength(50);
map.name = "@git-diff-view/core";
if (process.env.NODE_ENV === "development" && typeof globalThis !== "undefined") {
    if (Array.isArray(globalThis[devKey])) {
        globalThis[devKey] = globalThis[devKey].filter((i) => i !== map);
        if (globalThis[devKey].length > 0) {
            console.warn("there are multiple instance of @git-diff-view/core in current environment!");
        }
        globalThis[devKey].push(map);
    }
    else {
        globalThis[devKey] = [map];
    }
}
class File {
    static createInstance(data) {
        var _a;
        const file = new File(data === null || data === void 0 ? void 0 : data.raw, data === null || data === void 0 ? void 0 : data.lang, data === null || data === void 0 ? void 0 : data.fileName);
        file.ast = data === null || data === void 0 ? void 0 : data.ast;
        file.rawFile = (data === null || data === void 0 ? void 0 : data.rawFile) || {};
        file.plainFile = (data === null || data === void 0 ? void 0 : data.plainFile) || {};
        file.hasDoRaw = data === null || data === void 0 ? void 0 : data.hasDoRaw;
        file.rawLength = data === null || data === void 0 ? void 0 : data.rawLength;
        file.syntaxFile = (data === null || data === void 0 ? void 0 : data.syntaxFile) || {};
        file.hasDoSyntax = data === null || data === void 0 ? void 0 : data.hasDoSyntax;
        file.syntaxLength = data === null || data === void 0 ? void 0 : data.syntaxLength;
        file.highlighterName = data === null || data === void 0 ? void 0 : data.highlighterName;
        file.highlighterType = data === null || data === void 0 ? void 0 : data.highlighterType;
        file.maxLineNumber = data === null || data === void 0 ? void 0 : data.maxLineNumber;
        file.enableTemplate = (_a = data === null || data === void 0 ? void 0 : data.enableTemplate) !== null && _a !== void 0 ? _a : true;
        return file;
    }
    constructor(raw, lang, fileName) {
        _File_instances.add(this);
        this.raw = raw;
        this.lang = lang;
        this.fileName = fileName;
        this.rawFile = {};
        this.hasDoRaw = false;
        this.syntaxFile = {};
        this.plainFile = {};
        this.hasDoSyntax = false;
        this.maxLineNumber = 0;
        this.enableTemplate = true;
        this.raw = processTransformForFile(raw);
        Object.defineProperty(this, "__v_skip", { value: true });
    }
    doSyntax({ registerHighlighter, theme, }) {
        if (!this.raw || this.hasDoSyntax)
            return;
        const finalHighlighter = registerHighlighter || highlighter;
        if (this.syntaxLength) {
            if (process.env.NODE_ENV === "development") {
                console.error("current file already doSyntax before!");
            }
            return;
        }
        if (this.rawLength > finalHighlighter.maxLineToIgnoreSyntax) {
            if (process.env.NODE_ENV === "development") {
                console.warn(`ignore syntax for current file, because the rawLength is too long: ${this.rawLength}`);
            }
            return;
        }
        // check current lang is support or not
        // if it's a unsupported lang, fallback to use lowlightHighlighter
        let supportEngin = finalHighlighter;
        try {
            if (!finalHighlighter.hasRegisteredCurrentLang(this.lang)) {
                supportEngin = highlighter;
            }
        }
        catch (_a) {
            supportEngin = highlighter;
        }
        this.ast = supportEngin.getAST(this.raw, this.fileName, this.lang, theme);
        if (!this.ast)
            return;
        const { syntaxFileObject, syntaxFileLineNumber } = supportEngin.processAST(this.ast);
        if (this.enableTemplate) {
            // get syntax template
            Object.values(syntaxFileObject).forEach((line) => {
                line.template = getSyntaxLineTemplate(line);
            });
        }
        this.syntaxFile = syntaxFileObject;
        this.syntaxLength = syntaxFileLineNumber;
        this.highlighterName = supportEngin.name;
        this.highlighterType = supportEngin.type;
        if (process.env.NODE_ENV === "development") {
            __classPrivateFieldGet(this, _File_instances, "m", _File_doCheck).call(this);
        }
        this.hasDoSyntax = true;
    }
    doRaw() {
        if (!this.raw || this.hasDoRaw)
            return;
        const rawString = this.raw;
        const rawArray = rawString.split("\n");
        this.rawLength = rawArray.length;
        this.maxLineNumber = rawArray.length;
        this.rawFile = {};
        this.plainFile = {};
        for (let i = 0; i < rawArray.length; i++) {
            this.rawFile[i + 1] = i < rawArray.length - 1 ? rawArray[i] + "\n" : rawArray[i];
            if (this.enableTemplate) {
                this.plainFile[i + 1] = {
                    value: this.rawFile[i + 1],
                    template: getPlainLineTemplate(this.rawFile[i + 1]),
                };
            }
        }
        this.hasDoRaw = true;
    }
}
_File_instances = new WeakSet(), _File_doCheck = function _File_doCheck() {
    if (this.rawLength && this.syntaxLength) {
        if (this.rawLength !== this.syntaxLength) {
            console.warn("the rawLength not match for the syntaxLength");
        }
        Object.values(this.syntaxFile).forEach(({ value, lineNumber }) => {
            if (value !== this.rawFile[lineNumber]) {
                console.log("some line not match:" + value + " __ " + this.rawFile[lineNumber] + " __ at: " + lineNumber + " lineNumber");
            }
        });
    }
};
function getFile(raw, lang, theme, fileName, uuid) {
    let key = raw + "--" + "0.0.30" + "--" + theme + "--" + lang;
    if (uuid) {
        key = uuid + "--" + "0.0.30" + "--" + theme + "--" + lang;
    }
    let otherThemeKey = raw + "--" + "0.0.30" + "--" + (theme === "light" ? "dark" : "light") + "--" + lang;
    if (uuid) {
        otherThemeKey = uuid + "--" + "0.0.30" + "--" + (theme === "light" ? "dark" : "light") + "--" + lang;
    }
    if (map.has(key))
        return map.get(key);
    if (map.has(otherThemeKey)) {
        const cacheFile = map.get(otherThemeKey);
        // 基于className的ast不需要重新生成
        if (cacheFile.highlighterType === "class") {
            return cacheFile;
        }
    }
    const file = new File(raw, lang, fileName);
    map.set(key, file);
    return file;
}
const _cacheMap = map;
const disableCache = () => map.setMaxLength(0);

var _DiffFile_instances, _DiffFile_oldFileResult, _DiffFile_newFileResult, _DiffFile_diffListResults, _DiffFile_diffLines, _DiffFile_oldFileDiffLines, _DiffFile_newFileDiffLines, _DiffFile_oldFileLines, _DiffFile_newFileLines, _DiffFile_oldFilePlainLines, _DiffFile_newFilePlainLines, _DiffFile_oldFileSyntaxLines, _DiffFile_newFileSyntaxLines, _DiffFile_oldFilePlaceholderLines, _DiffFile_newFilePlaceholderLines, _DiffFile_splitLeftLines, _DiffFile_splitRightLines, _DiffFile_splitHunksLines, _DiffFile_unifiedLines, _DiffFile_unifiedHunksLines, _DiffFile_listeners, _DiffFile_hasInitRaw, _DiffFile_hasInitSyntax, _DiffFile_hasBuildSplit, _DiffFile_hasBuildUnified, _DiffFile_updateCount, _DiffFile_composeByDiff, _DiffFile_composeByMerge, _DiffFile_enableTemplate, _DiffFile_composeByFullMerge, _DiffFile_highlighterName, _DiffFile_highlighterType, _DiffFile_theme, _DiffFile__theme, _DiffFile_hasExpandSplitAll, _DiffFile_hasExpandUnifiedAll, _DiffFile_id, _DiffFile_clonedInstance, _DiffFile_doDiff, _DiffFile_doFile, _DiffFile_composeRaw, _DiffFile_composeFile, _DiffFile_composeDiff, _DiffFile_composeSyntax, _DiffFile_doSyntax, _DiffFile_getOldDiffLine, _DiffFile_getNewDiffLine, _DiffFile_getOldRawLine, _DiffFile_getNewRawLine, _DiffFile_getOldSyntaxLine, _DiffFile_getNewSyntaxLine;
let composeLen = 40;
const getCurrentComposeLength = () => composeLen;
const changeDefaultComposeLength = (compose) => {
    composeLen = compose;
};
const resetDefaultComposeLength = () => {
    composeLen = 40;
};
const idSet = new Set();
class DiffFile {
    static createInstance(data, bundle) {
        var _a, _b, _c, _d, _e, _f;
        const instance = new DiffFile(((_a = data === null || data === void 0 ? void 0 : data.oldFile) === null || _a === void 0 ? void 0 : _a.fileName) || "", ((_b = data === null || data === void 0 ? void 0 : data.oldFile) === null || _b === void 0 ? void 0 : _b.content) || "", ((_c = data === null || data === void 0 ? void 0 : data.newFile) === null || _c === void 0 ? void 0 : _c.fileName) || "", ((_d = data === null || data === void 0 ? void 0 : data.newFile) === null || _d === void 0 ? void 0 : _d.content) || "", (data === null || data === void 0 ? void 0 : data.hunks) || [], ((_e = data === null || data === void 0 ? void 0 : data.oldFile) === null || _e === void 0 ? void 0 : _e.fileLang) || "", ((_f = data === null || data === void 0 ? void 0 : data.newFile) === null || _f === void 0 ? void 0 : _f.fileLang) || "");
        if (bundle) {
            if (bundle.isFullMerge) {
                instance._mergeFullBundle(bundle);
            }
            else {
                instance.mergeBundle(bundle);
            }
        }
        return instance;
    }
    constructor(_oldFileName, _oldFileContent, _newFileName, _newFileContent, _diffList, _oldFileLang, _newFileLang, uuid) {
        _DiffFile_instances.add(this);
        this.uuid = uuid;
        _DiffFile_oldFileResult.set(this, void 0);
        _DiffFile_newFileResult.set(this, void 0);
        _DiffFile_diffListResults.set(this, void 0);
        _DiffFile_diffLines.set(this, void 0);
        _DiffFile_oldFileDiffLines.set(this, void 0);
        _DiffFile_newFileDiffLines.set(this, void 0);
        _DiffFile_oldFileLines.set(this, void 0);
        _DiffFile_newFileLines.set(this, void 0);
        _DiffFile_oldFilePlainLines.set(this, void 0);
        _DiffFile_newFilePlainLines.set(this, void 0);
        _DiffFile_oldFileSyntaxLines.set(this, void 0);
        _DiffFile_newFileSyntaxLines.set(this, void 0);
        _DiffFile_oldFilePlaceholderLines.set(this, void 0);
        _DiffFile_newFilePlaceholderLines.set(this, void 0);
        _DiffFile_splitLeftLines.set(this, []);
        _DiffFile_splitRightLines.set(this, []);
        _DiffFile_splitHunksLines.set(this, void 0);
        _DiffFile_unifiedLines.set(this, []);
        _DiffFile_unifiedHunksLines.set(this, void 0);
        _DiffFile_listeners.set(this, []);
        _DiffFile_hasInitRaw.set(this, false);
        _DiffFile_hasInitSyntax.set(this, false);
        _DiffFile_hasBuildSplit.set(this, false);
        _DiffFile_hasBuildUnified.set(this, false);
        _DiffFile_updateCount.set(this, 0);
        _DiffFile_composeByDiff.set(this, false);
        _DiffFile_composeByMerge.set(this, false);
        _DiffFile_enableTemplate.set(this, true);
        _DiffFile_composeByFullMerge.set(this, false);
        _DiffFile_highlighterName.set(this, void 0);
        _DiffFile_highlighterType.set(this, void 0);
        _DiffFile_theme.set(this, "light");
        _DiffFile__theme.set(this, void 0);
        _DiffFile_hasExpandSplitAll.set(this, { state: false });
        _DiffFile_hasExpandUnifiedAll.set(this, { state: false });
        this._version_ = "0.0.30";
        this._oldFileName = "";
        this._oldFileContent = "";
        this._oldFileLang = "";
        this._newFileName = "";
        this._newFileContent = "";
        this._newFileLang = "";
        this._diffList = [];
        this.diffLineLength = 0;
        this.splitLineLength = 0;
        this.unifiedLineLength = 0;
        this.fileLineLength = 0;
        this.additionLength = 0;
        this.deletionLength = 0;
        this.hasSomeLineCollapsed = false;
        _DiffFile_id.set(this, "");
        _DiffFile_clonedInstance.set(this, new Map());
        this.getSplitLeftLine = (index) => {
            return __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")[index];
        };
        this.getSplitLineByLineNumber = (lineNumber, side) => {
            var _a, _b;
            if (side === SplitSide.old) {
                return (_a = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")) === null || _a === void 0 ? void 0 : _a.find((item) => item.lineNumber === lineNumber);
            }
            else {
                return (_b = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")) === null || _b === void 0 ? void 0 : _b.find((item) => item.lineNumber === lineNumber);
            }
        };
        this.getSplitLineIndexByLineNumber = (lineNumber, side) => {
            var _a, _b;
            if (side === SplitSide.old) {
                return (_a = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")) === null || _a === void 0 ? void 0 : _a.findIndex((item) => item.lineNumber === lineNumber);
            }
            else {
                return (_b = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")) === null || _b === void 0 ? void 0 : _b.findIndex((item) => item.lineNumber === lineNumber);
            }
        };
        this.getSplitRightLine = (index) => {
            return __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")[index];
        };
        this.getSplitHunkLine = (index) => {
            var _a;
            return (_a = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")) === null || _a === void 0 ? void 0 : _a[index];
        };
        this.onSplitHunkExpand = (dir, index, needTrigger = true) => {
            var _a, _b;
            const current = (_a = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")) === null || _a === void 0 ? void 0 : _a[index];
            if (!current || !current.splitInfo)
                return;
            if (__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f"))
                return;
            if (dir === "all") {
                for (let i = current.splitInfo.startHiddenIndex; i < current.splitInfo.endHiddenIndex; i++) {
                    const leftLine = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")[i];
                    const rightLine = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")[i];
                    if (leftLine === null || leftLine === void 0 ? void 0 : leftLine.isHidden)
                        leftLine.isHidden = false;
                    if (rightLine === null || rightLine === void 0 ? void 0 : rightLine.isHidden)
                        rightLine.isHidden = false;
                }
                current.splitInfo = Object.assign(Object.assign(Object.assign({}, current.splitInfo), current.hunkInfo), { plainText: current.text, startHiddenIndex: current.splitInfo.endHiddenIndex });
            }
            else if (dir === "down") {
                for (let i = current.splitInfo.startHiddenIndex; i < current.splitInfo.startHiddenIndex + composeLen; i++) {
                    const leftLine = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")[i];
                    const rightLine = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")[i];
                    if (leftLine === null || leftLine === void 0 ? void 0 : leftLine.isHidden)
                        leftLine.isHidden = false;
                    if (rightLine === null || rightLine === void 0 ? void 0 : rightLine.isHidden)
                        rightLine.isHidden = false;
                }
                if (current.isLast) {
                    current.splitInfo = Object.assign(Object.assign({}, current.splitInfo), { startHiddenIndex: current.splitInfo.startHiddenIndex + composeLen });
                }
                else {
                    current.splitInfo = Object.assign(Object.assign({}, current.splitInfo), { startHiddenIndex: current.splitInfo.startHiddenIndex + composeLen, plainText: `@@ -${current.splitInfo.oldStartIndex},${current.splitInfo.oldLength} +${current.splitInfo.newStartIndex},${current.splitInfo.newLength}` });
                }
            }
            else {
                if (current.isLast) {
                    if (process.env.NODE_ENV === "development") {
                        console.error("the last hunk can not expand up!");
                    }
                    return;
                }
                for (let i = current.splitInfo.endHiddenIndex - composeLen; i < current.splitInfo.endHiddenIndex; i++) {
                    const leftLine = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f")[i];
                    const rightLine = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f")[i];
                    if (leftLine === null || leftLine === void 0 ? void 0 : leftLine.isHidden)
                        leftLine.isHidden = false;
                    if (rightLine === null || rightLine === void 0 ? void 0 : rightLine.isHidden)
                        rightLine.isHidden = false;
                }
                const oldStartIndex = current.splitInfo.oldStartIndex - composeLen;
                const oldLength = current.splitInfo.oldLength + composeLen;
                const newStartIndex = current.splitInfo.newStartIndex - composeLen;
                const newLength = current.splitInfo.newLength + composeLen;
                current.splitInfo = Object.assign(Object.assign({}, current.splitInfo), { endHiddenIndex: current.splitInfo.endHiddenIndex - composeLen, oldStartIndex,
                    oldLength,
                    newStartIndex,
                    newLength, plainText: `@@ -${oldStartIndex},${oldLength} +${newStartIndex},${newLength}` });
                (_b = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")) === null || _b === void 0 ? true : delete _b[index];
                __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")[current.splitInfo.endHiddenIndex] = current;
            }
            if (needTrigger) {
                this.notifyAll();
            }
        };
        this.getUnifiedLine = (index) => {
            return __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")[index];
        };
        this.getUnifiedLineByLineNumber = (lienNumber, side) => {
            var _a, _b;
            if (side === SplitSide.old) {
                return (_a = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _a === void 0 ? void 0 : _a.find((item) => item.oldLineNumber === lienNumber);
            }
            else {
                return (_b = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _b === void 0 ? void 0 : _b.find((item) => item.newLineNumber === lienNumber);
            }
        };
        this.getUnifiedLineIndexByLineNumber = (lineNumber, side) => {
            var _a, _b;
            if (side === SplitSide.old) {
                return (_a = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _a === void 0 ? void 0 : _a.findIndex((item) => item.oldLineNumber === lineNumber);
            }
            else {
                return (_b = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _b === void 0 ? void 0 : _b.findIndex((item) => item.newLineNumber === lineNumber);
            }
        };
        this.getUnifiedHunkLine = (index) => {
            var _a;
            return (_a = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")) === null || _a === void 0 ? void 0 : _a[index];
        };
        // TODO! support rollback?
        this.onUnifiedHunkExpand = (dir, index, needTrigger = true) => {
            var _a, _b, _c;
            if (__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f"))
                return;
            const current = (_a = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")) === null || _a === void 0 ? void 0 : _a[index];
            if (!current || !current.unifiedInfo)
                return;
            if (dir === "all") {
                for (let i = current.unifiedInfo.startHiddenIndex; i < current.unifiedInfo.endHiddenIndex; i++) {
                    const unifiedLine = (_b = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")) === null || _b === void 0 ? void 0 : _b[i];
                    if (unifiedLine === null || unifiedLine === void 0 ? void 0 : unifiedLine.isHidden) {
                        unifiedLine.isHidden = false;
                    }
                }
                current.unifiedInfo = Object.assign(Object.assign(Object.assign({}, current.unifiedInfo), current.hunkInfo), { plainText: current.text, startHiddenIndex: current.unifiedInfo.endHiddenIndex });
            }
            else if (dir === "down") {
                for (let i = current.unifiedInfo.startHiddenIndex; i < current.unifiedInfo.startHiddenIndex + composeLen; i++) {
                    const unifiedLine = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")[i];
                    if (unifiedLine === null || unifiedLine === void 0 ? void 0 : unifiedLine.isHidden)
                        unifiedLine.isHidden = false;
                }
                if (current.isLast) {
                    current.unifiedInfo = Object.assign(Object.assign({}, current.unifiedInfo), { startHiddenIndex: current.unifiedInfo.startHiddenIndex + composeLen });
                }
                else {
                    current.unifiedInfo = Object.assign(Object.assign({}, current.unifiedInfo), { startHiddenIndex: current.unifiedInfo.startHiddenIndex + composeLen, plainText: `@@ -${current.unifiedInfo.oldStartIndex},${current.unifiedInfo.oldLength} +${current.unifiedInfo.newStartIndex},${current.unifiedInfo.newLength}` });
                }
            }
            else {
                if (current.isLast) {
                    if (process.env.NODE_ENV === "development") {
                        console.error("the last hunk can not expand up!");
                    }
                    return;
                }
                for (let i = current.unifiedInfo.endHiddenIndex - composeLen; i < current.unifiedInfo.endHiddenIndex; i++) {
                    const unifiedLine = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f")[i];
                    if (unifiedLine === null || unifiedLine === void 0 ? void 0 : unifiedLine.isHidden)
                        unifiedLine.isHidden = false;
                }
                const oldStartIndex = current.unifiedInfo.oldStartIndex - composeLen;
                const oldLength = current.unifiedInfo.oldLength + composeLen;
                const newStartIndex = current.unifiedInfo.newStartIndex - composeLen;
                const newLength = current.unifiedInfo.newLength + composeLen;
                current.unifiedInfo = Object.assign(Object.assign({}, current.unifiedInfo), { endHiddenIndex: current.unifiedInfo.endHiddenIndex - composeLen, oldStartIndex,
                    oldLength,
                    newStartIndex,
                    newLength, plainText: `@@ -${oldStartIndex},${oldLength} +${newStartIndex},${newLength}` });
                (_c = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")) === null || _c === void 0 ? true : delete _c[index];
                __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")[current.unifiedInfo.endHiddenIndex] = current;
            }
            if (needTrigger) {
                this.notifyAll();
            }
        };
        this.onAllExpand = (mode) => {
            if (__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f"))
                return;
            if (mode === "split") {
                Object.keys(__classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f") || {}).forEach((key) => {
                    this.onSplitHunkExpand("all", +key, false);
                });
                __classPrivateFieldGet(this, _DiffFile_hasExpandSplitAll, "f").state = true;
            }
            else {
                Object.keys(__classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f") || {}).forEach((key) => {
                    this.onUnifiedHunkExpand("all", +key, false);
                });
                __classPrivateFieldGet(this, _DiffFile_hasExpandUnifiedAll, "f").state = true;
            }
            this.notifyAll();
        };
        this.onAllCollapse = (mode) => {
            if (__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f"))
                return;
            if (mode === "split") {
                Object.values(__classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f") || {}).forEach((item) => {
                    if (!item.isHidden && item._isHidden) {
                        item.isHidden = item._isHidden;
                    }
                });
                Object.values(__classPrivateFieldGet(this, _DiffFile_splitRightLines, "f") || {}).forEach((item) => {
                    if (!item.isHidden && item._isHidden) {
                        item.isHidden = item._isHidden;
                    }
                });
                Object.values(__classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f") || {}).forEach((item) => {
                    if (!item.splitInfo)
                        return;
                    item.splitInfo = Object.assign(Object.assign({}, item.splitInfo), { oldStartIndex: item.splitInfo._oldStartIndex, oldLength: item.splitInfo._oldLength, newStartIndex: item.splitInfo._newStartIndex, newLength: item.splitInfo._newLength, startHiddenIndex: item.splitInfo._startHiddenIndex, endHiddenIndex: item.splitInfo._endHiddenIndex, plainText: item.splitInfo._plainText });
                });
                Object.keys(__classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f") || {}).forEach((key) => {
                    const item = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")[key];
                    if (!item.splitInfo)
                        return;
                    if (item.splitInfo.endHiddenIndex !== +key) {
                        delete __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")[key];
                        __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")[item.splitInfo.endHiddenIndex] = item;
                    }
                });
                __classPrivateFieldGet(this, _DiffFile_hasExpandSplitAll, "f").state = false;
            }
            else {
                Object.values(__classPrivateFieldGet(this, _DiffFile_unifiedLines, "f") || {}).forEach((item) => {
                    if (!item.isHidden && item._isHidden) {
                        item.isHidden = item._isHidden;
                    }
                });
                Object.values(__classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f") || {}).forEach((item) => {
                    if (!item.unifiedInfo)
                        return;
                    item.unifiedInfo = Object.assign(Object.assign({}, item.unifiedInfo), { oldStartIndex: item.unifiedInfo._oldStartIndex, oldLength: item.unifiedInfo._oldLength, newStartIndex: item.unifiedInfo._newStartIndex, newLength: item.unifiedInfo._newLength, startHiddenIndex: item.unifiedInfo._startHiddenIndex, endHiddenIndex: item.unifiedInfo._endHiddenIndex, plainText: item.unifiedInfo._plainText });
                });
                Object.keys(__classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f") || {}).forEach((key) => {
                    const item = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")[key];
                    if (!item.unifiedInfo)
                        return;
                    if (item.unifiedInfo.endHiddenIndex !== +key) {
                        delete __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")[key];
                        __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")[item.unifiedInfo.endHiddenIndex] = item;
                    }
                });
                __classPrivateFieldGet(this, _DiffFile_hasExpandUnifiedAll, "f").state = false;
            }
            this.notifyAll();
        };
        this.getOldFileContent = () => {
            var _a;
            return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.raw;
        };
        this.getNewFileContent = () => {
            var _a;
            return (_a = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _a === void 0 ? void 0 : _a.raw;
        };
        this.getOldPlainLine = (lineNumber) => {
            var _a;
            return (_a = __classPrivateFieldGet(this, _DiffFile_oldFilePlainLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
        };
        this.getOldSyntaxLine = (lineNumber) => {
            var _a;
            return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileSyntaxLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
        };
        this.getNewPlainLine = (lineNumber) => {
            var _a;
            return (_a = __classPrivateFieldGet(this, _DiffFile_newFilePlainLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
        };
        this.getNewSyntaxLine = (lineNumber) => {
            var _a;
            return (_a = __classPrivateFieldGet(this, _DiffFile_newFileSyntaxLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
        };
        // TODO improve
        this.subscribe = (listener) => {
            __classPrivateFieldGet(this, _DiffFile_listeners, "f").push(listener);
            return () => {
                __classPrivateFieldSet(this, _DiffFile_listeners, __classPrivateFieldGet(this, _DiffFile_listeners, "f").filter((i) => i !== listener), "f");
            };
        };
        this.notifyAll = (skipSyncExternal) => {
            var _a;
            __classPrivateFieldSet(this, _DiffFile_updateCount, (_a = __classPrivateFieldGet(this, _DiffFile_updateCount, "f"), _a++, _a), "f");
            __classPrivateFieldGet(this, _DiffFile_listeners, "f").forEach((f) => {
                if (skipSyncExternal && f.isSyncExternal) {
                    return;
                }
                f();
            });
            // support update from outside instance
            __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").forEach((_, instance) => {
                instance.notifyAll(true);
            });
        };
        this.getUpdateCount = () => __classPrivateFieldGet(this, _DiffFile_updateCount, "f");
        this.getExpandEnabled = () => !__classPrivateFieldGet(this, _DiffFile_composeByDiff, "f");
        this.getBundle = () => {
            // common
            const hasInitRaw = __classPrivateFieldGet(this, _DiffFile_hasInitRaw, "f");
            const hasInitSyntax = __classPrivateFieldGet(this, _DiffFile_hasInitSyntax, "f");
            const hasBuildSplit = __classPrivateFieldGet(this, _DiffFile_hasBuildSplit, "f");
            const hasBuildUnified = __classPrivateFieldGet(this, _DiffFile_hasBuildUnified, "f");
            const oldFileLines = __classPrivateFieldGet(this, _DiffFile_oldFileLines, "f");
            const oldFileDiffLines = __classPrivateFieldGet(this, _DiffFile_oldFileDiffLines, "f");
            const oldFilePlainLines = __classPrivateFieldGet(this, _DiffFile_oldFilePlainLines, "f");
            const oldFileSyntaxLines = __classPrivateFieldGet(this, _DiffFile_oldFileSyntaxLines, "f");
            const oldFilePlaceholderLines = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f");
            const newFileLines = __classPrivateFieldGet(this, _DiffFile_newFileLines, "f");
            const newFileDiffLines = __classPrivateFieldGet(this, _DiffFile_newFileDiffLines, "f");
            const newFilePlainLines = __classPrivateFieldGet(this, _DiffFile_newFilePlainLines, "f");
            const newFileSyntaxLines = __classPrivateFieldGet(this, _DiffFile_newFileSyntaxLines, "f");
            const newFilePlaceholderLines = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f");
            const splitLineLength = this.splitLineLength;
            const unifiedLineLength = this.unifiedLineLength;
            const fileLineLength = this.fileLineLength;
            const additionLength = this.additionLength;
            const deletionLength = this.deletionLength;
            const composeByDiff = __classPrivateFieldGet(this, _DiffFile_composeByDiff, "f");
            const highlighterName = __classPrivateFieldGet(this, _DiffFile_highlighterName, "f");
            const highlighterType = __classPrivateFieldGet(this, _DiffFile_highlighterType, "f");
            const hasSomeLineCollapsed = this.hasSomeLineCollapsed;
            const hasExpandSplitAll = __classPrivateFieldGet(this, _DiffFile_hasExpandSplitAll, "f");
            const hasExpandUnifiedAll = __classPrivateFieldGet(this, _DiffFile_hasExpandUnifiedAll, "f");
            // split
            const splitLeftLines = __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f");
            const splitRightLines = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f");
            const splitHunkLines = __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f");
            // unified
            const unifiedLines = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f");
            const unifiedHunkLines = __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f");
            const version = this._version_;
            const theme = __classPrivateFieldGet(this, _DiffFile_theme, "f");
            const enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
            return {
                hasInitRaw,
                hasInitSyntax,
                hasBuildSplit,
                hasBuildUnified,
                oldFileLines,
                oldFileDiffLines,
                oldFilePlainLines,
                oldFileSyntaxLines,
                oldFilePlaceholderLines,
                newFileLines,
                newFileDiffLines,
                newFilePlainLines,
                newFileSyntaxLines,
                newFilePlaceholderLines,
                splitLineLength,
                unifiedLineLength,
                fileLineLength,
                additionLength,
                deletionLength,
                splitLeftLines,
                splitRightLines,
                splitHunkLines,
                unifiedLines,
                unifiedHunkLines,
                highlighterName,
                highlighterType,
                composeByDiff,
                hasSomeLineCollapsed,
                hasExpandSplitAll,
                hasExpandUnifiedAll,
                version,
                theme,
                enableTemplate,
                isFullMerge: false,
            };
        };
        this.mergeBundle = (data, notifyUpdate = true) => {
            __classPrivateFieldSet(this, _DiffFile_hasInitRaw, data.hasInitRaw, "f");
            __classPrivateFieldSet(this, _DiffFile_hasInitSyntax, data.hasInitSyntax, "f");
            __classPrivateFieldSet(this, _DiffFile_hasBuildSplit, data.hasBuildSplit, "f");
            __classPrivateFieldSet(this, _DiffFile_hasBuildUnified, data.hasBuildUnified, "f");
            __classPrivateFieldSet(this, _DiffFile_composeByDiff, data.composeByDiff, "f");
            __classPrivateFieldSet(this, _DiffFile_highlighterName, data.highlighterName, "f");
            __classPrivateFieldSet(this, _DiffFile_highlighterType, data.highlighterType, "f");
            __classPrivateFieldSet(this, _DiffFile_oldFileLines, data.oldFileLines, "f");
            __classPrivateFieldSet(this, _DiffFile_oldFileDiffLines, data.oldFileDiffLines, "f");
            __classPrivateFieldSet(this, _DiffFile_oldFilePlainLines, data.oldFilePlainLines, "f");
            __classPrivateFieldSet(this, _DiffFile_oldFileSyntaxLines, data.oldFileSyntaxLines, "f");
            __classPrivateFieldSet(this, _DiffFile_oldFilePlaceholderLines, data.oldFilePlaceholderLines, "f");
            __classPrivateFieldSet(this, _DiffFile_newFileLines, data.newFileLines, "f");
            __classPrivateFieldSet(this, _DiffFile_newFileDiffLines, data.newFileDiffLines, "f");
            __classPrivateFieldSet(this, _DiffFile_newFilePlainLines, data.newFilePlainLines, "f");
            __classPrivateFieldSet(this, _DiffFile_newFileSyntaxLines, data.newFileSyntaxLines, "f");
            __classPrivateFieldSet(this, _DiffFile_newFilePlaceholderLines, data.newFilePlaceholderLines, "f");
            this.splitLineLength = data.splitLineLength;
            this.unifiedLineLength = data.unifiedLineLength;
            this.fileLineLength = data.fileLineLength;
            this.additionLength = data.additionLength;
            this.deletionLength = data.deletionLength;
            this.hasSomeLineCollapsed = data.hasSomeLineCollapsed;
            __classPrivateFieldSet(this, _DiffFile_hasExpandSplitAll, data.hasExpandSplitAll, "f");
            __classPrivateFieldSet(this, _DiffFile_hasExpandUnifiedAll, data.hasExpandUnifiedAll, "f");
            __classPrivateFieldSet(this, _DiffFile_splitLeftLines, data.splitLeftLines, "f");
            __classPrivateFieldSet(this, _DiffFile_splitRightLines, data.splitRightLines, "f");
            __classPrivateFieldSet(this, _DiffFile_splitHunksLines, data.splitHunkLines, "f");
            __classPrivateFieldSet(this, _DiffFile_unifiedLines, data.unifiedLines, "f");
            __classPrivateFieldSet(this, _DiffFile_unifiedHunksLines, data.unifiedHunkLines, "f");
            __classPrivateFieldSet(this, _DiffFile_theme, data.theme, "f");
            __classPrivateFieldSet(this, _DiffFile_enableTemplate, data.enableTemplate, "f");
            // mark this instance as a merged instance
            __classPrivateFieldSet(this, _DiffFile_composeByMerge, true, "f");
            if (process.env.NODE_ENV === "development" && this._version_ !== data.version) {
                console.error("the version of the `diffInstance` is not match, some error may happen");
            }
            if (process.env.NODE_ENV === "development" && !data.hasInitRaw) {
                console.error(`there are not a valid bundle data, try to call 'initRaw' function before merge / getBundle`);
            }
            if (notifyUpdate) {
                this.notifyAll();
            }
        };
        this._getHighlighterName = () => __classPrivateFieldGet(this, _DiffFile_highlighterName, "f") || "";
        this._getIsPureDiffRender = () => __classPrivateFieldGet(this, _DiffFile_composeByDiff, "f");
        this._getTheme = () => __classPrivateFieldGet(this, _DiffFile_theme, "f");
        this._addClonedInstance = (instance) => {
            const updateFunc = () => {
                this._notifyOthers(instance);
                // sync state from child instance trigger update
                this._mergeFullBundle(instance._getFullBundle(), false);
            };
            updateFunc.isSyncExternal = true;
            const unsubscribe = instance.subscribe(updateFunc);
            __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").set(instance, unsubscribe);
        };
        this._notifyOthers = (instance) => {
            __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").forEach((_, i) => {
                if (i !== instance) {
                    i.notifyAll(true);
                }
            });
        };
        this._delClonedInstance = (instance) => {
            const unsubscribe = __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").get(instance);
            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
            __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").delete(instance);
        };
        this._getFullBundle = () => {
            const bundle = this.getBundle();
            const oldFileResult = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f");
            const newFileResult = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f");
            const diffLines = __classPrivateFieldGet(this, _DiffFile_diffLines, "f");
            const diffListResults = __classPrivateFieldGet(this, _DiffFile_diffListResults, "f");
            return Object.assign(Object.assign({}, bundle), { oldFileResult,
                newFileResult,
                diffLines,
                diffListResults, 
                // get current instance is a fullMerge instance or not
                isFullMerge: __classPrivateFieldGet(this, _DiffFile_composeByMerge, "f") ? __classPrivateFieldGet(this, _DiffFile_composeByFullMerge, "f") : true });
        };
        this._mergeFullBundle = (data, notifyUpdate = true) => {
            this.mergeBundle(data, notifyUpdate);
            try {
                __classPrivateFieldSet(this, _DiffFile_oldFileResult, data.oldFileResult ? File.createInstance(data.oldFileResult) : null, "f");
                __classPrivateFieldSet(this, _DiffFile_newFileResult, data.newFileResult ? File.createInstance(data.newFileResult) : null, "f");
                __classPrivateFieldSet(this, _DiffFile_diffLines, data.diffLines, "f");
                __classPrivateFieldSet(this, _DiffFile_diffListResults, data.diffListResults, "f");
                __classPrivateFieldSet(this, _DiffFile_composeByFullMerge, data.isFullMerge, "f");
            }
            catch (_a) {
            }
        };
        this._destroy = () => {
            this.clearId();
            __classPrivateFieldGet(this, _DiffFile_listeners, "f").splice(0, __classPrivateFieldGet(this, _DiffFile_listeners, "f").length);
            __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").forEach((v) => v());
            __classPrivateFieldGet(this, _DiffFile_clonedInstance, "f").clear();
        };
        this.clear = () => {
            this._destroy();
            __classPrivateFieldSet(this, _DiffFile_oldFileResult, null, "f");
            __classPrivateFieldSet(this, _DiffFile_newFileResult, null, "f");
            __classPrivateFieldSet(this, _DiffFile_diffLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_diffListResults, null, "f");
            __classPrivateFieldSet(this, _DiffFile_newFileDiffLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_oldFileDiffLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_newFileLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_oldFileLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_newFileSyntaxLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_oldFileSyntaxLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_splitHunksLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_splitLeftLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_splitRightLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_unifiedHunksLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_unifiedLines, null, "f");
            __classPrivateFieldSet(this, _DiffFile_theme, undefined, "f");
        };
        Object.defineProperty(this, "__v_skip", { value: true });
        const diffList = Array.from(new Set(_diffList));
        this._oldFileName = _oldFileName;
        this._newFileName = _newFileName;
        this._diffList = diffList;
        this._oldFileLang = getLang(_oldFileLang || _oldFileName || _newFileLang || _newFileName) || "txt";
        this._newFileLang = getLang(_newFileLang || _newFileName || _oldFileLang || _oldFileName) || "txt";
        this._oldFileContent = _oldFileContent;
        this._newFileContent = _newFileContent;
        this.initId();
    }
    initId() {
        let id = "--" + Math.random().toString().slice(2);
        while (idSet.has(id)) {
            id = "--" + Math.random().toString().slice(2);
        }
        idSet.add(id);
        __classPrivateFieldSet(this, _DiffFile_id, id, "f");
    }
    getId() {
        return __classPrivateFieldGet(this, _DiffFile_id, "f");
    }
    clearId() {
        idSet.delete(__classPrivateFieldGet(this, _DiffFile_id, "f"));
    }
    initTheme(theme) {
        __classPrivateFieldSet(this, _DiffFile__theme, __classPrivateFieldGet(this, _DiffFile_theme, "f"), "f");
        __classPrivateFieldSet(this, _DiffFile_theme, theme || __classPrivateFieldGet(this, _DiffFile_theme, "f") || "light", "f");
    }
    initRaw() {
        if (__classPrivateFieldGet(this, _DiffFile_hasInitRaw, "f"))
            return;
        __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_doFile).call(this);
        __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeRaw).call(this);
        __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_doDiff).call(this);
        __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeDiff).call(this);
        __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeFile).call(this);
        __classPrivateFieldSet(this, _DiffFile_hasInitRaw, true, "f");
    }
    initSyntax({ registerHighlighter } = {}) {
        if (__classPrivateFieldGet(this, _DiffFile_hasInitSyntax, "f") && (!__classPrivateFieldGet(this, _DiffFile__theme, "f") || __classPrivateFieldGet(this, _DiffFile_theme, "f") === __classPrivateFieldGet(this, _DiffFile__theme, "f")))
            return;
        __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_doSyntax).call(this, { registerHighlighter });
        __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeDiff).call(this);
        __classPrivateFieldSet(this, _DiffFile_hasInitSyntax, true, "f");
    }
    init() {
        this.initRaw();
        this.initSyntax();
    }
    enableTemplate() {
        __classPrivateFieldSet(this, _DiffFile_enableTemplate, true, "f");
    }
    disableTemplate() {
        __classPrivateFieldSet(this, _DiffFile_enableTemplate, false, "f");
    }
    getIsEnableTemplate() {
        return __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
    }
    buildSplitDiffLines() {
        var _a, _b, _c, _d, _e, _f;
        if (__classPrivateFieldGet(this, _DiffFile_hasBuildSplit, "f"))
            return;
        let oldFileLineNumber = 1;
        let newFileLineNumber = 1;
        let prevIsHidden = true;
        let hideStart = Infinity;
        const maxOldFileLineNumber = ((_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.maxLineNumber) || 0;
        const maxNewFileLineNumber = ((_b = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _b === void 0 ? void 0 : _b.maxLineNumber) || 0;
        if (process.env.NODE_ENV === "development" && !__classPrivateFieldGet(this, _DiffFile_oldFileResult, "f") && !__classPrivateFieldGet(this, _DiffFile_newFileResult, "f") && __classPrivateFieldGet(this, _DiffFile_composeByMerge, "f")) {
            console.error("this instance can not `buildSplitDiffLines` because of the data missing, try to use '_getFullBundle' & '_mergeFullBundle' instead of 'getBundle' & 'mergeBundle'");
        }
        while (oldFileLineNumber <= maxOldFileLineNumber || newFileLineNumber <= maxNewFileLineNumber) {
            const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldFileLineNumber);
            const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newFileLineNumber);
            const oldRawLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldRawLine).call(this, oldFileLineNumber);
            const newRawLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewRawLine).call(this, newFileLineNumber);
            const oldLineHasChange = DiffLine.prototype.isIncludeableLine.call(oldDiffLine || {});
            const newLineHasChange = DiffLine.prototype.isIncludeableLine.call(newDiffLine || {});
            const len = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length;
            const isHidden = !oldDiffLine && !newDiffLine;
            if (oldDiffLine && !newDiffLine) {
                if (oldDiffLine.newLineNumber && oldDiffLine.newLineNumber > newFileLineNumber) {
                    newFileLineNumber++;
                    continue;
                }
                if (oldDiffLine.newLineNumber === null || oldDiffLine.newLineNumber === undefined) {
                    newFileLineNumber++;
                }
            }
            if (newDiffLine && !oldDiffLine) {
                if (newDiffLine.oldLineNumber && newDiffLine.oldLineNumber > oldFileLineNumber) {
                    oldFileLineNumber++;
                    continue;
                }
                if (newDiffLine.oldLineNumber === null || newDiffLine.oldLineNumber === undefined) {
                    oldFileLineNumber++;
                }
            }
            if (!oldDiffLine && !oldRawLine && !newDiffLine && !newRawLine)
                break;
            if (!oldDiffLine && !newDiffLine) {
                if (((_c = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f")) === null || _c === void 0 ? void 0 : _c[oldFileLineNumber]) && ((_d = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f")) === null || _d === void 0 ? void 0 : _d[newFileLineNumber])) {
                    oldFileLineNumber++;
                    newFileLineNumber++;
                    continue;
                }
                if (!oldRawLine && ((_e = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f")) === null || _e === void 0 ? void 0 : _e[newFileLineNumber])) {
                    newFileLineNumber++;
                    continue;
                }
                if (!newRawLine && ((_f = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f")) === null || _f === void 0 ? void 0 : _f[oldFileLineNumber])) {
                    oldFileLineNumber++;
                    continue;
                }
            }
            if ((oldLineHasChange && newLineHasChange) || (!oldLineHasChange && !newLineHasChange)) {
                __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f").push({
                    lineNumber: oldFileLineNumber++,
                    value: oldRawLine,
                    diff: oldDiffLine,
                    isHidden,
                    _isHidden: isHidden,
                });
                __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").push({
                    lineNumber: newFileLineNumber++,
                    value: newRawLine,
                    diff: newDiffLine,
                    isHidden,
                    _isHidden: isHidden,
                });
            }
            else if (oldLineHasChange) {
                __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f").push({
                    lineNumber: oldFileLineNumber++,
                    value: oldRawLine,
                    diff: oldDiffLine,
                    isHidden,
                    _isHidden: isHidden,
                });
                __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").push({});
            }
            else if (newLineHasChange) {
                __classPrivateFieldGet(this, _DiffFile_splitLeftLines, "f").push({});
                __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").push({
                    lineNumber: newFileLineNumber++,
                    value: newRawLine,
                    diff: newDiffLine,
                    isHidden,
                    _isHidden: isHidden,
                });
            }
            if (!prevIsHidden && isHidden) {
                hideStart = len;
            }
            if (isHidden) {
                this.hasSomeLineCollapsed = true;
            }
            prevIsHidden = isHidden;
            if ((oldDiffLine === null || oldDiffLine === void 0 ? void 0 : oldDiffLine.prevHunkLine) || (newDiffLine === null || newDiffLine === void 0 ? void 0 : newDiffLine.prevHunkLine)) {
                const prevHunkLine = (oldDiffLine === null || oldDiffLine === void 0 ? void 0 : oldDiffLine.prevHunkLine) || newDiffLine.prevHunkLine;
                if (prevHunkLine.isFirst) {
                    if (process.env.NODE_ENV === "development" && Number.isFinite(hideStart)) {
                        console.warn("the first hunk can not have a previous diff line");
                    }
                    prevHunkLine.splitInfo = Object.assign(Object.assign({}, prevHunkLine.hunkInfo), { startHiddenIndex: 0, endHiddenIndex: prevHunkLine.hunkInfo.newStartIndex - 1, plainText: prevHunkLine.text, _startHiddenIndex: 0, _endHiddenIndex: prevHunkLine.hunkInfo.newStartIndex - 1, _plainText: prevHunkLine.text });
                    hideStart = Infinity;
                }
                else if (Number.isFinite(hideStart)) {
                    prevHunkLine.splitInfo = Object.assign(Object.assign({}, prevHunkLine.hunkInfo), { startHiddenIndex: hideStart, endHiddenIndex: len, plainText: prevHunkLine.text, _startHiddenIndex: hideStart, _endHiddenIndex: len, _plainText: prevHunkLine.text });
                    hideStart = Infinity;
                }
                __classPrivateFieldSet(this, _DiffFile_splitHunksLines, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")), { [len]: prevHunkLine }), "f");
            }
        }
        // have last hunk
        if (Number.isFinite(hideStart)) {
            const lastDiff = new DiffLine("", DiffLineType.Hunk, null, null, null);
            const lastHunk = lastDiff;
            lastHunk.isLast = true;
            lastHunk.splitInfo = {
                startHiddenIndex: hideStart,
                endHiddenIndex: __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length,
                _startHiddenIndex: hideStart,
                _endHiddenIndex: __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length,
                // just for placeholder
                plainText: "",
                oldStartIndex: 0,
                newStartIndex: 0,
                oldLength: 0,
                newLength: 0,
                _plainText: "",
                _oldStartIndex: 0,
                _newStartIndex: 0,
                _oldLength: 0,
                _newLength: 0,
            };
            __classPrivateFieldSet(this, _DiffFile_splitHunksLines, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _DiffFile_splitHunksLines, "f")), { [__classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length]: lastHunk }), "f");
            hideStart = Infinity;
        }
        this.splitLineLength = __classPrivateFieldGet(this, _DiffFile_splitRightLines, "f").length;
        __classPrivateFieldSet(this, _DiffFile_hasBuildSplit, true, "f");
        this.notifyAll();
    }
    buildUnifiedDiffLines() {
        var _a, _b, _c, _d, _e, _f;
        if (__classPrivateFieldGet(this, _DiffFile_hasBuildUnified, "f"))
            return;
        let oldFileLineNumber = 1;
        let newFileLineNumber = 1;
        let prevIsHidden = true;
        let hideStart = Infinity;
        const maxOldFileLineNumber = ((_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.maxLineNumber) || 0;
        const maxNewFileLineNumber = ((_b = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _b === void 0 ? void 0 : _b.maxLineNumber) || 0;
        if (process.env.NODE_ENV === "development" && !__classPrivateFieldGet(this, _DiffFile_oldFileResult, "f") && !__classPrivateFieldGet(this, _DiffFile_newFileResult, "f") && __classPrivateFieldGet(this, _DiffFile_composeByMerge, "f")) {
            console.error("this instance can not `buildUnifiedDiffLines` because of the data missing, try to use '_getFullBundle' & '_mergeFullBundle' instead of 'getBundle' & 'mergeBundle'");
        }
        while (oldFileLineNumber <= maxOldFileLineNumber || newFileLineNumber <= maxNewFileLineNumber) {
            const oldRawLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldRawLine).call(this, oldFileLineNumber);
            const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldFileLineNumber);
            const newRawLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewRawLine).call(this, newFileLineNumber);
            const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newFileLineNumber);
            const oldLineHasChange = DiffLine.prototype.isIncludeableLine.call(oldDiffLine || {});
            const newLineHasChange = DiffLine.prototype.isIncludeableLine.call(newDiffLine || {});
            const len = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length;
            const isHidden = !oldDiffLine && !newDiffLine;
            if (oldDiffLine && !newDiffLine) {
                if (oldDiffLine.newLineNumber && oldDiffLine.newLineNumber > newFileLineNumber) {
                    newFileLineNumber++;
                    continue;
                }
                if (oldDiffLine.newLineNumber === null || oldDiffLine.newLineNumber === undefined) {
                    newFileLineNumber++;
                }
            }
            if (newDiffLine && !oldDiffLine) {
                if (newDiffLine.oldLineNumber && newDiffLine.oldLineNumber > oldFileLineNumber) {
                    oldFileLineNumber++;
                    continue;
                }
                if (newDiffLine.oldLineNumber === null || newDiffLine.oldLineNumber === undefined) {
                    oldFileLineNumber++;
                }
            }
            if (!oldRawLine && !newRawLine && !newDiffLine && !oldDiffLine)
                break;
            if (!oldDiffLine && !newDiffLine) {
                if (((_c = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f")) === null || _c === void 0 ? void 0 : _c[oldFileLineNumber]) && ((_d = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f")) === null || _d === void 0 ? void 0 : _d[newFileLineNumber])) {
                    oldFileLineNumber++;
                    newFileLineNumber++;
                    continue;
                }
                if (!oldRawLine && ((_e = __classPrivateFieldGet(this, _DiffFile_newFilePlaceholderLines, "f")) === null || _e === void 0 ? void 0 : _e[newFileLineNumber])) {
                    newFileLineNumber++;
                    continue;
                }
                if (!newRawLine && ((_f = __classPrivateFieldGet(this, _DiffFile_oldFilePlaceholderLines, "f")) === null || _f === void 0 ? void 0 : _f[oldFileLineNumber])) {
                    oldFileLineNumber++;
                    continue;
                }
            }
            if (!oldLineHasChange && !newLineHasChange) {
                __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").push({
                    oldLineNumber: oldFileLineNumber++,
                    newLineNumber: newFileLineNumber++,
                    value: newRawLine,
                    diff: newDiffLine,
                    isHidden,
                    _isHidden: isHidden,
                });
            }
            else if (oldLineHasChange) {
                __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").push({
                    oldLineNumber: oldFileLineNumber++,
                    value: oldRawLine,
                    diff: oldDiffLine,
                    isHidden,
                    _isHidden: isHidden,
                });
            }
            else if (newLineHasChange) {
                __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").push({
                    newLineNumber: newFileLineNumber++,
                    value: newRawLine,
                    diff: newDiffLine,
                    isHidden,
                    _isHidden: isHidden,
                });
            }
            if (!prevIsHidden && isHidden) {
                hideStart = len;
            }
            if (isHidden) {
                this.hasSomeLineCollapsed = true;
            }
            prevIsHidden = isHidden;
            if ((oldDiffLine === null || oldDiffLine === void 0 ? void 0 : oldDiffLine.prevHunkLine) || (newDiffLine === null || newDiffLine === void 0 ? void 0 : newDiffLine.prevHunkLine)) {
                const prevHunkLine = (oldDiffLine === null || oldDiffLine === void 0 ? void 0 : oldDiffLine.prevHunkLine) || newDiffLine.prevHunkLine;
                if (prevHunkLine.isFirst) {
                    if (process.env.NODE_ENV === "development" && Number.isFinite(hideStart)) {
                        console.warn("the first hunk can not have a previous diff line");
                    }
                    prevHunkLine.unifiedInfo = Object.assign(Object.assign({}, prevHunkLine.hunkInfo), { startHiddenIndex: 0, endHiddenIndex: prevHunkLine.hunkInfo.newStartIndex - 1, plainText: prevHunkLine.text, _startHiddenIndex: 0, _endHiddenIndex: prevHunkLine.hunkInfo.newStartIndex - 1, _plainText: prevHunkLine.text });
                    hideStart = Infinity;
                }
                else if (Number.isFinite(hideStart)) {
                    prevHunkLine.unifiedInfo = Object.assign(Object.assign({}, prevHunkLine.hunkInfo), { startHiddenIndex: hideStart, endHiddenIndex: len, plainText: prevHunkLine.text, _startHiddenIndex: hideStart, _endHiddenIndex: len, _plainText: prevHunkLine.text });
                    hideStart = Infinity;
                }
                __classPrivateFieldSet(this, _DiffFile_unifiedHunksLines, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")), { [len]: prevHunkLine }), "f");
            }
        }
        // have last hunk
        if (Number.isFinite(hideStart)) {
            const lastDiff = new DiffLine("", DiffLineType.Hunk, null, null, null);
            const lastHunk = lastDiff;
            lastHunk.isLast = true;
            lastHunk.unifiedInfo = {
                startHiddenIndex: hideStart,
                endHiddenIndex: __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length,
                _startHiddenIndex: hideStart,
                _endHiddenIndex: __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length,
                // just for placeholder
                plainText: "",
                oldStartIndex: 0,
                newStartIndex: 0,
                oldLength: 0,
                newLength: 0,
                _plainText: "",
                _oldStartIndex: 0,
                _newStartIndex: 0,
                _oldLength: 0,
                _newLength: 0,
            };
            __classPrivateFieldSet(this, _DiffFile_unifiedHunksLines, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _DiffFile_unifiedHunksLines, "f")), { [__classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length]: lastHunk }), "f");
            hideStart = Infinity;
        }
        this.unifiedLineLength = __classPrivateFieldGet(this, _DiffFile_unifiedLines, "f").length;
        __classPrivateFieldSet(this, _DiffFile_hasBuildUnified, true, "f");
        this.notifyAll();
    }
    get hasExpandSplitAll() {
        return __classPrivateFieldGet(this, _DiffFile_hasExpandSplitAll, "f").state;
    }
    get hasExpandUnifiedAll() {
        return __classPrivateFieldGet(this, _DiffFile_hasExpandUnifiedAll, "f").state;
    }
}
_DiffFile_oldFileResult = new WeakMap(), _DiffFile_newFileResult = new WeakMap(), _DiffFile_diffListResults = new WeakMap(), _DiffFile_diffLines = new WeakMap(), _DiffFile_oldFileDiffLines = new WeakMap(), _DiffFile_newFileDiffLines = new WeakMap(), _DiffFile_oldFileLines = new WeakMap(), _DiffFile_newFileLines = new WeakMap(), _DiffFile_oldFilePlainLines = new WeakMap(), _DiffFile_newFilePlainLines = new WeakMap(), _DiffFile_oldFileSyntaxLines = new WeakMap(), _DiffFile_newFileSyntaxLines = new WeakMap(), _DiffFile_oldFilePlaceholderLines = new WeakMap(), _DiffFile_newFilePlaceholderLines = new WeakMap(), _DiffFile_splitLeftLines = new WeakMap(), _DiffFile_splitRightLines = new WeakMap(), _DiffFile_splitHunksLines = new WeakMap(), _DiffFile_unifiedLines = new WeakMap(), _DiffFile_unifiedHunksLines = new WeakMap(), _DiffFile_listeners = new WeakMap(), _DiffFile_hasInitRaw = new WeakMap(), _DiffFile_hasInitSyntax = new WeakMap(), _DiffFile_hasBuildSplit = new WeakMap(), _DiffFile_hasBuildUnified = new WeakMap(), _DiffFile_updateCount = new WeakMap(), _DiffFile_composeByDiff = new WeakMap(), _DiffFile_composeByMerge = new WeakMap(), _DiffFile_enableTemplate = new WeakMap(), _DiffFile_composeByFullMerge = new WeakMap(), _DiffFile_highlighterName = new WeakMap(), _DiffFile_highlighterType = new WeakMap(), _DiffFile_theme = new WeakMap(), _DiffFile__theme = new WeakMap(), _DiffFile_hasExpandSplitAll = new WeakMap(), _DiffFile_hasExpandUnifiedAll = new WeakMap(), _DiffFile_id = new WeakMap(), _DiffFile_clonedInstance = new WeakMap(), _DiffFile_instances = new WeakSet(), _DiffFile_doDiff = function _DiffFile_doDiff() {
    if (!this._diffList)
        return;
    __classPrivateFieldSet(this, _DiffFile_diffListResults, this._diffList.map((s) => parseInstance.parse(s)), "f");
}, _DiffFile_doFile = function _DiffFile_doFile() {
    if (!this._oldFileContent && !this._newFileContent)
        return;
    if (this._oldFileContent) {
        __classPrivateFieldSet(this, _DiffFile_oldFileResult, getFile(this._oldFileContent, this._oldFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._oldFileName, this.uuid ? this.uuid + "-old" : undefined), "f");
        __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
    }
    if (this._newFileContent) {
        __classPrivateFieldSet(this, _DiffFile_newFileResult, getFile(this._newFileContent, this._newFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._newFileName, this.uuid ? this.uuid + "-new" : undefined), "f");
        __classPrivateFieldGet(this, _DiffFile_newFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
    }
}, _DiffFile_composeRaw = function _DiffFile_composeRaw() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    (_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.doRaw();
    __classPrivateFieldSet(this, _DiffFile_oldFileLines, (_b = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _b === void 0 ? void 0 : _b.rawFile, "f");
    __classPrivateFieldSet(this, _DiffFile_oldFilePlainLines, (_c = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _c === void 0 ? void 0 : _c.plainFile, "f");
    (_d = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _d === void 0 ? void 0 : _d.doRaw();
    __classPrivateFieldSet(this, _DiffFile_newFileLines, (_e = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _e === void 0 ? void 0 : _e.rawFile, "f");
    __classPrivateFieldSet(this, _DiffFile_newFilePlainLines, (_f = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _f === void 0 ? void 0 : _f.plainFile, "f");
    this.fileLineLength = Math.max(this.fileLineLength, ((_g = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _g === void 0 ? void 0 : _g.maxLineNumber) || 0, ((_h = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _h === void 0 ? void 0 : _h.maxLineNumber) || 0);
}, _DiffFile_composeFile = function _DiffFile_composeFile() {
    if (this._oldFileContent && this._newFileContent)
        return;
    const oldFilePlaceholderLines = {};
    const newFilePlaceholderLines = {};
    // all of the file content not exist, try to use diff result to compose
    if (!this._oldFileContent && !this._newFileContent) {
        let newLineNumber = 1;
        let oldLineNumber = 1;
        let oldFileContent = "";
        let newFileContent = "";
        let hasSymbolChanged = false;
        while (oldLineNumber <= this.diffLineLength || newLineNumber <= this.diffLineLength) {
            const oldIndex = oldLineNumber++;
            const newIndex = newLineNumber++;
            const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldIndex);
            const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newIndex);
            if (oldDiffLine) {
                oldFileContent += oldDiffLine.text;
            }
            else {
                // empty line for placeholder
                oldFileContent += "\n";
                oldFilePlaceholderLines[oldIndex] = true;
            }
            if (newDiffLine) {
                newFileContent += newDiffLine.text;
            }
            else {
                // empty line for placeholder
                newFileContent += "\n";
                newFilePlaceholderLines[newIndex] = true;
            }
            if (!hasSymbolChanged && oldDiffLine && newDiffLine) {
                hasSymbolChanged = hasSymbolChanged || oldDiffLine.noTrailingNewLine !== newDiffLine.noTrailingNewLine;
            }
        }
        if (!hasSymbolChanged && oldFileContent === newFileContent)
            return;
        this._oldFileContent = oldFileContent;
        this._newFileContent = newFileContent;
        __classPrivateFieldSet(this, _DiffFile_oldFileResult, getFile(this._oldFileContent, this._oldFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._oldFileName, this.uuid ? this.uuid + "-old" : undefined), "f");
        __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
        __classPrivateFieldSet(this, _DiffFile_newFileResult, getFile(this._newFileContent, this._newFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._newFileName, this.uuid ? this.uuid + "-new" : undefined), "f");
        __classPrivateFieldGet(this, _DiffFile_newFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
        __classPrivateFieldSet(this, _DiffFile_oldFilePlaceholderLines, oldFilePlaceholderLines, "f");
        __classPrivateFieldSet(this, _DiffFile_newFilePlaceholderLines, newFilePlaceholderLines, "f");
        // all of the file just compose by diff, so we can not do the expand action
        __classPrivateFieldSet(this, _DiffFile_composeByDiff, true, "f");
    }
    else if (__classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) {
        let newLineNumber = 1;
        let oldLineNumber = 1;
        let newFileContent = "";
        let hasSymbolChanged = false;
        while (oldLineNumber <= __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f").maxLineNumber) {
            const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newLineNumber++);
            const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldLineNumber);
            if (newDiffLine) {
                newFileContent += newDiffLine.text;
                oldLineNumber = newDiffLine.oldLineNumber ? newDiffLine.oldLineNumber + 1 : oldLineNumber;
            }
            else {
                if (!oldDiffLine) {
                    newFileContent += __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldRawLine).call(this, oldLineNumber);
                }
                oldLineNumber++;
            }
            if (!hasSymbolChanged && newDiffLine && oldDiffLine) {
                hasSymbolChanged = hasSymbolChanged || newDiffLine.noTrailingNewLine !== oldDiffLine.noTrailingNewLine;
            }
        }
        if (!hasSymbolChanged && newFileContent === this._oldFileContent)
            return;
        this._newFileContent = newFileContent;
        __classPrivateFieldSet(this, _DiffFile_newFileResult, getFile(this._newFileContent, this._newFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._newFileName, this.uuid ? this.uuid + "-new" : undefined), "f");
        __classPrivateFieldGet(this, _DiffFile_newFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
    }
    else if (__classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) {
        let oldLineNumber = 1;
        let newLineNumber = 1;
        let oldFileContent = "";
        let hasSymbolChanged = false;
        while (newLineNumber <= __classPrivateFieldGet(this, _DiffFile_newFileResult, "f").maxLineNumber) {
            const oldDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldDiffLine).call(this, oldLineNumber++);
            const newDiffLine = __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewDiffLine).call(this, newLineNumber);
            if (oldDiffLine) {
                oldFileContent += oldDiffLine.text;
                newLineNumber = oldDiffLine.newLineNumber ? oldDiffLine.newLineNumber + 1 : newLineNumber;
            }
            else {
                if (!newDiffLine) {
                    oldFileContent += __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewRawLine).call(this, newLineNumber);
                }
                newLineNumber++;
            }
            if (!hasSymbolChanged && newDiffLine && oldDiffLine) {
                hasSymbolChanged = hasSymbolChanged || newDiffLine.noTrailingNewLine !== oldDiffLine.noTrailingNewLine;
            }
        }
        if (!hasSymbolChanged && oldFileContent === this._newFileContent)
            return;
        this._oldFileContent = oldFileContent;
        __classPrivateFieldSet(this, _DiffFile_oldFileResult, getFile(this._oldFileContent, this._oldFileLang, __classPrivateFieldGet(this, _DiffFile_theme, "f"), this._oldFileName, this.uuid ? this.uuid + "-old" : undefined), "f");
        __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f").enableTemplate = __classPrivateFieldGet(this, _DiffFile_enableTemplate, "f");
    }
    __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeRaw).call(this);
}, _DiffFile_composeDiff = function _DiffFile_composeDiff() {
    var _a;
    if (!((_a = __classPrivateFieldGet(this, _DiffFile_diffListResults, "f")) === null || _a === void 0 ? void 0 : _a.length))
        return;
    const getAdditionRaw = (lineNumber) => {
        return __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewRawLine).call(this, lineNumber);
    };
    const getDeletionRaw = (lineNumber) => {
        return __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldRawLine).call(this, lineNumber);
    };
    const getAdditionSyntax = (lineNumber) => {
        return __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getNewSyntaxLine).call(this, lineNumber);
    };
    const getDeletionSyntax = (lineNumber) => {
        return __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_getOldSyntaxLine).call(this, lineNumber);
    };
    __classPrivateFieldSet(this, _DiffFile_diffLines, [], "f");
    this.additionLength = 0;
    this.deletionLength = 0;
    const tmp = [];
    __classPrivateFieldGet(this, _DiffFile_diffListResults, "f").forEach((item) => {
        const hunks = item.hunks;
        hunks.forEach((hunk) => {
            let additions = [];
            let deletions = [];
            hunk.lines.forEach((line) => {
                if (line.type === DiffLineType.Add) {
                    additions.push(line);
                    this.additionLength++;
                }
                else if (line.type === DiffLineType.Delete) {
                    deletions.push(line);
                    this.deletionLength++;
                }
                else {
                    getDiffRange(additions, deletions, {
                        getAdditionRaw,
                        getDeletionRaw,
                        getAdditionSyntax,
                        getDeletionSyntax,
                    });
                    additions = [];
                    deletions = [];
                }
                tmp.push(line);
            });
            getDiffRange(additions, deletions, { getAdditionRaw, getDeletionRaw, getAdditionSyntax, getDeletionSyntax });
        });
    });
    let prevHunkLine = null;
    __classPrivateFieldSet(this, _DiffFile_diffLines, tmp.map((i, index) => {
        var _a;
        const typedI = i;
        typedI.index = index;
        typedI.isFirst = index === 0;
        if (typedI.type === DiffLineType.Hunk) {
            const numInfo = (_a = typedI.text.split("@@")) === null || _a === void 0 ? void 0 : _a[1].split(" ").filter(Boolean);
            const oldNumInfo = (numInfo === null || numInfo === void 0 ? void 0 : numInfo[0]) || "";
            const newNumInfo = (numInfo === null || numInfo === void 0 ? void 0 : numInfo[1]) || "";
            const [oldNumStartIndex, oldNumLength] = oldNumInfo.split(",");
            const [newNumStartIndex, newNumLength] = newNumInfo.split(",");
            typedI.hunkInfo = {
                oldStartIndex: -Number(oldNumStartIndex),
                oldLength: Number(oldNumLength),
                newStartIndex: +Number(newNumStartIndex),
                newLength: Number(newNumLength),
                _oldStartIndex: -Number(oldNumStartIndex),
                _oldLength: Number(oldNumLength),
                _newStartIndex: +Number(newNumStartIndex),
                _newLength: Number(newNumLength),
            };
            if (process.env.NODE_ENV === "development" &&
                typedI.isFirst &&
                typedI.hunkInfo.oldStartIndex &&
                typedI.hunkInfo.newStartIndex &&
                typedI.hunkInfo.oldStartIndex !== typedI.hunkInfo.newStartIndex) {
                console.warn("the first hunk should start with the same line number");
            }
            prevHunkLine = typedI;
        }
        else if (typedI.type === DiffLineType.Context) {
            const typedItem = i;
            if (prevHunkLine) {
                typedItem.prevHunkLine = prevHunkLine;
                prevHunkLine = null;
            }
        }
        else {
            prevHunkLine = null;
        }
        return typedI;
    }), "f");
    __classPrivateFieldSet(this, _DiffFile_oldFileDiffLines, {}, "f");
    __classPrivateFieldSet(this, _DiffFile_newFileDiffLines, {}, "f");
    let maxOldLineNumber = -1;
    let maxNewLineNumber = -1;
    __classPrivateFieldGet(this, _DiffFile_diffLines, "f").forEach((item) => {
        if (item.oldLineNumber) {
            this.diffLineLength = Math.max(this.diffLineLength, item.oldLineNumber);
            __classPrivateFieldGet(this, _DiffFile_oldFileDiffLines, "f")[item.oldLineNumber] = item;
            if (process.env.NODE_ENV === "development") {
                if (item.oldLineNumber <= maxOldLineNumber) {
                    console.warn('the "lineNumber" from "diff" should be in ascending order, maybe current "diff" string is not a valid "diff" string');
                }
                maxOldLineNumber = Math.max(maxOldLineNumber, item.oldLineNumber);
            }
        }
        if (item.newLineNumber) {
            this.diffLineLength = Math.max(this.diffLineLength, item.newLineNumber);
            __classPrivateFieldGet(this, _DiffFile_newFileDiffLines, "f")[item.newLineNumber] = item;
            if (process.env.NODE_ENV === "development") {
                if (item.newLineNumber <= maxNewLineNumber) {
                    console.warn('the "lineNumber" from "diff" should be in ascending order, maybe current "diff" string is not a valid "diff" string');
                }
                maxNewLineNumber = Math.max(maxNewLineNumber, item.newLineNumber);
            }
        }
    });
}, _DiffFile_composeSyntax = function _DiffFile_composeSyntax({ registerHighlighter }) {
    var _a, _b, _c, _d;
    (_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.doSyntax({ registerHighlighter, theme: __classPrivateFieldGet(this, _DiffFile_theme, "f") });
    __classPrivateFieldSet(this, _DiffFile_oldFileSyntaxLines, (_b = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _b === void 0 ? void 0 : _b.syntaxFile, "f");
    (_c = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _c === void 0 ? void 0 : _c.doSyntax({ registerHighlighter, theme: __classPrivateFieldGet(this, _DiffFile_theme, "f") });
    __classPrivateFieldSet(this, _DiffFile_newFileSyntaxLines, (_d = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _d === void 0 ? void 0 : _d.syntaxFile, "f");
}, _DiffFile_doSyntax = function _DiffFile_doSyntax({ registerHighlighter } = {}) {
    var _a, _b, _c, _d;
    if (__classPrivateFieldGet(this, _DiffFile_highlighterType, "f") === "class")
        return;
    if (__classPrivateFieldGet(this, _DiffFile_composeByMerge, "f") && !__classPrivateFieldGet(this, _DiffFile_composeByFullMerge, "f")) {
        if (process.env.NODE_ENV === "development") {
            console.error(`this instance can not do syntax because of the data missing, try to use '_getFullBundle' & '_mergeFullBundle' instead of 'getBundle' & 'mergeBundle'`);
        }
        return;
    }
    __classPrivateFieldGet(this, _DiffFile_instances, "m", _DiffFile_composeSyntax).call(this, { registerHighlighter });
    __classPrivateFieldSet(this, _DiffFile_highlighterName, ((_a = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _a === void 0 ? void 0 : _a.highlighterName) || ((_b = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _b === void 0 ? void 0 : _b.highlighterName) || __classPrivateFieldGet(this, _DiffFile_highlighterName, "f"), "f");
    __classPrivateFieldSet(this, _DiffFile_highlighterType, ((_c = __classPrivateFieldGet(this, _DiffFile_oldFileResult, "f")) === null || _c === void 0 ? void 0 : _c.highlighterType) || ((_d = __classPrivateFieldGet(this, _DiffFile_newFileResult, "f")) === null || _d === void 0 ? void 0 : _d.highlighterType) || __classPrivateFieldGet(this, _DiffFile_highlighterType, "f"), "f");
}, _DiffFile_getOldDiffLine = function _DiffFile_getOldDiffLine(lineNumber) {
    var _a;
    if (!lineNumber)
        return;
    return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileDiffLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getNewDiffLine = function _DiffFile_getNewDiffLine(lineNumber) {
    var _a;
    if (!lineNumber)
        return;
    return (_a = __classPrivateFieldGet(this, _DiffFile_newFileDiffLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getOldRawLine = function _DiffFile_getOldRawLine(lineNumber) {
    var _a;
    return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getNewRawLine = function _DiffFile_getNewRawLine(lineNumber) {
    var _a;
    return (_a = __classPrivateFieldGet(this, _DiffFile_newFileLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getOldSyntaxLine = function _DiffFile_getOldSyntaxLine(lineNumber) {
    var _a;
    return (_a = __classPrivateFieldGet(this, _DiffFile_oldFileSyntaxLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
}, _DiffFile_getNewSyntaxLine = function _DiffFile_getNewSyntaxLine(lineNumber) {
    var _a;
    return (_a = __classPrivateFieldGet(this, _DiffFile_newFileSyntaxLines, "f")) === null || _a === void 0 ? void 0 : _a[lineNumber];
};
if (process.env.NODE_ENV === "development") {
    Object.defineProperty(DiffFile.prototype, "__full_bundle__", {
        get: function () {
            return this._getFullBundle();
        },
    });
}

var DiffFileLineType;
(function (DiffFileLineType) {
    DiffFileLineType[DiffFileLineType["hunk"] = 1] = "hunk";
    DiffFileLineType[DiffFileLineType["content"] = 2] = "content";
    DiffFileLineType[DiffFileLineType["widget"] = 3] = "widget";
    DiffFileLineType[DiffFileLineType["extend"] = 4] = "extend";
})(DiffFileLineType || (DiffFileLineType = {}));
var SplitSide;
(function (SplitSide) {
    SplitSide[SplitSide["old"] = 1] = "old";
    SplitSide[SplitSide["new"] = 2] = "new";
})(SplitSide || (SplitSide = {}));
const getSplitLines = (diffFile) => {
    const splitLineLength = diffFile.splitLineLength;
    const splitLines = [];
    numIterator(splitLineLength, (index) => {
        splitLines.push({ type: DiffFileLineType.hunk, index, lineNumber: index + 1 });
        splitLines.push({
            type: DiffFileLineType.content,
            index,
            lineNumber: index + 1,
        });
        splitLines.push({ type: DiffFileLineType.widget, index, lineNumber: index + 1 });
        splitLines.push({ type: DiffFileLineType.extend, index, lineNumber: index + 1 });
    });
    return splitLines;
};
const getSplitContentLines = (diffFile) => {
    const splitLineLength = diffFile.splitLineLength;
    const splitLines = [];
    numIterator(splitLineLength, (index) => {
        const splitLeftLine = diffFile.getSplitLeftLine(index);
        const splitRightLine = diffFile.getSplitRightLine(index);
        if (!(splitLeftLine === null || splitLeftLine === void 0 ? void 0 : splitLeftLine.isHidden) && !(splitRightLine === null || splitRightLine === void 0 ? void 0 : splitRightLine.isHidden)) {
            {
                splitLines.push({
                    type: DiffFileLineType.content,
                    index,
                    lineNumber: index + 1,
                    splitLine: { left: splitLeftLine, right: splitRightLine },
                });
            }
        }
    });
    return splitLines;
};
const getUnifiedLines = (diffFile) => {
    const unifiedLineLength = diffFile.unifiedLineLength;
    const unifiedLines = [];
    numIterator(unifiedLineLength, (index) => {
        unifiedLines.push({ type: DiffFileLineType.hunk, index, lineNumber: index + 1 });
        unifiedLines.push({ type: DiffFileLineType.content, index, lineNumber: index + 1 });
        unifiedLines.push({ type: DiffFileLineType.widget, index, lineNumber: index + 1 });
        unifiedLines.push({ type: DiffFileLineType.extend, index, lineNumber: index + 1 });
    });
    return unifiedLines;
};
const getUnifiedContentLine = (diffFile) => {
    const unifiedLineLength = diffFile.unifiedLineLength;
    const unifiedLines = [];
    numIterator(unifiedLineLength, (index) => {
        const unifiedLine = diffFile.getUnifiedLine(index);
        if (!unifiedLine.isHidden) {
            unifiedLines.push({ type: DiffFileLineType.content, index, lineNumber: index + 1, unifiedLine: unifiedLine });
        }
    });
    return unifiedLines;
};
const checkCurrentLineIsHidden = (diffFile, lineNumber, side) => {
    const splitLine = diffFile.getSplitLineByLineNumber(lineNumber, side);
    const unifiedLine = diffFile.getUnifiedLineByLineNumber(lineNumber, side);
    return {
        split: !splitLine || splitLine.isHidden,
        unified: !unifiedLine || unifiedLine.isHidden,
    };
};

const versions = "0.0.30";

export { DefaultDiffExpansionStep, DiffFile, DiffFileLineType, DiffHunk, DiffHunkExpansionType, DiffHunkHeader, DiffLine, DiffLineType, DiffParser, File, HiddenBidiCharsRegex, SplitSide, _cacheMap, assertNever, changeDefaultComposeLength, checkCurrentLineIsHidden, checkDiffLineIncludeChange, composeLen, diffChanges, disableCache, escapeHtml, getCurrentComposeLength, getDiffRange, getFile, getHunkHeaderExpansionType, getLang, getLargestLineNumber, getPlainDiffTemplate, getPlainLineTemplate, getSplitContentLines, getSplitLines, getSyntaxDiffTemplate, getSyntaxLineTemplate, getUnifiedContentLine, getUnifiedLines, isTransformEnabled, numIterator, parseInstance, processTransformForFile, processTransformTemplateContent, relativeChanges, resetDefaultComposeLength, resetTransform, setTransformForFile, setTransformForTemplateContent, versions };
//# sourceMappingURL=index.mjs.map
