"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  RichDescription: () => RichDescription,
  RichHelp: () => RichHelp,
  default: () => index_default,
  getDefaultRegistry: () => getDefaultRegistry,
  getTestRegistry: () => getTestRegistry,
  withTheme: () => withTheme
});
module.exports = __toCommonJS(index_exports);

// src/components/Form.tsx
var import_react21 = require("react");
var import_utils49 = require("@rjsf/utils");
var import_cloneDeep2 = __toESM(require("lodash/cloneDeep"), 1);
var import_get5 = __toESM(require("lodash/get"), 1);
var import_isEmpty4 = __toESM(require("lodash/isEmpty"), 1);
var import_pick = __toESM(require("lodash/pick"), 1);
var import_set5 = __toESM(require("lodash/set"), 1);
var import_toPath = __toESM(require("lodash/toPath"), 1);
var import_unset = __toESM(require("lodash/unset"), 1);

// src/getDefaultRegistry.ts
var import_utils48 = require("@rjsf/utils");

// src/components/fields/ArrayField.tsx
var import_react = require("react");
var import_utils = require("@rjsf/utils");
var import_cloneDeep = __toESM(require("lodash/cloneDeep"), 1);
var import_isObject = __toESM(require("lodash/isObject"), 1);
var import_set = __toESM(require("lodash/set"), 1);
var import_uniqueId = __toESM(require("lodash/uniqueId"), 1);
var import_jsx_runtime = require("react/jsx-runtime");
function generateRowId() {
  return (0, import_uniqueId.default)("rjsf-array-item-");
}
function generateKeyedFormData(formData) {
  return !Array.isArray(formData) ? [] : formData.map((item) => {
    return {
      key: generateRowId(),
      item
    };
  });
}
function keyedToPlainFormData(keyedFormData) {
  if (Array.isArray(keyedFormData)) {
    return keyedFormData.map((keyedItem) => keyedItem.item);
  }
  return [];
}
function isItemRequired(itemSchema) {
  if (Array.isArray(itemSchema.type)) {
    return !itemSchema.type.includes("null");
  }
  return itemSchema.type !== "null";
}
function canAddItem(registry, schema, formItems, uiSchema) {
  let { addable } = (0, import_utils.getUiOptions)(uiSchema, registry.globalUiOptions);
  if (addable !== false) {
    if (schema.maxItems !== void 0) {
      addable = formItems.length < schema.maxItems;
    } else {
      addable = true;
    }
  }
  return addable;
}
function computeItemUiSchema(uiSchema, item, index, formContext) {
  if (typeof uiSchema.items === "function") {
    try {
      const result = uiSchema.items(item, index, formContext);
      return result;
    } catch (e) {
      console.error(`Error executing dynamic uiSchema.items function for item at index ${index}:`, e);
      return void 0;
    }
  } else {
    return uiSchema.items;
  }
}
function getNewFormDataRow(registry, schema) {
  const { schemaUtils, globalFormOptions } = registry;
  let itemSchema = schema.items;
  if (globalFormOptions.useFallbackUiForUnsupportedType && !itemSchema) {
    itemSchema = {};
  } else if ((0, import_utils.isFixedItems)(schema) && (0, import_utils.allowAdditionalItems)(schema)) {
    itemSchema = schema.additionalItems;
  }
  return schemaUtils.getDefaultFormState(itemSchema);
}
function ArrayAsMultiSelect(props) {
  const {
    schema,
    fieldPathId,
    uiSchema,
    formData: items = [],
    disabled = false,
    readonly = false,
    autofocus = false,
    required = false,
    placeholder,
    onBlur,
    onFocus,
    registry,
    rawErrors,
    name,
    onSelectChange
  } = props;
  const { widgets: widgets2, schemaUtils, globalFormOptions, globalUiOptions } = registry;
  const itemsSchema = schemaUtils.retrieveSchema(schema.items, items);
  const enumOptions = (0, import_utils.optionsList)(itemsSchema, uiSchema);
  const { widget = "select", title: uiTitle, ...options } = (0, import_utils.getUiOptions)(uiSchema, globalUiOptions);
  const Widget = (0, import_utils.getWidget)(schema, widget, widgets2);
  const label = uiTitle ?? schema.title ?? name;
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const multiValueFieldPathId = (0, import_utils.useDeepCompareMemo)((0, import_utils.toFieldPathId)("", globalFormOptions, fieldPathId, true));
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    Widget,
    {
      id: multiValueFieldPathId[import_utils.ID_KEY],
      name,
      multiple: true,
      onChange: onSelectChange,
      onBlur,
      onFocus,
      options: { ...options, enumOptions },
      schema,
      uiSchema,
      registry,
      value: items,
      disabled,
      readonly,
      required,
      label,
      hideLabel: !displayLabel,
      placeholder,
      autofocus,
      rawErrors,
      htmlName: multiValueFieldPathId.name
    }
  );
}
function ArrayAsCustomWidget(props) {
  const {
    schema,
    fieldPathId,
    uiSchema,
    disabled = false,
    readonly = false,
    autofocus = false,
    required = false,
    hideError,
    placeholder,
    onBlur,
    onFocus,
    formData: items = [],
    registry,
    rawErrors,
    name,
    onSelectChange
  } = props;
  const { widgets: widgets2, schemaUtils, globalFormOptions, globalUiOptions } = registry;
  const { widget, title: uiTitle, ...options } = (0, import_utils.getUiOptions)(uiSchema, globalUiOptions);
  const Widget = (0, import_utils.getWidget)(schema, widget, widgets2);
  const label = uiTitle ?? schema.title ?? name;
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const multiValueFieldPathId = (0, import_utils.useDeepCompareMemo)((0, import_utils.toFieldPathId)("", globalFormOptions, fieldPathId, true));
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    Widget,
    {
      id: multiValueFieldPathId[import_utils.ID_KEY],
      name,
      multiple: true,
      onChange: onSelectChange,
      onBlur,
      onFocus,
      options,
      schema,
      uiSchema,
      registry,
      value: items,
      disabled,
      readonly,
      hideError,
      required,
      label,
      hideLabel: !displayLabel,
      placeholder,
      autofocus,
      rawErrors,
      htmlName: multiValueFieldPathId.name
    }
  );
}
function ArrayAsFiles(props) {
  const {
    schema,
    uiSchema,
    fieldPathId,
    name,
    disabled = false,
    readonly = false,
    autofocus = false,
    required = false,
    onBlur,
    onFocus,
    registry,
    formData: items = [],
    rawErrors,
    onSelectChange
  } = props;
  const { widgets: widgets2, schemaUtils, globalFormOptions, globalUiOptions } = registry;
  const { widget = "files", title: uiTitle, ...options } = (0, import_utils.getUiOptions)(uiSchema, globalUiOptions);
  const Widget = (0, import_utils.getWidget)(schema, widget, widgets2);
  const label = uiTitle ?? schema.title ?? name;
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const multiValueFieldPathId = (0, import_utils.useDeepCompareMemo)((0, import_utils.toFieldPathId)("", globalFormOptions, fieldPathId, true));
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    Widget,
    {
      options,
      id: multiValueFieldPathId[import_utils.ID_KEY],
      name,
      multiple: true,
      onChange: onSelectChange,
      onBlur,
      onFocus,
      schema,
      uiSchema,
      value: items,
      disabled,
      readonly,
      required,
      registry,
      autofocus,
      rawErrors,
      label,
      hideLabel: !displayLabel,
      htmlName: multiValueFieldPathId.name
    }
  );
}
function ArrayFieldItem(props) {
  const {
    itemKey,
    index,
    name,
    disabled,
    hideError,
    readonly,
    registry,
    uiOptions,
    parentUiSchema,
    canAdd,
    canRemove = true,
    canMoveUp,
    canMoveDown,
    itemSchema,
    itemData,
    itemUiSchema,
    itemFieldPathId,
    itemErrorSchema,
    autofocus,
    onBlur,
    onFocus,
    onChange,
    rawErrors,
    totalItems,
    title,
    handleAddItem,
    handleCopyItem,
    handleRemoveItem,
    handleReorderItems
  } = props;
  const {
    schemaUtils,
    fields: { ArraySchemaField, SchemaField: SchemaField2 },
    globalUiOptions
  } = registry;
  const fieldPathId = (0, import_utils.useDeepCompareMemo)(itemFieldPathId);
  const ItemSchemaField = ArraySchemaField || SchemaField2;
  const ArrayFieldItemTemplate2 = (0, import_utils.getTemplate)(
    "ArrayFieldItemTemplate",
    registry,
    uiOptions
  );
  const displayLabel = schemaUtils.getDisplayLabel(itemSchema, itemUiSchema, globalUiOptions);
  const { description } = (0, import_utils.getUiOptions)(itemUiSchema);
  const hasDescription = !!description || !!itemSchema.description;
  const { orderable = true, removable = true, copyable = false } = uiOptions;
  const has4 = {
    moveUp: orderable && canMoveUp,
    moveDown: orderable && canMoveDown,
    copy: copyable && canAdd,
    remove: removable && canRemove,
    toolbar: false
  };
  has4.toolbar = Object.keys(has4).some((key) => has4[key]);
  const onAddItem = (0, import_react.useCallback)(
    (event) => {
      handleAddItem(event, index + 1);
    },
    [handleAddItem, index]
  );
  const onCopyItem = (0, import_react.useCallback)(
    (event) => {
      handleCopyItem(event, index);
    },
    [handleCopyItem, index]
  );
  const onRemoveItem = (0, import_react.useCallback)(
    (event) => {
      handleRemoveItem(event, index);
    },
    [handleRemoveItem, index]
  );
  const onMoveUpItem = (0, import_react.useCallback)(
    (event) => {
      handleReorderItems(event, index, index - 1);
    },
    [handleReorderItems, index]
  );
  const onMoveDownItem = (0, import_react.useCallback)(
    (event) => {
      handleReorderItems(event, index, index + 1);
    },
    [handleReorderItems, index]
  );
  const templateProps = {
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      ItemSchemaField,
      {
        name,
        title,
        index,
        schema: itemSchema,
        uiSchema: itemUiSchema,
        formData: itemData,
        errorSchema: itemErrorSchema,
        fieldPathId,
        required: isItemRequired(itemSchema),
        onChange,
        onBlur,
        onFocus,
        registry,
        disabled,
        readonly,
        hideError,
        autofocus,
        rawErrors
      }
    ),
    buttonsProps: {
      fieldPathId,
      disabled,
      readonly,
      canAdd,
      hasCopy: has4.copy,
      hasMoveUp: has4.moveUp,
      hasMoveDown: has4.moveDown,
      hasRemove: has4.remove,
      index,
      totalItems,
      onAddItem,
      onCopyItem,
      onRemoveItem,
      onMoveUpItem,
      onMoveDownItem,
      registry,
      schema: itemSchema,
      uiSchema: itemUiSchema
    },
    itemKey,
    className: "rjsf-array-item",
    disabled,
    hasToolbar: has4.toolbar,
    index,
    totalItems,
    readonly,
    registry,
    schema: itemSchema,
    uiSchema: itemUiSchema,
    parentUiSchema,
    displayLabel,
    hasDescription
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrayFieldItemTemplate2, { ...templateProps });
}
function NormalArray(props) {
  const {
    schema,
    uiSchema = {},
    errorSchema,
    fieldPathId,
    formData: formDataFromProps,
    name,
    title,
    disabled = false,
    readonly = false,
    autofocus = false,
    required = false,
    hideError = false,
    registry,
    onBlur,
    onFocus,
    rawErrors,
    onChange,
    keyedFormData,
    handleAddItem,
    handleCopyItem,
    handleRemoveItem,
    handleReorderItems
  } = props;
  const fieldTitle = schema.title || title || name;
  const { schemaUtils, fields: fields2, formContext, globalFormOptions, globalUiOptions } = registry;
  const { OptionalDataControlsField: OptionalDataControlsField2 } = fields2;
  const uiOptions = (0, import_utils.getUiOptions)(uiSchema, globalUiOptions);
  const _schemaItems = (0, import_isObject.default)(schema.items) ? schema.items : {};
  const itemsSchema = schemaUtils.retrieveSchema(_schemaItems);
  const formData = keyedToPlainFormData(keyedFormData);
  const renderOptionalField = (0, import_utils.shouldRenderOptionalField)(registry, schema, required, uiSchema);
  const hasFormData = (0, import_utils.isFormDataAvailable)(formDataFromProps);
  const canAdd = canAddItem(registry, schema, formData, uiSchema) && (!renderOptionalField || hasFormData);
  const actualFormData = hasFormData ? keyedFormData : [];
  const extraClass = renderOptionalField ? " rjsf-optional-array-field" : "";
  const childFieldPathId = props.childFieldPathId ?? fieldPathId;
  const optionalDataControl = renderOptionalField ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalDataControlsField2, { ...props, fieldPathId: childFieldPathId }) : void 0;
  const arrayProps = {
    canAdd,
    items: actualFormData.map((keyedItem, index) => {
      const { key, item } = keyedItem;
      const itemCast = item;
      const itemSchema = schemaUtils.retrieveSchema(_schemaItems, itemCast);
      const itemErrorSchema = errorSchema ? errorSchema[index] : void 0;
      const itemFieldPathId = (0, import_utils.toFieldPathId)(index, globalFormOptions, childFieldPathId);
      const itemUiSchema = computeItemUiSchema(uiSchema, item, index, formContext);
      const itemProps = {
        itemKey: key,
        index,
        name: name && `${name}-${index}`,
        registry,
        uiOptions,
        hideError,
        readonly,
        disabled,
        required,
        title: fieldTitle ? `${fieldTitle}-${index + 1}` : void 0,
        canAdd,
        canMoveUp: index > 0,
        canMoveDown: index < formData.length - 1,
        itemSchema,
        itemFieldPathId,
        itemErrorSchema,
        itemData: itemCast,
        itemUiSchema,
        autofocus: autofocus && index === 0,
        onBlur,
        onFocus,
        rawErrors,
        totalItems: keyedFormData.length,
        handleAddItem,
        handleCopyItem,
        handleRemoveItem,
        handleReorderItems,
        onChange
      };
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrayFieldItem, { ...itemProps }, key);
    }),
    className: `rjsf-field rjsf-field-array rjsf-field-array-of-${itemsSchema.type}${extraClass}`,
    disabled,
    fieldPathId,
    uiSchema,
    onAddClick: handleAddItem,
    readonly,
    required,
    schema,
    title: fieldTitle,
    formData,
    rawErrors,
    registry,
    optionalDataControl
  };
  const Template = (0, import_utils.getTemplate)("ArrayFieldTemplate", registry, uiOptions);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Template, { ...arrayProps });
}
function FixedArray(props) {
  const {
    schema,
    uiSchema = {},
    formData,
    errorSchema,
    fieldPathId,
    name,
    title,
    disabled = false,
    readonly = false,
    autofocus = false,
    required = false,
    hideError = false,
    registry,
    onBlur,
    onFocus,
    rawErrors,
    keyedFormData,
    onChange,
    handleAddItem,
    handleCopyItem,
    handleRemoveItem,
    handleReorderItems
  } = props;
  let { formData: items = [] } = props;
  const fieldTitle = schema.title || title || name;
  const { schemaUtils, fields: fields2, formContext, globalFormOptions, globalUiOptions } = registry;
  const uiOptions = (0, import_utils.getUiOptions)(uiSchema, globalUiOptions);
  const { OptionalDataControlsField: OptionalDataControlsField2 } = fields2;
  const renderOptionalField = (0, import_utils.shouldRenderOptionalField)(registry, schema, required, uiSchema);
  const hasFormData = (0, import_utils.isFormDataAvailable)(formData);
  const _schemaItems = (0, import_isObject.default)(schema.items) ? schema.items : [];
  const itemSchemas = _schemaItems.map(
    (item, index) => schemaUtils.retrieveSchema(item, items[index])
  );
  const additionalSchema = (0, import_isObject.default)(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, formData) : null;
  const childFieldPathId = props.childFieldPathId ?? fieldPathId;
  if (items.length < itemSchemas.length) {
    items = items.concat(new Array(itemSchemas.length - items.length));
  }
  const actualFormData = hasFormData ? keyedFormData : [];
  const extraClass = renderOptionalField ? " rjsf-optional-array-field" : "";
  const optionalDataControl = renderOptionalField ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalDataControlsField2, { ...props, fieldPathId: childFieldPathId }) : void 0;
  const canAdd = canAddItem(registry, schema, items, uiSchema) && !!additionalSchema && (!renderOptionalField || hasFormData);
  const arrayProps = {
    canAdd,
    className: `rjsf-field rjsf-field-array rjsf-field-array-fixed-items${extraClass}`,
    disabled,
    fieldPathId,
    formData,
    items: actualFormData.map((keyedItem, index) => {
      const { key, item } = keyedItem;
      const itemCast = item;
      const additional = index >= itemSchemas.length;
      const itemSchema = (additional && (0, import_isObject.default)(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, itemCast) : itemSchemas[index]) || {};
      const itemFieldPathId = (0, import_utils.toFieldPathId)(index, globalFormOptions, childFieldPathId);
      let itemUiSchema;
      if (additional) {
        itemUiSchema = uiSchema.additionalItems;
      } else {
        if (Array.isArray(uiSchema.items)) {
          itemUiSchema = uiSchema.items[index];
        } else {
          itemUiSchema = computeItemUiSchema(uiSchema, item, index, formContext);
        }
      }
      const itemErrorSchema = errorSchema ? errorSchema[index] : void 0;
      const itemProps = {
        index,
        itemKey: key,
        name: name && `${name}-${index}`,
        registry,
        uiOptions,
        hideError,
        readonly,
        disabled,
        required,
        title: fieldTitle ? `${fieldTitle}-${index + 1}` : void 0,
        canAdd,
        canRemove: additional,
        canMoveUp: index >= itemSchemas.length + 1,
        canMoveDown: additional && index < items.length - 1,
        itemSchema,
        itemData: itemCast,
        itemUiSchema,
        itemFieldPathId,
        itemErrorSchema,
        autofocus: autofocus && index === 0,
        onBlur,
        onFocus,
        rawErrors,
        totalItems: keyedFormData.length,
        onChange,
        handleAddItem,
        handleCopyItem,
        handleRemoveItem,
        handleReorderItems
      };
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrayFieldItem, { ...itemProps }, key);
    }),
    onAddClick: handleAddItem,
    readonly,
    required,
    registry,
    schema,
    uiSchema,
    title: fieldTitle,
    errorSchema,
    rawErrors,
    optionalDataControl
  };
  const Template = (0, import_utils.getTemplate)("ArrayFieldTemplate", registry, uiOptions);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Template, { ...arrayProps });
}
function useKeyedFormData(formData = []) {
  const newHash = (0, import_react.useMemo)(() => (0, import_utils.hashObject)(formData), [formData]);
  const [state, setState] = (0, import_react.useState)(() => ({
    formDataHash: newHash,
    keyedFormData: generateKeyedFormData(formData)
  }));
  let { keyedFormData, formDataHash } = state;
  if (newHash !== formDataHash) {
    const nextFormData = Array.isArray(formData) ? formData : [];
    const previousKeyedFormData = keyedFormData || [];
    keyedFormData = nextFormData.length === previousKeyedFormData.length ? previousKeyedFormData.map((previousKeyedFormDatum, index) => ({
      key: previousKeyedFormDatum.key,
      item: nextFormData[index]
    })) : generateKeyedFormData(nextFormData);
    formDataHash = newHash;
    setState({ formDataHash, keyedFormData });
  }
  const updateKeyedFormData = (0, import_react.useCallback)((newData) => {
    const plainFormData = keyedToPlainFormData(newData);
    const newHash2 = (0, import_utils.hashObject)(plainFormData);
    setState({ formDataHash: newHash2, keyedFormData: newData });
    return plainFormData;
  }, []);
  return { keyedFormData, updateKeyedFormData };
}
function ArrayField(props) {
  const { schema, uiSchema, errorSchema, fieldPathId, registry, formData, onChange } = props;
  const { globalFormOptions, schemaUtils, translateString } = registry;
  const { keyedFormData, updateKeyedFormData } = useKeyedFormData(formData);
  const childFieldPathId = props.childFieldPathId ?? fieldPathId;
  const handleAddItem = (0, import_react.useCallback)(
    (event, index) => {
      if (event) {
        event.preventDefault();
      }
      let newErrorSchema;
      if (errorSchema) {
        newErrorSchema = {};
        for (const idx in errorSchema) {
          const i = parseInt(idx);
          if (index === void 0 || i < index) {
            (0, import_set.default)(newErrorSchema, [i], errorSchema[idx]);
          } else if (i >= index) {
            (0, import_set.default)(newErrorSchema, [i + 1], errorSchema[idx]);
          }
        }
      }
      const newKeyedFormDataRow = {
        key: generateRowId(),
        item: getNewFormDataRow(registry, schema)
      };
      const newKeyedFormData = [...keyedFormData];
      if (index !== void 0) {
        newKeyedFormData.splice(index, 0, newKeyedFormDataRow);
      } else {
        newKeyedFormData.push(newKeyedFormDataRow);
      }
      onChange(updateKeyedFormData(newKeyedFormData), childFieldPathId.path, newErrorSchema);
    },
    [keyedFormData, registry, schema, onChange, updateKeyedFormData, errorSchema, childFieldPathId]
  );
  const handleCopyItem = (0, import_react.useCallback)(
    (event, index) => {
      if (event) {
        event.preventDefault();
      }
      let newErrorSchema;
      if (errorSchema) {
        newErrorSchema = {};
        for (const idx in errorSchema) {
          const i = parseInt(idx);
          if (i <= index) {
            (0, import_set.default)(newErrorSchema, [i], errorSchema[idx]);
          } else if (i > index) {
            (0, import_set.default)(newErrorSchema, [i + 1], errorSchema[idx]);
          }
        }
      }
      const newKeyedFormDataRow = {
        key: generateRowId(),
        item: (0, import_cloneDeep.default)(keyedFormData[index].item)
      };
      const newKeyedFormData = [...keyedFormData];
      if (index !== void 0) {
        newKeyedFormData.splice(index + 1, 0, newKeyedFormDataRow);
      } else {
        newKeyedFormData.push(newKeyedFormDataRow);
      }
      onChange(updateKeyedFormData(newKeyedFormData), childFieldPathId.path, newErrorSchema);
    },
    [keyedFormData, onChange, updateKeyedFormData, errorSchema, childFieldPathId]
  );
  const handleRemoveItem = (0, import_react.useCallback)(
    (event, index) => {
      if (event) {
        event.preventDefault();
      }
      let newErrorSchema;
      if (errorSchema) {
        newErrorSchema = {};
        for (const idx in errorSchema) {
          const i = parseInt(idx);
          if (i < index) {
            (0, import_set.default)(newErrorSchema, [i], errorSchema[idx]);
          } else if (i > index) {
            (0, import_set.default)(newErrorSchema, [i - 1], errorSchema[idx]);
          }
        }
      }
      const newKeyedFormData = keyedFormData.filter((_, i) => i !== index);
      onChange(updateKeyedFormData(newKeyedFormData), childFieldPathId.path, newErrorSchema);
    },
    [keyedFormData, onChange, updateKeyedFormData, errorSchema, childFieldPathId]
  );
  const handleReorderItems = (0, import_react.useCallback)(
    (event, index, newIndex) => {
      if (event) {
        event.preventDefault();
        event.currentTarget.blur();
      }
      let newErrorSchema;
      if (errorSchema) {
        newErrorSchema = {};
        for (const idx in errorSchema) {
          const i = parseInt(idx);
          if (i == index) {
            (0, import_set.default)(newErrorSchema, [newIndex], errorSchema[index]);
          } else if (i == newIndex) {
            (0, import_set.default)(newErrorSchema, [index], errorSchema[newIndex]);
          } else {
            (0, import_set.default)(newErrorSchema, [idx], errorSchema[i]);
          }
        }
      }
      function reOrderArray() {
        const _newKeyedFormData = keyedFormData.slice();
        _newKeyedFormData.splice(index, 1);
        _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);
        return _newKeyedFormData;
      }
      const newKeyedFormData = reOrderArray();
      onChange(updateKeyedFormData(newKeyedFormData), childFieldPathId.path, newErrorSchema);
    },
    [keyedFormData, onChange, updateKeyedFormData, errorSchema, childFieldPathId]
  );
  const handleChange = (0, import_react.useCallback)(
    (value, path, newErrorSchema, id) => {
      onChange(
        // We need to treat undefined items as nulls to have validation.
        // See https://github.com/tdegrunt/jsonschema/issues/206
        value === void 0 ? null : value,
        path,
        newErrorSchema,
        id
      );
    },
    [onChange]
  );
  const onSelectChange = (0, import_react.useCallback)(
    (value) => {
      onChange(value, childFieldPathId.path, void 0, childFieldPathId?.[import_utils.ID_KEY]);
    },
    [onChange, childFieldPathId]
  );
  const arrayAsMultiProps = {
    ...props,
    formData,
    fieldPathId: childFieldPathId,
    onSelectChange
  };
  const arrayProps = {
    ...props,
    handleAddItem,
    handleCopyItem,
    handleRemoveItem,
    handleReorderItems,
    keyedFormData,
    onChange: handleChange
  };
  if (!(import_utils.ITEMS_KEY in schema)) {
    if (!globalFormOptions.useFallbackUiForUnsupportedType) {
      const uiOptions = (0, import_utils.getUiOptions)(uiSchema);
      const UnsupportedFieldTemplate = (0, import_utils.getTemplate)(
        "UnsupportedFieldTemplate",
        registry,
        uiOptions
      );
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        UnsupportedFieldTemplate,
        {
          schema,
          fieldPathId,
          reason: translateString(import_utils.TranslatableString.MissingItems),
          registry
        }
      );
    }
    const fallbackSchema = { ...schema, [import_utils.ITEMS_KEY]: { type: void 0 } };
    arrayAsMultiProps.schema = fallbackSchema;
    arrayProps.schema = fallbackSchema;
  }
  if (schemaUtils.isMultiSelect(arrayAsMultiProps.schema)) {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrayAsMultiSelect, { ...arrayAsMultiProps });
  }
  if ((0, import_utils.isCustomWidget)(uiSchema)) {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrayAsCustomWidget, { ...arrayAsMultiProps });
  }
  if ((0, import_utils.isFixedItems)(arrayAsMultiProps.schema)) {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FixedArray, { ...arrayProps });
  }
  if (schemaUtils.isFilesArray(arrayAsMultiProps.schema, uiSchema)) {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrayAsFiles, { ...arrayAsMultiProps });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NormalArray, { ...arrayProps });
}

// src/components/fields/BooleanField.tsx
var import_react2 = require("react");
var import_utils2 = require("@rjsf/utils");
var import_isObject2 = __toESM(require("lodash/isObject"), 1);
var import_jsx_runtime2 = require("react/jsx-runtime");
function BooleanField(props) {
  const {
    schema,
    name,
    uiSchema,
    fieldPathId,
    formData,
    registry,
    required,
    disabled,
    readonly,
    hideError,
    autofocus,
    title,
    onChange,
    onFocus,
    onBlur,
    rawErrors
  } = props;
  const { title: schemaTitle } = schema;
  const { widgets: widgets2, translateString, globalUiOptions } = registry;
  const {
    widget = "checkbox",
    title: uiTitle,
    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
    label: displayLabel = true,
    enumNames,
    ...options
  } = (0, import_utils2.getUiOptions)(uiSchema, globalUiOptions);
  const Widget = (0, import_utils2.getWidget)(schema, widget, widgets2);
  const yes = translateString(import_utils2.TranslatableString.YesLabel);
  const no = translateString(import_utils2.TranslatableString.NoLabel);
  let enumOptions;
  const label = uiTitle ?? schemaTitle ?? title ?? name;
  if (Array.isArray(schema.oneOf)) {
    enumOptions = (0, import_utils2.optionsList)(
      {
        oneOf: schema.oneOf.map((option) => {
          if ((0, import_isObject2.default)(option)) {
            return {
              ...option,
              title: option.title || (option.const === true ? yes : no)
            };
          }
          return void 0;
        }).filter((o) => o)
        // cast away the error that typescript can't grok is fixed
      },
      uiSchema
    );
  } else {
    const enums = schema.enum ?? [true, false];
    if (!enumNames && enums.length === 2 && enums.every((v) => typeof v === "boolean")) {
      enumOptions = [
        {
          value: enums[0],
          label: enums[0] ? yes : no
        },
        {
          value: enums[1],
          label: enums[1] ? yes : no
        }
      ];
    } else {
      enumOptions = (0, import_utils2.optionsList)({ enum: enums }, uiSchema);
    }
  }
  const onWidgetChange = (0, import_react2.useCallback)(
    (value, errorSchema, id) => {
      return onChange(value, fieldPathId.path, errorSchema, id);
    },
    [onChange, fieldPathId]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    Widget,
    {
      options: { ...options, enumOptions },
      schema,
      uiSchema,
      id: fieldPathId.$id,
      name,
      onChange: onWidgetChange,
      onFocus,
      onBlur,
      label,
      hideLabel: !displayLabel,
      value: formData,
      required,
      disabled,
      readonly,
      hideError,
      registry,
      autofocus,
      rawErrors,
      htmlName: fieldPathId.name
    }
  );
}
var BooleanField_default = BooleanField;

// src/components/fields/FallbackField.tsx
var import_utils3 = require("@rjsf/utils");
var import_react3 = require("react");
var import_jsx_runtime3 = require("react/jsx-runtime");
function getFallbackTypeSelectionSchema(title) {
  return {
    type: "string",
    enum: ["string", "number", "boolean", "object", "array"],
    default: "string",
    title
  };
}
function getTypeOfFormData(formData) {
  const dataType = typeof formData;
  if (dataType === "string" || dataType === "number" || dataType === "boolean") {
    return dataType;
  }
  if (dataType === "object") {
    return Array.isArray(formData) ? "array" : "object";
  }
  return "string";
}
function castToNewType(formData, newType) {
  switch (newType) {
    case "string":
      return String(formData);
    case "number": {
      const castedNumber = Number(formData);
      return isNaN(castedNumber) ? 0 : castedNumber;
    }
    case "boolean":
      return Boolean(formData);
    default:
      return formData;
  }
}
function FallbackField(props) {
  const {
    id,
    formData,
    displayLabel = true,
    schema,
    name,
    uiSchema,
    required,
    disabled = false,
    readonly = false,
    onBlur,
    onFocus,
    registry,
    fieldPathId,
    onChange,
    errorSchema
  } = props;
  const { translateString, fields: fields2, globalFormOptions } = registry;
  const [type, setType] = (0, import_react3.useState)(getTypeOfFormData(formData));
  const uiOptions = (0, import_utils3.getUiOptions)(uiSchema);
  const typeSelectorInnerFieldPathId = (0, import_utils3.useDeepCompareMemo)(
    (0, import_utils3.toFieldPathId)("__internal_type_selector", globalFormOptions, fieldPathId)
  );
  const schemaTitle = translateString(import_utils3.TranslatableString.Type);
  const typesOptionSchema = (0, import_react3.useMemo)(() => getFallbackTypeSelectionSchema(schemaTitle), [schemaTitle]);
  const onTypeChange = (newType) => {
    if (newType != null) {
      setType(newType);
      onChange(castToNewType(formData, newType), fieldPathId.path, errorSchema, id);
    }
  };
  if (!globalFormOptions.useFallbackUiForUnsupportedType) {
    const { reason = translateString(import_utils3.TranslatableString.UnknownFieldType, [String(schema.type)]) } = props;
    const UnsupportedFieldTemplate = (0, import_utils3.getTemplate)(
      "UnsupportedFieldTemplate",
      registry,
      uiOptions
    );
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(UnsupportedFieldTemplate, { schema, fieldPathId, reason, registry });
  }
  const FallbackFieldTemplate2 = (0, import_utils3.getTemplate)(
    "FallbackFieldTemplate",
    registry,
    uiOptions
  );
  const { SchemaField: SchemaField2 } = fields2;
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    FallbackFieldTemplate2,
    {
      schema,
      registry,
      typeSelector: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        SchemaField2,
        {
          fieldPathId: typeSelectorInnerFieldPathId,
          name: `${name}__fallback_type`,
          schema: typesOptionSchema,
          formData: type,
          onChange: onTypeChange,
          onBlur,
          onFocus,
          registry,
          hideLabel: !displayLabel,
          disabled,
          readonly,
          required
        },
        formData ? (0, import_utils3.hashObject)(formData) : "__empty__"
      ),
      schemaField: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        SchemaField2,
        {
          ...props,
          schema: {
            type,
            title: translateString(import_utils3.TranslatableString.Value),
            ...type === "object" && { additionalProperties: true }
          }
        }
      )
    }
  );
}

// src/components/fields/LayoutGridField.tsx
var import_utils4 = require("@rjsf/utils");
var import_each = __toESM(require("lodash/each"), 1);
var import_flatten = __toESM(require("lodash/flatten"), 1);
var import_get = __toESM(require("lodash/get"), 1);
var import_has = __toESM(require("lodash/has"), 1);
var import_includes = __toESM(require("lodash/includes"), 1);
var import_intersection = __toESM(require("lodash/intersection"), 1);
var import_isEmpty = __toESM(require("lodash/isEmpty"), 1);
var import_isFunction = __toESM(require("lodash/isFunction"), 1);
var import_isEqual = __toESM(require("lodash/isEqual"), 1);
var import_isObject3 = __toESM(require("lodash/isObject"), 1);
var import_isPlainObject = __toESM(require("lodash/isPlainObject"), 1);
var import_isString = __toESM(require("lodash/isString"), 1);
var import_isUndefined = __toESM(require("lodash/isUndefined"), 1);
var import_last = __toESM(require("lodash/last"), 1);
var import_set2 = __toESM(require("lodash/set"), 1);
var import_jsx_runtime4 = require("react/jsx-runtime");
var import_react4 = require("react");
var LOOKUP_REGEX = /^\$lookup=(.+)/;
var LAYOUT_GRID_UI_OPTION = "layoutGrid";
var LAYOUT_GRID_OPTION = `ui:${LAYOUT_GRID_UI_OPTION}`;
function getNonNullishValue(value, fallback) {
  return value ?? fallback;
}
function isNumericIndex(str) {
  return /^\d+?$/.test(str);
}
var LAYOUT_GRID_FIELD_TEST_IDS = (0, import_utils4.getTestIds)();
function computeFieldUiSchema(field, uiProps, uiSchema, schemaReadonly, forceReadonly) {
  const globalUiOptions = (0, import_get.default)(uiSchema, [import_utils4.UI_GLOBAL_OPTIONS_KEY], {});
  const localUiSchema = (0, import_get.default)(uiSchema, field);
  const localUiOptions = { ...(0, import_get.default)(localUiSchema, [import_utils4.UI_OPTIONS_KEY], {}), ...uiProps, ...globalUiOptions };
  const fieldUiSchema = { ...localUiSchema };
  if (!(0, import_isEmpty.default)(localUiOptions)) {
    (0, import_set2.default)(fieldUiSchema, [import_utils4.UI_OPTIONS_KEY], localUiOptions);
  }
  if (!(0, import_isEmpty.default)(globalUiOptions)) {
    (0, import_set2.default)(fieldUiSchema, [import_utils4.UI_GLOBAL_OPTIONS_KEY], globalUiOptions);
  }
  let { readonly: uiReadonly } = (0, import_utils4.getUiOptions)(fieldUiSchema);
  if (forceReadonly === true || (0, import_isUndefined.default)(uiReadonly) && schemaReadonly === true) {
    uiReadonly = true;
    if ((0, import_has.default)(localUiOptions, import_utils4.READONLY_KEY)) {
      (0, import_set2.default)(fieldUiSchema, [import_utils4.UI_OPTIONS_KEY, import_utils4.READONLY_KEY], true);
    } else {
      (0, import_set2.default)(fieldUiSchema, `ui:${import_utils4.READONLY_KEY}`, true);
    }
  }
  return { fieldUiSchema, uiReadonly };
}
function conditionMatches(operator, datum, value = "$0m3tH1nG Un3xP3cT3d") {
  const data = (0, import_flatten.default)([datum]).sort();
  const values = (0, import_flatten.default)([value]).sort();
  switch (operator) {
    case "all" /* ALL */:
      return (0, import_isEqual.default)(data, values);
    case "some" /* SOME */:
      return (0, import_intersection.default)(data, values).length > 0;
    case "none" /* NONE */:
      return (0, import_intersection.default)(data, values).length === 0;
    default:
      return false;
  }
}
function findChildrenAndProps(layoutGridSchema, schemaKey, registry) {
  let gridProps = {};
  let children = layoutGridSchema[schemaKey];
  if ((0, import_isPlainObject.default)(children)) {
    const { children: elements, className: toMapClassNames, ...otherProps } = children;
    children = elements;
    if (toMapClassNames) {
      const classes = toMapClassNames.split(" ");
      const className = classes.map((ele) => (0, import_utils4.lookupFromFormContext)(registry, ele, ele)).join(" ");
      gridProps = { ...otherProps, className };
    } else {
      gridProps = otherProps;
    }
  }
  if (!Array.isArray(children)) {
    throw new TypeError(`Expected array for "${schemaKey}" in ${JSON.stringify(layoutGridSchema)}`);
  }
  return { children, gridProps };
}
function computeArraySchemasIfPresent(schema, fieldPathId, potentialIndex) {
  let rawSchema;
  if (isNumericIndex(potentialIndex) && schema && schema?.type === "array" && (0, import_has.default)(schema, import_utils4.ITEMS_KEY)) {
    const index = Number(potentialIndex);
    const items = schema[import_utils4.ITEMS_KEY];
    if (Array.isArray(items)) {
      if (index > items.length) {
        rawSchema = (0, import_last.default)(items);
      } else {
        rawSchema = items[index];
      }
    } else {
      rawSchema = items;
    }
    fieldPathId = {
      [import_utils4.ID_KEY]: fieldPathId[import_utils4.ID_KEY],
      path: [...fieldPathId.path.slice(0, fieldPathId.path.length - 1), index]
    };
  }
  return { rawSchema, fieldPathId };
}
function getSchemaDetailsForField(registry, dottedPath, initialSchema, formData, initialFieldIdPath) {
  const { schemaUtils, globalFormOptions } = registry;
  let rawSchema = initialSchema;
  let fieldPathId = initialFieldIdPath;
  const parts = dottedPath.split(".");
  const leafPath = parts.pop();
  let schema = schemaUtils.retrieveSchema(rawSchema, formData);
  let innerData = formData;
  let isReadonly = schema.readOnly;
  parts.forEach((part) => {
    fieldPathId = (0, import_utils4.toFieldPathId)(part, globalFormOptions, fieldPathId);
    if ((0, import_has.default)(schema, import_utils4.PROPERTIES_KEY)) {
      rawSchema = (0, import_get.default)(schema, [import_utils4.PROPERTIES_KEY, part], {});
    } else if (schema && ((0, import_has.default)(schema, import_utils4.ONE_OF_KEY) || (0, import_has.default)(schema, import_utils4.ANY_OF_KEY))) {
      const xxx = (0, import_has.default)(schema, import_utils4.ONE_OF_KEY) ? import_utils4.ONE_OF_KEY : import_utils4.ANY_OF_KEY;
      const selectedSchema = schemaUtils.findSelectedOptionInXxxOf(schema, part, xxx, innerData);
      rawSchema = (0, import_get.default)(selectedSchema, [import_utils4.PROPERTIES_KEY, part], {});
    } else {
      const result = computeArraySchemasIfPresent(schema, fieldPathId, part);
      rawSchema = result.rawSchema ?? {};
      fieldPathId = result.fieldPathId;
    }
    innerData = (0, import_get.default)(innerData, part, {});
    schema = schemaUtils.retrieveSchema(rawSchema, innerData);
    isReadonly = getNonNullishValue(schema.readOnly, isReadonly);
  });
  let optionsInfo;
  let isRequired2 = false;
  if ((0, import_isEmpty.default)(schema)) {
    schema = void 0;
  }
  if (schema && leafPath) {
    if (schema && ((0, import_has.default)(schema, import_utils4.ONE_OF_KEY) || (0, import_has.default)(schema, import_utils4.ANY_OF_KEY))) {
      const xxx = (0, import_has.default)(schema, import_utils4.ONE_OF_KEY) ? import_utils4.ONE_OF_KEY : import_utils4.ANY_OF_KEY;
      schema = schemaUtils.findSelectedOptionInXxxOf(schema, leafPath, xxx, innerData);
    }
    fieldPathId = (0, import_utils4.toFieldPathId)(leafPath, globalFormOptions, fieldPathId);
    isRequired2 = schema !== void 0 && Array.isArray(schema.required) && (0, import_includes.default)(schema.required, leafPath);
    const result = computeArraySchemasIfPresent(schema, fieldPathId, leafPath);
    if (result.rawSchema) {
      schema = result.rawSchema;
      fieldPathId = result.fieldPathId;
    } else {
      schema = (0, import_get.default)(schema, [import_utils4.PROPERTIES_KEY, leafPath]);
      schema = schema ? schemaUtils.retrieveSchema(schema) : schema;
    }
    isReadonly = getNonNullishValue(schema?.readOnly, isReadonly);
    if (schema && ((0, import_has.default)(schema, import_utils4.ONE_OF_KEY) || (0, import_has.default)(schema, import_utils4.ANY_OF_KEY))) {
      const xxx = (0, import_has.default)(schema, import_utils4.ONE_OF_KEY) ? import_utils4.ONE_OF_KEY : import_utils4.ANY_OF_KEY;
      const discriminator = (0, import_utils4.getDiscriminatorFieldFromSchema)(schema);
      optionsInfo = { options: schema[xxx], hasDiscriminator: !!discriminator };
    }
  }
  return { schema, isRequired: isRequired2, isReadonly, optionsInfo, fieldPathId };
}
function getCustomRenderComponent(render, registry) {
  let customRenderer = render;
  if ((0, import_isString.default)(customRenderer)) {
    customRenderer = (0, import_utils4.lookupFromFormContext)(registry, customRenderer);
  }
  if ((0, import_isFunction.default)(customRenderer)) {
    return customRenderer;
  }
  return null;
}
function computeUIComponentPropsFromGridSchema(registry, gridSchema) {
  let name;
  let UIComponent = null;
  let uiProps = {};
  let rendered;
  if ((0, import_isString.default)(gridSchema) || (0, import_isUndefined.default)(gridSchema)) {
    name = gridSchema ?? "";
  } else {
    const { name: innerName = "", render, ...innerProps } = gridSchema;
    name = innerName;
    uiProps = innerProps;
    if (!(0, import_isEmpty.default)(uiProps)) {
      (0, import_each.default)(uiProps, (prop, key) => {
        if ((0, import_isString.default)(prop)) {
          const match = LOOKUP_REGEX.exec(prop);
          if (Array.isArray(match) && match.length > 1) {
            const name2 = match[1];
            uiProps[key] = (0, import_utils4.lookupFromFormContext)(registry, name2, name2);
          }
        }
      });
    }
    UIComponent = getCustomRenderComponent(render, registry);
    if (!innerName && UIComponent) {
      rendered = /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(UIComponent, { ...innerProps, "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.uiComponent });
    }
  }
  return { name, UIComponent, uiProps, rendered };
}
function LayoutGridFieldChildren(props) {
  const { childrenLayoutGridSchemaId, ...layoutGridFieldProps } = props;
  const { registry, schema: rawSchema, formData } = layoutGridFieldProps;
  const { schemaUtils } = registry;
  const schema = schemaUtils.retrieveSchema(rawSchema, formData);
  return childrenLayoutGridSchemaId.map((layoutGridSchema) => /* @__PURE__ */ (0, import_react4.createElement)(
    LayoutGridField,
    {
      ...layoutGridFieldProps,
      key: `layoutGrid-${(0, import_utils4.hashObject)(layoutGridSchema)}`,
      schema,
      layoutGridSchema
    }
  ));
}
function LayoutGridCondition(props) {
  const { layoutGridSchema, ...layoutGridFieldProps } = props;
  const { formData, registry } = layoutGridFieldProps;
  const { children, gridProps } = findChildrenAndProps(layoutGridSchema, "ui:condition" /* CONDITION */, registry);
  const { operator, field = "", value } = gridProps;
  const fieldData = (0, import_get.default)(formData, field, null);
  if (conditionMatches(operator, fieldData, value)) {
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(LayoutGridFieldChildren, { ...layoutGridFieldProps, childrenLayoutGridSchemaId: children });
  }
  return null;
}
function LayoutGridCol(props) {
  const { layoutGridSchema, ...layoutGridFieldProps } = props;
  const { registry, uiSchema } = layoutGridFieldProps;
  const { children, gridProps } = findChildrenAndProps(layoutGridSchema, "ui:col" /* COLUMN */, registry);
  const uiOptions = (0, import_utils4.getUiOptions)(uiSchema);
  const GridTemplate2 = (0, import_utils4.getTemplate)("GridTemplate", registry, uiOptions);
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(GridTemplate2, { column: true, "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.col, ...gridProps, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(LayoutGridFieldChildren, { ...layoutGridFieldProps, childrenLayoutGridSchemaId: children }) });
}
function LayoutGridColumns(props) {
  const { layoutGridSchema, ...layoutGridFieldProps } = props;
  const { registry, uiSchema } = layoutGridFieldProps;
  const { children, gridProps } = findChildrenAndProps(layoutGridSchema, "ui:columns" /* COLUMNS */, registry);
  const uiOptions = (0, import_utils4.getUiOptions)(uiSchema);
  const GridTemplate2 = (0, import_utils4.getTemplate)("GridTemplate", registry, uiOptions);
  return children.map((child) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    GridTemplate2,
    {
      column: true,
      "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.col,
      ...gridProps,
      children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(LayoutGridFieldChildren, { ...layoutGridFieldProps, childrenLayoutGridSchemaId: [child] })
    },
    `column-${(0, import_utils4.hashObject)(child)}`
  ));
}
function LayoutGridRow(props) {
  const { layoutGridSchema, ...layoutGridFieldProps } = props;
  const { registry, uiSchema } = layoutGridFieldProps;
  const { children, gridProps } = findChildrenAndProps(layoutGridSchema, "ui:row" /* ROW */, registry);
  const uiOptions = (0, import_utils4.getUiOptions)(uiSchema);
  const GridTemplate2 = (0, import_utils4.getTemplate)("GridTemplate", registry, uiOptions);
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(GridTemplate2, { ...gridProps, "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.row, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(LayoutGridFieldChildren, { ...layoutGridFieldProps, childrenLayoutGridSchemaId: children }) });
}
function LayoutGridFieldComponent(props) {
  const {
    gridSchema,
    schema: initialSchema,
    uiSchema,
    errorSchema,
    fieldPathId,
    onBlur,
    onFocus,
    formData,
    readonly,
    registry,
    layoutGridSchema,
    // Used to pull this out of otherProps since we don't want to pass it through
    ...otherProps
  } = props;
  const { onChange } = otherProps;
  const { fields: fields2 } = registry;
  const { SchemaField: SchemaField2, LayoutMultiSchemaField: LayoutMultiSchemaField2 } = fields2;
  const uiComponentProps = computeUIComponentPropsFromGridSchema(registry, gridSchema);
  const { name, UIComponent, uiProps } = uiComponentProps;
  const {
    schema,
    isRequired: isRequired2,
    isReadonly,
    optionsInfo,
    fieldPathId: fieldIdSchema
  } = getSchemaDetailsForField(registry, name, initialSchema, formData, fieldPathId);
  const memoFieldPathId = (0, import_utils4.useDeepCompareMemo)(fieldIdSchema);
  if (uiComponentProps.rendered) {
    return uiComponentProps.rendered;
  }
  if (schema) {
    const Field2 = optionsInfo?.hasDiscriminator ? LayoutMultiSchemaField2 : SchemaField2;
    const { fieldUiSchema, uiReadonly } = computeFieldUiSchema(name, uiProps, uiSchema, isReadonly, readonly);
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      Field2,
      {
        "data-testid": optionsInfo?.hasDiscriminator ? LAYOUT_GRID_FIELD_TEST_IDS.layoutMultiSchemaField : LAYOUT_GRID_FIELD_TEST_IDS.field,
        ...otherProps,
        name,
        required: isRequired2,
        readonly: uiReadonly,
        schema,
        uiSchema: fieldUiSchema,
        errorSchema: (0, import_get.default)(errorSchema, name),
        fieldPathId: memoFieldPathId,
        formData: (0, import_get.default)(formData, name),
        onChange,
        onBlur,
        onFocus,
        options: optionsInfo?.options,
        registry
      }
    );
  }
  if (UIComponent) {
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      UIComponent,
      {
        "data-testid": LAYOUT_GRID_FIELD_TEST_IDS.uiComponent,
        ...otherProps,
        name,
        required: isRequired2,
        formData,
        readOnly: !!isReadonly || readonly,
        errorSchema,
        uiSchema,
        schema: initialSchema,
        fieldPathId,
        onBlur,
        onFocus,
        registry,
        ...uiProps
      }
    );
  }
  return null;
}
function LayoutGridField(props) {
  const { uiSchema } = props;
  let { layoutGridSchema } = props;
  const uiOptions = (0, import_utils4.getUiOptions)(uiSchema);
  if (!layoutGridSchema && LAYOUT_GRID_UI_OPTION in uiOptions && (0, import_isObject3.default)(uiOptions[LAYOUT_GRID_UI_OPTION])) {
    layoutGridSchema = uiOptions[LAYOUT_GRID_UI_OPTION];
  }
  if ((0, import_isObject3.default)(layoutGridSchema)) {
    if ("ui:row" /* ROW */ in layoutGridSchema) {
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(LayoutGridRow, { ...props, layoutGridSchema });
    }
    if ("ui:col" /* COLUMN */ in layoutGridSchema) {
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(LayoutGridCol, { ...props, layoutGridSchema });
    }
    if ("ui:columns" /* COLUMNS */ in layoutGridSchema) {
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(LayoutGridColumns, { ...props, layoutGridSchema });
    }
    if ("ui:condition" /* CONDITION */ in layoutGridSchema) {
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(LayoutGridCondition, { ...props, layoutGridSchema });
    }
  }
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(LayoutGridFieldComponent, { ...props, gridSchema: layoutGridSchema });
}
LayoutGridField.TEST_IDS = LAYOUT_GRID_FIELD_TEST_IDS;

// src/components/fields/LayoutHeaderField.tsx
var import_utils5 = require("@rjsf/utils");
var import_jsx_runtime5 = require("react/jsx-runtime");
function LayoutHeaderField(props) {
  const { fieldPathId, title, schema, uiSchema, required, registry, name } = props;
  const options = (0, import_utils5.getUiOptions)(uiSchema, registry.globalUiOptions);
  const { title: uiTitle } = options;
  const { title: schemaTitle } = schema;
  const fieldTitle = uiTitle || title || schemaTitle || name;
  if (!fieldTitle) {
    return null;
  }
  const TitleFieldTemplate = (0, import_utils5.getTemplate)(
    "TitleFieldTemplate",
    registry,
    options
  );
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    TitleFieldTemplate,
    {
      id: (0, import_utils5.titleId)(fieldPathId),
      title: fieldTitle,
      required,
      schema,
      uiSchema,
      registry
    }
  );
}

// src/components/fields/LayoutMultiSchemaField.tsx
var import_react5 = require("react");
var import_utils6 = require("@rjsf/utils");
var import_get2 = __toESM(require("lodash/get"), 1);
var import_has2 = __toESM(require("lodash/has"), 1);
var import_isEmpty2 = __toESM(require("lodash/isEmpty"), 1);
var import_noop = __toESM(require("lodash/noop"), 1);
var import_omit = __toESM(require("lodash/omit"), 1);
var import_set3 = __toESM(require("lodash/set"), 1);
var import_jsx_runtime6 = require("react/jsx-runtime");
function getSelectedOption(options, selectorField, value) {
  const defaultValue = "!@#!@$@#$!@$#";
  const schemaOptions = options.map(({ schema }) => schema);
  return schemaOptions.find((option) => {
    const selector = (0, import_get2.default)(option, [import_utils6.PROPERTIES_KEY, selectorField]);
    const result = (0, import_get2.default)(selector, import_utils6.DEFAULT_KEY, (0, import_get2.default)(selector, import_utils6.CONST_KEY, defaultValue));
    return result === value;
  });
}
function computeEnumOptions(schema, options, schemaUtils, uiSchema, formData) {
  const realOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
  let tempSchema = schema;
  if ((0, import_has2.default)(schema, import_utils6.ONE_OF_KEY)) {
    tempSchema = { ...schema, [import_utils6.ONE_OF_KEY]: realOptions };
  } else if ((0, import_has2.default)(schema, import_utils6.ANY_OF_KEY)) {
    tempSchema = { ...schema, [import_utils6.ANY_OF_KEY]: realOptions };
  }
  const enumOptions = (0, import_utils6.optionsList)(tempSchema, uiSchema);
  if (!enumOptions) {
    throw new Error(`No enumOptions were computed from the schema ${JSON.stringify(tempSchema)}`);
  }
  return enumOptions;
}
function LayoutMultiSchemaField(props) {
  const {
    name,
    baseType,
    disabled = false,
    formData,
    fieldPathId,
    onBlur,
    onChange,
    options,
    onFocus,
    registry,
    uiSchema,
    schema,
    autofocus,
    readonly,
    required,
    errorSchema,
    hideError = false
  } = props;
  const { widgets: widgets2, schemaUtils, globalUiOptions } = registry;
  const [enumOptions, setEnumOptions] = (0, import_react5.useState)(computeEnumOptions(schema, options, schemaUtils, uiSchema, formData));
  const id = (0, import_get2.default)(fieldPathId, import_utils6.ID_KEY);
  const discriminator = (0, import_utils6.getDiscriminatorFieldFromSchema)(schema);
  const FieldErrorTemplate2 = (0, import_utils6.getTemplate)("FieldErrorTemplate", registry, options);
  const FieldTemplate2 = (0, import_utils6.getTemplate)("FieldTemplate", registry, options);
  const schemaHash = (0, import_utils6.hashObject)(schema);
  const optionsHash = (0, import_utils6.hashObject)(options);
  const uiSchemaHash = uiSchema ? (0, import_utils6.hashObject)(uiSchema) : "";
  const formDataHash = formData ? (0, import_utils6.hashObject)(formData) : "";
  (0, import_react5.useEffect)(() => {
    setEnumOptions(computeEnumOptions(schema, options, schemaUtils, uiSchema, formData));
  }, [schemaHash, optionsHash, schemaUtils, uiSchemaHash, formDataHash]);
  const {
    widget = discriminator ? "radio" : "select",
    title = "",
    placeholder = "",
    optionsSchemaSelector: selectorField = discriminator,
    hideError: uiSchemaHideError,
    ...uiOptions
  } = (0, import_utils6.getUiOptions)(uiSchema);
  if (!selectorField) {
    throw new Error("No selector field provided for the LayoutMultiSchemaField");
  }
  const selectedOption = (0, import_get2.default)(formData, selectorField);
  let optionSchema = (0, import_get2.default)(enumOptions[0]?.schema, [import_utils6.PROPERTIES_KEY, selectorField], {});
  const option = getSelectedOption(enumOptions, selectorField, selectedOption);
  optionSchema = optionSchema?.type ? optionSchema : { ...optionSchema, type: option?.type || baseType };
  const Widget = (0, import_utils6.getWidget)(optionSchema, widget, widgets2);
  const hideFieldError = uiSchemaHideError === void 0 ? hideError : Boolean(uiSchemaHideError);
  const rawErrors = (0, import_get2.default)(errorSchema, [import_utils6.ERRORS_KEY], []);
  const fieldErrorSchema = (0, import_omit.default)(errorSchema, [import_utils6.ERRORS_KEY]);
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const onOptionChange = (opt) => {
    const newOption = getSelectedOption(enumOptions, selectorField, opt);
    const oldOption = getSelectedOption(enumOptions, selectorField, selectedOption);
    let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);
    if (newFormData && newOption) {
      newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, "excludeObjectChildren");
    }
    if (newFormData) {
      (0, import_set3.default)(newFormData, selectorField, opt);
    }
    onChange(newFormData, fieldPathId.path, void 0, id);
  };
  const widgetOptions = { enumOptions, ...uiOptions };
  const errors = !hideFieldError && rawErrors.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(FieldErrorTemplate2, { fieldPathId, schema, errors: rawErrors, registry }) : void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    FieldTemplate2,
    {
      id,
      schema,
      label: (title || schema.title) ?? "",
      disabled: disabled || Array.isArray(enumOptions) && (0, import_isEmpty2.default)(enumOptions),
      uiSchema,
      required,
      readonly: !!readonly,
      registry,
      displayLabel,
      errors,
      onChange,
      onKeyRename: import_noop.default,
      onKeyRenameBlur: import_noop.default,
      onRemoveProperty: import_noop.default,
      children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
        Widget,
        {
          id,
          name,
          schema,
          label: (title || schema.title) ?? "",
          disabled: disabled || Array.isArray(enumOptions) && (0, import_isEmpty2.default)(enumOptions),
          uiSchema,
          autofocus,
          readonly,
          required,
          registry,
          multiple: false,
          rawErrors,
          hideError: hideFieldError,
          hideLabel: !displayLabel,
          errorSchema: fieldErrorSchema,
          placeholder,
          onChange: onOptionChange,
          onBlur,
          onFocus,
          value: selectedOption,
          options: widgetOptions,
          htmlName: fieldPathId.name
        }
      )
    }
  );
}

// src/components/fields/MultiSchemaField.tsx
var import_react6 = require("react");
var import_get3 = __toESM(require("lodash/get"), 1);
var import_isEmpty3 = __toESM(require("lodash/isEmpty"), 1);
var import_omit2 = __toESM(require("lodash/omit"), 1);
var import_utils7 = require("@rjsf/utils");
var import_jsx_runtime7 = require("react/jsx-runtime");
var AnyOfField = class extends import_react6.Component {
  /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(props) {
    super(props);
    const {
      formData,
      options,
      registry: { schemaUtils }
    } = this.props;
    const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
    this.state = {
      retrievedOptions,
      selectedOption: this.getMatchingOption(0, formData, retrievedOptions)
    };
  }
  /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
   * currently selected option based on the overall `formData`
   *
   * @param prevProps - The previous `FieldProps` for this template
   * @param prevState - The previous `AnyOfFieldState` for this template
   */
  componentDidUpdate(prevProps, prevState) {
    const { formData, options, fieldPathId } = this.props;
    const { selectedOption } = this.state;
    let newState = this.state;
    if (!(0, import_utils7.deepEquals)(prevProps.options, options)) {
      const {
        registry: { schemaUtils }
      } = this.props;
      const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
      newState = { selectedOption, retrievedOptions };
    }
    if (!(0, import_utils7.deepEquals)(formData, prevProps.formData) && fieldPathId.$id === prevProps.fieldPathId.$id) {
      const { retrievedOptions } = newState;
      const matchingOption = this.getMatchingOption(selectedOption, formData, retrievedOptions);
      if (prevState && matchingOption !== selectedOption) {
        newState = { selectedOption: matchingOption, retrievedOptions };
      }
    }
    if (newState !== this.state) {
      this.setState(newState);
    }
  }
  /** Determines the best matching option for the given `formData` and `options`.
   *
   * @param formData - The new formData
   * @param options - The list of options to choose from
   * @return - The index of the `option` that best matches the `formData`
   */
  getMatchingOption(selectedOption, formData, options) {
    const {
      schema,
      registry: { schemaUtils }
    } = this.props;
    const discriminator = (0, import_utils7.getDiscriminatorFieldFromSchema)(schema);
    const option = schemaUtils.getClosestMatchingOption(formData, options, selectedOption, discriminator);
    return option;
  }
  /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
   * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
   * the `onChange` handler.
   *
   * @param option - The new option value being selected
   */
  onOptionChange = (option) => {
    const { selectedOption, retrievedOptions } = this.state;
    const { formData, onChange, registry, fieldPathId } = this.props;
    const { schemaUtils } = registry;
    const intOption = option !== void 0 ? parseInt(option, 10) : -1;
    if (intOption === selectedOption) {
      return;
    }
    const newOption = intOption >= 0 ? retrievedOptions[intOption] : void 0;
    const oldOption = selectedOption >= 0 ? retrievedOptions[selectedOption] : void 0;
    let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);
    if (newOption) {
      newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, "excludeObjectChildren");
    }
    this.setState({ selectedOption: intOption }, () => {
      onChange(newFormData, fieldPathId.path, void 0, this.getFieldId());
    });
  };
  getFieldId() {
    const { fieldPathId, schema } = this.props;
    return `${fieldPathId.$id}${schema.oneOf ? "__oneof_select" : "__anyof_select"}`;
  }
  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
   */
  render() {
    const {
      name,
      disabled = false,
      errorSchema = {},
      formData,
      onBlur,
      onFocus,
      readonly,
      required = false,
      registry,
      schema,
      uiSchema
    } = this.props;
    const { widgets: widgets2, fields: fields2, translateString, globalUiOptions, schemaUtils } = registry;
    const { SchemaField: _SchemaField } = fields2;
    const MultiSchemaFieldTemplate2 = (0, import_utils7.getTemplate)(
      "MultiSchemaFieldTemplate",
      registry,
      globalUiOptions
    );
    const isOptionalRender = (0, import_utils7.shouldRenderOptionalField)(registry, schema, required, uiSchema);
    const hasFormData = (0, import_utils7.isFormDataAvailable)(formData);
    const { selectedOption, retrievedOptions } = this.state;
    const {
      widget = "select",
      placeholder,
      autofocus,
      autocomplete,
      title = schema.title,
      ...uiOptions
    } = (0, import_utils7.getUiOptions)(uiSchema, globalUiOptions);
    const Widget = (0, import_utils7.getWidget)({ type: "number" }, widget, widgets2);
    const rawErrors = (0, import_get3.default)(errorSchema, import_utils7.ERRORS_KEY, []);
    const fieldErrorSchema = (0, import_omit2.default)(errorSchema, [import_utils7.ERRORS_KEY]);
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    const option = selectedOption >= 0 ? retrievedOptions[selectedOption] || null : null;
    let optionSchema;
    if (option) {
      const { required: required2 } = schema;
      optionSchema = required2 ? (0, import_utils7.mergeSchemas)({ required: required2 }, option) : option;
    }
    let optionsUiSchema = [];
    if (import_utils7.ONE_OF_KEY in schema && uiSchema && import_utils7.ONE_OF_KEY in uiSchema) {
      if (Array.isArray(uiSchema[import_utils7.ONE_OF_KEY])) {
        optionsUiSchema = uiSchema[import_utils7.ONE_OF_KEY];
      } else {
        console.warn(`uiSchema.oneOf is not an array for "${title || name}"`);
      }
    } else if (import_utils7.ANY_OF_KEY in schema && uiSchema && import_utils7.ANY_OF_KEY in uiSchema) {
      if (Array.isArray(uiSchema[import_utils7.ANY_OF_KEY])) {
        optionsUiSchema = uiSchema[import_utils7.ANY_OF_KEY];
      } else {
        console.warn(`uiSchema.anyOf is not an array for "${title || name}"`);
      }
    }
    let optionUiSchema = uiSchema;
    if (selectedOption >= 0 && optionsUiSchema.length > selectedOption) {
      optionUiSchema = optionsUiSchema[selectedOption];
    }
    const translateEnum = title ? import_utils7.TranslatableString.TitleOptionPrefix : import_utils7.TranslatableString.OptionPrefix;
    const translateParams = title ? [title] : [];
    const enumOptions = retrievedOptions.map((opt, index) => {
      const { title: uiTitle = opt.title } = (0, import_utils7.getUiOptions)(optionsUiSchema[index]);
      return {
        label: uiTitle || translateString(translateEnum, translateParams.concat(String(index + 1))),
        value: index
      };
    });
    const selector = !isOptionalRender || hasFormData ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      Widget,
      {
        id: this.getFieldId(),
        name: `${name}${schema.oneOf ? "__oneof_select" : "__anyof_select"}`,
        schema: { type: "number", default: 0 },
        onChange: this.onOptionChange,
        onBlur,
        onFocus,
        disabled: disabled || (0, import_isEmpty3.default)(enumOptions),
        multiple: false,
        rawErrors,
        errorSchema: fieldErrorSchema,
        value: selectedOption >= 0 ? selectedOption : void 0,
        options: { enumOptions, ...uiOptions },
        registry,
        placeholder,
        autocomplete,
        autofocus,
        label: title ?? name,
        hideLabel: !displayLabel,
        readonly
      }
    ) : void 0;
    const optionsSchemaField = optionSchema && optionSchema.type !== "null" && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(_SchemaField, { ...this.props, schema: optionSchema, uiSchema: optionUiSchema }) || null;
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      MultiSchemaFieldTemplate2,
      {
        schema,
        registry,
        uiSchema,
        selector,
        optionSchemaField: optionsSchemaField
      }
    );
  }
};
var MultiSchemaField_default = AnyOfField;

// src/components/fields/NumberField.tsx
var import_react7 = require("react");
var import_utils8 = require("@rjsf/utils");
var import_jsx_runtime8 = require("react/jsx-runtime");
var trailingCharMatcherWithPrefix = /\.([0-9]*0)*$/;
var trailingCharMatcher = /[0.]0*$/;
function NumberField(props) {
  const { registry, onChange, formData, value: initialValue } = props;
  const [lastValue, setLastValue] = (0, import_react7.useState)(initialValue);
  const { StringField: StringField2 } = registry.fields;
  let value = formData;
  const handleChange = (0, import_react7.useCallback)(
    (value2, path, errorSchema, id) => {
      setLastValue(value2);
      if (`${value2}`.charAt(0) === ".") {
        value2 = `0${value2}`;
      }
      const processed = typeof value2 === "string" && value2.match(trailingCharMatcherWithPrefix) ? (0, import_utils8.asNumber)(value2.replace(trailingCharMatcher, "")) : (0, import_utils8.asNumber)(value2);
      onChange(processed, path, errorSchema, id);
    },
    [onChange]
  );
  if (typeof lastValue === "string" && typeof value === "number") {
    const re = new RegExp(`^(${String(value).replace(".", "\\.")})?\\.?0*$`);
    if (lastValue.match(re)) {
      value = lastValue;
    }
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(StringField2, { ...props, formData: value, onChange: handleChange });
}
var NumberField_default = NumberField;

// src/components/fields/ObjectField.tsx
var import_react8 = require("react");
var import_utils9 = require("@rjsf/utils");
var import_markdown_to_jsx = __toESM(require("markdown-to-jsx"), 1);
var import_get4 = __toESM(require("lodash/get"), 1);
var import_has3 = __toESM(require("lodash/has"), 1);
var import_isObject4 = __toESM(require("lodash/isObject"), 1);
var import_set4 = __toESM(require("lodash/set"), 1);

// src/components/constants.ts
var ADDITIONAL_PROPERTY_KEY_REMOVE = Symbol("remove-this-key");
var IS_RESET = Symbol("reset");

// src/components/fields/ObjectField.tsx
var import_jsx_runtime9 = require("react/jsx-runtime");
function isRequired(schema, name) {
  return Array.isArray(schema.required) && schema.required.indexOf(name) !== -1;
}
function getDefaultValue(translateString, type) {
  switch (type) {
    case "array":
      return [];
    case "boolean":
      return false;
    case "null":
      return null;
    case "number":
      return 0;
    case "object":
      return {};
    case "string":
    default:
      return translateString(import_utils9.TranslatableString.NewStringDefault);
  }
}
function ObjectFieldProperty(props) {
  const {
    fieldPathId,
    schema,
    registry,
    uiSchema,
    errorSchema,
    formData,
    onChange,
    onBlur,
    onFocus,
    disabled,
    readonly,
    required,
    hideError,
    propertyName,
    handleKeyRename,
    handleRemoveProperty,
    addedByAdditionalProperties
  } = props;
  const [wasPropertyKeyModified, setWasPropertyKeyModified] = (0, import_react8.useState)(false);
  const { globalFormOptions, fields: fields2 } = registry;
  const { SchemaField: SchemaField2 } = fields2;
  const innerFieldIdPathId = (0, import_utils9.useDeepCompareMemo)(
    (0, import_utils9.toFieldPathId)(propertyName, globalFormOptions, fieldPathId.path)
  );
  const onPropertyChange = (0, import_react8.useCallback)(
    (value, path, newErrorSchema, id) => {
      if (value === void 0 && addedByAdditionalProperties) {
        value = "";
      }
      onChange(value, path, newErrorSchema, id);
    },
    [onChange, addedByAdditionalProperties]
  );
  const onKeyRename = (0, import_react8.useCallback)(
    (value) => {
      if (propertyName !== value) {
        setWasPropertyKeyModified(true);
      }
      handleKeyRename(propertyName, value);
    },
    [propertyName, handleKeyRename]
  );
  const onKeyRenameBlur = (0, import_react8.useCallback)(
    (event) => {
      const {
        target: { value }
      } = event;
      onKeyRename(value);
    },
    [onKeyRename]
  );
  const onRemoveProperty = (0, import_react8.useCallback)(() => {
    handleRemoveProperty(propertyName);
  }, [propertyName, handleRemoveProperty]);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
    SchemaField2,
    {
      name: propertyName,
      required,
      schema,
      uiSchema,
      errorSchema,
      fieldPathId: innerFieldIdPathId,
      formData,
      wasPropertyKeyModified,
      onKeyRename,
      onKeyRenameBlur,
      onRemoveProperty,
      onChange: onPropertyChange,
      onBlur,
      onFocus,
      registry,
      disabled,
      readonly,
      hideError
    }
  );
}
function ObjectField(props) {
  const {
    schema: rawSchema,
    uiSchema = {},
    formData,
    errorSchema,
    fieldPathId,
    name,
    required = false,
    disabled,
    readonly,
    hideError,
    onBlur,
    onFocus,
    onChange,
    registry,
    title
  } = props;
  const { fields: fields2, schemaUtils, translateString, globalUiOptions } = registry;
  const { OptionalDataControlsField: OptionalDataControlsField2 } = fields2;
  const schema = schemaUtils.retrieveSchema(rawSchema, formData, true);
  const uiOptions = (0, import_utils9.getUiOptions)(uiSchema, globalUiOptions);
  const { properties: schemaProperties = {} } = schema;
  const childFieldPathId = props.childFieldPathId ?? fieldPathId;
  const templateTitle = uiOptions.title ?? schema.title ?? title ?? name;
  const description = uiOptions.description ?? schema.description;
  const renderOptionalField = (0, import_utils9.shouldRenderOptionalField)(registry, schema, required, uiSchema);
  const hasFormData = (0, import_utils9.isFormDataAvailable)(formData);
  let orderedProperties = [];
  const getAvailableKey = (0, import_react8.useCallback)(
    (preferredKey, formData2) => {
      const { duplicateKeySuffixSeparator = "-" } = (0, import_utils9.getUiOptions)(uiSchema, globalUiOptions);
      let index = 0;
      let newKey = preferredKey;
      while ((0, import_has3.default)(formData2, newKey)) {
        newKey = `${preferredKey}${duplicateKeySuffixSeparator}${++index}`;
      }
      return newKey;
    },
    [uiSchema, globalUiOptions]
  );
  const onAddProperty = (0, import_react8.useCallback)(() => {
    if (!(schema.additionalProperties || schema.patternProperties)) {
      return;
    }
    const { translateString: translateString2 } = registry;
    const newFormData = { ...formData };
    const newKey = getAvailableKey("newKey", newFormData);
    if (schema.patternProperties) {
      (0, import_set4.default)(newFormData, newKey, null);
    } else {
      let type = void 0;
      let constValue = void 0;
      let defaultValue = void 0;
      if ((0, import_isObject4.default)(schema.additionalProperties)) {
        type = schema.additionalProperties.type;
        constValue = schema.additionalProperties.const;
        defaultValue = schema.additionalProperties.default;
        let apSchema = schema.additionalProperties;
        if (import_utils9.REF_KEY in apSchema) {
          const { schemaUtils: schemaUtils2 } = registry;
          apSchema = schemaUtils2.retrieveSchema({ [import_utils9.REF_KEY]: apSchema[import_utils9.REF_KEY] }, formData);
          type = apSchema.type;
          constValue = apSchema.const;
          defaultValue = apSchema.default;
        }
        if (!type && (import_utils9.ANY_OF_KEY in apSchema || import_utils9.ONE_OF_KEY in apSchema)) {
          type = "object";
        }
      }
      const newValue = constValue ?? defaultValue ?? getDefaultValue(translateString2, type);
      (0, import_set4.default)(newFormData, newKey, newValue);
    }
    onChange(newFormData, childFieldPathId.path);
  }, [formData, onChange, registry, childFieldPathId, getAvailableKey, schema]);
  const handleKeyRename = (0, import_react8.useCallback)(
    (oldKey, newKey) => {
      if (oldKey !== newKey) {
        const actualNewKey = getAvailableKey(newKey, formData);
        const newFormData = {
          ...formData
        };
        const newKeys = { [oldKey]: actualNewKey };
        const keyValues = Object.keys(newFormData).map((key) => {
          const newKey2 = newKeys[key] || key;
          return { [newKey2]: newFormData[key] };
        });
        const renamedObj = Object.assign({}, ...keyValues);
        onChange(renamedObj, childFieldPathId.path);
      }
    },
    [formData, onChange, childFieldPathId, getAvailableKey]
  );
  const handleRemoveProperty = (0, import_react8.useCallback)(
    (key) => {
      onChange(ADDITIONAL_PROPERTY_KEY_REMOVE, [...childFieldPathId.path, key]);
    },
    [onChange, childFieldPathId]
  );
  if (!renderOptionalField || hasFormData) {
    try {
      const properties = Object.keys(schemaProperties);
      orderedProperties = (0, import_utils9.orderProperties)(properties, uiOptions.order);
    } catch (err) {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "rjsf-config-error", style: { color: "red" }, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_markdown_to_jsx.default, { options: { disableParsingRawHTML: true }, children: translateString(import_utils9.TranslatableString.InvalidObjectField, [name || "root", err.message]) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("pre", { children: JSON.stringify(schema) })
      ] });
    }
  }
  const Template = (0, import_utils9.getTemplate)("ObjectFieldTemplate", registry, uiOptions);
  const optionalDataControl = renderOptionalField ? /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(OptionalDataControlsField2, { ...props, fieldPathId: childFieldPathId, schema }) : void 0;
  const templateProps = {
    // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
    title: uiOptions.label === false ? "" : templateTitle,
    description: uiOptions.label === false ? void 0 : description,
    properties: orderedProperties.map((name2) => {
      const addedByAdditionalProperties = (0, import_has3.default)(schema, [import_utils9.PROPERTIES_KEY, name2, import_utils9.ADDITIONAL_PROPERTY_FLAG]);
      const fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name2];
      const hidden = (0, import_utils9.getUiOptions)(fieldUiSchema).widget === "hidden";
      const content = /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ObjectFieldProperty,
        {
          propertyName: name2,
          required: isRequired(schema, name2),
          schema: (0, import_get4.default)(schema, [import_utils9.PROPERTIES_KEY, name2], {}),
          uiSchema: fieldUiSchema,
          errorSchema: (0, import_get4.default)(errorSchema, [name2]),
          fieldPathId: childFieldPathId,
          formData: (0, import_get4.default)(formData, [name2]),
          handleKeyRename,
          handleRemoveProperty,
          addedByAdditionalProperties,
          onChange,
          onBlur,
          onFocus,
          registry,
          disabled,
          readonly,
          hideError
        },
        name2
      );
      return {
        content,
        name: name2,
        readonly,
        disabled,
        required,
        hidden
      };
    }),
    readonly,
    disabled,
    required,
    fieldPathId,
    uiSchema,
    errorSchema,
    schema,
    formData,
    registry,
    optionalDataControl,
    className: renderOptionalField ? "rjsf-optional-object-field" : void 0
  };
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Template, { ...templateProps, onAddProperty });
}

// src/components/fields/OptionalDataControlsField.tsx
var import_utils10 = require("@rjsf/utils");
var import_jsx_runtime10 = require("react/jsx-runtime");
function OptionalDataControlsField(props) {
  const {
    schema,
    uiSchema = {},
    formData,
    disabled = false,
    readonly = false,
    onChange,
    errorSchema,
    fieldPathId,
    registry
  } = props;
  const { globalUiOptions = {}, schemaUtils, translateString } = registry;
  const uiOptions = (0, import_utils10.getUiOptions)(uiSchema, globalUiOptions);
  const OptionalDataControlsTemplate2 = (0, import_utils10.getTemplate)(
    "OptionalDataControlsTemplate",
    registry,
    uiOptions
  );
  const hasFormData = (0, import_utils10.isFormDataAvailable)(formData);
  let id;
  let label;
  let onAddClick;
  let onRemoveClick;
  if (disabled || readonly) {
    id = (0, import_utils10.optionalControlsId)(fieldPathId, "Msg");
    label = hasFormData ? void 0 : translateString(import_utils10.TranslatableString.OptionalObjectEmptyMsg);
  } else {
    const labelEnum = hasFormData ? import_utils10.TranslatableString.OptionalObjectRemove : import_utils10.TranslatableString.OptionalObjectAdd;
    label = translateString(labelEnum);
    if (hasFormData) {
      id = (0, import_utils10.optionalControlsId)(fieldPathId, "Remove");
      onRemoveClick = () => onChange(void 0, fieldPathId.path, errorSchema);
    } else {
      id = (0, import_utils10.optionalControlsId)(fieldPathId, "Add");
      onAddClick = () => {
        let newFormData = schemaUtils.getDefaultFormState(schema, formData, "excludeObjectChildren");
        if (newFormData === void 0) {
          newFormData = (0, import_utils10.getSchemaType)(schema) === "array" ? [] : {};
        }
        onChange(newFormData, fieldPathId.path, errorSchema);
      };
    }
  }
  return label && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    OptionalDataControlsTemplate2,
    {
      id,
      registry,
      schema,
      uiSchema,
      label,
      onAddClick,
      onRemoveClick
    }
  );
}

// src/components/fields/SchemaField.tsx
var import_react9 = require("react");
var import_utils11 = require("@rjsf/utils");
var import_isObject5 = __toESM(require("lodash/isObject"), 1);
var import_omit3 = __toESM(require("lodash/omit"), 1);
var import_jsx_runtime11 = require("react/jsx-runtime");
var COMPONENT_TYPES = {
  array: "ArrayField",
  boolean: "BooleanField",
  integer: "NumberField",
  number: "NumberField",
  object: "ObjectField",
  string: "StringField",
  null: "NullField"
};
function getFieldComponent(schema, uiOptions, registry) {
  const field = uiOptions.field;
  const { fields: fields2 } = registry;
  if (typeof field === "function") {
    return field;
  }
  if (typeof field === "string" && field in fields2) {
    return fields2[field];
  }
  const schemaType = (0, import_utils11.getSchemaType)(schema);
  const type = Array.isArray(schemaType) ? schemaType[0] : schemaType || "";
  const schemaId = schema.$id;
  let componentName = COMPONENT_TYPES[type];
  if (schemaId && schemaId in fields2) {
    componentName = schemaId;
  }
  if (!componentName && (schema.anyOf || schema.oneOf)) {
    return () => null;
  }
  return componentName in fields2 ? fields2[componentName] : fields2["FallbackField"];
}
function SchemaFieldRender(props) {
  const {
    schema: _schema,
    fieldPathId,
    uiSchema,
    formData,
    errorSchema,
    name,
    onChange,
    onKeyRename,
    onKeyRenameBlur,
    onRemoveProperty,
    required = false,
    registry,
    wasPropertyKeyModified = false
  } = props;
  const { schemaUtils, globalFormOptions, globalUiOptions, fields: fields2 } = registry;
  const { AnyOfField: _AnyOfField, OneOfField: _OneOfField } = fields2;
  const uiOptions = (0, import_utils11.getUiOptions)(uiSchema, globalUiOptions);
  const FieldTemplate2 = (0, import_utils11.getTemplate)("FieldTemplate", registry, uiOptions);
  const DescriptionFieldTemplate = (0, import_utils11.getTemplate)(
    "DescriptionFieldTemplate",
    registry,
    uiOptions
  );
  const FieldHelpTemplate2 = (0, import_utils11.getTemplate)("FieldHelpTemplate", registry, uiOptions);
  const FieldErrorTemplate2 = (0, import_utils11.getTemplate)("FieldErrorTemplate", registry, uiOptions);
  const schema = schemaUtils.retrieveSchema(_schema, formData);
  const fieldId = fieldPathId[import_utils11.ID_KEY];
  const handleFieldComponentChange = (0, import_react9.useCallback)(
    (formData2, path, newErrorSchema, id2) => {
      const theId = id2 || fieldId;
      return onChange(formData2, path, newErrorSchema, theId);
    },
    [fieldId, onChange]
  );
  const FieldComponent = getFieldComponent(schema, uiOptions, registry);
  const disabled = Boolean(uiOptions.disabled ?? props.disabled);
  const readonly = Boolean(uiOptions.readonly ?? (props.readonly || props.schema.readOnly || schema.readOnly));
  const uiSchemaHideError = uiOptions.hideError;
  const hideError = uiSchemaHideError === void 0 ? props.hideError : Boolean(uiSchemaHideError);
  const autofocus = Boolean(uiOptions.autofocus ?? props.autofocus);
  if (Object.keys(schema).length === 0) {
    return null;
  }
  let displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const isReplacingAnyOrOneOf = uiOptions.field && uiOptions.fieldReplacesAnyOrOneOf === true;
  let XxxOfField;
  let XxxOfOptions;
  let fieldPathIdProps = { fieldPathId };
  if ((import_utils11.ANY_OF_KEY in schema || import_utils11.ONE_OF_KEY in schema) && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema)) {
    if (schema[import_utils11.ANY_OF_KEY]) {
      XxxOfField = _AnyOfField;
      XxxOfOptions = schema[import_utils11.ANY_OF_KEY].map(
        (_schema2) => schemaUtils.retrieveSchema((0, import_isObject5.default)(_schema2) ? _schema2 : {}, formData)
      );
    } else if (schema[import_utils11.ONE_OF_KEY]) {
      XxxOfField = _OneOfField;
      XxxOfOptions = schema[import_utils11.ONE_OF_KEY].map(
        (_schema2) => schemaUtils.retrieveSchema((0, import_isObject5.default)(_schema2) ? _schema2 : {}, formData)
      );
    }
    const isOptionalRender = (0, import_utils11.shouldRenderOptionalField)(registry, schema, required, uiSchema);
    const hasFormData = (0, import_utils11.isFormDataAvailable)(formData);
    displayLabel = displayLabel && (!isOptionalRender || hasFormData);
    fieldPathIdProps = {
      childFieldPathId: fieldPathId,
      // The main FieldComponent will add `XxxOf` onto the fieldPathId to avoid duplication with the rendering of the
      // same FieldComponent by the `XxxOfField`
      fieldPathId: (0, import_utils11.toFieldPathId)("XxxOf", globalFormOptions, fieldPathId)
    };
  }
  const { __errors, ...fieldErrorSchema } = errorSchema || {};
  const fieldUiSchema = (0, import_omit3.default)(uiSchema, ["ui:classNames", "classNames", "ui:style"]);
  if (import_utils11.UI_OPTIONS_KEY in fieldUiSchema) {
    fieldUiSchema[import_utils11.UI_OPTIONS_KEY] = (0, import_omit3.default)(fieldUiSchema[import_utils11.UI_OPTIONS_KEY], ["classNames", "style"]);
  }
  const field = /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    FieldComponent,
    {
      ...props,
      onChange: handleFieldComponentChange,
      ...fieldPathIdProps,
      schema,
      uiSchema: fieldUiSchema,
      disabled,
      readonly,
      hideError,
      autofocus,
      errorSchema: fieldErrorSchema,
      rawErrors: __errors
    }
  );
  const id = fieldPathId[import_utils11.ID_KEY];
  let label;
  if (wasPropertyKeyModified) {
    label = name;
  } else {
    label = import_utils11.ADDITIONAL_PROPERTY_FLAG in schema ? name : uiOptions.title || props.schema.title || schema.title || props.title || name;
  }
  const description = uiOptions.description || props.schema.description || schema.description || "";
  const help = uiOptions.help;
  const hidden = uiOptions.widget === "hidden";
  const classNames = ["rjsf-field", `rjsf-field-${(0, import_utils11.getSchemaType)(schema)}`];
  if (!hideError && __errors && __errors.length > 0) {
    classNames.push("rjsf-field-error");
  }
  if (uiOptions.classNames) {
    classNames.push(uiOptions.classNames);
  }
  const helpComponent = /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    FieldHelpTemplate2,
    {
      help,
      fieldPathId,
      schema,
      uiSchema,
      hasErrors: !hideError && __errors && __errors.length > 0,
      registry
    }
  );
  const errorsComponent = hideError || XxxOfField && !schemaUtils.isSelect(schema) ? void 0 : /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    FieldErrorTemplate2,
    {
      errors: __errors,
      errorSchema,
      fieldPathId,
      schema,
      uiSchema,
      registry
    }
  );
  const fieldProps = {
    description: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      DescriptionFieldTemplate,
      {
        id: (0, import_utils11.descriptionId)(id),
        description,
        schema,
        uiSchema,
        registry
      }
    ),
    rawDescription: description,
    help: helpComponent,
    rawHelp: typeof help === "string" ? help : void 0,
    errors: errorsComponent,
    rawErrors: hideError ? void 0 : __errors,
    id,
    label,
    hidden,
    onChange,
    onKeyRename,
    onKeyRenameBlur,
    onRemoveProperty,
    required,
    disabled,
    readonly,
    hideError,
    displayLabel,
    classNames: classNames.join(" ").trim(),
    style: uiOptions.style,
    formData,
    schema,
    uiSchema,
    registry
  };
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(FieldTemplate2, { ...fieldProps, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
    field,
    XxxOfField && /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      XxxOfField,
      {
        name,
        disabled,
        readonly,
        hideError,
        errorSchema,
        formData,
        fieldPathId,
        onBlur: props.onBlur,
        onChange: props.onChange,
        onFocus: props.onFocus,
        options: XxxOfOptions,
        registry,
        required,
        schema,
        uiSchema
      }
    )
  ] }) });
}
var SchemaField = class extends import_react9.Component {
  shouldComponentUpdate(nextProps) {
    const {
      registry: { globalFormOptions }
    } = this.props;
    const { experimental_componentUpdateStrategy = "customDeep" } = globalFormOptions;
    return (0, import_utils11.shouldRender)(this, nextProps, this.state, experimental_componentUpdateStrategy);
  }
  render() {
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(SchemaFieldRender, { ...this.props });
  }
};
var SchemaField_default = SchemaField;

// src/components/fields/StringField.tsx
var import_react10 = require("react");
var import_utils12 = require("@rjsf/utils");
var import_jsx_runtime12 = require("react/jsx-runtime");
function StringField(props) {
  const {
    schema,
    name,
    uiSchema,
    fieldPathId,
    formData,
    required,
    disabled = false,
    readonly = false,
    autofocus = false,
    onChange,
    onBlur,
    onFocus,
    registry,
    rawErrors,
    hideError,
    title
  } = props;
  const { title: schemaTitle, format } = schema;
  const { widgets: widgets2, schemaUtils, globalUiOptions } = registry;
  const enumOptions = schemaUtils.isSelect(schema) ? (0, import_utils12.optionsList)(schema, uiSchema) : void 0;
  let defaultWidget = enumOptions ? "select" : "text";
  if (format && (0, import_utils12.hasWidget)(schema, format, widgets2)) {
    defaultWidget = format;
  }
  const { widget = defaultWidget, placeholder = "", title: uiTitle, ...options } = (0, import_utils12.getUiOptions)(uiSchema);
  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
  const label = uiTitle ?? title ?? schemaTitle ?? name;
  const Widget = (0, import_utils12.getWidget)(schema, widget, widgets2);
  const onWidgetChange = (0, import_react10.useCallback)(
    (value, errorSchema, id) => {
      return onChange(value, fieldPathId.path, errorSchema, id);
    },
    [onChange, fieldPathId]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
    Widget,
    {
      options: { ...options, enumOptions },
      schema,
      uiSchema,
      id: fieldPathId.$id,
      name,
      label,
      hideLabel: !displayLabel,
      hideError,
      value: formData,
      onChange: onWidgetChange,
      onBlur,
      onFocus,
      required,
      disabled,
      readonly,
      autofocus,
      registry,
      placeholder,
      rawErrors,
      htmlName: fieldPathId.name
    }
  );
}
var StringField_default = StringField;

// src/components/fields/NullField.tsx
var import_react11 = require("react");
function NullField(props) {
  const { formData, onChange, fieldPathId } = props;
  (0, import_react11.useEffect)(() => {
    if (formData === void 0) {
      onChange(null, fieldPathId.path);
    }
  }, [fieldPathId, formData, onChange]);
  return null;
}
var NullField_default = NullField;

// src/components/fields/index.ts
function fields() {
  return {
    AnyOfField: MultiSchemaField_default,
    ArrayField,
    // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
    BooleanField: BooleanField_default,
    FallbackField,
    LayoutGridField,
    LayoutHeaderField,
    LayoutMultiSchemaField,
    NumberField: NumberField_default,
    ObjectField,
    OneOfField: MultiSchemaField_default,
    OptionalDataControlsField,
    SchemaField: SchemaField_default,
    StringField: StringField_default,
    NullField: NullField_default
  };
}
var fields_default = fields;

// src/components/templates/ArrayFieldDescriptionTemplate.tsx
var import_utils13 = require("@rjsf/utils");
var import_jsx_runtime13 = require("react/jsx-runtime");
function ArrayFieldDescriptionTemplate(props) {
  const { fieldPathId, description, registry, schema, uiSchema } = props;
  const options = (0, import_utils13.getUiOptions)(uiSchema, registry.globalUiOptions);
  const { label: displayLabel = true } = options;
  if (!description || !displayLabel) {
    return null;
  }
  const DescriptionFieldTemplate = (0, import_utils13.getTemplate)(
    "DescriptionFieldTemplate",
    registry,
    options
  );
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
    DescriptionFieldTemplate,
    {
      id: (0, import_utils13.descriptionId)(fieldPathId),
      description,
      schema,
      uiSchema,
      registry
    }
  );
}

// src/components/templates/ArrayFieldItemTemplate.tsx
var import_utils14 = require("@rjsf/utils");
var import_jsx_runtime14 = require("react/jsx-runtime");
function ArrayFieldItemTemplate(props) {
  const { children, className, buttonsProps, displayLabel, hasDescription, hasToolbar, registry, uiSchema } = props;
  const uiOptions = (0, import_utils14.getUiOptions)(uiSchema);
  const ArrayFieldItemButtonsTemplate2 = (0, import_utils14.getTemplate)(
    "ArrayFieldItemButtonsTemplate",
    registry,
    uiOptions
  );
  const btnStyle = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  };
  const margin = hasDescription ? 31 : 9;
  const containerStyle = { display: "flex", alignItems: displayLabel ? "center" : "baseline" };
  const toolbarStyle = { display: "flex", justifyContent: "flex-end", marginTop: displayLabel ? `${margin}px` : 0 };
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className, style: containerStyle, children: [
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: hasToolbar ? "col-xs-9 col-md-10 col-xl-11" : "col-xs-12", children }),
    hasToolbar && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "col-xs-3 col-md-2 col-xl-1 array-item-toolbox", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "btn-group", style: toolbarStyle, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(ArrayFieldItemButtonsTemplate2, { ...buttonsProps, style: btnStyle }) }) })
  ] });
}

// src/components/templates/ArrayFieldItemButtonsTemplate.tsx
var import_utils15 = require("@rjsf/utils");
var import_jsx_runtime15 = require("react/jsx-runtime");
function ArrayFieldItemButtonsTemplate(props) {
  const {
    disabled,
    hasCopy,
    hasMoveDown,
    hasMoveUp,
    hasRemove,
    fieldPathId,
    onCopyItem,
    onRemoveItem,
    onMoveDownItem,
    onMoveUpItem,
    readonly,
    registry,
    uiSchema
  } = props;
  const { CopyButton: CopyButton2, MoveDownButton: MoveDownButton2, MoveUpButton: MoveUpButton2, RemoveButton: RemoveButton2 } = registry.templates.ButtonTemplates;
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [
    (hasMoveUp || hasMoveDown) && /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      MoveUpButton2,
      {
        id: (0, import_utils15.buttonId)(fieldPathId, "moveUp"),
        className: "rjsf-array-item-move-up",
        disabled: disabled || readonly || !hasMoveUp,
        onClick: onMoveUpItem,
        uiSchema,
        registry
      }
    ),
    (hasMoveUp || hasMoveDown) && /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      MoveDownButton2,
      {
        id: (0, import_utils15.buttonId)(fieldPathId, "moveDown"),
        className: "rjsf-array-item-move-down",
        disabled: disabled || readonly || !hasMoveDown,
        onClick: onMoveDownItem,
        uiSchema,
        registry
      }
    ),
    hasCopy && /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      CopyButton2,
      {
        id: (0, import_utils15.buttonId)(fieldPathId, "copy"),
        className: "rjsf-array-item-copy",
        disabled: disabled || readonly,
        onClick: onCopyItem,
        uiSchema,
        registry
      }
    ),
    hasRemove && /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      RemoveButton2,
      {
        id: (0, import_utils15.buttonId)(fieldPathId, "remove"),
        className: "rjsf-array-item-remove",
        disabled: disabled || readonly,
        onClick: onRemoveItem,
        uiSchema,
        registry
      }
    )
  ] });
}

// src/components/templates/ArrayFieldTemplate.tsx
var import_utils16 = require("@rjsf/utils");
var import_jsx_runtime16 = require("react/jsx-runtime");
function ArrayFieldTemplate(props) {
  const {
    canAdd,
    className,
    disabled,
    fieldPathId,
    uiSchema,
    items,
    optionalDataControl,
    onAddClick,
    readonly,
    registry,
    required,
    schema,
    title
  } = props;
  const uiOptions = (0, import_utils16.getUiOptions)(uiSchema);
  const ArrayFieldDescriptionTemplate2 = (0, import_utils16.getTemplate)(
    "ArrayFieldDescriptionTemplate",
    registry,
    uiOptions
  );
  const ArrayFieldTitleTemplate2 = (0, import_utils16.getTemplate)(
    "ArrayFieldTitleTemplate",
    registry,
    uiOptions
  );
  const showOptionalDataControlInTitle = !readonly && !disabled;
  const {
    ButtonTemplates: { AddButton: AddButton2 }
  } = registry.templates;
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("fieldset", { className, id: fieldPathId.$id, children: [
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      ArrayFieldTitleTemplate2,
      {
        fieldPathId,
        title: uiOptions.title || title,
        required,
        schema,
        uiSchema,
        registry,
        optionalDataControl: showOptionalDataControlInTitle ? optionalDataControl : void 0
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      ArrayFieldDescriptionTemplate2,
      {
        fieldPathId,
        description: uiOptions.description || schema.description,
        schema,
        uiSchema,
        registry
      }
    ),
    !showOptionalDataControlInTitle ? optionalDataControl : void 0,
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "row array-item-list", children: items }),
    canAdd && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      AddButton2,
      {
        id: (0, import_utils16.buttonId)(fieldPathId, "add"),
        className: "rjsf-array-item-add",
        onClick: onAddClick,
        disabled: disabled || readonly,
        uiSchema,
        registry
      }
    )
  ] });
}

// src/components/templates/ArrayFieldTitleTemplate.tsx
var import_utils17 = require("@rjsf/utils");
var import_jsx_runtime17 = require("react/jsx-runtime");
function ArrayFieldTitleTemplate(props) {
  const { fieldPathId, title, schema, uiSchema, required, registry, optionalDataControl } = props;
  const options = (0, import_utils17.getUiOptions)(uiSchema, registry.globalUiOptions);
  const { label: displayLabel = true } = options;
  if (!title || !displayLabel) {
    return null;
  }
  const TitleFieldTemplate = (0, import_utils17.getTemplate)(
    "TitleFieldTemplate",
    registry,
    options
  );
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    TitleFieldTemplate,
    {
      id: (0, import_utils17.titleId)(fieldPathId),
      title,
      required,
      schema,
      uiSchema,
      registry,
      optionalDataControl
    }
  );
}

// src/components/templates/BaseInputTemplate.tsx
var import_react12 = require("react");
var import_utils18 = require("@rjsf/utils");
var import_jsx_runtime18 = require("react/jsx-runtime");
function BaseInputTemplate(props) {
  const {
    id,
    name,
    // remove this from ...rest
    htmlName,
    value,
    readonly,
    disabled,
    autofocus,
    onBlur,
    onFocus,
    onChange,
    onChangeOverride,
    options,
    schema,
    uiSchema,
    registry,
    rawErrors,
    type,
    hideLabel,
    // remove this from ...rest
    hideError,
    // remove this from ...rest
    ...rest
  } = props;
  if (!id) {
    console.log("No id for", props);
    throw new Error(`no id for props ${JSON.stringify(props)}`);
  }
  const inputProps = {
    ...rest,
    ...(0, import_utils18.getInputProps)(schema, type, options)
  };
  let inputValue;
  if (inputProps.type === "number" || inputProps.type === "integer") {
    inputValue = value || value === 0 ? value : "";
  } else {
    inputValue = value == null ? "" : value;
  }
  const _onChange = (0, import_react12.useCallback)(
    ({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2),
    [onChange, options]
  );
  const _onBlur = (0, import_react12.useCallback)(
    ({ target }) => onBlur(id, target && target.value),
    [onBlur, id]
  );
  const _onFocus = (0, import_react12.useCallback)(
    ({ target }) => onFocus(id, target && target.value),
    [onFocus, id]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      "input",
      {
        id,
        name: htmlName || id,
        className: "form-control",
        readOnly: readonly,
        disabled,
        autoFocus: autofocus,
        value: inputValue,
        ...inputProps,
        list: schema.examples ? (0, import_utils18.examplesId)(id) : void 0,
        onChange: onChangeOverride || _onChange,
        onBlur: _onBlur,
        onFocus: _onFocus,
        "aria-describedby": (0, import_utils18.ariaDescribedByIds)(id, !!schema.examples)
      }
    ),
    Array.isArray(schema.examples) && /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("datalist", { id: (0, import_utils18.examplesId)(id), children: schema.examples.concat(schema.default && !schema.examples.includes(schema.default) ? [schema.default] : []).map((example) => {
      return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("option", { value: example }, example);
    }) }, `datalist_${id}`)
  ] });
}

// src/components/templates/ButtonTemplates/SubmitButton.tsx
var import_utils19 = require("@rjsf/utils");
var import_jsx_runtime19 = require("react/jsx-runtime");
function SubmitButton({ uiSchema }) {
  const { submitText, norender, props: submitButtonProps = {} } = (0, import_utils19.getSubmitButtonOptions)(uiSchema);
  if (norender) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("button", { type: "submit", ...submitButtonProps, className: `btn btn-info ${submitButtonProps.className || ""}`, children: submitText }) });
}

// src/components/templates/ButtonTemplates/AddButton.tsx
var import_utils21 = require("@rjsf/utils");

// src/components/templates/ButtonTemplates/IconButton.tsx
var import_utils20 = require("@rjsf/utils");
var import_jsx_runtime20 = require("react/jsx-runtime");
function IconButton(props) {
  const { iconType = "default", icon, className, uiSchema, registry, ...otherProps } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("button", { type: "button", className: `btn btn-${iconType} ${className}`, ...otherProps, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("i", { className: `glyphicon glyphicon-${icon}` }) });
}
function CopyButton(props) {
  const {
    registry: { translateString }
  } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(IconButton, { title: translateString(import_utils20.TranslatableString.CopyButton), ...props, icon: "copy" });
}
function MoveDownButton(props) {
  const {
    registry: { translateString }
  } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(IconButton, { title: translateString(import_utils20.TranslatableString.MoveDownButton), ...props, icon: "arrow-down" });
}
function MoveUpButton(props) {
  const {
    registry: { translateString }
  } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(IconButton, { title: translateString(import_utils20.TranslatableString.MoveUpButton), ...props, icon: "arrow-up" });
}
function RemoveButton(props) {
  const {
    registry: { translateString }
  } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(IconButton, { title: translateString(import_utils20.TranslatableString.RemoveButton), ...props, iconType: "danger", icon: "remove" });
}

// src/components/templates/ButtonTemplates/AddButton.tsx
var import_jsx_runtime21 = require("react/jsx-runtime");
function AddButton({
  id,
  className,
  onClick,
  disabled,
  registry
}) {
  const { translateString } = registry;
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("div", { className: "row", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
    "p",
    {
      className: `col-xs-4 col-sm-2 col-lg-1 col-xs-offset-8 col-sm-offset-10 col-lg-offset-11 text-right ${className}`,
      children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
        IconButton,
        {
          id,
          iconType: "info",
          icon: "plus",
          className: "btn-add col-xs-12",
          title: translateString(import_utils21.TranslatableString.AddButton),
          onClick,
          disabled,
          registry
        }
      )
    }
  ) });
}

// src/components/templates/ButtonTemplates/index.ts
function buttonTemplates() {
  return {
    SubmitButton,
    AddButton,
    CopyButton,
    MoveDownButton,
    MoveUpButton,
    RemoveButton
  };
}
var ButtonTemplates_default = buttonTemplates;

// src/components/RichDescription.tsx
var import_utils22 = require("@rjsf/utils");
var import_markdown_to_jsx2 = __toESM(require("markdown-to-jsx"), 1);
var import_jsx_runtime22 = require("react/jsx-runtime");
var TEST_IDS = (0, import_utils22.getTestIds)();
function RichDescription({ description, registry, uiSchema = {} }) {
  const { globalUiOptions } = registry;
  const uiOptions = (0, import_utils22.getUiOptions)(uiSchema, globalUiOptions);
  if (uiOptions.enableMarkdownInDescription && typeof description === "string") {
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(import_markdown_to_jsx2.default, { options: { disableParsingRawHTML: true }, "data-testid": TEST_IDS.markdown, children: description });
  }
  return description;
}
RichDescription.TEST_IDS = TEST_IDS;

// src/components/templates/DescriptionField.tsx
var import_jsx_runtime23 = require("react/jsx-runtime");
function DescriptionField(props) {
  const { id, description, registry, uiSchema } = props;
  if (!description) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { id, className: "field-description", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(RichDescription, { description, registry, uiSchema }) });
}

// src/components/templates/ErrorList.tsx
var import_utils23 = require("@rjsf/utils");
var import_jsx_runtime24 = require("react/jsx-runtime");
function ErrorList({
  errors,
  registry
}) {
  const { translateString } = registry;
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { className: "panel panel-danger errors", children: [
    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: "panel-heading", children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("h3", { className: "panel-title", children: translateString(import_utils23.TranslatableString.ErrorsLabel) }) }),
    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("ul", { className: "list-group", children: errors.map((error, i) => {
      return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("li", { className: "list-group-item text-danger", children: error.stack }, i);
    }) })
  ] });
}

// src/components/templates/FallbackFieldTemplate.tsx
var import_utils24 = require("@rjsf/utils");
var import_jsx_runtime25 = require("react/jsx-runtime");
function FallbackFieldTemplate(props) {
  const { schema, registry, typeSelector, schemaField } = props;
  const MultiSchemaFieldTemplate2 = (0, import_utils24.getTemplate)(
    "MultiSchemaFieldTemplate",
    registry
  );
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    MultiSchemaFieldTemplate2,
    {
      selector: typeSelector,
      optionSchemaField: schemaField,
      schema,
      registry
    }
  );
}

// src/components/templates/FieldTemplate/FieldTemplate.tsx
var import_utils25 = require("@rjsf/utils");

// src/components/templates/FieldTemplate/Label.tsx
var import_jsx_runtime26 = require("react/jsx-runtime");
var REQUIRED_FIELD_SYMBOL = "*";
function Label(props) {
  const { label, required, id } = props;
  if (!label) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("label", { className: "control-label", htmlFor: id, children: [
    label,
    required && /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { className: "required", children: REQUIRED_FIELD_SYMBOL })
  ] });
}

// src/components/templates/FieldTemplate/FieldTemplate.tsx
var import_jsx_runtime27 = require("react/jsx-runtime");
function FieldTemplate(props) {
  const { id, label, children, errors, help, description, hidden, required, displayLabel, registry, uiSchema } = props;
  const uiOptions = (0, import_utils25.getUiOptions)(uiSchema);
  const WrapIfAdditionalTemplate2 = (0, import_utils25.getTemplate)(
    "WrapIfAdditionalTemplate",
    registry,
    uiOptions
  );
  if (hidden) {
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("div", { className: "hidden", children });
  }
  const isCheckbox = uiOptions.widget === "checkbox";
  return /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(WrapIfAdditionalTemplate2, { ...props, children: [
    displayLabel && !isCheckbox && /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Label, { label, required, id }),
    displayLabel && description ? description : null,
    children,
    errors,
    help
  ] });
}

// src/components/templates/FieldTemplate/index.ts
var FieldTemplate_default = FieldTemplate;

// src/components/templates/FieldErrorTemplate.tsx
var import_utils26 = require("@rjsf/utils");
var import_jsx_runtime28 = require("react/jsx-runtime");
function FieldErrorTemplate(props) {
  const { errors = [], fieldPathId } = props;
  if (errors.length === 0) {
    return null;
  }
  const id = (0, import_utils26.errorId)(fieldPathId);
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("ul", { id, className: "error-detail bs-callout bs-callout-info", children: errors.filter((elem) => !!elem).map((error, index) => {
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("li", { className: "text-danger", children: error }, index);
  }) }) });
}

// src/components/templates/FieldHelpTemplate.tsx
var import_utils28 = require("@rjsf/utils");

// src/components/RichHelp.tsx
var import_utils27 = require("@rjsf/utils");
var import_markdown_to_jsx3 = __toESM(require("markdown-to-jsx"), 1);
var import_jsx_runtime29 = require("react/jsx-runtime");
var TEST_IDS2 = (0, import_utils27.getTestIds)();
function RichHelp({
  help,
  registry,
  uiSchema = {}
}) {
  const { globalUiOptions } = registry;
  const uiOptions = (0, import_utils27.getUiOptions)(uiSchema, globalUiOptions);
  if (uiOptions.enableMarkdownInHelp && typeof help === "string") {
    return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(import_markdown_to_jsx3.default, { options: { disableParsingRawHTML: true }, "data-testid": TEST_IDS2.markdown, children: help });
  }
  return help;
}
RichHelp.TEST_IDS = TEST_IDS2;

// src/components/templates/FieldHelpTemplate.tsx
var import_jsx_runtime30 = require("react/jsx-runtime");
function FieldHelpTemplate(props) {
  const { fieldPathId, help, uiSchema, registry } = props;
  if (!help) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { id: (0, import_utils28.helpId)(fieldPathId), className: "help-block", children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(RichHelp, { help, registry, uiSchema }) });
}

// src/components/templates/GridTemplate.tsx
var import_jsx_runtime31 = require("react/jsx-runtime");
function GridTemplate(props) {
  const { children, column, className, ...rest } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className, ...rest, children });
}

// src/components/templates/MultiSchemaFieldTemplate.tsx
var import_jsx_runtime32 = require("react/jsx-runtime");
function MultiSchemaFieldTemplate(props) {
  const { selector, optionSchemaField } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)("div", { className: "panel panel-default panel-body", children: [
    /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("div", { className: "form-group", children: selector }),
    optionSchemaField
  ] });
}

// src/components/templates/ObjectFieldTemplate.tsx
var import_utils29 = require("@rjsf/utils");
var import_jsx_runtime33 = require("react/jsx-runtime");
function ObjectFieldTemplate(props) {
  const {
    className,
    description,
    disabled,
    formData,
    fieldPathId,
    onAddProperty,
    optionalDataControl,
    properties,
    readonly,
    registry,
    required,
    schema,
    title,
    uiSchema
  } = props;
  const options = (0, import_utils29.getUiOptions)(uiSchema);
  const TitleFieldTemplate = (0, import_utils29.getTemplate)("TitleFieldTemplate", registry, options);
  const DescriptionFieldTemplate = (0, import_utils29.getTemplate)(
    "DescriptionFieldTemplate",
    registry,
    options
  );
  const showOptionalDataControlInTitle = !readonly && !disabled;
  const {
    ButtonTemplates: { AddButton: AddButton2 }
  } = registry.templates;
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { className, id: fieldPathId.$id, children: [
    title && /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      TitleFieldTemplate,
      {
        id: (0, import_utils29.titleId)(fieldPathId),
        title,
        required,
        schema,
        uiSchema,
        registry,
        optionalDataControl: showOptionalDataControlInTitle ? optionalDataControl : void 0
      }
    ),
    description && /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      DescriptionFieldTemplate,
      {
        id: (0, import_utils29.descriptionId)(fieldPathId),
        description,
        schema,
        uiSchema,
        registry
      }
    ),
    !showOptionalDataControlInTitle ? optionalDataControl : void 0,
    properties.map((prop) => prop.content),
    (0, import_utils29.canExpand)(schema, uiSchema, formData) && /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      AddButton2,
      {
        id: (0, import_utils29.buttonId)(fieldPathId, "add"),
        className: "rjsf-object-property-expand",
        onClick: onAddProperty,
        disabled: disabled || readonly,
        uiSchema,
        registry
      }
    )
  ] });
}

// src/components/templates/OptionalDataControlsTemplate.tsx
var import_jsx_runtime34 = require("react/jsx-runtime");
function OptionalDataControlsTemplate(props) {
  const { id, registry, label, onAddClick, onRemoveClick } = props;
  if (onAddClick) {
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      IconButton,
      {
        id,
        registry,
        icon: "plus",
        className: "rjsf-add-optional-data btn-sm",
        onClick: onAddClick,
        title: label
      }
    );
  } else if (onRemoveClick) {
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      IconButton,
      {
        id,
        registry,
        icon: "remove",
        className: "rjsf-remove-optional-data btn-sm",
        onClick: onRemoveClick,
        title: label
      }
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("em", { id, children: label });
}

// src/components/templates/TitleField.tsx
var import_jsx_runtime35 = require("react/jsx-runtime");
var REQUIRED_FIELD_SYMBOL2 = "*";
function TitleField(props) {
  const { id, title, required, optionalDataControl } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("legend", { id, children: [
    title,
    required && /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("span", { className: "required", children: REQUIRED_FIELD_SYMBOL2 }),
    optionalDataControl && /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("span", { className: "pull-right", style: { marginBottom: "2px" }, children: optionalDataControl })
  ] });
}

// src/components/templates/UnsupportedField.tsx
var import_utils30 = require("@rjsf/utils");
var import_markdown_to_jsx4 = __toESM(require("markdown-to-jsx"), 1);
var import_jsx_runtime36 = require("react/jsx-runtime");
function UnsupportedField(props) {
  const { schema, fieldPathId, reason, registry } = props;
  const { translateString } = registry;
  let translateEnum = import_utils30.TranslatableString.UnsupportedField;
  const translateParams = [];
  if (fieldPathId && fieldPathId.$id) {
    translateEnum = import_utils30.TranslatableString.UnsupportedFieldWithId;
    translateParams.push(fieldPathId.$id);
  }
  if (reason) {
    translateEnum = translateEnum === import_utils30.TranslatableString.UnsupportedField ? import_utils30.TranslatableString.UnsupportedFieldWithReason : import_utils30.TranslatableString.UnsupportedFieldWithIdAndReason;
    translateParams.push(reason);
  }
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)("div", { className: "unsupported-field", children: [
    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(import_markdown_to_jsx4.default, { options: { disableParsingRawHTML: true }, children: translateString(translateEnum, translateParams) }) }),
    schema && /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("pre", { children: JSON.stringify(schema, null, 2) })
  ] });
}
var UnsupportedField_default = UnsupportedField;

// src/components/templates/WrapIfAdditionalTemplate.tsx
var import_utils31 = require("@rjsf/utils");
var import_jsx_runtime37 = require("react/jsx-runtime");
function WrapIfAdditionalTemplate(props) {
  const {
    id,
    classNames,
    style,
    disabled,
    displayLabel,
    label,
    onKeyRenameBlur,
    onRemoveProperty,
    rawDescription,
    readonly,
    required,
    schema,
    hideError,
    rawErrors,
    children,
    uiSchema,
    registry
  } = props;
  const { templates: templates2, translateString } = registry;
  const { RemoveButton: RemoveButton2 } = templates2.ButtonTemplates;
  const keyLabel = translateString(import_utils31.TranslatableString.KeyLabel, [label]);
  const additional = import_utils31.ADDITIONAL_PROPERTY_FLAG in schema;
  const hasDescription = !!rawDescription;
  const classNamesList = ["form-group", classNames];
  if (!hideError && rawErrors && rawErrors.length > 0) {
    classNamesList.push("has-error has-danger");
  }
  const uiClassNames = classNamesList.join(" ").trim();
  if (!additional) {
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: uiClassNames, style, children });
  }
  const margin = hasDescription ? 46 : 26;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: uiClassNames, style, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "row", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "col-xs-5 form-additional", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "form-group", children: [
      displayLabel && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Label, { label: keyLabel, required, id: `${id}-key` }),
      displayLabel && rawDescription && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { children: "\xA0" }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
        "input",
        {
          className: "form-control",
          type: "text",
          id: `${id}-key`,
          onBlur: onKeyRenameBlur,
          defaultValue: label
        }
      )
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "form-additional form-group col-xs-5", children }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "col-xs-2", style: { marginTop: displayLabel ? `${margin}px` : void 0 }, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
      RemoveButton2,
      {
        id: (0, import_utils31.buttonId)(id, "remove"),
        className: "rjsf-object-property-remove btn-block",
        style: { border: "0" },
        disabled: disabled || readonly,
        onClick: onRemoveProperty,
        uiSchema,
        registry
      }
    ) })
  ] }) });
}

// src/components/templates/index.ts
function templates() {
  return {
    ArrayFieldDescriptionTemplate,
    ArrayFieldItemTemplate,
    ArrayFieldItemButtonsTemplate,
    ArrayFieldTemplate,
    ArrayFieldTitleTemplate,
    ButtonTemplates: ButtonTemplates_default(),
    BaseInputTemplate,
    DescriptionFieldTemplate: DescriptionField,
    ErrorListTemplate: ErrorList,
    FallbackFieldTemplate,
    FieldTemplate: FieldTemplate_default,
    FieldErrorTemplate,
    FieldHelpTemplate,
    GridTemplate,
    MultiSchemaFieldTemplate,
    ObjectFieldTemplate,
    OptionalDataControlsTemplate,
    TitleFieldTemplate: TitleField,
    UnsupportedFieldTemplate: UnsupportedField_default,
    WrapIfAdditionalTemplate
  };
}
var templates_default = templates;

// src/components/widgets/AltDateWidget.tsx
var import_utils32 = require("@rjsf/utils");
var import_jsx_runtime38 = require("react/jsx-runtime");
function AltDateWidget(props) {
  const { disabled = false, readonly = false, autofocus = false, options, id, name, registry, onBlur, onFocus } = props;
  const { translateString } = registry;
  const { elements, handleChange, handleClear, handleSetNow } = (0, import_utils32.useAltDateWidgetProps)(props);
  return /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)("ul", { className: "list-inline", children: [
    elements.map((elemProps, i) => /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("li", { className: "list-inline-item", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
      import_utils32.DateElement,
      {
        rootId: id,
        name,
        select: handleChange,
        ...elemProps,
        disabled,
        readonly,
        registry,
        onBlur,
        onFocus,
        autofocus: autofocus && i === 0
      }
    ) }, i)),
    (options.hideNowButton !== "undefined" ? !options.hideNowButton : true) && /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("li", { className: "list-inline-item", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("a", { href: "#", className: "btn btn-info btn-now", onClick: handleSetNow, children: translateString(import_utils32.TranslatableString.NowLabel) }) }),
    (options.hideClearButton !== "undefined" ? !options.hideClearButton : true) && /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("li", { className: "list-inline-item", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("a", { href: "#", className: "btn btn-warning btn-clear", onClick: handleClear, children: translateString(import_utils32.TranslatableString.ClearLabel) }) })
  ] });
}
var AltDateWidget_default = AltDateWidget;

// src/components/widgets/AltDateTimeWidget.tsx
var import_jsx_runtime39 = require("react/jsx-runtime");
function AltDateTimeWidget({
  time = true,
  ...props
}) {
  const { AltDateWidget: AltDateWidget2 } = props.registry.widgets;
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(AltDateWidget2, { time, ...props });
}
var AltDateTimeWidget_default = AltDateTimeWidget;

// src/components/widgets/CheckboxWidget.tsx
var import_react13 = require("react");
var import_utils33 = require("@rjsf/utils");
var import_jsx_runtime40 = require("react/jsx-runtime");
function CheckboxWidget({
  schema,
  uiSchema,
  options,
  id,
  value,
  disabled,
  readonly,
  label,
  hideLabel,
  autofocus = false,
  onBlur,
  onFocus,
  onChange,
  registry,
  htmlName
}) {
  const DescriptionFieldTemplate = (0, import_utils33.getTemplate)(
    "DescriptionFieldTemplate",
    registry,
    options
  );
  const required = (0, import_utils33.schemaRequiresTrueValue)(schema);
  const handleChange = (0, import_react13.useCallback)(
    (event) => onChange(event.target.checked),
    [onChange]
  );
  const handleBlur = (0, import_react13.useCallback)(
    (event) => onBlur(id, event.target.checked),
    [onBlur, id]
  );
  const handleFocus = (0, import_react13.useCallback)(
    (event) => onFocus(id, event.target.checked),
    [onFocus, id]
  );
  const uiOptions = (0, import_utils33.getUiOptions)(uiSchema);
  const isCheckboxWidget = uiOptions.widget === "checkbox";
  const description = isCheckboxWidget ? void 0 : options.description ?? schema.description;
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("div", { className: `checkbox ${disabled || readonly ? "disabled" : ""}`, children: [
    !hideLabel && description && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
      DescriptionFieldTemplate,
      {
        id: (0, import_utils33.descriptionId)(id),
        description,
        schema,
        uiSchema,
        registry
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("label", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
        "input",
        {
          type: "checkbox",
          id,
          name: htmlName || id,
          checked: typeof value === "undefined" ? false : value,
          required,
          disabled: disabled || readonly,
          autoFocus: autofocus,
          onChange: handleChange,
          onBlur: handleBlur,
          onFocus: handleFocus,
          "aria-describedby": (0, import_utils33.ariaDescribedByIds)(id)
        }
      ),
      (0, import_utils33.labelValue)(/* @__PURE__ */ (0, import_jsx_runtime40.jsx)("span", { children: label }), hideLabel)
    ] })
  ] });
}
var CheckboxWidget_default = CheckboxWidget;

// src/components/widgets/CheckboxesWidget.tsx
var import_react14 = require("react");
var import_utils34 = require("@rjsf/utils");
var import_jsx_runtime41 = require("react/jsx-runtime");
function CheckboxesWidget({
  id,
  disabled,
  options: { inline = false, enumOptions, enumDisabled, emptyValue },
  value,
  autofocus = false,
  readonly,
  onChange,
  onBlur,
  onFocus,
  htmlName
}) {
  const checkboxesValues = Array.isArray(value) ? value : [value];
  const handleBlur = (0, import_react14.useCallback)(
    ({ target }) => onBlur(id, (0, import_utils34.enumOptionsValueForIndex)(target && target.value, enumOptions, emptyValue)),
    [onBlur, id, enumOptions, emptyValue]
  );
  const handleFocus = (0, import_react14.useCallback)(
    ({ target }) => onFocus(id, (0, import_utils34.enumOptionsValueForIndex)(target && target.value, enumOptions, emptyValue)),
    [onFocus, id, enumOptions, emptyValue]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("div", { className: "checkboxes", id, children: Array.isArray(enumOptions) && enumOptions.map((option, index) => {
    const checked = (0, import_utils34.enumOptionsIsSelected)(option.value, checkboxesValues);
    const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
    const disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
    const handleChange = (event) => {
      if (event.target.checked) {
        onChange((0, import_utils34.enumOptionsSelectValue)(index, checkboxesValues, enumOptions));
      } else {
        onChange((0, import_utils34.enumOptionsDeselectValue)(index, checkboxesValues, enumOptions));
      }
    };
    const checkbox = /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)("span", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
        "input",
        {
          type: "checkbox",
          id: (0, import_utils34.optionId)(id, index),
          name: htmlName || id,
          checked,
          value: String(index),
          disabled: disabled || itemDisabled || readonly,
          autoFocus: autofocus && index === 0,
          onChange: handleChange,
          onBlur: handleBlur,
          onFocus: handleFocus,
          "aria-describedby": (0, import_utils34.ariaDescribedByIds)(id)
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("span", { children: option.label })
    ] });
    return inline ? /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("label", { className: `checkbox-inline ${disabledCls}`, children: checkbox }, index) : /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("div", { className: `checkbox ${disabledCls}`, children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("label", { children: checkbox }) }, index);
  }) });
}
var CheckboxesWidget_default = CheckboxesWidget;

// src/components/widgets/ColorWidget.tsx
var import_utils35 = require("@rjsf/utils");
var import_jsx_runtime42 = require("react/jsx-runtime");
function ColorWidget(props) {
  const { disabled, readonly, options, registry } = props;
  const BaseInputTemplate2 = (0, import_utils35.getTemplate)("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(BaseInputTemplate2, { type: "color", ...props, disabled: disabled || readonly });
}

// src/components/widgets/DateWidget.tsx
var import_react15 = require("react");
var import_utils36 = require("@rjsf/utils");
var import_jsx_runtime43 = require("react/jsx-runtime");
function DateWidget(props) {
  const { onChange, options, registry } = props;
  const BaseInputTemplate2 = (0, import_utils36.getTemplate)("BaseInputTemplate", registry, options);
  const handleChange = (0, import_react15.useCallback)((value) => onChange(value || void 0), [onChange]);
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(BaseInputTemplate2, { type: "date", ...props, onChange: handleChange });
}

// src/components/widgets/DateTimeWidget.tsx
var import_utils37 = require("@rjsf/utils");
var import_jsx_runtime44 = require("react/jsx-runtime");
function DateTimeWidget(props) {
  const { onChange, value, options, registry } = props;
  const BaseInputTemplate2 = (0, import_utils37.getTemplate)("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
    BaseInputTemplate2,
    {
      type: "datetime-local",
      ...props,
      value: (0, import_utils37.utcToLocal)(value),
      onChange: (value2) => onChange((0, import_utils37.localToUTC)(value2))
    }
  );
}

// src/components/widgets/EmailWidget.tsx
var import_utils38 = require("@rjsf/utils");
var import_jsx_runtime45 = require("react/jsx-runtime");
function EmailWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = (0, import_utils38.getTemplate)("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(BaseInputTemplate2, { type: "email", ...props });
}

// src/components/widgets/FileWidget.tsx
var import_utils39 = require("@rjsf/utils");
var import_markdown_to_jsx5 = __toESM(require("markdown-to-jsx"), 1);
var import_jsx_runtime46 = require("react/jsx-runtime");
function FileInfoPreview({
  fileInfo,
  registry
}) {
  const { translateString } = registry;
  const { dataURL, type, name } = fileInfo;
  if (!dataURL) {
    return null;
  }
  if (["image/jpeg", "image/png"].includes(type)) {
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("img", { src: dataURL, style: { maxWidth: "100%" }, className: "file-preview" });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
    " ",
    /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("a", { download: `preview-${name}`, href: dataURL, className: "file-download", children: translateString(import_utils39.TranslatableString.PreviewLabel) })
  ] });
}
function FilesInfo({
  filesInfo,
  registry,
  preview,
  onRemove,
  options
}) {
  if (filesInfo.length === 0) {
    return null;
  }
  const { translateString } = registry;
  const { RemoveButton: RemoveButton2 } = (0, import_utils39.getTemplate)("ButtonTemplates", registry, options);
  return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("ul", { className: "file-info", children: filesInfo.map((fileInfo, key) => {
    const { name, size, type } = fileInfo;
    const handleRemove = () => onRemove(key);
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("li", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(import_markdown_to_jsx5.default, { children: translateString(import_utils39.TranslatableString.FilesInfo, [name, type, String(size)]) }),
      preview && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(FileInfoPreview, { fileInfo, registry }),
      /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(RemoveButton2, { onClick: handleRemove, registry })
    ] }, key);
  }) });
}
function FileWidget(props) {
  const { disabled, readonly, required, multiple, onChange, value, options, registry } = props;
  const { filesInfo, handleChange, handleRemove } = (0, import_utils39.useFileWidgetProps)(value, onChange, multiple);
  const BaseInputTemplate2 = (0, import_utils39.getTemplate)("BaseInputTemplate", registry, options);
  const handleOnChangeEvent = (event) => {
    if (event.target.files) {
      handleChange(event.target.files);
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
      BaseInputTemplate2,
      {
        ...props,
        disabled: disabled || readonly,
        type: "file",
        required: value ? false : required,
        onChangeOverride: handleOnChangeEvent,
        value: "",
        accept: options.accept ? String(options.accept) : void 0
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
      FilesInfo,
      {
        filesInfo,
        onRemove: handleRemove,
        registry,
        preview: options.filePreview,
        options
      }
    )
  ] });
}
var FileWidget_default = FileWidget;

// src/components/widgets/HiddenWidget.tsx
var import_jsx_runtime47 = require("react/jsx-runtime");
function HiddenWidget({
  id,
  value,
  htmlName
}) {
  return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("input", { type: "hidden", id, name: htmlName || id, value: typeof value === "undefined" ? "" : value });
}
var HiddenWidget_default = HiddenWidget;

// src/components/widgets/PasswordWidget.tsx
var import_utils40 = require("@rjsf/utils");
var import_jsx_runtime48 = require("react/jsx-runtime");
function PasswordWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = (0, import_utils40.getTemplate)("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(BaseInputTemplate2, { type: "password", ...props });
}

// src/components/widgets/RadioWidget.tsx
var import_react16 = require("react");
var import_utils41 = require("@rjsf/utils");
var import_jsx_runtime49 = require("react/jsx-runtime");
function RadioWidget({
  options,
  value,
  required,
  disabled,
  readonly,
  autofocus = false,
  onBlur,
  onFocus,
  onChange,
  id,
  htmlName
}) {
  const { enumOptions, enumDisabled, inline, emptyValue } = options;
  const handleBlur = (0, import_react16.useCallback)(
    ({ target }) => onBlur(id, (0, import_utils41.enumOptionsValueForIndex)(target && target.value, enumOptions, emptyValue)),
    [onBlur, enumOptions, emptyValue, id]
  );
  const handleFocus = (0, import_react16.useCallback)(
    ({ target }) => onFocus(id, (0, import_utils41.enumOptionsValueForIndex)(target && target.value, enumOptions, emptyValue)),
    [onFocus, enumOptions, emptyValue, id]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("div", { className: "field-radio-group", id, role: "radiogroup", children: Array.isArray(enumOptions) && enumOptions.map((option, i) => {
    const checked = (0, import_utils41.enumOptionsIsSelected)(option.value, value);
    const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
    const disabledCls = disabled || itemDisabled || readonly ? "disabled" : "";
    const handleChange = () => onChange(option.value);
    const radio = /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)("span", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
        "input",
        {
          type: "radio",
          id: (0, import_utils41.optionId)(id, i),
          checked,
          name: htmlName || id,
          required,
          value: String(i),
          disabled: disabled || itemDisabled || readonly,
          autoFocus: autofocus && i === 0,
          onChange: handleChange,
          onBlur: handleBlur,
          onFocus: handleFocus,
          "aria-describedby": (0, import_utils41.ariaDescribedByIds)(id)
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("span", { children: option.label })
    ] });
    return inline ? /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("label", { className: `radio-inline ${disabledCls}`, children: radio }, i) : /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("div", { className: `radio ${disabledCls}`, children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("label", { children: radio }) }, i);
  }) });
}
var RadioWidget_default = RadioWidget;

// src/components/widgets/RangeWidget.tsx
var import_jsx_runtime50 = require("react/jsx-runtime");
function RangeWidget(props) {
  const {
    value,
    registry: {
      templates: { BaseInputTemplate: BaseInputTemplate2 }
    }
  } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)("div", { className: "field-range-wrapper", children: [
    /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(BaseInputTemplate2, { type: "range", ...props }),
    /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("span", { className: "range-view", children: value })
  ] });
}

// src/components/widgets/RatingWidget.tsx
var import_react17 = require("react");
var import_jsx_runtime51 = require("react/jsx-runtime");
function RatingWidget({
  id,
  value,
  required,
  disabled,
  readonly,
  autofocus,
  onChange,
  onFocus,
  onBlur,
  schema,
  options,
  htmlName
}) {
  const { stars = 5, shape = "star" } = options;
  const numStars = schema.maximum ? Math.min(schema.maximum, 5) : Math.min(Math.max(stars, 1), 5);
  const min = schema.minimum || 0;
  const handleStarClick = (0, import_react17.useCallback)(
    (starValue) => {
      if (!disabled && !readonly) {
        onChange(starValue);
      }
    },
    [onChange, disabled, readonly]
  );
  const handleFocus = (0, import_react17.useCallback)(
    (event) => {
      if (onFocus) {
        const starValue = Number(event.target.dataset.value);
        onFocus(id, starValue);
      }
    },
    [onFocus, id]
  );
  const handleBlur = (0, import_react17.useCallback)(
    (event) => {
      if (onBlur) {
        const starValue = Number(event.target.dataset.value);
        onBlur(id, starValue);
      }
    },
    [onBlur, id]
  );
  const getSymbol = (isFilled) => {
    if (shape === "heart") {
      return isFilled ? "\u2665" : "\u2661";
    }
    return isFilled ? "\u2605" : "\u2606";
  };
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(import_jsx_runtime51.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(
    "div",
    {
      className: "rating-widget",
      style: {
        display: "inline-flex",
        fontSize: "1.5rem",
        cursor: disabled || readonly ? "default" : "pointer"
      },
      children: [
        [...Array(numStars)].map((_, index) => {
          const starValue = min + index;
          const isFilled = starValue <= value;
          return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
            "span",
            {
              onClick: () => handleStarClick(starValue),
              onFocus: handleFocus,
              onBlur: handleBlur,
              "data-value": starValue,
              tabIndex: disabled || readonly ? -1 : 0,
              role: "radio",
              "aria-checked": starValue === value,
              "aria-label": `${starValue} ${shape === "heart" ? "heart" : "star"}${starValue === 1 ? "" : "s"}`,
              style: {
                color: isFilled ? "#FFD700" : "#ccc",
                padding: "0 0.2rem",
                transition: "color 0.2s",
                userSelect: "none"
              },
              children: getSymbol(isFilled)
            },
            index
          );
        }),
        /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
          "input",
          {
            type: "hidden",
            id,
            name: htmlName || id,
            value: value || "",
            required,
            disabled: disabled || readonly,
            "aria-hidden": "true"
          }
        )
      ]
    }
  ) });
}

// src/components/widgets/SelectWidget.tsx
var import_react18 = require("react");
var import_utils42 = require("@rjsf/utils");
var import_jsx_runtime52 = require("react/jsx-runtime");
function getValue(event, multiple) {
  if (multiple) {
    return Array.from(event.target.options).slice().filter((o) => o.selected).map((o) => o.value);
  }
  return event.target.value;
}
function SelectWidget({
  schema,
  id,
  options,
  value,
  required,
  disabled,
  readonly,
  multiple = false,
  autofocus = false,
  onChange,
  onBlur,
  onFocus,
  placeholder,
  htmlName
}) {
  const { enumOptions, enumDisabled, emptyValue: optEmptyVal } = options;
  const emptyValue = multiple ? [] : "";
  const handleFocus = (0, import_react18.useCallback)(
    (event) => {
      const newValue = getValue(event, multiple);
      return onFocus(id, (0, import_utils42.enumOptionsValueForIndex)(newValue, enumOptions, optEmptyVal));
    },
    [onFocus, id, multiple, enumOptions, optEmptyVal]
  );
  const handleBlur = (0, import_react18.useCallback)(
    (event) => {
      const newValue = getValue(event, multiple);
      return onBlur(id, (0, import_utils42.enumOptionsValueForIndex)(newValue, enumOptions, optEmptyVal));
    },
    [onBlur, id, multiple, enumOptions, optEmptyVal]
  );
  const handleChange = (0, import_react18.useCallback)(
    (event) => {
      const newValue = getValue(event, multiple);
      return onChange((0, import_utils42.enumOptionsValueForIndex)(newValue, enumOptions, optEmptyVal));
    },
    [onChange, multiple, enumOptions, optEmptyVal]
  );
  const selectedIndexes = (0, import_utils42.enumOptionsIndexForValue)(value, enumOptions, multiple);
  const showPlaceholderOption = !multiple && schema.default === void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(
    "select",
    {
      id,
      name: htmlName || id,
      multiple,
      role: "combobox",
      className: "form-control",
      value: typeof selectedIndexes === "undefined" ? emptyValue : selectedIndexes,
      required,
      disabled: disabled || readonly,
      autoFocus: autofocus,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onChange: handleChange,
      "aria-describedby": (0, import_utils42.ariaDescribedByIds)(id),
      children: [
        showPlaceholderOption && /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("option", { value: "", children: placeholder }),
        Array.isArray(enumOptions) && enumOptions.map(({ value: value2, label }, i) => {
          const disabled2 = enumDisabled && enumDisabled.indexOf(value2) !== -1;
          return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("option", { value: String(i), disabled: disabled2, children: label }, i);
        })
      ]
    }
  );
}
var SelectWidget_default = SelectWidget;

// src/components/widgets/TextareaWidget.tsx
var import_react19 = require("react");
var import_utils43 = require("@rjsf/utils");
var import_jsx_runtime53 = require("react/jsx-runtime");
function TextareaWidget({
  id,
  options = {},
  placeholder,
  value,
  required,
  disabled,
  readonly,
  autofocus = false,
  onChange,
  onBlur,
  onFocus,
  htmlName
}) {
  const handleChange = (0, import_react19.useCallback)(
    ({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2),
    [onChange, options.emptyValue]
  );
  const handleBlur = (0, import_react19.useCallback)(
    ({ target }) => onBlur(id, target && target.value),
    [onBlur, id]
  );
  const handleFocus = (0, import_react19.useCallback)(
    ({ target }) => onFocus(id, target && target.value),
    [id, onFocus]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
    "textarea",
    {
      id,
      name: htmlName || id,
      className: "form-control",
      value: value ? value : "",
      placeholder,
      required,
      disabled,
      readOnly: readonly,
      autoFocus: autofocus,
      rows: options.rows,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onChange: handleChange,
      "aria-describedby": (0, import_utils43.ariaDescribedByIds)(id)
    }
  );
}
TextareaWidget.defaultProps = {
  autofocus: false,
  options: {}
};
var TextareaWidget_default = TextareaWidget;

// src/components/widgets/TextWidget.tsx
var import_utils44 = require("@rjsf/utils");
var import_jsx_runtime54 = require("react/jsx-runtime");
function TextWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = (0, import_utils44.getTemplate)("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(BaseInputTemplate2, { ...props });
}

// src/components/widgets/TimeWidget.tsx
var import_react20 = require("react");
var import_utils45 = require("@rjsf/utils");
var import_jsx_runtime55 = require("react/jsx-runtime");
function TimeWidget(props) {
  const { onChange, options, registry } = props;
  const BaseInputTemplate2 = (0, import_utils45.getTemplate)("BaseInputTemplate", registry, options);
  const handleChange = (0, import_react20.useCallback)((value) => onChange(value ? `${value}:00` : void 0), [onChange]);
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(BaseInputTemplate2, { type: "time", ...props, onChange: handleChange });
}

// src/components/widgets/URLWidget.tsx
var import_utils46 = require("@rjsf/utils");
var import_jsx_runtime56 = require("react/jsx-runtime");
function URLWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = (0, import_utils46.getTemplate)("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(BaseInputTemplate2, { type: "url", ...props });
}

// src/components/widgets/UpDownWidget.tsx
var import_utils47 = require("@rjsf/utils");
var import_jsx_runtime57 = require("react/jsx-runtime");
function UpDownWidget(props) {
  const { options, registry } = props;
  const BaseInputTemplate2 = (0, import_utils47.getTemplate)("BaseInputTemplate", registry, options);
  return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(BaseInputTemplate2, { type: "number", ...props });
}

// src/components/widgets/index.ts
function widgets() {
  return {
    AltDateWidget: AltDateWidget_default,
    AltDateTimeWidget: AltDateTimeWidget_default,
    CheckboxWidget: CheckboxWidget_default,
    CheckboxesWidget: CheckboxesWidget_default,
    ColorWidget,
    DateWidget,
    DateTimeWidget,
    EmailWidget,
    FileWidget: FileWidget_default,
    HiddenWidget: HiddenWidget_default,
    PasswordWidget,
    RadioWidget: RadioWidget_default,
    RangeWidget,
    RatingWidget,
    SelectWidget: SelectWidget_default,
    TextWidget,
    TextareaWidget: TextareaWidget_default,
    TimeWidget,
    UpDownWidget,
    URLWidget
  };
}
var widgets_default = widgets;

// src/getDefaultRegistry.ts
function getDefaultRegistry() {
  return {
    fields: fields_default(),
    templates: templates_default(),
    widgets: widgets_default(),
    rootSchema: {},
    formContext: {},
    translateString: import_utils48.englishStringTranslator,
    globalFormOptions: {
      idPrefix: import_utils48.DEFAULT_ID_PREFIX,
      idSeparator: import_utils48.DEFAULT_ID_SEPARATOR,
      useFallbackUiForUnsupportedType: false
    }
  };
}

// src/components/Form.tsx
var import_jsx_runtime58 = require("react/jsx-runtime");
function toIChangeEvent(state, status) {
  return {
    ...(0, import_pick.default)(state, ["schema", "uiSchema", "fieldPathId", "schemaUtils", "formData", "edit", "errors", "errorSchema"]),
    ...status !== void 0 && { status }
  };
}
var Form = class extends import_react21.Component {
  /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can
   * provide any possible type here
   */
  formElement;
  /** The list of pending changes
   */
  pendingChanges = [];
  /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
   * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
   * state construction.
   *
   * @param props - The initial props for the `Form`
   */
  constructor(props) {
    super(props);
    if (!props.validator) {
      throw new Error("A validator is required for Form functionality to work");
    }
    const { formData: propsFormData, initialFormData, onChange } = props;
    const formData = propsFormData ?? initialFormData;
    this.state = this.getStateFromProps(props, formData, void 0, void 0, void 0, true);
    if (onChange && !(0, import_utils49.deepEquals)(this.state.formData, formData)) {
      onChange(toIChangeEvent(this.state));
    }
    this.formElement = (0, import_react21.createRef)();
  }
  /**
   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
   * they are potentially changed.
   *
   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
   * state ready to be applied in `componentDidUpdate`.
   *
   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
   * state update is not necessary.
   *
   * @param prevProps - The previous set of props before the update.
   * @param prevState - The previous state before the update.
   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
   *        with a flag indicating that an update is not necessary.
   */
  getSnapshotBeforeUpdate(prevProps, prevState) {
    if (!(0, import_utils49.deepEquals)(this.props, prevProps)) {
      const formDataChangedFields = (0, import_utils49.getChangedFields)(this.props.formData, prevProps.formData);
      const stateDataChangedFields = (0, import_utils49.getChangedFields)(this.props.formData, this.state.formData);
      const isSchemaChanged = !(0, import_utils49.deepEquals)(prevProps.schema, this.props.schema);
      const isFormDataChanged = formDataChangedFields.length > 0 || !(0, import_utils49.deepEquals)(prevProps.formData, this.props.formData);
      const isStateDataChanged = stateDataChangedFields.length > 0 || !(0, import_utils49.deepEquals)(this.state.formData, this.props.formData);
      const nextState = this.getStateFromProps(
        this.props,
        this.props.formData,
        // If the `schema` has changed, we need to update the retrieved schema.
        // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
        //  match one of the subSchemas, the retrieved schema must be updated.
        isSchemaChanged || isFormDataChanged ? void 0 : this.state.retrievedSchema,
        isSchemaChanged,
        formDataChangedFields,
        // Skip live validation for this request if no form data has changed from the last state
        !isStateDataChanged
      );
      const shouldUpdate = !(0, import_utils49.deepEquals)(nextState, prevState);
      return { nextState, shouldUpdate };
    }
    return { shouldUpdate: false };
  }
  /**
   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
   * not called for the initial render.
   *
   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
   * changes.
   *
   * @param _ - The previous set of props.
   * @param prevState - The previous state of the component before the update.
   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
   */
  componentDidUpdate(_, prevState, snapshot) {
    if (snapshot.shouldUpdate) {
      const { nextState } = snapshot;
      if (!(0, import_utils49.deepEquals)(nextState.formData, this.props.formData) && !(0, import_utils49.deepEquals)(nextState.formData, prevState.formData) && this.props.onChange) {
        this.props.onChange(toIChangeEvent(nextState));
      }
      this.setState(nextState);
    }
  }
  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
   * validation process IF required by the `props`.
   *
   * @param props - The props passed to the `Form`
   * @param inputFormData - The new or current data for the `Form`
   * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
   * @param isSchemaChanged - A flag indicating whether the schema has changed.
   * @param formDataChangedFields - The changed fields of `formData`
   * @param skipLiveValidate - Optional flag, if true, means that we are not running live validation
   * @returns - The new state for the `Form`
   */
  getStateFromProps(props, inputFormData, retrievedSchema, isSchemaChanged = false, formDataChangedFields = [], skipLiveValidate = false) {
    const state = this.state || {};
    const schema = "schema" in props ? props.schema : this.props.schema;
    const validator2 = "validator" in props ? props.validator : this.props.validator;
    const uiSchema = ("uiSchema" in props ? props.uiSchema : this.props.uiSchema) || {};
    const isUncontrolled = props.formData === void 0 && this.props.formData === void 0;
    const edit = typeof inputFormData !== "undefined";
    const liveValidate = "liveValidate" in props ? props.liveValidate : this.props.liveValidate;
    const mustValidate = edit && !props.noValidate && liveValidate;
    const experimental_defaultFormStateBehavior = "experimental_defaultFormStateBehavior" in props ? props.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior;
    const experimental_customMergeAllOf = "experimental_customMergeAllOf" in props ? props.experimental_customMergeAllOf : this.props.experimental_customMergeAllOf;
    let schemaUtils = state.schemaUtils;
    if (!schemaUtils || schemaUtils.doesSchemaUtilsDiffer(
      validator2,
      schema,
      experimental_defaultFormStateBehavior,
      experimental_customMergeAllOf
    )) {
      schemaUtils = (0, import_utils49.createSchemaUtils)(
        validator2,
        schema,
        experimental_defaultFormStateBehavior,
        experimental_customMergeAllOf
      );
    }
    const rootSchema = schemaUtils.getRootSchema();
    let defaultsFormData = inputFormData;
    if (inputFormData === IS_RESET) {
      defaultsFormData = void 0;
    } else if (inputFormData === void 0 && isUncontrolled) {
      defaultsFormData = state.formData;
    }
    const formData = schemaUtils.getDefaultFormState(
      rootSchema,
      defaultsFormData,
      false,
      state.initialDefaultsGenerated
    );
    const _retrievedSchema = this.updateRetrievedSchema(
      retrievedSchema ?? schemaUtils.retrieveSchema(rootSchema, formData)
    );
    const getCurrentErrors = () => {
      if (props.noValidate || isSchemaChanged) {
        return { errors: [], errorSchema: {} };
      } else if (!props.liveValidate) {
        return {
          errors: state.schemaValidationErrors || [],
          errorSchema: state.schemaValidationErrorSchema || {}
        };
      }
      return {
        errors: state.errors || [],
        errorSchema: state.errorSchema || {}
      };
    };
    let errors;
    let errorSchema;
    let schemaValidationErrors = state.schemaValidationErrors;
    let schemaValidationErrorSchema = state.schemaValidationErrorSchema;
    if (mustValidate && !skipLiveValidate) {
      const liveValidation = this.liveValidate(
        rootSchema,
        schemaUtils,
        state.errorSchema,
        formData,
        void 0,
        state.customErrors,
        retrievedSchema,
        // If retrievedSchema is undefined which means the schema or formData has changed, we do not merge state.
        // Else in the case where it hasn't changed,
        retrievedSchema !== void 0
      );
      errors = liveValidation.errors;
      errorSchema = liveValidation.errorSchema;
      schemaValidationErrors = liveValidation.schemaValidationErrors;
      schemaValidationErrorSchema = liveValidation.schemaValidationErrorSchema;
    } else {
      const currentErrors = getCurrentErrors();
      errors = currentErrors.errors;
      errorSchema = currentErrors.errorSchema;
      if (formDataChangedFields.length > 0 && !mustValidate) {
        const newErrorSchema = formDataChangedFields.reduce(
          (acc, key) => {
            acc[key] = void 0;
            return acc;
          },
          {}
        );
        errorSchema = schemaValidationErrorSchema = (0, import_utils49.mergeObjects)(
          currentErrors.errorSchema,
          newErrorSchema,
          "preventDuplicates"
        );
      }
      const mergedErrors = this.mergeErrors({ errorSchema, errors }, props.extraErrors, state.customErrors);
      errors = mergedErrors.errors;
      errorSchema = mergedErrors.errorSchema;
    }
    const newRegistry = this.getRegistry(props, rootSchema, schemaUtils);
    const registry = (0, import_utils49.deepEquals)(state.registry, newRegistry) ? state.registry : newRegistry;
    const fieldPathId = state.fieldPathId && state.fieldPathId?.[import_utils49.ID_KEY] === registry.globalFormOptions.idPrefix ? state.fieldPathId : (0, import_utils49.toFieldPathId)("", registry.globalFormOptions);
    const nextState = {
      schemaUtils,
      schema: rootSchema,
      uiSchema,
      fieldPathId,
      formData,
      edit,
      errors,
      errorSchema,
      schemaValidationErrors,
      schemaValidationErrorSchema,
      retrievedSchema: _retrievedSchema,
      initialDefaultsGenerated: true,
      registry
    };
    return nextState;
  }
  /** React lifecycle method that is used to determine whether component should be updated.
   *
   * @param nextProps - The next version of the props
   * @param nextState - The next version of the state
   * @returns - True if the component should be updated, false otherwise
   */
  shouldComponentUpdate(nextProps, nextState) {
    const { experimental_componentUpdateStrategy = "customDeep" } = this.props;
    return (0, import_utils49.shouldRender)(this, nextProps, nextState, experimental_componentUpdateStrategy);
  }
  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
   * `schemaUtils` in the state), returning the results.
   *
   * @param formData - The new form data to validate
   * @param schema - The schema used to validate against
   * @param [altSchemaUtils] - The alternate schemaUtils to use for validation
   * @param [retrievedSchema] - An optionally retrieved schema for per
   */
  validate(formData, schema = this.state.schema, altSchemaUtils, retrievedSchema) {
    const schemaUtils = altSchemaUtils ? altSchemaUtils : this.state.schemaUtils;
    const { customValidate, transformErrors, uiSchema } = this.props;
    const resolvedSchema = retrievedSchema ?? schemaUtils.retrieveSchema(schema, formData);
    return schemaUtils.getValidator().validateFormData(formData, resolvedSchema, customValidate, transformErrors, uiSchema);
  }
  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
  renderErrors(registry) {
    const { errors, errorSchema, schema, uiSchema } = this.state;
    const options = (0, import_utils49.getUiOptions)(uiSchema);
    const ErrorListTemplate = (0, import_utils49.getTemplate)("ErrorListTemplate", registry, options);
    if (errors && errors.length) {
      return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
        ErrorListTemplate,
        {
          errors,
          errorSchema: errorSchema || {},
          schema,
          uiSchema,
          registry
        }
      );
    }
    return null;
  }
  /** Merges any `extraErrors` or `customErrors` into the given `schemaValidation` object, returning the result
   *
   * @param schemaValidation - The `ValidationData` object into which additional errors are merged
   * @param [extraErrors] - The extra errors from the props
   * @param [customErrors] - The customErrors from custom components
   * @return - The `extraErrors` and `customErrors` merged into the `schemaValidation`
   * @private
   */
  mergeErrors(schemaValidation, extraErrors, customErrors) {
    let errorSchema = schemaValidation.errorSchema;
    let errors = schemaValidation.errors;
    if (extraErrors) {
      const merged = (0, import_utils49.validationDataMerge)(schemaValidation, extraErrors);
      errorSchema = merged.errorSchema;
      errors = merged.errors;
    }
    if (customErrors) {
      const merged = (0, import_utils49.validationDataMerge)(schemaValidation, customErrors.ErrorSchema, true);
      errorSchema = merged.errorSchema;
      errors = merged.errors;
    }
    return { errors, errorSchema };
  }
  /** Performs live validation and then updates and returns the errors and error schemas by potentially merging in
   * `extraErrors` and `customErrors`.
   *
   * @param rootSchema - The `rootSchema` from the state
   * @param schemaUtils - The `SchemaUtilsType` from the state
   * @param originalErrorSchema - The original `ErrorSchema` from the state
   * @param [formData] - The new form data to validate
   * @param [extraErrors] - The extra errors from the props
   * @param [customErrors] - The customErrors from custom components
   * @param [retrievedSchema] - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`
   * @param [mergeIntoOriginalErrorSchema=false] - Optional flag indicating whether we merge into original schema
   * @returns - An object containing `errorSchema`, `errors`, `schemaValidationErrors` and `schemaValidationErrorSchema`
   * @private
   */
  liveValidate(rootSchema, schemaUtils, originalErrorSchema, formData, extraErrors, customErrors, retrievedSchema, mergeIntoOriginalErrorSchema = false) {
    const schemaValidation = this.validate(formData, rootSchema, schemaUtils, retrievedSchema);
    const errors = schemaValidation.errors;
    let errorSchema = schemaValidation.errorSchema;
    if (mergeIntoOriginalErrorSchema) {
      errorSchema = (0, import_utils49.mergeObjects)(
        originalErrorSchema,
        schemaValidation.errorSchema,
        "preventDuplicates"
      );
    }
    const schemaValidationErrors = errors;
    const schemaValidationErrorSchema = errorSchema;
    const mergedErrors = this.mergeErrors({ errorSchema, errors }, extraErrors, customErrors);
    return { ...mergedErrors, schemaValidationErrors, schemaValidationErrorSchema };
  }
  /** Returns the `formData` with only the elements specified in the `fields` list
   *
   * @param formData - The data for the `Form`
   * @param fields - The fields to keep while filtering
   */
  getUsedFormData = (formData, fields2) => {
    if (fields2.length === 0 && typeof formData !== "object") {
      return formData;
    }
    const data = (0, import_pick.default)(formData, fields2);
    if (Array.isArray(formData)) {
      return Object.keys(data).map((key) => data[key]);
    }
    return data;
  };
  /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
   *
   * @param pathSchema - The `PathSchema` object for the form
   * @param [formData] - The form data to use while checking for empty objects/arrays
   */
  getFieldNames = (pathSchema, formData) => {
    const formValueHasData = (value, isLeaf) => typeof value !== "object" || (0, import_isEmpty4.default)(value) || isLeaf && !(0, import_isEmpty4.default)(value);
    const getAllPaths = (_obj, acc = [], paths = [[]]) => {
      const objKeys = Object.keys(_obj);
      objKeys.forEach((key) => {
        const data = _obj[key];
        if (typeof data === "object") {
          const newPaths = paths.map((path) => [...path, key]);
          if (data[import_utils49.RJSF_ADDITIONAL_PROPERTIES_FLAG] && data[import_utils49.NAME_KEY] !== "") {
            acc.push(data[import_utils49.NAME_KEY]);
          } else {
            getAllPaths(data, acc, newPaths);
          }
        } else if (key === import_utils49.NAME_KEY && data !== "") {
          paths.forEach((path) => {
            const formValue = (0, import_get5.default)(formData, path);
            const isLeaf = objKeys.length === 1;
            if (formValueHasData(formValue, isLeaf) || Array.isArray(formValue) && formValue.every((val) => formValueHasData(val, isLeaf))) {
              acc.push(path);
            }
          });
        }
      });
      return acc;
    };
    return getAllPaths(pathSchema);
  };
  /** Returns the `formData` after filtering to remove any extra data not in a form field
   *
   * @param formData - The data for the `Form`
   * @returns The `formData` after omitting extra data
   */
  omitExtraData = (formData) => {
    const { schema, schemaUtils } = this.state;
    const retrievedSchema = schemaUtils.retrieveSchema(schema, formData);
    const pathSchema = schemaUtils.toPathSchema(retrievedSchema, "", formData);
    const fieldNames = this.getFieldNames(pathSchema, formData);
    return this.getUsedFormData(formData, fieldNames);
  };
  /** Allows a user to set a value for the provided `fieldPath`, which must be either a dotted path to the field OR a
   * `FieldPathList`. To set the root element, used either `''` or `[]` for the path. Passing undefined will clear the
   * value in the field.
   *
   * @param fieldPath - Either a dotted path to the field or the `FieldPathList` to the field
   * @param [newValue] - The new value for the field
   */
  setFieldValue = (fieldPath, newValue) => {
    const { registry } = this.state;
    const path = Array.isArray(fieldPath) ? fieldPath : fieldPath.split(".");
    const fieldPathId = (0, import_utils49.toFieldPathId)("", registry.globalFormOptions, path);
    this.onChange(newValue, path, void 0, fieldPathId[import_utils49.ID_KEY]);
  };
  /** Pushes the given change information into the `pendingChanges` array and then calls `processPendingChanges()` if
   * the array only contains a single pending change.
   *
   * @param newValue - The new form data from a change to a field
   * @param path - The path to the change into which to set the formData
   * @param [newErrorSchema] - The new `ErrorSchema` based on the field change
   * @param [id] - The id of the field that caused the change
   */
  onChange = (newValue, path, newErrorSchema, id) => {
    this.pendingChanges.push({ newValue, path, newErrorSchema, id });
    if (this.pendingChanges.length === 1) {
      this.processPendingChange();
    }
  };
  /** Function to handle changes made to a field in the `Form`. This handler gets the first change from the
   * `pendingChanges` list, containing the `newValue` for the `formData` and the `path` at which the `newValue` is to be
   * updated, along with a new, optional `ErrorSchema` for that same `path` and potentially the `id` of the field being
   * changed. It will first update the `formData` with any missing default fields and then, if `omitExtraData` and
   * `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not in a form field. Then, the
   * resulting `formData` will be validated if required. The state will be updated with the new updated (potentially
   * filtered) `formData`, any errors that resulted from validation. Finally the `onChange` callback will be called, if
   * specified, with the updated state and the `processPendingChange()` function is called again.
   */
  processPendingChange() {
    if (this.pendingChanges.length === 0) {
      return;
    }
    const { newValue, path, id } = this.pendingChanges[0];
    const { newErrorSchema } = this.pendingChanges[0];
    const { extraErrors, omitExtraData, liveOmit, noValidate, liveValidate, onChange } = this.props;
    const { formData: oldFormData, schemaUtils, schema, fieldPathId, schemaValidationErrorSchema, errors } = this.state;
    let { customErrors, errorSchema: originalErrorSchema } = this.state;
    const rootPathId = fieldPathId.path[0] || "";
    const isRootPath = !path || path.length === 0 || path.length === 1 && path[0] === rootPathId;
    let retrievedSchema = this.state.retrievedSchema;
    let formData = isRootPath ? newValue : (0, import_cloneDeep2.default)(oldFormData);
    if ((0, import_utils49.isObject)(formData) || Array.isArray(formData)) {
      if (newValue === ADDITIONAL_PROPERTY_KEY_REMOVE) {
        (0, import_unset.default)(formData, path);
      } else if (!isRootPath) {
        (0, import_set5.default)(formData, path, newValue);
      }
      const newState = this.getStateFromProps(this.props, formData, void 0, void 0, void 0, true);
      formData = newState.formData;
      retrievedSchema = newState.retrievedSchema;
    }
    const mustValidate = !noValidate && (liveValidate === true || liveValidate === "onChange");
    let state = { formData, schema };
    let newFormData = formData;
    if (omitExtraData === true && (liveOmit === true || liveOmit === "onChange")) {
      newFormData = this.omitExtraData(formData);
      state = {
        formData: newFormData
      };
    }
    if (newErrorSchema) {
      const oldValidationError = !isRootPath ? (0, import_get5.default)(schemaValidationErrorSchema, path) : schemaValidationErrorSchema;
      if (!(0, import_isEmpty4.default)(oldValidationError)) {
        if (!isRootPath) {
          (0, import_set5.default)(originalErrorSchema, path, newErrorSchema);
        } else {
          originalErrorSchema = newErrorSchema;
        }
      } else {
        if (!customErrors) {
          customErrors = new import_utils49.ErrorSchemaBuilder();
        }
        if (isRootPath) {
          const errors2 = (0, import_get5.default)(newErrorSchema, import_utils49.ERRORS_KEY);
          if (errors2) {
            customErrors.setErrors(errors2);
          }
        } else {
          (0, import_set5.default)(customErrors.ErrorSchema, path, newErrorSchema);
        }
      }
    } else if (customErrors && (0, import_get5.default)(customErrors.ErrorSchema, [...path, import_utils49.ERRORS_KEY])) {
      customErrors.clearErrors(path);
    }
    if (mustValidate && this.pendingChanges.length === 1) {
      const liveValidation = this.liveValidate(
        schema,
        schemaUtils,
        originalErrorSchema,
        newFormData,
        extraErrors,
        customErrors,
        retrievedSchema
      );
      state = { formData: newFormData, ...liveValidation, customErrors };
    } else if (!noValidate && newErrorSchema) {
      const mergedErrors = this.mergeErrors({ errorSchema: originalErrorSchema, errors }, extraErrors, customErrors);
      state = {
        formData: newFormData,
        ...mergedErrors,
        customErrors
      };
    }
    this.setState(state, () => {
      if (onChange) {
        onChange(toIChangeEvent({ ...this.state, ...state }), id);
      }
      this.pendingChanges.shift();
      this.processPendingChange();
    });
  }
  /**
   * If the retrievedSchema has changed the new retrievedSchema is returned.
   * Otherwise, the old retrievedSchema is returned to persist reference.
   * -  This ensures that AJV retrieves the schema from the cache when it has not changed,
   *    avoiding the performance cost of recompiling the schema.
   *
   * @param retrievedSchema The new retrieved schema.
   * @returns The new retrieved schema if it has changed, else the old retrieved schema.
   */
  updateRetrievedSchema(retrievedSchema) {
    const isTheSame = (0, import_utils49.deepEquals)(retrievedSchema, this.state?.retrievedSchema);
    return isTheSame ? this.state.retrievedSchema : retrievedSchema;
  }
  /**
   * Callback function to handle reset form data.
   * - Reset all fields with default values.
   * - Reset validations and errors
   *
   */
  reset = () => {
    const { formData: propsFormData, initialFormData = IS_RESET, onChange } = this.props;
    const newState = this.getStateFromProps(
      this.props,
      propsFormData ?? initialFormData,
      void 0,
      void 0,
      void 0,
      true
    );
    const newFormData = newState.formData;
    const state = {
      formData: newFormData,
      errorSchema: {},
      errors: [],
      schemaValidationErrors: [],
      schemaValidationErrorSchema: {},
      initialDefaultsGenerated: false,
      customErrors: void 0
    };
    this.setState(state, () => onChange && onChange(toIChangeEvent({ ...this.state, ...state })));
  };
  /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
   * was provided. Also runs any live validation and/or live omit operations if the flags indicate they should happen
   * during `onBlur`.
   *
   * @param id - The unique `id` of the field that was blurred
   * @param data - The data associated with the field that was blurred
   */
  onBlur = (id, data) => {
    const { onBlur, omitExtraData, liveOmit, liveValidate } = this.props;
    if (onBlur) {
      onBlur(id, data);
    }
    if (omitExtraData === true && liveOmit === "onBlur" || liveValidate === "onBlur") {
      const { onChange, extraErrors } = this.props;
      const { formData } = this.state;
      let newFormData = formData;
      let state = { formData: newFormData };
      if (omitExtraData === true && liveOmit === "onBlur") {
        newFormData = this.omitExtraData(formData);
        state = { formData: newFormData };
      }
      if (liveValidate === "onBlur") {
        const { schema, schemaUtils, errorSchema, customErrors, retrievedSchema } = this.state;
        const liveValidation = this.liveValidate(
          schema,
          schemaUtils,
          errorSchema,
          newFormData,
          extraErrors,
          customErrors,
          retrievedSchema
        );
        state = { formData: newFormData, ...liveValidation, customErrors };
      }
      const hasChanges = Object.keys(state).filter((key) => !key.startsWith("schemaValidation")).some((key) => {
        const oldData = (0, import_get5.default)(this.state, key);
        const newData = (0, import_get5.default)(state, key);
        return !(0, import_utils49.deepEquals)(oldData, newData);
      });
      this.setState(state, () => {
        if (onChange && hasChanges) {
          onChange(toIChangeEvent({ ...this.state, ...state }), id);
        }
      });
    }
  };
  /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
   * was provided.
   *
   * @param id - The unique `id` of the field that was focused
   * @param data - The data associated with the field that was focused
   */
  onFocus = (id, data) => {
    const { onFocus } = this.props;
    if (onFocus) {
      onFocus(id, data);
    }
  };
  /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
   * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
   * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
   * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
   * back the `onSubmit` callback if it was provided.
   *
   * @param event - The submit HTML form event
   */
  onSubmit = (event) => {
    event.preventDefault();
    if (event.target !== event.currentTarget) {
      return;
    }
    event.persist();
    const { omitExtraData, extraErrors, noValidate, onSubmit } = this.props;
    let { formData: newFormData } = this.state;
    if (omitExtraData === true) {
      newFormData = this.omitExtraData(newFormData);
    }
    if (noValidate || this.validateFormWithFormData(newFormData)) {
      const errorSchema = extraErrors || {};
      const errors = extraErrors ? (0, import_utils49.toErrorList)(extraErrors) : [];
      this.setState(
        {
          formData: newFormData,
          errors,
          errorSchema,
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        },
        () => {
          if (onSubmit) {
            onSubmit(toIChangeEvent({ ...this.state, formData: newFormData }, "submitted"), event);
          }
        }
      );
    }
  };
  /** Extracts the `GlobalFormOptions` from the given Form `props`
   *
   * @param props - The form props to extract the global form options from
   * @returns - The `GlobalFormOptions` from the props
   * @private
   */
  getGlobalFormOptions(props) {
    const {
      uiSchema = {},
      experimental_componentUpdateStrategy,
      idSeparator = import_utils49.DEFAULT_ID_SEPARATOR,
      idPrefix = import_utils49.DEFAULT_ID_PREFIX,
      nameGenerator,
      useFallbackUiForUnsupportedType = false
    } = props;
    const rootFieldId = uiSchema["ui:rootFieldId"];
    return {
      idPrefix: rootFieldId || idPrefix,
      idSeparator,
      useFallbackUiForUnsupportedType,
      ...experimental_componentUpdateStrategy !== void 0 && { experimental_componentUpdateStrategy },
      ...nameGenerator !== void 0 && { nameGenerator }
    };
  }
  /** Computed the registry for the form using the given `props`, `schema` and `schemaUtils` */
  getRegistry(props, schema, schemaUtils) {
    const { translateString: customTranslateString, uiSchema = {} } = props;
    const { fields: fields2, templates: templates2, widgets: widgets2, formContext, translateString } = getDefaultRegistry();
    return {
      fields: { ...fields2, ...props.fields },
      templates: {
        ...templates2,
        ...props.templates,
        ButtonTemplates: {
          ...templates2.ButtonTemplates,
          ...props.templates?.ButtonTemplates
        }
      },
      widgets: { ...widgets2, ...props.widgets },
      rootSchema: schema,
      formContext: props.formContext || formContext,
      schemaUtils,
      translateString: customTranslateString || translateString,
      globalUiOptions: uiSchema[import_utils49.UI_GLOBAL_OPTIONS_KEY],
      globalFormOptions: this.getGlobalFormOptions(props)
    };
  }
  /** Provides a function that can be used to programmatically submit the `Form` */
  submit = () => {
    if (this.formElement.current) {
      const submitCustomEvent = new CustomEvent("submit", {
        cancelable: true
      });
      submitCustomEvent.preventDefault();
      this.formElement.current.dispatchEvent(submitCustomEvent);
      this.formElement.current.requestSubmit();
    }
  };
  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
   * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
   *
   * @param error - The error on which to focus
   */
  focusOnError(error) {
    const { idPrefix = "root", idSeparator = "_" } = this.props;
    const { property } = error;
    const path = (0, import_toPath.default)(property);
    if (path[0] === "") {
      path[0] = idPrefix;
    } else {
      path.unshift(idPrefix);
    }
    const elementId = path.join(idSeparator);
    let field = this.formElement.current.elements[elementId];
    if (!field) {
      field = this.formElement.current.querySelector(`input[id^="${elementId}"`);
    }
    if (field && field.length) {
      field = field[0];
    }
    if (field) {
      field.focus();
    }
  }
  /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.
   * If `onError` is provided, then it will be called with the list of errors.
   *
   * @param formData - The form data to validate
   * @returns - True if the form is valid, false otherwise.
   */
  validateFormWithFormData = (formData) => {
    const { extraErrors, extraErrorsBlockSubmit, focusOnFirstError, onError } = this.props;
    const { errors: prevErrors } = this.state;
    const schemaValidation = this.validate(formData);
    let errors = schemaValidation.errors;
    let errorSchema = schemaValidation.errorSchema;
    const schemaValidationErrors = errors;
    const schemaValidationErrorSchema = errorSchema;
    const hasError = errors.length > 0 || extraErrors && extraErrorsBlockSubmit;
    if (hasError) {
      if (extraErrors) {
        const merged = (0, import_utils49.validationDataMerge)(schemaValidation, extraErrors);
        errorSchema = merged.errorSchema;
        errors = merged.errors;
      }
      if (focusOnFirstError) {
        if (typeof focusOnFirstError === "function") {
          focusOnFirstError(errors[0]);
        } else {
          this.focusOnError(errors[0]);
        }
      }
      this.setState(
        {
          errors,
          errorSchema,
          schemaValidationErrors,
          schemaValidationErrorSchema
        },
        () => {
          if (onError) {
            onError(errors);
          } else {
            console.error("Form validation failed", errors);
          }
        }
      );
    } else if (prevErrors.length > 0) {
      this.setState({
        errors: [],
        errorSchema: {},
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {}
      });
    }
    return !hasError;
  };
  /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
   * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
   * same way as would happen on form submission.
   *
   * @returns - True if the form is valid, false otherwise.
   */
  validateForm() {
    const { omitExtraData } = this.props;
    let { formData: newFormData } = this.state;
    if (omitExtraData === true) {
      newFormData = this.omitExtraData(newFormData);
    }
    return this.validateFormWithFormData(newFormData);
  }
  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
   * needed along with the submit button or any children of the form.
   */
  render() {
    const {
      children,
      id,
      className = "",
      tagName,
      name,
      method,
      target,
      action,
      autoComplete,
      enctype,
      acceptCharset,
      noHtml5Validate = false,
      disabled,
      readonly,
      showErrorList = "top",
      _internalFormWrapper
    } = this.props;
    const { schema, uiSchema, formData, errorSchema, fieldPathId, registry } = this.state;
    const { SchemaField: _SchemaField } = registry.fields;
    const { SubmitButton: SubmitButton2 } = registry.templates.ButtonTemplates;
    const as = _internalFormWrapper ? tagName : void 0;
    const FormTag = _internalFormWrapper || tagName || "form";
    let { [import_utils49.SUBMIT_BTN_OPTIONS_KEY]: submitOptions = {} } = (0, import_utils49.getUiOptions)(uiSchema);
    if (disabled) {
      submitOptions = { ...submitOptions, props: { ...submitOptions.props, disabled: true } };
    }
    const submitUiSchema = { [import_utils49.UI_OPTIONS_KEY]: { [import_utils49.SUBMIT_BTN_OPTIONS_KEY]: submitOptions } };
    return /* @__PURE__ */ (0, import_jsx_runtime58.jsxs)(
      FormTag,
      {
        className: className ? className : "rjsf",
        id,
        name,
        method,
        target,
        action,
        autoComplete,
        encType: enctype,
        acceptCharset,
        noValidate: noHtml5Validate,
        onSubmit: this.onSubmit,
        as,
        ref: this.formElement,
        children: [
          showErrorList === "top" && this.renderErrors(registry),
          /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
            _SchemaField,
            {
              name: "",
              schema,
              uiSchema,
              errorSchema,
              fieldPathId,
              formData,
              onChange: this.onChange,
              onBlur: this.onBlur,
              onFocus: this.onFocus,
              registry,
              disabled,
              readonly
            }
          ),
          children ? children : /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(SubmitButton2, { uiSchema: submitUiSchema, registry }),
          showErrorList === "bottom" && this.renderErrors(registry)
        ]
      }
    );
  }
};

// src/withTheme.tsx
var import_react22 = require("react");
var import_jsx_runtime59 = require("react/jsx-runtime");
function withTheme(themeProps) {
  return (0, import_react22.forwardRef)(
    ({ fields: fields2, widgets: widgets2, templates: templates2, ...directProps }, ref) => {
      fields2 = { ...themeProps?.fields, ...fields2 };
      widgets2 = { ...themeProps?.widgets, ...widgets2 };
      templates2 = {
        ...themeProps?.templates,
        ...templates2,
        ButtonTemplates: {
          ...themeProps?.templates?.ButtonTemplates,
          ...templates2?.ButtonTemplates
        }
      };
      return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(
        Form,
        {
          ...themeProps,
          ...directProps,
          fields: fields2,
          widgets: widgets2,
          templates: templates2,
          ref
        }
      );
    }
  );
}

// src/getTestRegistry.tsx
var import_utils50 = require("@rjsf/utils");
var import_validator_ajv8 = __toESM(require("@rjsf/validator-ajv8"), 1);
function getTestRegistry(rootSchema, fields2 = {}, templates2 = {}, widgets2 = {}, formContext = {}, globalFormOptions = {
  idPrefix: import_utils50.DEFAULT_ID_PREFIX,
  idSeparator: import_utils50.DEFAULT_ID_SEPARATOR,
  useFallbackUiForUnsupportedType: false
}) {
  const defaults = getDefaultRegistry();
  const schemaUtils = (0, import_utils50.createSchemaUtils)(import_validator_ajv8.default, rootSchema);
  return {
    fields: { ...defaults.fields, ...fields2 },
    templates: { ...defaults.templates, ...templates2 },
    widgets: { ...defaults.widgets, ...widgets2 },
    formContext,
    rootSchema,
    schemaUtils,
    translateString: import_utils50.englishStringTranslator,
    globalFormOptions
  };
}

// src/index.ts
var index_default = Form;
//# sourceMappingURL=index.cjs.map
