import get from 'lodash-es/get.js';
import has from 'lodash-es/has.js';
import isEmpty from 'lodash-es/isEmpty.js';
import retrieveSchema from './retrieveSchema.js';
import { REF_KEY } from '../constants.js';
/** Internal helper function that acts like lodash's `get` but additionally retrieves `$ref`s as needed to get the path
 * for schemas containing potentially nested `$ref`s.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param schema - The current node within the JSON schema recursion
 * @param path - The remaining keys in the path to the desired property
 * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
 * @returns - The internal schema from the `schema` for the given `path` or undefined if not found
 */
function getFromSchemaInternal(validator, rootSchema, schema, path, experimental_customMergeAllOf) {
    let fieldSchema = schema;
    if (has(schema, REF_KEY)) {
        fieldSchema = retrieveSchema(validator, schema, rootSchema, undefined, experimental_customMergeAllOf);
    }
    if (isEmpty(path)) {
        return fieldSchema;
    }
    const pathList = Array.isArray(path) ? path : path.split('.');
    const [part, ...nestedPath] = pathList;
    if (part && has(fieldSchema, part)) {
        fieldSchema = get(fieldSchema, part);
        return getFromSchemaInternal(validator, rootSchema, fieldSchema, nestedPath, experimental_customMergeAllOf);
    }
    return undefined;
}
export default function getFromSchema(validator, rootSchema, schema, path, defaultValue, experimental_customMergeAllOf) {
    const result = getFromSchemaInternal(validator, rootSchema, schema, path, experimental_customMergeAllOf);
    if (result === undefined) {
        return defaultValue;
    }
    return result;
}
//# sourceMappingURL=getFromSchema.js.map