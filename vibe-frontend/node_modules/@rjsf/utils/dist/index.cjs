"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ADDITIONAL_PROPERTIES_KEY: () => ADDITIONAL_PROPERTIES_KEY,
  ADDITIONAL_PROPERTY_FLAG: () => ADDITIONAL_PROPERTY_FLAG,
  ALL_OF_KEY: () => ALL_OF_KEY,
  ANY_OF_KEY: () => ANY_OF_KEY,
  CONST_KEY: () => CONST_KEY,
  DEFAULT_ID_PREFIX: () => DEFAULT_ID_PREFIX,
  DEFAULT_ID_SEPARATOR: () => DEFAULT_ID_SEPARATOR,
  DEFAULT_KEY: () => DEFAULT_KEY,
  DEFINITIONS_KEY: () => DEFINITIONS_KEY,
  DEPENDENCIES_KEY: () => DEPENDENCIES_KEY,
  DISCRIMINATOR_PATH: () => DISCRIMINATOR_PATH,
  DateElement: () => DateElement,
  ENUM_KEY: () => ENUM_KEY,
  ERRORS_KEY: () => ERRORS_KEY,
  ErrorSchemaBuilder: () => ErrorSchemaBuilder,
  FORM_CONTEXT_NAME: () => FORM_CONTEXT_NAME,
  ID_KEY: () => ID_KEY,
  IF_KEY: () => IF_KEY,
  ITEMS_KEY: () => ITEMS_KEY,
  JSON_SCHEMA_DRAFT_2019_09: () => JSON_SCHEMA_DRAFT_2019_09,
  JSON_SCHEMA_DRAFT_2020_12: () => JSON_SCHEMA_DRAFT_2020_12,
  JUNK_OPTION_ID: () => JUNK_OPTION_ID,
  LOOKUP_MAP_NAME: () => LOOKUP_MAP_NAME,
  NAME_KEY: () => NAME_KEY,
  ONE_OF_KEY: () => ONE_OF_KEY,
  PATTERN_PROPERTIES_KEY: () => PATTERN_PROPERTIES_KEY,
  PROPERTIES_KEY: () => PROPERTIES_KEY,
  READONLY_KEY: () => READONLY_KEY,
  REF_KEY: () => REF_KEY,
  REQUIRED_KEY: () => REQUIRED_KEY,
  RJSF_ADDITIONAL_PROPERTIES_FLAG: () => RJSF_ADDITIONAL_PROPERTIES_FLAG,
  ROOT_SCHEMA_PREFIX: () => ROOT_SCHEMA_PREFIX,
  SCHEMA_KEY: () => SCHEMA_KEY,
  SUBMIT_BTN_OPTIONS_KEY: () => SUBMIT_BTN_OPTIONS_KEY,
  TranslatableString: () => TranslatableString,
  UI_FIELD_KEY: () => UI_FIELD_KEY,
  UI_GLOBAL_OPTIONS_KEY: () => UI_GLOBAL_OPTIONS_KEY,
  UI_OPTIONS_KEY: () => UI_OPTIONS_KEY,
  UI_WIDGET_KEY: () => UI_WIDGET_KEY,
  allowAdditionalItems: () => allowAdditionalItems,
  ariaDescribedByIds: () => ariaDescribedByIds,
  asNumber: () => asNumber,
  bracketNameGenerator: () => bracketNameGenerator,
  buttonId: () => buttonId,
  canExpand: () => canExpand,
  createErrorHandler: () => createErrorHandler,
  createSchemaUtils: () => createSchemaUtils,
  dataURItoBlob: () => dataURItoBlob,
  dateRangeOptions: () => dateRangeOptions,
  deepEquals: () => deepEquals,
  descriptionId: () => descriptionId,
  dotNotationNameGenerator: () => dotNotationNameGenerator,
  englishStringTranslator: () => englishStringTranslator,
  enumOptionsDeselectValue: () => enumOptionsDeselectValue,
  enumOptionsIndexForValue: () => enumOptionsIndexForValue,
  enumOptionsIsSelected: () => enumOptionsIsSelected,
  enumOptionsSelectValue: () => enumOptionsSelectValue,
  enumOptionsValueForIndex: () => enumOptionsValueForIndex,
  errorId: () => errorId,
  examplesId: () => examplesId,
  findFieldInSchema: () => findFieldInSchema,
  findSchemaDefinition: () => findSchemaDefinition,
  findSelectedOptionInXxxOf: () => findSelectedOptionInXxxOf,
  getChangedFields: () => getChangedFields,
  getClosestMatchingOption: () => getClosestMatchingOption,
  getDateElementProps: () => getDateElementProps,
  getDefaultFormState: () => getDefaultFormState,
  getDiscriminatorFieldFromSchema: () => getDiscriminatorFieldFromSchema,
  getDisplayLabel: () => getDisplayLabel,
  getFirstMatchingOption: () => getFirstMatchingOption,
  getFromSchema: () => getFromSchema,
  getInputProps: () => getInputProps,
  getOptionMatchingSimpleDiscriminator: () => getOptionMatchingSimpleDiscriminator,
  getSchemaType: () => getSchemaType,
  getSubmitButtonOptions: () => getSubmitButtonOptions,
  getTemplate: () => getTemplate,
  getTestIds: () => getTestIds,
  getUiOptions: () => getUiOptions,
  getWidget: () => getWidget,
  guessType: () => guessType,
  hasWidget: () => hasWidget,
  hashForSchema: () => hashForSchema,
  hashObject: () => hashObject,
  hashString: () => hashString,
  helpId: () => helpId,
  isConstant: () => isConstant,
  isCustomWidget: () => isCustomWidget,
  isFilesArray: () => isFilesArray,
  isFixedItems: () => isFixedItems,
  isFormDataAvailable: () => isFormDataAvailable,
  isMultiSelect: () => isMultiSelect,
  isObject: () => isObject,
  isRootSchema: () => isRootSchema,
  isSelect: () => isSelect,
  labelValue: () => labelValue,
  localToUTC: () => localToUTC,
  lookupFromFormContext: () => lookupFromFormContext,
  mergeDefaultsWithFormData: () => mergeDefaultsWithFormData,
  mergeObjects: () => mergeObjects,
  mergeSchemas: () => mergeSchemas,
  optionId: () => optionId,
  optionalControlsId: () => optionalControlsId,
  optionsList: () => optionsList,
  orderProperties: () => orderProperties,
  pad: () => pad,
  parseDateString: () => parseDateString,
  rangeSpec: () => rangeSpec,
  replaceStringParameters: () => replaceStringParameters,
  retrieveSchema: () => retrieveSchema,
  sanitizeDataForNewSchema: () => sanitizeDataForNewSchema,
  schemaParser: () => schemaParser,
  schemaRequiresTrueValue: () => schemaRequiresTrueValue,
  shallowEquals: () => shallowEquals,
  shouldRender: () => shouldRender,
  shouldRenderOptionalField: () => shouldRenderOptionalField,
  sortedJSONStringify: () => sortedJSONStringify,
  titleId: () => titleId,
  toConstant: () => toConstant,
  toDateString: () => toDateString,
  toErrorList: () => toErrorList,
  toErrorSchema: () => toErrorSchema,
  toFieldPathId: () => toFieldPathId,
  toPathSchema: () => toPathSchema,
  unwrapErrorHandler: () => unwrapErrorHandler,
  useAltDateWidgetProps: () => useAltDateWidgetProps,
  useDeepCompareMemo: () => useDeepCompareMemo,
  useFileWidgetProps: () => useFileWidgetProps,
  utcToLocal: () => utcToLocal,
  validationDataMerge: () => validationDataMerge,
  withIdRefPrefix: () => withIdRefPrefix
});
module.exports = __toCommonJS(index_exports);

// src/isObject.ts
function isObject(thing) {
  if (typeof thing !== "object" || thing === null) {
    return false;
  }
  if (typeof thing.lastModified === "number" && typeof File !== "undefined" && thing instanceof File) {
    return false;
  }
  if (typeof thing.getMonth === "function" && typeof Date !== "undefined" && thing instanceof Date) {
    return false;
  }
  return !Array.isArray(thing);
}

// src/allowAdditionalItems.ts
function allowAdditionalItems(schema) {
  if (schema.additionalItems === true) {
    console.warn("additionalItems=true is currently not supported");
  }
  return isObject(schema.additionalItems);
}

// src/asNumber.ts
function asNumber(value) {
  if (value === "") {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  if (/\.$/.test(value)) {
    return value;
  }
  if (/\.0$/.test(value)) {
    return value;
  }
  if (/\.\d*0$/.test(value)) {
    return value;
  }
  const n = Number(value);
  const valid = typeof n === "number" && !Number.isNaN(n);
  return valid ? n : value;
}

// src/constants.ts
var ADDITIONAL_PROPERTY_FLAG = "__additional_property";
var ADDITIONAL_PROPERTIES_KEY = "additionalProperties";
var ALL_OF_KEY = "allOf";
var ANY_OF_KEY = "anyOf";
var CONST_KEY = "const";
var DEFAULT_KEY = "default";
var DEFINITIONS_KEY = "definitions";
var DEPENDENCIES_KEY = "dependencies";
var ENUM_KEY = "enum";
var ERRORS_KEY = "__errors";
var ID_KEY = "$id";
var IF_KEY = "if";
var ITEMS_KEY = "items";
var JUNK_OPTION_ID = "_$junk_option_schema_id$_";
var NAME_KEY = "$name";
var ONE_OF_KEY = "oneOf";
var PATTERN_PROPERTIES_KEY = "patternProperties";
var PROPERTIES_KEY = "properties";
var READONLY_KEY = "readonly";
var REQUIRED_KEY = "required";
var SUBMIT_BTN_OPTIONS_KEY = "submitButtonOptions";
var REF_KEY = "$ref";
var SCHEMA_KEY = "$schema";
var DEFAULT_ID_PREFIX = "root";
var DEFAULT_ID_SEPARATOR = "_";
var DISCRIMINATOR_PATH = ["discriminator", "propertyName"];
var FORM_CONTEXT_NAME = "formContext";
var LOOKUP_MAP_NAME = "layoutGridLookupMap";
var RJSF_ADDITIONAL_PROPERTIES_FLAG = "__rjsf_additionalProperties";
var ROOT_SCHEMA_PREFIX = "__rjsf_rootSchema";
var UI_FIELD_KEY = "ui:field";
var UI_WIDGET_KEY = "ui:widget";
var UI_OPTIONS_KEY = "ui:options";
var UI_GLOBAL_OPTIONS_KEY = "ui:globalOptions";
var JSON_SCHEMA_DRAFT_2019_09 = "https://json-schema.org/draft/2019-09/schema";
var JSON_SCHEMA_DRAFT_2020_12 = "https://json-schema.org/draft/2020-12/schema";

// src/getUiOptions.ts
function getUiOptions(uiSchema = {}, globalOptions = {}) {
  if (!uiSchema) {
    return { ...globalOptions };
  }
  return Object.keys(uiSchema).filter((key) => key.indexOf("ui:") === 0).reduce(
    (options, key) => {
      const value = uiSchema[key];
      if (key === UI_WIDGET_KEY && isObject(value)) {
        console.error("Setting options via ui:widget object is no longer supported, use ui:options instead");
        return options;
      }
      if (key === UI_OPTIONS_KEY && isObject(value)) {
        return { ...options, ...value };
      }
      return { ...options, [key.substring(3)]: value };
    },
    { ...globalOptions }
  );
}

// src/canExpand.ts
function canExpand(schema, uiSchema = {}, formData) {
  if (!(schema.additionalProperties || schema.patternProperties)) {
    return false;
  }
  const { expandable = true } = getUiOptions(uiSchema);
  if (expandable === false) {
    return expandable;
  }
  if (schema.maxProperties !== void 0 && formData) {
    return Object.keys(formData).length < schema.maxProperties;
  }
  return true;
}

// src/createErrorHandler.ts
var import_isPlainObject = __toESM(require("lodash/isPlainObject"), 1);
function createErrorHandler(formData) {
  const handler = {
    // We store the list of errors for this node in a property named __errors
    // to avoid name collision with a possible sub schema field named
    // 'errors' (see `utils.toErrorSchema`).
    [ERRORS_KEY]: [],
    addError(message) {
      this[ERRORS_KEY].push(message);
    }
  };
  if (Array.isArray(formData)) {
    return formData.reduce((acc, value, key) => {
      return { ...acc, [key]: createErrorHandler(value) };
    }, handler);
  }
  if ((0, import_isPlainObject.default)(formData)) {
    const formObject = formData;
    return Object.keys(formObject).reduce((acc, key) => {
      return { ...acc, [key]: createErrorHandler(formObject[key]) };
    }, handler);
  }
  return handler;
}

// src/deepEquals.ts
var import_isEqualWith = __toESM(require("lodash/isEqualWith"), 1);
function deepEquals(a, b) {
  return (0, import_isEqualWith.default)(a, b, (obj, other) => {
    if (typeof obj === "function" && typeof other === "function") {
      return true;
    }
    return void 0;
  });
}

// src/schema/findFieldInSchema.ts
var import_get8 = __toESM(require("lodash/get"), 1);
var import_has3 = __toESM(require("lodash/has"), 1);

// src/schema/findSelectedOptionInXxxOf.ts
var import_get6 = __toESM(require("lodash/get"), 1);
var import_isEqual = __toESM(require("lodash/isEqual"), 1);

// src/schema/retrieveSchema.ts
var import_get5 = __toESM(require("lodash/get"), 1);
var import_set = __toESM(require("lodash/set"), 1);
var import_times = __toESM(require("lodash/times"), 1);
var import_transform = __toESM(require("lodash/transform"), 1);
var import_merge = __toESM(require("lodash/merge"), 1);
var import_flattenDeep = __toESM(require("lodash/flattenDeep"), 1);
var import_uniq = __toESM(require("lodash/uniq"), 1);
var import_json_schema_merge_allof = __toESM(require("json-schema-merge-allof"), 1);

// src/findSchemaDefinition.ts
var import_jsonpointer = __toESM(require("jsonpointer"), 1);
var import_omit = __toESM(require("lodash/omit"), 1);
var import_isObject3 = __toESM(require("lodash/isObject"), 1);
var import_isEmpty = __toESM(require("lodash/isEmpty"), 1);
var import_fast_uri = __toESM(require("fast-uri"), 1);
var import_get = __toESM(require("lodash/get"), 1);
function findEmbeddedSchemaRecursive(schema, ref) {
  if (ID_KEY in schema && import_fast_uri.default.equal(schema[ID_KEY], ref)) {
    return schema;
  }
  for (const subSchema of Object.values(schema)) {
    if (Array.isArray(subSchema)) {
      for (const item of subSchema) {
        if ((0, import_isObject3.default)(item)) {
          const result = findEmbeddedSchemaRecursive(item, ref);
          if (result !== void 0) {
            return result;
          }
        }
      }
    } else if ((0, import_isObject3.default)(subSchema)) {
      const result = findEmbeddedSchemaRecursive(subSchema, ref);
      if (result !== void 0) {
        return result;
      }
    }
  }
  return void 0;
}
function makeAllReferencesAbsolute(schema, baseURI) {
  const currentURI = (0, import_get.default)(schema, ID_KEY, baseURI);
  if (REF_KEY in schema) {
    schema = { ...schema, [REF_KEY]: import_fast_uri.default.resolve(currentURI, schema[REF_KEY]) };
  }
  for (const [key, subSchema] of Object.entries(schema)) {
    if (Array.isArray(subSchema)) {
      schema = {
        ...schema,
        [key]: subSchema.map((item) => (0, import_isObject3.default)(item) ? makeAllReferencesAbsolute(item, currentURI) : item)
      };
    } else if ((0, import_isObject3.default)(subSchema)) {
      schema = { ...schema, [key]: makeAllReferencesAbsolute(subSchema, currentURI) };
    }
  }
  return schema;
}
function splitKeyElementFromObject(key, object) {
  const value = object[key];
  const remaining = (0, import_omit.default)(object, [key]);
  return [remaining, value];
}
function findSchemaDefinitionRecursive($ref, rootSchema = {}, recurseList = [], baseURI = (0, import_get.default)(rootSchema, [ID_KEY])) {
  const ref = $ref || "";
  let current = void 0;
  if (ref.startsWith("#")) {
    const decodedRef = decodeURIComponent(ref.substring(1));
    if (baseURI === void 0 || ID_KEY in rootSchema && rootSchema[ID_KEY] === baseURI) {
      current = import_jsonpointer.default.get(rootSchema, decodedRef);
    } else if (rootSchema[SCHEMA_KEY] === JSON_SCHEMA_DRAFT_2020_12) {
      current = findEmbeddedSchemaRecursive(rootSchema, baseURI.replace(/\/$/, ""));
      if (current !== void 0) {
        current = import_jsonpointer.default.get(current, decodedRef);
      }
    }
  } else if (rootSchema[SCHEMA_KEY] === JSON_SCHEMA_DRAFT_2020_12) {
    const resolvedRef = baseURI ? import_fast_uri.default.resolve(baseURI, ref) : ref;
    const [refId, ...refAnchor] = resolvedRef.replace(/#\/?$/, "").split("#");
    current = findEmbeddedSchemaRecursive(rootSchema, refId.replace(/\/$/, ""));
    if (current !== void 0) {
      baseURI = current[ID_KEY];
      if (!(0, import_isEmpty.default)(refAnchor)) {
        current = import_jsonpointer.default.get(current, decodeURIComponent(refAnchor.join("#")));
      }
    }
  }
  if (current === void 0) {
    throw new Error(`Could not find a definition for ${$ref}.`);
  }
  const nextRef = current[REF_KEY];
  if (nextRef) {
    if (recurseList.includes(nextRef)) {
      if (recurseList.length === 1) {
        throw new Error(`Definition for ${$ref} is a circular reference`);
      }
      const [firstRef, ...restRefs] = recurseList;
      const circularPath = [...restRefs, ref, firstRef].join(" -> ");
      throw new Error(`Definition for ${firstRef} contains a circular reference through ${circularPath}`);
    }
    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);
    const subSchema = findSchemaDefinitionRecursive(theRef, rootSchema, [...recurseList, ref], baseURI);
    if (Object.keys(remaining).length > 0) {
      if (rootSchema[SCHEMA_KEY] === JSON_SCHEMA_DRAFT_2019_09 || rootSchema[SCHEMA_KEY] === JSON_SCHEMA_DRAFT_2020_12) {
        return { [ALL_OF_KEY]: [remaining, subSchema] };
      } else {
        return { ...remaining, ...subSchema };
      }
    }
    return subSchema;
  }
  return current;
}
function findSchemaDefinition($ref, rootSchema = {}, baseURI = (0, import_get.default)(rootSchema, [ID_KEY])) {
  const recurseList = [];
  return findSchemaDefinitionRecursive($ref, rootSchema, recurseList, baseURI);
}

// src/getDiscriminatorFieldFromSchema.ts
var import_get2 = __toESM(require("lodash/get"), 1);
var import_isString = __toESM(require("lodash/isString"), 1);
function getDiscriminatorFieldFromSchema(schema) {
  let discriminator;
  const maybeString = (0, import_get2.default)(schema, DISCRIMINATOR_PATH);
  if ((0, import_isString.default)(maybeString)) {
    discriminator = maybeString;
  } else if (maybeString !== void 0) {
    console.warn(`Expecting discriminator to be a string, got "${typeof maybeString}" instead`);
  }
  return discriminator;
}

// src/guessType.ts
function guessType(value) {
  if (Array.isArray(value)) {
    return "array";
  }
  if (typeof value === "string") {
    return "string";
  }
  if (value == null) {
    return "null";
  }
  if (typeof value === "boolean") {
    return "boolean";
  }
  if (!isNaN(value)) {
    return "number";
  }
  if (typeof value === "object") {
    return "object";
  }
  return "string";
}

// src/mergeSchemas.ts
var import_union = __toESM(require("lodash/union"), 1);

// src/getSchemaType.ts
function getSchemaType(schema) {
  let { type } = schema;
  if (!type && schema.const) {
    return guessType(schema.const);
  }
  if (!type && schema.enum) {
    return "string";
  }
  if (!type && (schema.properties || schema.additionalProperties || schema.patternProperties)) {
    return "object";
  }
  if (Array.isArray(type)) {
    if (type.length === 2 && type.includes("null")) {
      type = type.find((type2) => type2 !== "null");
    } else {
      type = type[0];
    }
  }
  return type;
}

// src/mergeSchemas.ts
function mergeSchemas(obj1, obj2) {
  const acc = Object.assign({}, obj1);
  return Object.keys(obj2).reduce((acc2, key) => {
    const left = obj1 ? obj1[key] : {}, right = obj2[key];
    if (obj1 && key in obj1 && isObject(right)) {
      acc2[key] = mergeSchemas(left, right);
    } else if (obj1 && obj2 && (getSchemaType(obj1) === "object" || getSchemaType(obj2) === "object") && key === REQUIRED_KEY && Array.isArray(left) && Array.isArray(right)) {
      acc2[key] = (0, import_union.default)(left, right);
    } else {
      acc2[key] = right;
    }
    return acc2;
  }, acc);
}

// src/schema/getFirstMatchingOption.ts
var import_get4 = __toESM(require("lodash/get"), 1);
var import_has = __toESM(require("lodash/has"), 1);
var import_isNumber = __toESM(require("lodash/isNumber"), 1);

// src/getOptionMatchingSimpleDiscriminator.ts
var import_get3 = __toESM(require("lodash/get"), 1);
function getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField) {
  if (formData && discriminatorField) {
    const value = (0, import_get3.default)(formData, discriminatorField);
    if (value === void 0) {
      return;
    }
    for (let i = 0; i < options.length; i++) {
      const option = options[i];
      const discriminator = (0, import_get3.default)(option, [PROPERTIES_KEY, discriminatorField], {});
      if (discriminator.type === "object" || discriminator.type === "array") {
        continue;
      }
      if (discriminator.const === value) {
        return i;
      }
      if (discriminator.enum?.includes(value)) {
        return i;
      }
    }
  }
  return;
}

// src/schema/getFirstMatchingOption.ts
function getFirstMatchingOption(validator, formData, options, rootSchema, discriminatorField) {
  if (formData === void 0) {
    return 0;
  }
  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);
  if ((0, import_isNumber.default)(simpleDiscriminatorMatch)) {
    return simpleDiscriminatorMatch;
  }
  for (let i = 0; i < options.length; i++) {
    const option = options[i];
    if (discriminatorField && (0, import_has.default)(option, [PROPERTIES_KEY, discriminatorField])) {
      const value = (0, import_get4.default)(formData, discriminatorField);
      const discriminator = (0, import_get4.default)(option, [PROPERTIES_KEY, discriminatorField], {});
      if (validator.isValid(discriminator, value, rootSchema)) {
        return i;
      }
    } else if (option[PROPERTIES_KEY]) {
      const requiresAnyOf = {
        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({
          required: [key]
        }))
      };
      let augmentedSchema;
      if (option.anyOf) {
        const { ...shallowClone } = option;
        if (!shallowClone.allOf) {
          shallowClone.allOf = [];
        } else {
          shallowClone.allOf = shallowClone.allOf.slice();
        }
        shallowClone.allOf.push(requiresAnyOf);
        augmentedSchema = shallowClone;
      } else {
        augmentedSchema = Object.assign({}, option, requiresAnyOf);
      }
      delete augmentedSchema.required;
      if (validator.isValid(augmentedSchema, formData, rootSchema)) {
        return i;
      }
    } else if (validator.isValid(option, formData, rootSchema)) {
      return i;
    }
  }
  return 0;
}

// src/schema/retrieveSchema.ts
var import_isEmpty2 = __toESM(require("lodash/isEmpty"), 1);
function retrieveSchema(validator, schema, rootSchema = {}, rawFormData, experimental_customMergeAllOf, resolveAnyOfOrOneOfRefs = false) {
  return retrieveSchemaInternal(
    validator,
    schema,
    rootSchema,
    rawFormData,
    void 0,
    void 0,
    experimental_customMergeAllOf,
    resolveAnyOfOrOneOfRefs
  )[0];
}
function resolveCondition(validator, schema, rootSchema, expandAllBranches, recurseList, formData, experimental_customMergeAllOf) {
  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;
  const conditionValue = validator.isValid(expression, formData || {}, rootSchema);
  let resolvedSchemas = [resolvedSchemaLessConditional];
  let schemas = [];
  if (expandAllBranches) {
    if (then && typeof then !== "boolean") {
      schemas = schemas.concat(
        retrieveSchemaInternal(
          validator,
          then,
          rootSchema,
          formData,
          expandAllBranches,
          recurseList,
          experimental_customMergeAllOf
        )
      );
    }
    if (otherwise && typeof otherwise !== "boolean") {
      schemas = schemas.concat(
        retrieveSchemaInternal(
          validator,
          otherwise,
          rootSchema,
          formData,
          expandAllBranches,
          recurseList,
          experimental_customMergeAllOf
        )
      );
    }
  } else {
    const conditionalSchema = conditionValue ? then : otherwise;
    if (conditionalSchema && typeof conditionalSchema !== "boolean") {
      schemas = schemas.concat(
        retrieveSchemaInternal(
          validator,
          conditionalSchema,
          rootSchema,
          formData,
          expandAllBranches,
          recurseList,
          experimental_customMergeAllOf
        )
      );
    }
  }
  if (schemas.length) {
    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s));
  }
  return resolvedSchemas.flatMap(
    (s) => retrieveSchemaInternal(
      validator,
      s,
      rootSchema,
      formData,
      expandAllBranches,
      recurseList,
      experimental_customMergeAllOf
    )
  );
}
function getAllPermutationsOfXxxOf(listOfLists) {
  const allPermutations = listOfLists.reduce(
    (permutations, list) => {
      if (list.length > 1) {
        return list.flatMap((element) => (0, import_times.default)(permutations.length, (i) => [...permutations[i]].concat(element)));
      }
      permutations.forEach((permutation) => permutation.push(list[0]));
      return permutations;
    },
    [[]]
    // Start with an empty list
  );
  return allPermutations;
}
function getMatchingPatternProperties(schema, key) {
  return Object.keys(schema.patternProperties).filter((pattern) => RegExp(pattern).test(key)).reduce(
    (obj, pattern) => {
      (0, import_set.default)(obj, [pattern], schema.patternProperties[pattern]);
      return obj;
    },
    {}
  );
}
function resolveSchema(validator, schema, rootSchema, expandAllBranches, recurseList, formData, experimental_customMergeAllOf, resolveAnyOfOrOneOfRefs) {
  const updatedSchemas = resolveReference(
    validator,
    schema,
    rootSchema,
    expandAllBranches,
    recurseList,
    formData,
    experimental_customMergeAllOf,
    resolveAnyOfOrOneOfRefs
  );
  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {
    return updatedSchemas;
  }
  if (DEPENDENCIES_KEY in schema) {
    const resolvedSchemas = resolveDependencies(
      validator,
      schema,
      rootSchema,
      expandAllBranches,
      recurseList,
      formData,
      experimental_customMergeAllOf
    );
    return resolvedSchemas.flatMap((s) => {
      return retrieveSchemaInternal(
        validator,
        s,
        rootSchema,
        formData,
        expandAllBranches,
        recurseList,
        experimental_customMergeAllOf
      );
    });
  }
  if (ALL_OF_KEY in schema && Array.isArray(schema[ALL_OF_KEY])) {
    const allOfSchemaElements = schema.allOf.map(
      (allOfSubschema) => retrieveSchemaInternal(
        validator,
        allOfSubschema,
        rootSchema,
        formData,
        expandAllBranches,
        recurseList,
        experimental_customMergeAllOf
      )
    );
    const allPermutations = getAllPermutationsOfXxxOf(allOfSchemaElements);
    return allPermutations.map((permutation) => ({
      ...schema,
      allOf: permutation
    }));
  }
  return [schema];
}
function resolveReference(validator, schema, rootSchema, expandAllBranches, recurseList, formData, experimental_customMergeAllOf, resolveAnyOfOrOneOfRefs) {
  const updatedSchema = resolveAllReferences(schema, rootSchema, recurseList, void 0, resolveAnyOfOrOneOfRefs);
  if (updatedSchema !== schema) {
    return retrieveSchemaInternal(
      validator,
      updatedSchema,
      rootSchema,
      formData,
      expandAllBranches,
      recurseList,
      experimental_customMergeAllOf,
      resolveAnyOfOrOneOfRefs
    );
  }
  return [schema];
}
function resolveAllReferences(schema, rootSchema, recurseList, baseURI, resolveAnyOfOrOneOfRefs) {
  if (!isObject(schema)) {
    return schema;
  }
  let resolvedSchema = schema;
  if (REF_KEY in resolvedSchema) {
    const { $ref, ...localSchema } = resolvedSchema;
    if (recurseList.includes($ref)) {
      return resolvedSchema;
    }
    recurseList.push($ref);
    const refSchema = findSchemaDefinition($ref, rootSchema, baseURI);
    resolvedSchema = { ...refSchema, ...localSchema };
    if (ID_KEY in resolvedSchema) {
      baseURI = resolvedSchema[ID_KEY];
    }
  }
  if (PROPERTIES_KEY in resolvedSchema) {
    const childrenLists = [];
    const updatedProps = (0, import_transform.default)(
      resolvedSchema[PROPERTIES_KEY],
      (result, value, key) => {
        const childList = [...recurseList];
        result[key] = resolveAllReferences(value, rootSchema, childList, baseURI, resolveAnyOfOrOneOfRefs);
        childrenLists.push(childList);
      },
      {}
    );
    (0, import_merge.default)(recurseList, (0, import_uniq.default)((0, import_flattenDeep.default)(childrenLists)));
    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };
  }
  if (ITEMS_KEY in resolvedSchema && !Array.isArray(resolvedSchema.items) && typeof resolvedSchema.items !== "boolean") {
    resolvedSchema = {
      ...resolvedSchema,
      items: resolveAllReferences(resolvedSchema.items, rootSchema, recurseList, baseURI, resolveAnyOfOrOneOfRefs)
    };
  }
  if (resolveAnyOfOrOneOfRefs) {
    let key;
    let schemas;
    if (ANY_OF_KEY in schema && Array.isArray(schema[ANY_OF_KEY])) {
      key = ANY_OF_KEY;
      schemas = resolvedSchema[ANY_OF_KEY];
    } else if (ONE_OF_KEY in schema && Array.isArray(schema[ONE_OF_KEY])) {
      key = ONE_OF_KEY;
      schemas = resolvedSchema[ONE_OF_KEY];
    }
    if (key && schemas) {
      resolvedSchema = {
        ...resolvedSchema,
        [key]: schemas.map(
          (s) => resolveAllReferences(s, rootSchema, recurseList, baseURI, resolveAnyOfOrOneOfRefs)
        )
      };
    }
  }
  return deepEquals(schema, resolvedSchema) ? schema : resolvedSchema;
}
function stubExistingAdditionalProperties(validator, theSchema, rootSchema, aFormData, experimental_customMergeAllOf) {
  const schema = {
    ...theSchema,
    properties: { ...theSchema.properties }
  };
  const formData = aFormData && isObject(aFormData) ? aFormData : {};
  Object.keys(formData).forEach((key) => {
    if (key in schema.properties) {
      return;
    }
    if (PATTERN_PROPERTIES_KEY in schema) {
      const matchingProperties = getMatchingPatternProperties(schema, key);
      if (!(0, import_isEmpty2.default)(matchingProperties)) {
        schema.properties[key] = retrieveSchema(
          validator,
          { [ALL_OF_KEY]: Object.values(matchingProperties) },
          rootSchema,
          (0, import_get5.default)(formData, [key]),
          experimental_customMergeAllOf
        );
        (0, import_set.default)(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);
        return;
      }
    }
    if (ADDITIONAL_PROPERTIES_KEY in schema && schema.additionalProperties !== false) {
      let additionalProperties;
      if (typeof schema.additionalProperties !== "boolean") {
        if (REF_KEY in schema.additionalProperties) {
          additionalProperties = retrieveSchema(
            validator,
            { [REF_KEY]: (0, import_get5.default)(schema.additionalProperties, [REF_KEY]) },
            rootSchema,
            formData,
            experimental_customMergeAllOf
          );
        } else if ("type" in schema.additionalProperties) {
          additionalProperties = { ...schema.additionalProperties };
        } else if (ANY_OF_KEY in schema.additionalProperties || ONE_OF_KEY in schema.additionalProperties) {
          additionalProperties = {
            type: "object",
            ...schema.additionalProperties
          };
        } else {
          additionalProperties = { type: guessType((0, import_get5.default)(formData, [key])) };
        }
      } else {
        additionalProperties = { type: guessType((0, import_get5.default)(formData, [key])) };
      }
      schema.properties[key] = additionalProperties;
      (0, import_set.default)(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);
    } else {
      schema.properties[key] = { type: "null" };
      (0, import_set.default)(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);
    }
  });
  return schema;
}
function retrieveSchemaInternal(validator, schema, rootSchema, rawFormData, expandAllBranches = false, recurseList = [], experimental_customMergeAllOf, resolveAnyOfOrOneOfRefs) {
  if (!isObject(schema)) {
    return [{}];
  }
  const resolvedSchemas = resolveSchema(
    validator,
    schema,
    rootSchema,
    expandAllBranches,
    recurseList,
    rawFormData,
    experimental_customMergeAllOf,
    resolveAnyOfOrOneOfRefs
  );
  return resolvedSchemas.flatMap((s) => {
    let resolvedSchema = s;
    if (IF_KEY in resolvedSchema) {
      return resolveCondition(
        validator,
        resolvedSchema,
        rootSchema,
        expandAllBranches,
        recurseList,
        rawFormData,
        experimental_customMergeAllOf
      );
    }
    if (ALL_OF_KEY in resolvedSchema) {
      if (expandAllBranches) {
        const { allOf, ...restOfSchema } = resolvedSchema;
        return [...allOf, restOfSchema];
      }
      try {
        const withContainsSchemas = [];
        const withoutContainsSchemas = [];
        resolvedSchema.allOf?.forEach((s2) => {
          if (typeof s2 === "object" && s2.contains) {
            withContainsSchemas.push(s2);
          } else {
            withoutContainsSchemas.push(s2);
          }
        });
        if (withContainsSchemas.length) {
          resolvedSchema = { ...resolvedSchema, allOf: withoutContainsSchemas };
        }
        resolvedSchema = experimental_customMergeAllOf ? experimental_customMergeAllOf(resolvedSchema) : (0, import_json_schema_merge_allof.default)(resolvedSchema, {
          deep: false,
          resolvers: {
            $defs: import_json_schema_merge_allof.default.options.resolvers.definitions
          }
        });
        if (withContainsSchemas.length) {
          resolvedSchema.allOf = withContainsSchemas;
        }
      } catch (e) {
        console.warn("could not merge subschemas in allOf:\n", e);
        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;
        return resolvedSchemaWithoutAllOf;
      }
    }
    if (PROPERTIES_KEY in resolvedSchema && PATTERN_PROPERTIES_KEY in resolvedSchema) {
      resolvedSchema = Object.keys(resolvedSchema.properties).reduce(
        (schema2, key) => {
          const matchingProperties = getMatchingPatternProperties(schema2, key);
          if (!(0, import_isEmpty2.default)(matchingProperties)) {
            schema2.properties[key] = retrieveSchema(
              validator,
              { allOf: [schema2.properties[key], ...Object.values(matchingProperties)] },
              rootSchema,
              (0, import_get5.default)(rawFormData, [key]),
              experimental_customMergeAllOf
            );
          }
          return schema2;
        },
        {
          ...resolvedSchema,
          properties: { ...resolvedSchema.properties }
        }
      );
    }
    const hasAdditionalProperties = PATTERN_PROPERTIES_KEY in resolvedSchema || ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;
    if (hasAdditionalProperties) {
      return stubExistingAdditionalProperties(
        validator,
        resolvedSchema,
        rootSchema,
        rawFormData,
        experimental_customMergeAllOf
      );
    }
    return resolvedSchema;
  });
}
function resolveAnyOrOneOfSchemas(validator, schema, rootSchema, expandAllBranches, rawFormData) {
  let anyOrOneOf;
  const { oneOf, anyOf, ...remaining } = schema;
  if (Array.isArray(oneOf)) {
    anyOrOneOf = oneOf;
  } else if (Array.isArray(anyOf)) {
    anyOrOneOf = anyOf;
  }
  if (anyOrOneOf) {
    const formData = rawFormData === void 0 && expandAllBranches ? {} : rawFormData;
    const discriminator = getDiscriminatorFieldFromSchema(schema);
    anyOrOneOf = anyOrOneOf.map((s) => {
      return resolveAllReferences(s, rootSchema, []);
    });
    const option = getFirstMatchingOption(validator, formData, anyOrOneOf, rootSchema, discriminator);
    if (expandAllBranches) {
      return anyOrOneOf.map((item) => mergeSchemas(remaining, item));
    }
    schema = mergeSchemas(remaining, anyOrOneOf[option]);
  }
  return [schema];
}
function resolveDependencies(validator, schema, rootSchema, expandAllBranches, recurseList, formData, experimental_customMergeAllOf) {
  const { dependencies, ...remainingSchema } = schema;
  const resolvedSchemas = resolveAnyOrOneOfSchemas(
    validator,
    remainingSchema,
    rootSchema,
    expandAllBranches,
    formData
  );
  return resolvedSchemas.flatMap(
    (resolvedSchema) => processDependencies(
      validator,
      dependencies,
      resolvedSchema,
      rootSchema,
      expandAllBranches,
      recurseList,
      formData,
      experimental_customMergeAllOf
    )
  );
}
function processDependencies(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, recurseList, formData, experimental_customMergeAllOf) {
  let schemas = [resolvedSchema];
  for (const dependencyKey in dependencies) {
    if (!expandAllBranches && (0, import_get5.default)(formData, [dependencyKey]) === void 0) {
      continue;
    }
    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {
      continue;
    }
    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(
      dependencyKey,
      dependencies
    );
    if (Array.isArray(dependencyValue)) {
      schemas[0] = withDependentProperties(resolvedSchema, dependencyValue);
    } else if (isObject(dependencyValue)) {
      schemas = withDependentSchema(
        validator,
        resolvedSchema,
        rootSchema,
        dependencyKey,
        dependencyValue,
        expandAllBranches,
        recurseList,
        formData,
        experimental_customMergeAllOf
      );
    }
    return schemas.flatMap(
      (schema) => processDependencies(
        validator,
        remainingDependencies,
        schema,
        rootSchema,
        expandAllBranches,
        recurseList,
        formData,
        experimental_customMergeAllOf
      )
    );
  }
  return schemas;
}
function withDependentProperties(schema, additionallyRequired) {
  if (!additionallyRequired) {
    return schema;
  }
  const required = Array.isArray(schema.required) ? Array.from(/* @__PURE__ */ new Set([...schema.required, ...additionallyRequired])) : additionallyRequired;
  return { ...schema, required };
}
function withDependentSchema(validator, schema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, recurseList, formData, experimental_customMergeAllOf) {
  const dependentSchemas = retrieveSchemaInternal(
    validator,
    dependencyValue,
    rootSchema,
    formData,
    expandAllBranches,
    recurseList,
    experimental_customMergeAllOf
  );
  return dependentSchemas.flatMap((dependent) => {
    const { oneOf, ...dependentSchema } = dependent;
    schema = mergeSchemas(schema, dependentSchema);
    if (oneOf === void 0) {
      return schema;
    }
    const resolvedOneOfs = oneOf.map((subschema) => {
      if (typeof subschema === "boolean" || !(REF_KEY in subschema)) {
        return [subschema];
      }
      return resolveReference(validator, subschema, rootSchema, expandAllBranches, recurseList, formData);
    });
    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);
    return allPermutations.flatMap(
      (resolvedOneOf) => withExactlyOneSubschema(
        validator,
        schema,
        rootSchema,
        dependencyKey,
        resolvedOneOf,
        expandAllBranches,
        recurseList,
        formData,
        experimental_customMergeAllOf
      )
    );
  });
}
function withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, oneOf, expandAllBranches, recurseList, formData, experimental_customMergeAllOf) {
  const validSubschemas = oneOf.filter((subschema) => {
    if (typeof subschema === "boolean" || !subschema || !subschema.properties) {
      return false;
    }
    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;
    if (conditionPropertySchema) {
      const conditionSchema = {
        type: "object",
        properties: {
          [dependencyKey]: conditionPropertySchema
        }
      };
      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;
    }
    return false;
  });
  if (!expandAllBranches && validSubschemas.length !== 1) {
    console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid");
    return [schema];
  }
  return validSubschemas.flatMap((s) => {
    const subschema = s;
    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties);
    const dependentSchema = { ...subschema, properties: dependentSubschema };
    const schemas = retrieveSchemaInternal(
      validator,
      dependentSchema,
      rootSchema,
      formData,
      expandAllBranches,
      recurseList,
      experimental_customMergeAllOf
    );
    return schemas.map((s2) => mergeSchemas(schema, s2));
  });
}

// src/schema/findSelectedOptionInXxxOf.ts
function findSelectedOptionInXxxOf(validator, rootSchema, schema, fallbackField, xxx, formData = {}, experimental_customMergeAllOf) {
  if (Array.isArray(schema[xxx])) {
    const discriminator = getDiscriminatorFieldFromSchema(schema);
    const selectorField = discriminator || fallbackField;
    const xxxOfs = schema[xxx].map(
      (xxxOf) => retrieveSchema(validator, xxxOf, rootSchema, formData, experimental_customMergeAllOf)
    );
    const data = (0, import_get6.default)(formData, selectorField);
    if (data !== void 0) {
      return xxxOfs.find((xxx2) => {
        return (0, import_isEqual.default)(
          (0, import_get6.default)(xxx2, [PROPERTIES_KEY, selectorField, DEFAULT_KEY], (0, import_get6.default)(xxx2, [PROPERTIES_KEY, selectorField, CONST_KEY])),
          data
        );
      });
    }
  }
  return void 0;
}

// src/schema/getFromSchema.ts
var import_get7 = __toESM(require("lodash/get"), 1);
var import_has2 = __toESM(require("lodash/has"), 1);
var import_isEmpty3 = __toESM(require("lodash/isEmpty"), 1);
function getFromSchemaInternal(validator, rootSchema, schema, path, experimental_customMergeAllOf) {
  let fieldSchema = schema;
  if ((0, import_has2.default)(schema, REF_KEY)) {
    fieldSchema = retrieveSchema(validator, schema, rootSchema, void 0, experimental_customMergeAllOf);
  }
  if ((0, import_isEmpty3.default)(path)) {
    return fieldSchema;
  }
  const pathList = Array.isArray(path) ? path : path.split(".");
  const [part, ...nestedPath] = pathList;
  if (part && (0, import_has2.default)(fieldSchema, part)) {
    fieldSchema = (0, import_get7.default)(fieldSchema, part);
    return getFromSchemaInternal(
      validator,
      rootSchema,
      fieldSchema,
      nestedPath,
      experimental_customMergeAllOf
    );
  }
  return void 0;
}
function getFromSchema(validator, rootSchema, schema, path, defaultValue, experimental_customMergeAllOf) {
  const result = getFromSchemaInternal(validator, rootSchema, schema, path, experimental_customMergeAllOf);
  if (result === void 0) {
    return defaultValue;
  }
  return result;
}

// src/schema/findFieldInSchema.ts
var NOT_FOUND_SCHEMA = { title: "!@#$_UNKNOWN_$#@!" };
function findFieldInSchema(validator, rootSchema, schema, path, formData = {}, experimental_customMergeAllOf) {
  const pathList = Array.isArray(path) ? [...path] : path.split(".");
  let parentField = schema;
  const fieldName = pathList.pop();
  if (pathList.length) {
    pathList.forEach((subPath) => {
      parentField = getFromSchema(
        validator,
        rootSchema,
        parentField,
        [PROPERTIES_KEY, subPath],
        {},
        experimental_customMergeAllOf
      );
      if ((0, import_has3.default)(parentField, ONE_OF_KEY)) {
        parentField = findSelectedOptionInXxxOf(
          validator,
          rootSchema,
          parentField,
          fieldName,
          ONE_OF_KEY,
          (0, import_get8.default)(formData, subPath),
          experimental_customMergeAllOf
        );
      } else if ((0, import_has3.default)(parentField, ANY_OF_KEY)) {
        parentField = findSelectedOptionInXxxOf(
          validator,
          rootSchema,
          parentField,
          fieldName,
          ANY_OF_KEY,
          (0, import_get8.default)(formData, subPath),
          experimental_customMergeAllOf
        );
      }
    });
  }
  if ((0, import_has3.default)(parentField, ONE_OF_KEY)) {
    parentField = findSelectedOptionInXxxOf(
      validator,
      rootSchema,
      parentField,
      fieldName,
      ONE_OF_KEY,
      formData,
      experimental_customMergeAllOf
    );
  } else if ((0, import_has3.default)(parentField, ANY_OF_KEY)) {
    parentField = findSelectedOptionInXxxOf(
      validator,
      rootSchema,
      parentField,
      fieldName,
      ANY_OF_KEY,
      formData,
      experimental_customMergeAllOf
    );
  }
  let field = getFromSchema(
    validator,
    rootSchema,
    parentField,
    [PROPERTIES_KEY, fieldName],
    NOT_FOUND_SCHEMA,
    experimental_customMergeAllOf
  );
  if (field === NOT_FOUND_SCHEMA) {
    field = void 0;
  }
  const requiredArray = getFromSchema(
    validator,
    rootSchema,
    parentField,
    REQUIRED_KEY,
    [],
    experimental_customMergeAllOf
  );
  let isRequired;
  if (field && Array.isArray(requiredArray)) {
    isRequired = requiredArray.includes(fieldName);
  }
  return { field, isRequired };
}

// src/schema/getDefaultFormState.ts
var import_get12 = __toESM(require("lodash/get"), 1);
var import_isEmpty4 = __toESM(require("lodash/isEmpty"), 1);

// src/schema/getClosestMatchingOption.ts
var import_get9 = __toESM(require("lodash/get"), 1);
var import_has4 = __toESM(require("lodash/has"), 1);
var import_isNumber2 = __toESM(require("lodash/isNumber"), 1);
var import_isObject6 = __toESM(require("lodash/isObject"), 1);
var import_isString2 = __toESM(require("lodash/isString"), 1);
var import_reduce = __toESM(require("lodash/reduce"), 1);
var import_times2 = __toESM(require("lodash/times"), 1);
var JUNK_OPTION = {
  type: "object",
  $id: JUNK_OPTION_ID,
  properties: {
    __not_really_there__: {
      type: "number"
    }
  }
};
function calculateIndexScore(validator, rootSchema, schema, formData, experimental_customMergeAllOf) {
  let totalScore = 0;
  if (schema) {
    if ((0, import_isObject6.default)(schema.properties)) {
      totalScore += (0, import_reduce.default)(
        schema.properties,
        (score, value, key) => {
          const formValue = (0, import_get9.default)(formData, key);
          if (typeof value === "boolean") {
            return score;
          }
          if ((0, import_has4.default)(value, REF_KEY)) {
            const newSchema = retrieveSchema(
              validator,
              value,
              rootSchema,
              formValue,
              experimental_customMergeAllOf
            );
            return score + calculateIndexScore(
              validator,
              rootSchema,
              newSchema,
              formValue || {},
              experimental_customMergeAllOf
            );
          }
          if (((0, import_has4.default)(value, ONE_OF_KEY) || (0, import_has4.default)(value, ANY_OF_KEY)) && formValue) {
            const key2 = (0, import_has4.default)(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;
            const discriminator = getDiscriminatorFieldFromSchema(value);
            return score + getClosestMatchingOption(
              validator,
              rootSchema,
              formValue,
              (0, import_get9.default)(value, key2),
              -1,
              discriminator,
              experimental_customMergeAllOf
            );
          }
          if (value.type === "object") {
            if ((0, import_isObject6.default)(formValue)) {
              score += 1;
            }
            return score + calculateIndexScore(validator, rootSchema, value, formValue, experimental_customMergeAllOf);
          }
          if (value.type === guessType(formValue)) {
            let newScore = score + 1;
            if (value.default) {
              newScore += formValue === value.default ? 1 : -1;
            } else if (value.const) {
              newScore += formValue === value.const ? 1 : -1;
            }
            return newScore;
          }
          return score;
        },
        0
      );
    } else if ((0, import_isString2.default)(schema.type) && schema.type === guessType(formData)) {
      totalScore += 1;
    }
  }
  return totalScore;
}
function getClosestMatchingOption(validator, rootSchema, formData, options, selectedOption = -1, discriminatorField, experimental_customMergeAllOf) {
  const resolvedOptions = options.map((option) => {
    return resolveAllReferences(option, rootSchema, []);
  });
  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);
  if ((0, import_isNumber2.default)(simpleDiscriminatorMatch)) {
    return simpleDiscriminatorMatch;
  }
  const allValidIndexes = resolvedOptions.reduce((validList, option, index) => {
    const testOptions = [JUNK_OPTION, option];
    const match = getFirstMatchingOption(validator, formData, testOptions, rootSchema, discriminatorField);
    if (match === 1) {
      validList.push(index);
    }
    return validList;
  }, []);
  if (allValidIndexes.length === 1) {
    return allValidIndexes[0];
  }
  if (!allValidIndexes.length) {
    (0, import_times2.default)(resolvedOptions.length, (i) => allValidIndexes.push(i));
  }
  const scoreCount = /* @__PURE__ */ new Set();
  const { bestIndex } = allValidIndexes.reduce(
    (scoreData, index) => {
      const { bestScore } = scoreData;
      const option = resolvedOptions[index];
      const score = calculateIndexScore(validator, rootSchema, option, formData, experimental_customMergeAllOf);
      scoreCount.add(score);
      if (score > bestScore) {
        return { bestIndex: index, bestScore: score };
      }
      return scoreData;
    },
    { bestIndex: selectedOption, bestScore: 0 }
  );
  if (scoreCount.size === 1 && selectedOption >= 0) {
    return selectedOption;
  }
  return bestIndex;
}

// src/isFixedItems.ts
function isFixedItems(schema) {
  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));
}

// src/mergeDefaultsWithFormData.ts
var import_get10 = __toESM(require("lodash/get"), 1);
var import_isNil = __toESM(require("lodash/isNil"), 1);
function mergeDefaultsWithFormData(defaults, formData, mergeExtraArrayDefaults = false, defaultSupercedesUndefined = false, overrideFormDataWithDefaults = false) {
  if (Array.isArray(formData)) {
    const defaultsArray = Array.isArray(defaults) ? defaults : [];
    const overrideArray = overrideFormDataWithDefaults ? defaultsArray : formData;
    const overrideOppositeArray = overrideFormDataWithDefaults ? formData : defaultsArray;
    const mapped = overrideArray.map((value, idx) => {
      if (overrideOppositeArray[idx] !== void 0) {
        return mergeDefaultsWithFormData(
          defaultsArray[idx],
          formData[idx],
          mergeExtraArrayDefaults,
          defaultSupercedesUndefined,
          overrideFormDataWithDefaults
        );
      }
      return value;
    });
    if ((mergeExtraArrayDefaults || overrideFormDataWithDefaults) && mapped.length < overrideOppositeArray.length) {
      mapped.push(...overrideOppositeArray.slice(mapped.length));
    }
    return mapped;
  }
  if (isObject(formData)) {
    const acc = Object.assign({}, defaults);
    return Object.keys(formData).reduce((acc2, key) => {
      const keyValue = (0, import_get10.default)(formData, key);
      const keyExistsInDefaults = isObject(defaults) && key in defaults;
      const keyExistsInFormData = key in formData;
      const keyDefault = (0, import_get10.default)(defaults, key) ?? {};
      const defaultValueIsNestedObject = keyExistsInDefaults && Object.entries(keyDefault).some(([, v]) => isObject(v));
      const keyDefaultIsObject = keyExistsInDefaults && isObject((0, import_get10.default)(defaults, key));
      const keyHasFormDataObject = keyExistsInFormData && isObject(keyValue);
      if (keyDefaultIsObject && keyHasFormDataObject && !defaultValueIsNestedObject) {
        acc2[key] = {
          ...(0, import_get10.default)(defaults, key),
          ...keyValue
        };
        return acc2;
      }
      acc2[key] = mergeDefaultsWithFormData(
        (0, import_get10.default)(defaults, key),
        keyValue,
        mergeExtraArrayDefaults,
        defaultSupercedesUndefined,
        // overrideFormDataWithDefaults can be true only when the key value exists in defaults
        // Or if the key value doesn't exist in formData
        overrideFormDataWithDefaults && (keyExistsInDefaults || !keyExistsInFormData)
      );
      return acc2;
    }, acc);
  }
  if (defaultSupercedesUndefined && (!(defaults === void 0) && (0, import_isNil.default)(formData) || typeof formData === "number" && isNaN(formData)) || overrideFormDataWithDefaults && !(0, import_isNil.default)(formData)) {
    return defaults;
  }
  return formData;
}

// src/mergeObjects.ts
function mergeObjects(obj1, obj2, concatArrays = false) {
  return Object.keys(obj2).reduce(
    (acc, key) => {
      const left = obj1 ? obj1[key] : {}, right = obj2[key];
      if (obj1 && key in obj1 && isObject(right)) {
        acc[key] = mergeObjects(left, right, concatArrays);
      } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {
        let toMerge = right;
        if (concatArrays === "preventDuplicates") {
          toMerge = right.reduce((result, value) => {
            if (!left.includes(value)) {
              result.push(value);
            }
            return result;
          }, []);
        }
        acc[key] = left.concat(toMerge);
      } else {
        acc[key] = right;
      }
      return acc;
    },
    Object.assign({}, obj1)
  );
}

// src/isConstant.ts
function isConstant(schema) {
  return Array.isArray(schema.enum) && schema.enum.length === 1 || CONST_KEY in schema;
}

// src/schema/isSelect.ts
function isSelect(validator, theSchema, rootSchema = {}, experimental_customMergeAllOf) {
  const schema = retrieveSchema(validator, theSchema, rootSchema, void 0, experimental_customMergeAllOf);
  const altSchemas = schema.oneOf || schema.anyOf;
  if (Array.isArray(schema.enum)) {
    return true;
  }
  if (Array.isArray(altSchemas)) {
    return altSchemas.every((altSchemas2) => typeof altSchemas2 !== "boolean" && isConstant(altSchemas2));
  }
  return false;
}

// src/schema/isMultiSelect.ts
function isMultiSelect(validator, schema, rootSchema, experimental_customMergeAllOf) {
  if (!schema.uniqueItems || !schema.items || typeof schema.items === "boolean") {
    return false;
  }
  return isSelect(validator, schema.items, rootSchema, experimental_customMergeAllOf);
}

// src/constIsAjvDataReference.ts
var import_isString3 = __toESM(require("lodash/isString"), 1);
function constIsAjvDataReference(schema) {
  const schemaConst = schema[CONST_KEY];
  const schemaType = getSchemaType(schema);
  return isObject(schemaConst) && (0, import_isString3.default)(schemaConst?.$data) && schemaType !== "object" && schemaType !== "array";
}

// src/optionsList.ts
var import_get11 = __toESM(require("lodash/get"), 1);

// src/toConstant.ts
function toConstant(schema) {
  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {
    return schema.enum[0];
  }
  if (CONST_KEY in schema) {
    return schema.const;
  }
  throw new Error("schema cannot be inferred as a constant");
}

// src/optionsList.ts
function optionsList(schema, uiSchema) {
  if (schema.enum) {
    let enumNames;
    if (uiSchema) {
      const { enumNames: uiEnumNames } = getUiOptions(uiSchema);
      enumNames = uiEnumNames;
    }
    return schema.enum.map((value, i) => {
      const label = enumNames?.[i] || String(value);
      return { label, value };
    });
  }
  let altSchemas = void 0;
  let altUiSchemas = void 0;
  if (schema.anyOf) {
    altSchemas = schema.anyOf;
    altUiSchemas = uiSchema?.anyOf;
  } else if (schema.oneOf) {
    altSchemas = schema.oneOf;
    altUiSchemas = uiSchema?.oneOf;
  }
  let selectorField = getDiscriminatorFieldFromSchema(schema);
  if (uiSchema) {
    const { optionsSchemaSelector = selectorField } = getUiOptions(uiSchema);
    selectorField = optionsSchemaSelector;
  }
  return altSchemas && altSchemas.map((aSchemaDef, index) => {
    const { title } = getUiOptions(altUiSchemas?.[index]);
    const aSchema = aSchemaDef;
    let value;
    let label = title;
    if (selectorField) {
      const innerSchema = (0, import_get11.default)(aSchema, [PROPERTIES_KEY, selectorField], {});
      value = (0, import_get11.default)(innerSchema, DEFAULT_KEY, (0, import_get11.default)(innerSchema, CONST_KEY));
      label = label || innerSchema?.title || aSchema.title || String(value);
    } else {
      value = toConstant(aSchema);
      label = label || aSchema.title || String(value);
    }
    return {
      schema: aSchema,
      label,
      value
    };
  });
}

// src/schema/getDefaultFormState.ts
var PRIMITIVE_TYPES = ["string", "number", "integer", "boolean", "null"];
function getInnerSchemaForArrayItem(schema, additionalItems = 0 /* Ignore */, idx = -1) {
  if (idx >= 0) {
    if (Array.isArray(schema.items) && idx < schema.items.length) {
      const item = schema.items[idx];
      if (typeof item !== "boolean") {
        return item;
      }
    }
  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== "boolean") {
    return schema.items;
  }
  if (additionalItems !== 0 /* Ignore */ && isObject(schema.additionalItems)) {
    return schema.additionalItems;
  }
  return {};
}
function computeDefaultBasedOnSchemaTypeAndDefaults(schema, computedDefault) {
  const { default: schemaDefault, type } = schema;
  const shouldReturnNullAsDefault = Array.isArray(type) && type.includes("null") && (0, import_isEmpty4.default)(computedDefault) && schemaDefault === null;
  return shouldReturnNullAsDefault ? null : computedDefault;
}
function maybeAddDefaultToObject(obj, key, computedDefault, includeUndefinedValues, isParentRequired, requiredFields = [], experimental_defaultFormStateBehavior = {}, isConst = false, isNullType = false) {
  const { emptyObjectFields = "populateAllDefaults" } = experimental_defaultFormStateBehavior;
  if (includeUndefinedValues === true || isConst) {
    obj[key] = computedDefault;
  } else if (includeUndefinedValues === "excludeObjectChildren") {
    if (isNullType && computedDefault !== void 0 || !isObject(computedDefault) || !(0, import_isEmpty4.default)(computedDefault)) {
      obj[key] = computedDefault;
    }
  } else if (emptyObjectFields !== "skipDefaults") {
    const isSelfOrParentRequired = isParentRequired === void 0 ? requiredFields.includes(key) : isParentRequired;
    if (isObject(computedDefault)) {
      if (emptyObjectFields === "skipEmptyDefaults") {
        if (!(0, import_isEmpty4.default)(computedDefault)) {
          obj[key] = computedDefault;
        }
      } else if ((!(0, import_isEmpty4.default)(computedDefault) || requiredFields.includes(key)) && (isSelfOrParentRequired || emptyObjectFields !== "populateRequiredDefaults")) {
        obj[key] = computedDefault;
      }
    } else if (
      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
      // Condition 1: computedDefault is not undefined
      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults)
      // Or if isSelfOrParentRequired is 'true' and the key is a required field
      computedDefault !== void 0 && (emptyObjectFields === "populateAllDefaults" || emptyObjectFields === "skipEmptyDefaults" || isSelfOrParentRequired && requiredFields.includes(key))
    ) {
      obj[key] = computedDefault;
    }
  }
}
function computeDefaults(validator, rawSchema, computeDefaultsProps = {}) {
  const {
    parentDefaults,
    rawFormData,
    rootSchema = {},
    includeUndefinedValues = false,
    _recurseList = [],
    experimental_defaultFormStateBehavior = void 0,
    experimental_customMergeAllOf = void 0,
    required,
    shouldMergeDefaultsIntoFormData = false,
    initialDefaultsGenerated
  } = computeDefaultsProps;
  let formData = isObject(rawFormData) ? rawFormData : {};
  const schema = isObject(rawSchema) ? rawSchema : {};
  let defaults = parentDefaults;
  let schemaToCompute = null;
  let experimental_dfsb_to_compute = experimental_defaultFormStateBehavior;
  let updatedRecurseList = _recurseList;
  if (schema[CONST_KEY] !== void 0 && experimental_defaultFormStateBehavior?.constAsDefaults !== "never" && !constIsAjvDataReference(schema)) {
    defaults = schema[CONST_KEY];
  } else if (isObject(defaults) && isObject(schema.default)) {
    defaults = mergeObjects(defaults, schema.default);
  } else if (DEFAULT_KEY in schema && !schema[ANY_OF_KEY] && !schema[ONE_OF_KEY] && !schema[REF_KEY]) {
    defaults = schema.default;
  } else if (REF_KEY in schema) {
    const refName = schema[REF_KEY];
    if (!_recurseList.includes(refName)) {
      updatedRecurseList = _recurseList.concat(refName);
      schemaToCompute = findSchemaDefinition(refName, rootSchema);
    }
    if (schemaToCompute && !defaults) {
      defaults = schema.default;
    }
    if (shouldMergeDefaultsIntoFormData && schemaToCompute && !isObject(rawFormData)) {
      formData = rawFormData;
    }
  } else if (DEPENDENCIES_KEY in schema) {
    const defaultFormData = {
      ...getDefaultBasedOnSchemaType(validator, schema, computeDefaultsProps, defaults),
      ...formData
    };
    const resolvedSchema = resolveDependencies(
      validator,
      schema,
      rootSchema,
      false,
      [],
      defaultFormData,
      experimental_customMergeAllOf
    );
    schemaToCompute = resolvedSchema[0];
  } else if (isFixedItems(schema)) {
    defaults = schema.items.map(
      (itemSchema, idx) => computeDefaults(validator, itemSchema, {
        rootSchema,
        includeUndefinedValues,
        _recurseList,
        experimental_defaultFormStateBehavior,
        experimental_customMergeAllOf,
        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : void 0,
        rawFormData: formData,
        required,
        shouldMergeDefaultsIntoFormData
      })
    );
  } else if (ONE_OF_KEY in schema) {
    const { oneOf, ...remaining } = schema;
    if (oneOf.length === 0) {
      return void 0;
    }
    const discriminator = getDiscriminatorFieldFromSchema(schema);
    const { type = "null" } = remaining;
    if (!Array.isArray(type) && PRIMITIVE_TYPES.includes(type) && experimental_dfsb_to_compute?.constAsDefaults === "skipOneOf") {
      experimental_dfsb_to_compute = {
        ...experimental_dfsb_to_compute,
        constAsDefaults: "never"
      };
    }
    schemaToCompute = oneOf[getClosestMatchingOption(
      validator,
      rootSchema,
      rawFormData ?? schema.default,
      oneOf,
      0,
      discriminator,
      experimental_customMergeAllOf
    )];
    schemaToCompute = mergeSchemas(remaining, schemaToCompute);
  } else if (ANY_OF_KEY in schema) {
    const { anyOf, ...remaining } = schema;
    if (anyOf.length === 0) {
      return void 0;
    }
    const discriminator = getDiscriminatorFieldFromSchema(schema);
    schemaToCompute = anyOf[getClosestMatchingOption(
      validator,
      rootSchema,
      rawFormData ?? schema.default,
      anyOf,
      0,
      discriminator,
      experimental_customMergeAllOf
    )];
    schemaToCompute = mergeSchemas(remaining, schemaToCompute);
  }
  if (schemaToCompute) {
    return computeDefaults(validator, schemaToCompute, {
      rootSchema,
      includeUndefinedValues,
      _recurseList: updatedRecurseList,
      experimental_defaultFormStateBehavior: experimental_dfsb_to_compute,
      experimental_customMergeAllOf,
      parentDefaults: defaults,
      rawFormData: rawFormData ?? formData,
      required,
      shouldMergeDefaultsIntoFormData,
      initialDefaultsGenerated
    });
  }
  if (defaults === void 0) {
    defaults = schema.default;
  }
  const defaultBasedOnSchemaType = getDefaultBasedOnSchemaType(validator, schema, computeDefaultsProps, defaults);
  let defaultsWithFormData = defaultBasedOnSchemaType ?? defaults;
  if (shouldMergeDefaultsIntoFormData) {
    const { arrayMinItems = {} } = experimental_defaultFormStateBehavior || {};
    const { mergeExtraDefaults } = arrayMinItems;
    const matchingFormData = ensureFormDataMatchingSchema(
      validator,
      schema,
      rootSchema,
      rawFormData,
      experimental_defaultFormStateBehavior,
      experimental_customMergeAllOf
    );
    if (!isObject(rawFormData) || ALL_OF_KEY in schema) {
      defaultsWithFormData = mergeDefaultsWithFormData(
        defaultsWithFormData,
        matchingFormData,
        mergeExtraDefaults,
        true
      );
    }
  }
  return defaultsWithFormData;
}
function ensureFormDataMatchingSchema(validator, schema, rootSchema, formData, experimental_defaultFormStateBehavior, experimental_customMergeAllOf) {
  const isSelectField = !isConstant(schema) && isSelect(validator, schema, rootSchema, experimental_customMergeAllOf);
  let validFormData = formData;
  if (isSelectField) {
    const getOptionsList = optionsList(schema);
    const isValid = getOptionsList?.some((option) => deepEquals(option.value, formData));
    validFormData = isValid ? formData : void 0;
  }
  const constTakesPrecedence = schema[CONST_KEY] && experimental_defaultFormStateBehavior?.constAsDefaults === "always";
  if (constTakesPrecedence) {
    validFormData = schema.const;
  }
  return validFormData;
}
function getObjectDefaults(validator, rawSchema, {
  rawFormData,
  rootSchema = {},
  includeUndefinedValues = false,
  _recurseList = [],
  experimental_defaultFormStateBehavior = void 0,
  experimental_customMergeAllOf = void 0,
  required,
  shouldMergeDefaultsIntoFormData,
  initialDefaultsGenerated
} = {}, defaults) {
  {
    const formData = isObject(rawFormData) ? rawFormData : {};
    const schema = rawSchema;
    const retrievedSchema = experimental_defaultFormStateBehavior?.allOf === "populateDefaults" && ALL_OF_KEY in schema ? retrieveSchema(validator, schema, rootSchema, formData, experimental_customMergeAllOf) : schema;
    const parentConst = retrievedSchema[CONST_KEY];
    const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(
      (acc, key) => {
        const propertySchema = (0, import_get12.default)(retrievedSchema, [PROPERTIES_KEY, key], {});
        const hasParentConst = isObject(parentConst) && parentConst[key] !== void 0;
        const hasConst = (isObject(propertySchema) && CONST_KEY in propertySchema || hasParentConst) && experimental_defaultFormStateBehavior?.constAsDefaults !== "never" && !constIsAjvDataReference(propertySchema);
        const computedDefault = computeDefaults(validator, propertySchema, {
          rootSchema,
          _recurseList,
          experimental_defaultFormStateBehavior,
          experimental_customMergeAllOf,
          includeUndefinedValues: includeUndefinedValues === true,
          parentDefaults: (0, import_get12.default)(defaults, [key]),
          rawFormData: (0, import_get12.default)(formData, [key]),
          required: retrievedSchema.required?.includes(key),
          shouldMergeDefaultsIntoFormData,
          initialDefaultsGenerated
        });
        maybeAddDefaultToObject(
          acc,
          key,
          computedDefault,
          includeUndefinedValues,
          required,
          retrievedSchema.required,
          experimental_defaultFormStateBehavior,
          hasConst,
          propertySchema?.type === "null"
        );
        return acc;
      },
      {}
    );
    if (retrievedSchema.additionalProperties && !initialDefaultsGenerated) {
      const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties) ? retrievedSchema.additionalProperties : {};
      const keys2 = /* @__PURE__ */ new Set();
      if (isObject(defaults)) {
        Object.keys(defaults).filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach((key) => keys2.add(key));
      }
      const formDataRequired = [];
      Object.keys(formData).filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach((key) => {
        keys2.add(key);
        formDataRequired.push(key);
      });
      keys2.forEach((key) => {
        const computedDefault = computeDefaults(validator, additionalPropertiesSchema, {
          rootSchema,
          _recurseList,
          experimental_defaultFormStateBehavior,
          experimental_customMergeAllOf,
          includeUndefinedValues: includeUndefinedValues === true,
          parentDefaults: (0, import_get12.default)(defaults, [key]),
          rawFormData: (0, import_get12.default)(formData, [key]),
          required: retrievedSchema.required?.includes(key),
          shouldMergeDefaultsIntoFormData,
          initialDefaultsGenerated
        });
        maybeAddDefaultToObject(
          objectDefaults,
          key,
          computedDefault,
          includeUndefinedValues,
          required,
          formDataRequired
        );
      });
    }
    return computeDefaultBasedOnSchemaTypeAndDefaults(rawSchema, objectDefaults);
  }
}
function getArrayDefaults(validator, rawSchema, {
  rawFormData,
  rootSchema = {},
  _recurseList = [],
  experimental_defaultFormStateBehavior = void 0,
  experimental_customMergeAllOf = void 0,
  required,
  requiredAsRoot = false,
  shouldMergeDefaultsIntoFormData,
  initialDefaultsGenerated
} = {}, defaults) {
  const schema = rawSchema;
  const arrayMinItemsStateBehavior = experimental_defaultFormStateBehavior?.arrayMinItems ?? {};
  const { populate: arrayMinItemsPopulate, mergeExtraDefaults: arrayMergeExtraDefaults } = arrayMinItemsStateBehavior;
  const neverPopulate = arrayMinItemsPopulate === "never";
  const ignoreMinItemsFlagSet = arrayMinItemsPopulate === "requiredOnly";
  const isPopulateAll = arrayMinItemsPopulate === "all" || !neverPopulate && !ignoreMinItemsFlagSet;
  const computeSkipPopulate = arrayMinItemsStateBehavior?.computeSkipPopulate ?? (() => false);
  const isSkipEmptyDefaults = experimental_defaultFormStateBehavior?.emptyObjectFields === "skipEmptyDefaults";
  const emptyDefault = isSkipEmptyDefaults ? void 0 : [];
  if (Array.isArray(defaults)) {
    defaults = defaults.map((item, idx) => {
      const schemaItem = getInnerSchemaForArrayItem(schema, 2 /* Fallback */, idx);
      return computeDefaults(validator, schemaItem, {
        rootSchema,
        _recurseList,
        experimental_defaultFormStateBehavior,
        experimental_customMergeAllOf,
        parentDefaults: item,
        required,
        shouldMergeDefaultsIntoFormData,
        initialDefaultsGenerated
      });
    });
  }
  if (Array.isArray(rawFormData)) {
    const schemaItem = getInnerSchemaForArrayItem(schema);
    if (neverPopulate) {
      defaults = rawFormData;
    } else {
      const itemDefaults = rawFormData.map((item, idx) => {
        return computeDefaults(validator, schemaItem, {
          rootSchema,
          _recurseList,
          experimental_defaultFormStateBehavior,
          experimental_customMergeAllOf,
          rawFormData: item,
          parentDefaults: (0, import_get12.default)(defaults, [idx]),
          required,
          shouldMergeDefaultsIntoFormData,
          initialDefaultsGenerated
        });
      });
      const mergeExtraDefaults = (ignoreMinItemsFlagSet && required || isPopulateAll) && arrayMergeExtraDefaults;
      defaults = mergeDefaultsWithFormData(defaults, itemDefaults, mergeExtraDefaults);
    }
  }
  const hasConst = isObject(schema) && CONST_KEY in schema && experimental_defaultFormStateBehavior?.constAsDefaults !== "never";
  if (hasConst === false) {
    if (neverPopulate) {
      return defaults ?? emptyDefault;
    }
    if (ignoreMinItemsFlagSet && !required) {
      return defaults ? defaults : void 0;
    }
  }
  let arrayDefault;
  const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;
  if (!schema.minItems || isMultiSelect(validator, schema, rootSchema, experimental_customMergeAllOf) || computeSkipPopulate(validator, schema, rootSchema) || schema.minItems <= defaultsLength) {
    arrayDefault = defaults || !required && !requiredAsRoot ? defaults : emptyDefault;
  } else {
    const defaultEntries = defaults || [];
    const fillerSchema = getInnerSchemaForArrayItem(schema, 1 /* Invert */);
    const fillerDefault = fillerSchema.default;
    const fillerEntries = Array.from(
      { length: schema.minItems - defaultsLength },
      () => computeDefaults(validator, fillerSchema, {
        parentDefaults: fillerDefault,
        rootSchema,
        _recurseList,
        experimental_defaultFormStateBehavior,
        experimental_customMergeAllOf,
        required,
        shouldMergeDefaultsIntoFormData
      })
    );
    arrayDefault = defaultEntries.concat(fillerEntries);
  }
  return computeDefaultBasedOnSchemaTypeAndDefaults(rawSchema, arrayDefault);
}
function getDefaultBasedOnSchemaType(validator, rawSchema, computeDefaultsProps = {}, defaults) {
  switch (getSchemaType(rawSchema)) {
    // We need to recurse for object schema inner default values.
    case "object": {
      return getObjectDefaults(validator, rawSchema, computeDefaultsProps, defaults);
    }
    case "array": {
      return getArrayDefaults(validator, rawSchema, computeDefaultsProps, defaults);
    }
  }
}
function getDefaultFormState(validator, theSchema, formData, rootSchema, includeUndefinedValues = false, experimental_defaultFormStateBehavior, experimental_customMergeAllOf, initialDefaultsGenerated) {
  if (!isObject(theSchema)) {
    throw new Error("Invalid schema: " + theSchema);
  }
  const schema = retrieveSchema(validator, theSchema, rootSchema, formData, experimental_customMergeAllOf);
  const defaults = computeDefaults(validator, schema, {
    rootSchema,
    includeUndefinedValues,
    experimental_defaultFormStateBehavior,
    experimental_customMergeAllOf,
    rawFormData: formData,
    shouldMergeDefaultsIntoFormData: true,
    initialDefaultsGenerated,
    requiredAsRoot: true
  });
  if (schema.type !== "object" && isObject(schema.default)) {
    return {
      ...defaults,
      ...formData
    };
  }
  if (isObject(formData) || Array.isArray(formData)) {
    const { mergeDefaultsIntoFormData } = experimental_defaultFormStateBehavior || {};
    const defaultSupercedesUndefined = mergeDefaultsIntoFormData === "useDefaultIfFormDataUndefined";
    const result = mergeDefaultsWithFormData(
      defaults,
      formData,
      true,
      // set to true to add any additional default array entries.
      defaultSupercedesUndefined,
      true
      // set to true to override formData with defaults if they exist.
    );
    return result;
  }
  return defaults;
}

// src/schema/getDisplayLabel.ts
var import_get13 = __toESM(require("lodash/get"), 1);

// src/isCustomWidget.ts
function isCustomWidget(uiSchema = {}) {
  return (
    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.
    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets
    "widget" in getUiOptions(uiSchema) && getUiOptions(uiSchema)["widget"] !== "hidden"
  );
}

// src/schema/isFilesArray.ts
function isFilesArray(validator, schema, uiSchema = {}, rootSchema, experimental_customMergeAllOf) {
  if (uiSchema[UI_WIDGET_KEY] === "files") {
    return true;
  }
  if (schema.items) {
    const itemsSchema = retrieveSchema(
      validator,
      schema.items,
      rootSchema,
      void 0,
      experimental_customMergeAllOf
    );
    return itemsSchema.type === "string" && itemsSchema.format === "data-url";
  }
  return false;
}

// src/schema/getDisplayLabel.ts
function getDisplayLabel(validator, schema, uiSchema = {}, rootSchema, globalOptions, experimental_customMergeAllOf) {
  const uiOptions = getUiOptions(uiSchema, globalOptions);
  const { label = true } = uiOptions;
  let displayLabel = Boolean(label);
  if (displayLabel) {
    const schemaType = getSchemaType(schema);
    const addedByAdditionalProperty = (0, import_get13.default)(schema, ADDITIONAL_PROPERTY_FLAG, false);
    if (schemaType === "array") {
      displayLabel = addedByAdditionalProperty || isMultiSelect(validator, schema, rootSchema, experimental_customMergeAllOf) || isFilesArray(validator, schema, uiSchema, rootSchema, experimental_customMergeAllOf) || isCustomWidget(uiSchema);
    }
    if (schemaType === "object") {
      displayLabel = addedByAdditionalProperty;
    }
    if (schemaType === "boolean" && uiSchema && !uiSchema[UI_WIDGET_KEY]) {
      displayLabel = false;
    }
    if (uiSchema && uiSchema[UI_FIELD_KEY]) {
      displayLabel = false;
    }
  }
  return displayLabel;
}

// src/schema/sanitizeDataForNewSchema.ts
var import_get14 = __toESM(require("lodash/get"), 1);
var import_has5 = __toESM(require("lodash/has"), 1);
var NO_VALUE = Symbol("no Value");
function sanitizeDataForNewSchema(validator, rootSchema, newSchema, oldSchema, data = {}, experimental_customMergeAllOf) {
  let newFormData;
  if ((0, import_has5.default)(newSchema, PROPERTIES_KEY)) {
    const removeOldSchemaData = {};
    if ((0, import_has5.default)(oldSchema, PROPERTIES_KEY)) {
      const properties = (0, import_get14.default)(oldSchema, PROPERTIES_KEY, {});
      Object.keys(properties).forEach((key) => {
        if ((0, import_has5.default)(data, key)) {
          removeOldSchemaData[key] = void 0;
        }
      });
    }
    const keys2 = Object.keys((0, import_get14.default)(newSchema, PROPERTIES_KEY, {}));
    const nestedData = {};
    keys2.forEach((key) => {
      const formValue = (0, import_get14.default)(data, key);
      let oldKeyedSchema = (0, import_get14.default)(oldSchema, [PROPERTIES_KEY, key], {});
      let newKeyedSchema = (0, import_get14.default)(newSchema, [PROPERTIES_KEY, key], {});
      if ((0, import_has5.default)(oldKeyedSchema, REF_KEY)) {
        oldKeyedSchema = retrieveSchema(
          validator,
          oldKeyedSchema,
          rootSchema,
          formValue,
          experimental_customMergeAllOf
        );
      }
      if ((0, import_has5.default)(newKeyedSchema, REF_KEY)) {
        newKeyedSchema = retrieveSchema(
          validator,
          newKeyedSchema,
          rootSchema,
          formValue,
          experimental_customMergeAllOf
        );
      }
      const oldSchemaTypeForKey = (0, import_get14.default)(oldKeyedSchema, "type");
      const newSchemaTypeForKey = (0, import_get14.default)(newKeyedSchema, "type");
      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {
        if ((0, import_has5.default)(removeOldSchemaData, key)) {
          delete removeOldSchemaData[key];
        }
        if (newSchemaTypeForKey === "object" || newSchemaTypeForKey === "array" && Array.isArray(formValue)) {
          const itemData = sanitizeDataForNewSchema(
            validator,
            rootSchema,
            newKeyedSchema,
            oldKeyedSchema,
            formValue,
            experimental_customMergeAllOf
          );
          if (itemData !== void 0 || newSchemaTypeForKey === "array") {
            nestedData[key] = itemData;
          }
        } else {
          const newOptionDefault = (0, import_get14.default)(newKeyedSchema, "default", NO_VALUE);
          const oldOptionDefault = (0, import_get14.default)(oldKeyedSchema, "default", NO_VALUE);
          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {
            if (oldOptionDefault === formValue) {
              removeOldSchemaData[key] = newOptionDefault;
            } else if ((0, import_get14.default)(newKeyedSchema, "readOnly") === true) {
              removeOldSchemaData[key] = void 0;
            }
          }
          const newOptionConst = (0, import_get14.default)(newKeyedSchema, "const", NO_VALUE);
          const oldOptionConst = (0, import_get14.default)(oldKeyedSchema, "const", NO_VALUE);
          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {
            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : void 0;
          }
        }
      }
    });
    newFormData = {
      ...typeof data == "string" || Array.isArray(data) ? void 0 : data,
      ...removeOldSchemaData,
      ...nestedData
    };
  } else if ((0, import_get14.default)(oldSchema, "type") === "array" && (0, import_get14.default)(newSchema, "type") === "array" && Array.isArray(data)) {
    let oldSchemaItems = (0, import_get14.default)(oldSchema, "items");
    let newSchemaItems = (0, import_get14.default)(newSchema, "items");
    if (typeof oldSchemaItems === "object" && typeof newSchemaItems === "object" && !Array.isArray(oldSchemaItems) && !Array.isArray(newSchemaItems)) {
      if ((0, import_has5.default)(oldSchemaItems, REF_KEY)) {
        oldSchemaItems = retrieveSchema(
          validator,
          oldSchemaItems,
          rootSchema,
          data,
          experimental_customMergeAllOf
        );
      }
      if ((0, import_has5.default)(newSchemaItems, REF_KEY)) {
        newSchemaItems = retrieveSchema(
          validator,
          newSchemaItems,
          rootSchema,
          data,
          experimental_customMergeAllOf
        );
      }
      const oldSchemaType = (0, import_get14.default)(oldSchemaItems, "type");
      const newSchemaType = (0, import_get14.default)(newSchemaItems, "type");
      if (!oldSchemaType || oldSchemaType === newSchemaType) {
        const maxItems = (0, import_get14.default)(newSchema, "maxItems", -1);
        if (newSchemaType === "object") {
          newFormData = data.reduce((newValue, aValue) => {
            const itemValue = sanitizeDataForNewSchema(
              validator,
              rootSchema,
              newSchemaItems,
              oldSchemaItems,
              aValue,
              experimental_customMergeAllOf
            );
            if (itemValue !== void 0 && (maxItems < 0 || newValue.length < maxItems)) {
              newValue.push(itemValue);
            }
            return newValue;
          }, []);
        } else {
          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;
        }
      }
    } else if (typeof oldSchemaItems === "boolean" && typeof newSchemaItems === "boolean" && oldSchemaItems === newSchemaItems) {
      newFormData = data;
    }
  }
  return newFormData;
}

// src/schema/toPathSchema.ts
var import_get15 = __toESM(require("lodash/get"), 1);
var import_set2 = __toESM(require("lodash/set"), 1);
function toPathSchemaInternal(validator, schema, name, rootSchema, formData, _recurseList = [], experimental_customMergeAllOf) {
  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {
    const _schema = retrieveSchema(validator, schema, rootSchema, formData, experimental_customMergeAllOf);
    const sameSchemaIndex = _recurseList.findIndex((item) => deepEquals(item, _schema));
    if (sameSchemaIndex === -1) {
      return toPathSchemaInternal(
        validator,
        _schema,
        name,
        rootSchema,
        formData,
        _recurseList.concat(_schema),
        experimental_customMergeAllOf
      );
    }
  }
  let pathSchema = {
    [NAME_KEY]: name.replace(/^\./, "")
  };
  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {
    const xxxOf = ONE_OF_KEY in schema ? schema.oneOf : schema.anyOf;
    const discriminator = getDiscriminatorFieldFromSchema(schema);
    const index = getClosestMatchingOption(
      validator,
      rootSchema,
      formData,
      xxxOf,
      0,
      discriminator,
      experimental_customMergeAllOf
    );
    const _schema = xxxOf[index];
    pathSchema = {
      ...pathSchema,
      ...toPathSchemaInternal(
        validator,
        _schema,
        name,
        rootSchema,
        formData,
        _recurseList,
        experimental_customMergeAllOf
      )
    };
  }
  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {
    (0, import_set2.default)(pathSchema, RJSF_ADDITIONAL_PROPERTIES_FLAG, true);
  }
  if (ITEMS_KEY in schema && Array.isArray(formData)) {
    const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;
    if (Array.isArray(schemaItems)) {
      formData.forEach((element, i) => {
        if (schemaItems[i]) {
          pathSchema[i] = toPathSchemaInternal(
            validator,
            schemaItems[i],
            `${name}.${i}`,
            rootSchema,
            element,
            _recurseList,
            experimental_customMergeAllOf
          );
        } else if (schemaAdditionalItems) {
          pathSchema[i] = toPathSchemaInternal(
            validator,
            schemaAdditionalItems,
            `${name}.${i}`,
            rootSchema,
            element,
            _recurseList,
            experimental_customMergeAllOf
          );
        } else {
          console.warn(`Unable to generate path schema for "${name}.${i}". No schema defined for it`);
        }
      });
    } else {
      formData.forEach((element, i) => {
        pathSchema[i] = toPathSchemaInternal(
          validator,
          schemaItems,
          `${name}.${i}`,
          rootSchema,
          element,
          _recurseList,
          experimental_customMergeAllOf
        );
      });
    }
  } else if (PROPERTIES_KEY in schema) {
    for (const property in schema.properties) {
      const field = (0, import_get15.default)(schema, [PROPERTIES_KEY, property], {});
      pathSchema[property] = toPathSchemaInternal(
        validator,
        field,
        `${name}.${property}`,
        rootSchema,
        // It's possible that formData is not an object -- this can happen if an
        // array item has just been added, but not populated with data yet
        (0, import_get15.default)(formData, [property]),
        _recurseList,
        experimental_customMergeAllOf
      );
    }
  }
  return pathSchema;
}
function toPathSchema(validator, schema, name = "", rootSchema, formData, experimental_customMergeAllOf) {
  return toPathSchemaInternal(validator, schema, name, rootSchema, formData, void 0, experimental_customMergeAllOf);
}

// src/createSchemaUtils.ts
var import_get16 = __toESM(require("lodash/get"), 1);
var SchemaUtils = class {
  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
   * @param rootSchema - The root schema that will be forwarded to all the APIs
   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior
   * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
   */
  constructor(validator, rootSchema, experimental_defaultFormStateBehavior, experimental_customMergeAllOf) {
    if (rootSchema && rootSchema[SCHEMA_KEY] === JSON_SCHEMA_DRAFT_2020_12) {
      this.rootSchema = makeAllReferencesAbsolute(rootSchema, (0, import_get16.default)(rootSchema, ID_KEY, "#"));
    } else {
      this.rootSchema = rootSchema;
    }
    this.validator = validator;
    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;
    this.experimental_customMergeAllOf = experimental_customMergeAllOf;
  }
  /** Returns the `rootSchema` in the `SchemaUtilsType`
   *
   * @returns - The `rootSchema`
   */
  getRootSchema() {
    return this.rootSchema;
  }
  /** Returns the `ValidatorType` in the `SchemaUtilsType`
   *
   * @returns - The `ValidatorType`
   */
  getValidator() {
    return this.validator;
  }
  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of
   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation
   * of a new `SchemaUtilsType` with incomplete properties.
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one
   * @param rootSchema - The root schema that will be compared against the current one
   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
   * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`
   */
  doesSchemaUtilsDiffer(validator, rootSchema, experimental_defaultFormStateBehavior = {}, experimental_customMergeAllOf) {
    if (!validator || !rootSchema) {
      return false;
    }
    return this.validator !== validator || !deepEquals(this.rootSchema, rootSchema) || !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior) || this.experimental_customMergeAllOf !== experimental_customMergeAllOf;
  }
  /** Finds the field specified by the `path` within the root or recursed `schema`. If there is no field for the specified
   * `path`, then the default `{ field: undefined, isRequired: undefined }` is returned. It determines whether a leaf
   * field is in the `required` list for its parent and if so, it is marked as required on return.
   *
   * @param schema - The current node within the JSON schema
   * @param path - The remaining keys in the path to the desired field
   * @param [formData] - The form data that is used to determine which oneOf option
   * @returns - An object that contains the field and its required state. If no field can be found then
   *            `{ field: undefined, isRequired: undefined }` is returned.
   */
  findFieldInSchema(schema, path, formData) {
    return findFieldInSchema(
      this.validator,
      this.rootSchema,
      schema,
      path,
      formData,
      this.experimental_customMergeAllOf
    );
  }
  /** Finds the oneOf option inside the `schema['any/oneOf']` list which has the `properties[selectorField].default` that
   * matches the `formData[selectorField]` value. For the purposes of this function, `selectorField` is either
   * `schema.discriminator.propertyName` or `fallbackField`.
   *
   * @param schema - The schema element in which to search for the selected oneOf option
   * @param fallbackField - The field to use as a backup selector field if the schema does not have a required field
   * @param xxx - Either `oneOf` or `anyOf`, defines which value is being sought
   * @param [formData={}] - The form data that is used to determine which oneOf option
   * @returns - The anyOf/oneOf option that matches the selector field in the schema or undefined if nothing is selected
   */
  findSelectedOptionInXxxOf(schema, fallbackField, xxx, formData) {
    return findSelectedOptionInXxxOf(
      this.validator,
      this.rootSchema,
      schema,
      fallbackField,
      xxx,
      formData,
      this.experimental_customMergeAllOf
    );
  }
  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
   * computed to have defaults provided in the `schema`.
   *
   * @param schema - The schema for which the default state is desired
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
   *          If "excludeObjectChildren", pass `includeUndefinedValues` as false when computing defaults for any nested
   *          object properties.
   * @param initialDefaultsGenerated - Indicates whether or not initial defaults have been generated
   * @returns - The resulting `formData` with all the defaults provided
   */
  getDefaultFormState(schema, formData, includeUndefinedValues = false, initialDefaultsGenerated) {
    return getDefaultFormState(
      this.validator,
      schema,
      formData,
      this.rootSchema,
      includeUndefinedValues,
      this.experimental_defaultFormStateBehavior,
      this.experimental_customMergeAllOf,
      initialDefaultsGenerated
    );
  }
  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
   * should be displayed in a UI.
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [uiSchema] - The UI schema from which to derive potentially displayable information
   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
   * @returns - True if the label should be displayed or false if it should not
   */
  getDisplayLabel(schema, uiSchema, globalOptions) {
    return getDisplayLabel(
      this.validator,
      schema,
      uiSchema,
      this.rootSchema,
      globalOptions,
      this.experimental_customMergeAllOf
    );
  }
  /** Determines which of the given `options` provided most closely matches the `formData`.
   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.
   *
   * The closest match is determined using the number of matching properties, and more heavily favors options with
   * matching readOnly, default, or const values.
   *
   * @param formData - The form data associated with the schema
   * @param options - The list of options that can be selected from
   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
   */
  getClosestMatchingOption(formData, options, selectedOption, discriminatorField) {
    return getClosestMatchingOption(
      this.validator,
      this.rootSchema,
      formData,
      options,
      selectedOption,
      discriminatorField,
      this.experimental_customMergeAllOf
    );
  }
  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
   * Always returns the first option if there is nothing that matches.
   *
   * @param formData - The current formData, if any, used to figure out a match
   * @param options - The list of options to find a matching options from
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The firstindex of the matched option or 0 if none is available
   */
  getFirstMatchingOption(formData, options, discriminatorField) {
    return getFirstMatchingOption(this.validator, formData, options, this.rootSchema, discriminatorField);
  }
  getFromSchema(schema, path, defaultValue) {
    return getFromSchema(
      this.validator,
      this.rootSchema,
      schema,
      path,
      // @ts-expect-error TS2769: No overload matches this call
      defaultValue,
      this.experimental_customMergeAllOf
    );
  }
  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files
   *
   * @param schema - The schema for which check for array of files flag is desired
   * @param [uiSchema] - The UI schema from which to check the widget
   * @returns - True if schema/uiSchema contains an array of files, otherwise false
   */
  isFilesArray(schema, uiSchema) {
    return isFilesArray(this.validator, schema, uiSchema, this.rootSchema, this.experimental_customMergeAllOf);
  }
  /** Checks to see if the `schema` combination represents a multi-select
   *
   * @param schema - The schema for which check for a multi-select flag is desired
   * @returns - True if schema contains a multi-select, otherwise false
   */
  isMultiSelect(schema) {
    return isMultiSelect(this.validator, schema, this.rootSchema, this.experimental_customMergeAllOf);
  }
  /** Checks to see if the `schema` combination represents a select
   *
   * @param schema - The schema for which check for a select flag is desired
   * @returns - True if schema contains a select, otherwise false
   */
  isSelect(schema) {
    return isSelect(this.validator, schema, this.rootSchema, this.experimental_customMergeAllOf);
  }
  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and
   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially
   * recursive resolution.
   *
   * @param schema - The schema for which retrieving a schema is desired
   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
   * @param [resolveAnyOfOrOneOfRefs] - Optional flag indicating whether to resolved refs in anyOf/oneOf lists
   * @returns - The schema having its conditions, additional properties, references and dependencies resolved
   */
  retrieveSchema(schema, rawFormData, resolveAnyOfOrOneOfRefs) {
    return retrieveSchema(
      this.validator,
      schema,
      this.rootSchema,
      rawFormData,
      this.experimental_customMergeAllOf,
      resolveAnyOfOrOneOfRefs
    );
  }
  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the
   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the
   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the
   * old schemas that are non-existent in the new schema are set to `undefined`.
   *
   * @param [newSchema] - The new schema for which the data is being sanitized
   * @param [oldSchema] - The old schema from which the data originated
   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
   * @returns - The new form data, with all the fields uniquely associated with the old schema set
   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
   */
  sanitizeDataForNewSchema(newSchema, oldSchema, data) {
    return sanitizeDataForNewSchema(
      this.validator,
      this.rootSchema,
      newSchema,
      oldSchema,
      data,
      this.experimental_customMergeAllOf
    );
  }
  /** Generates an `PathSchema` object for the `schema`, recursively
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [name] - The base name for the schema
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @returns - The `PathSchema` object for the `schema`
   */
  toPathSchema(schema, name, formData) {
    return toPathSchema(
      this.validator,
      schema,
      name,
      this.rootSchema,
      formData,
      this.experimental_customMergeAllOf
    );
  }
};
function createSchemaUtils(validator, rootSchema, experimental_defaultFormStateBehavior = {}, experimental_customMergeAllOf) {
  return new SchemaUtils(
    validator,
    rootSchema,
    experimental_defaultFormStateBehavior,
    experimental_customMergeAllOf
  );
}

// src/dataURItoBlob.ts
function dataURItoBlob(dataURILike) {
  if (dataURILike.indexOf("data:") === -1) {
    throw new Error("File is invalid: URI must be a dataURI");
  }
  const dataURI = dataURILike.slice(5);
  const splitted = dataURI.split(";base64,");
  if (splitted.length !== 2) {
    throw new Error("File is invalid: dataURI must be base64");
  }
  const [media, base64] = splitted;
  const [mime, ...mediaparams] = media.split(";");
  const type = mime || "";
  const name = decodeURI(
    // parse the parameters into key-value pairs, find a key, and extract a value
    // if no key is found, then the name is unknown
    mediaparams.map((param) => param.split("=")).find(([key]) => key === "name")?.[1] || "unknown"
  );
  try {
    const binary = atob(base64);
    const array = new Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      array[i] = binary.charCodeAt(i);
    }
    const blob = new window.Blob([new Uint8Array(array)], { type });
    return { blob, name };
  } catch (error) {
    throw new Error("File is invalid: " + error.message);
  }
}

// src/pad.ts
function pad(num, width) {
  let s = String(num);
  while (s.length < width) {
    s = "0" + s;
  }
  return s;
}

// src/dateRangeOptions.ts
function dateRangeOptions(start, stop) {
  if (start <= 0 && stop <= 0) {
    start = (/* @__PURE__ */ new Date()).getFullYear() + start;
    stop = (/* @__PURE__ */ new Date()).getFullYear() + stop;
  } else if (start < 0 || stop < 0) {
    throw new Error(`Both start (${start}) and stop (${stop}) must both be <= 0 or > 0, got one of each`);
  }
  if (start > stop) {
    return dateRangeOptions(stop, start).reverse();
  }
  const options = [];
  for (let i = start; i <= stop; i++) {
    options.push({ value: i, label: pad(i, 2) });
  }
  return options;
}

// src/shallowEquals.ts
function shallowEquals(a, b) {
  if (Object.is(a, b)) {
    return true;
  }
  if (a == null || b == null) {
    return false;
  }
  if (typeof a !== "object" || typeof b !== "object") {
    return false;
  }
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    const key = keysA[i];
    if (!Object.prototype.hasOwnProperty.call(b, key) || !Object.is(a[key], b[key])) {
      return false;
    }
  }
  return true;
}

// src/replaceStringParameters.ts
function replaceStringParameters(inputString, params) {
  let output = inputString;
  if (Array.isArray(params)) {
    const parts = output.split(/(%\d)/);
    params.forEach((param, index) => {
      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);
      if (partIndex >= 0) {
        parts[partIndex] = param;
      }
    });
    output = parts.join("");
  }
  return output;
}

// src/englishStringTranslator.ts
function englishStringTranslator(stringToTranslate, params) {
  return replaceStringParameters(stringToTranslate, params);
}

// src/enumOptionsValueForIndex.ts
function enumOptionsValueForIndex(valueIndex, allEnumOptions = [], emptyValue) {
  if (Array.isArray(valueIndex)) {
    return valueIndex.map((index2) => enumOptionsValueForIndex(index2, allEnumOptions)).filter((val) => val !== emptyValue);
  }
  const index = valueIndex === "" || valueIndex === null ? -1 : Number(valueIndex);
  const option = allEnumOptions[index];
  return option ? option.value : emptyValue;
}

// src/enumOptionsDeselectValue.ts
function enumOptionsDeselectValue(valueIndex, selected, allEnumOptions = []) {
  const value = enumOptionsValueForIndex(valueIndex, allEnumOptions);
  if (Array.isArray(selected)) {
    return selected.filter((v) => !deepEquals(v, value));
  }
  return deepEquals(value, selected) ? void 0 : selected;
}

// src/enumOptionsIsSelected.ts
function enumOptionsIsSelected(value, selected) {
  if (Array.isArray(selected)) {
    return selected.some((sel) => deepEquals(sel, value));
  }
  return deepEquals(selected, value);
}

// src/enumOptionsIndexForValue.ts
function enumOptionsIndexForValue(value, allEnumOptions = [], multiple = false) {
  const selectedIndexes = allEnumOptions.map((opt, index) => enumOptionsIsSelected(opt.value, value) ? String(index) : void 0).filter((opt) => typeof opt !== "undefined");
  if (!multiple) {
    return selectedIndexes[0];
  }
  return selectedIndexes;
}

// src/enumOptionsSelectValue.ts
var import_isNil2 = __toESM(require("lodash/isNil"), 1);
function enumOptionsSelectValue(valueIndex, selected, allEnumOptions = []) {
  const value = enumOptionsValueForIndex(valueIndex, allEnumOptions);
  if (!(0, import_isNil2.default)(value)) {
    const index = allEnumOptions.findIndex((opt) => value === opt.value);
    const all = allEnumOptions.map(({ value: val }) => val);
    const updated = selected.slice(0, index).concat(value, selected.slice(index));
    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));
  }
  return selected;
}

// src/ErrorSchemaBuilder.ts
var import_cloneDeep = __toESM(require("lodash/cloneDeep"), 1);
var import_get17 = __toESM(require("lodash/get"), 1);
var import_set3 = __toESM(require("lodash/set"), 1);
var import_setWith = __toESM(require("lodash/setWith"), 1);
var ErrorSchemaBuilder = class {
  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   */
  constructor(initialSchema) {
    /** The error schema being built
     *
     * @private
     */
    this.errorSchema = {};
    this.resetAllErrors(initialSchema);
  }
  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`
   */
  get ErrorSchema() {
    return this.errorSchema;
  }
  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The error block for the given `pathOfError` or the root if not provided
   * @private
   */
  getOrCreateErrorBlock(pathOfError) {
    const hasPath = Array.isArray(pathOfError) && pathOfError.length > 0 || typeof pathOfError === "string";
    let errorBlock = hasPath ? (0, import_get17.default)(this.errorSchema, pathOfError) : this.errorSchema;
    if (!errorBlock && pathOfError) {
      errorBlock = {};
      (0, import_setWith.default)(this.errorSchema, pathOfError, errorBlock, Object);
    }
    return errorBlock;
  }
  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  resetAllErrors(initialSchema) {
    this.errorSchema = initialSchema ? (0, import_cloneDeep.default)(initialSchema) : {};
    return this;
  }
  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within
   * the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  addErrors(errorOrList, pathOfError) {
    const errorBlock = this.getOrCreateErrorBlock(pathOfError);
    let errorsList = (0, import_get17.default)(errorBlock, ERRORS_KEY);
    if (!Array.isArray(errorsList)) {
      errorsList = [];
      errorBlock[ERRORS_KEY] = errorsList;
    }
    if (Array.isArray(errorOrList)) {
      (0, import_set3.default)(errorBlock, ERRORS_KEY, [.../* @__PURE__ */ new Set([...errorsList, ...errorOrList])]);
    } else {
      (0, import_set3.default)(errorBlock, ERRORS_KEY, [.../* @__PURE__ */ new Set([...errorsList, errorOrList])]);
    }
    return this;
  }
  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location
   * within the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  setErrors(errorOrList, pathOfError) {
    const errorBlock = this.getOrCreateErrorBlock(pathOfError);
    const listToAdd = Array.isArray(errorOrList) ? [.../* @__PURE__ */ new Set([...errorOrList])] : [errorOrList];
    (0, import_set3.default)(errorBlock, ERRORS_KEY, listToAdd);
    return this;
  }
  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by
   * the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  clearErrors(pathOfError) {
    const errorBlock = this.getOrCreateErrorBlock(pathOfError);
    (0, import_set3.default)(errorBlock, ERRORS_KEY, []);
    return this;
  }
};

// src/getChangedFields.ts
var import_keys = __toESM(require("lodash/keys"), 1);
var import_pickBy = __toESM(require("lodash/pickBy"), 1);
var import_isPlainObject2 = __toESM(require("lodash/isPlainObject"), 1);
var import_get18 = __toESM(require("lodash/get"), 1);
var import_difference = __toESM(require("lodash/difference"), 1);
function getChangedFields(a, b) {
  const aIsPlainObject = (0, import_isPlainObject2.default)(a);
  const bIsPlainObject = (0, import_isPlainObject2.default)(b);
  if (a === b || !aIsPlainObject && !bIsPlainObject) {
    return [];
  }
  if (aIsPlainObject && !bIsPlainObject) {
    return (0, import_keys.default)(a);
  } else if (!aIsPlainObject && bIsPlainObject) {
    return (0, import_keys.default)(b);
  } else {
    const unequalFields = (0, import_keys.default)((0, import_pickBy.default)(a, (value, key) => !deepEquals(value, (0, import_get18.default)(b, key))));
    const diffFields = (0, import_difference.default)((0, import_keys.default)(b), (0, import_keys.default)(a));
    return [...unequalFields, ...diffFields];
  }
}

// src/getDateElementProps.ts
function getDateElementProps(date, time, yearRange = [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2], format = "YMD") {
  const { day, month, year, hour, minute, second } = date;
  const dayObj = { type: "day", range: [1, 31], value: day };
  const monthObj = { type: "month", range: [1, 12], value: month };
  const yearObj = { type: "year", range: yearRange, value: year };
  const dateElementProp = [];
  switch (format) {
    case "MDY":
      dateElementProp.push(monthObj, dayObj, yearObj);
      break;
    case "DMY":
      dateElementProp.push(dayObj, monthObj, yearObj);
      break;
    case "YMD":
    default:
      dateElementProp.push(yearObj, monthObj, dayObj);
  }
  if (time) {
    dateElementProp.push(
      { type: "hour", range: [0, 23], value: hour },
      { type: "minute", range: [0, 59], value: minute },
      { type: "second", range: [0, 59], value: second }
    );
  }
  return dateElementProp;
}

// src/rangeSpec.ts
function rangeSpec(schema) {
  const spec = {};
  if (schema.multipleOf) {
    spec.step = schema.multipleOf;
  }
  if (schema.minimum || schema.minimum === 0) {
    spec.min = schema.minimum;
  }
  if (schema.maximum || schema.maximum === 0) {
    spec.max = schema.maximum;
  }
  return spec;
}

// src/getInputProps.ts
function getInputProps(schema, defaultType, options = {}, autoDefaultStepAny = true) {
  const inputProps = {
    type: defaultType || "text",
    ...rangeSpec(schema)
  };
  if (options.inputType) {
    inputProps.type = options.inputType;
  } else if (!defaultType) {
    if (schema.type === "number") {
      inputProps.type = "number";
      if (autoDefaultStepAny && inputProps.step === void 0) {
        inputProps.step = "any";
      }
    } else if (schema.type === "integer") {
      inputProps.type = "number";
      if (inputProps.step === void 0) {
        inputProps.step = 1;
      }
    }
  }
  if (options.autocomplete) {
    inputProps.autoComplete = options.autocomplete;
  }
  if (options.accept) {
    inputProps.accept = options.accept;
  }
  return inputProps;
}

// src/getSubmitButtonOptions.ts
var DEFAULT_OPTIONS = {
  props: {
    disabled: false
  },
  submitText: "Submit",
  norender: false
};
function getSubmitButtonOptions(uiSchema = {}) {
  const uiOptions = getUiOptions(uiSchema);
  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {
    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY];
    return { ...DEFAULT_OPTIONS, ...options };
  }
  return DEFAULT_OPTIONS;
}

// src/getTemplate.ts
function getTemplate(name, registry, uiOptions = {}) {
  const { templates } = registry;
  if (name === "ButtonTemplates") {
    return templates[name];
  }
  if (Object.hasOwn(uiOptions, name) && typeof uiOptions[name] === "string" && Object.hasOwn(templates, uiOptions[name])) {
    const key = uiOptions[name];
    return templates[key];
  }
  return (
    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent
    // To avoid that, we cast uiOptions to `any` before accessing the name field
    uiOptions[name] || templates[name]
  );
}

// src/getTestIds.ts
var import_get19 = __toESM(require("lodash/get"), 1);
var import_uniqueId = __toESM(require("lodash/uniqueId"), 1);
function getTestIds() {
  if (typeof process === "undefined" || (0, import_get19.default)(process, "env.NODE_ENV") !== "test") {
    return {};
  }
  const ids = /* @__PURE__ */ new Map();
  return new Proxy(
    {},
    {
      get(_obj, prop) {
        if (!ids.has(prop)) {
          ids.set(prop, (0, import_uniqueId.default)("test-id-"));
        }
        return ids.get(prop);
      }
    }
  );
}

// src/getWidget.tsx
var import_react = require("react");
var import_react_is = __toESM(require("react-is"), 1);
var import_get20 = __toESM(require("lodash/get"), 1);
var import_set4 = __toESM(require("lodash/set"), 1);
var import_jsx_runtime = require("react/jsx-runtime");
var widgetMap = {
  boolean: {
    checkbox: "CheckboxWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    hidden: "HiddenWidget"
  },
  string: {
    text: "TextWidget",
    password: "PasswordWidget",
    email: "EmailWidget",
    hostname: "TextWidget",
    ipv4: "TextWidget",
    ipv6: "TextWidget",
    uri: "URLWidget",
    "data-url": "FileWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    textarea: "TextareaWidget",
    hidden: "HiddenWidget",
    date: "DateWidget",
    datetime: "DateTimeWidget",
    "date-time": "DateTimeWidget",
    "alt-date": "AltDateWidget",
    "alt-datetime": "AltDateTimeWidget",
    time: "TimeWidget",
    color: "ColorWidget",
    file: "FileWidget"
  },
  number: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  integer: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  array: {
    select: "SelectWidget",
    checkboxes: "CheckboxesWidget",
    files: "FileWidget",
    hidden: "HiddenWidget"
  }
};
function mergeWidgetOptions(AWidget) {
  let MergedWidget = (0, import_get20.default)(AWidget, "MergedWidget");
  if (!MergedWidget) {
    const defaultOptions = AWidget.defaultProps && AWidget.defaultProps.options || {};
    MergedWidget = ({ options, ...props }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AWidget, { options: { ...defaultOptions, ...options }, ...props });
    };
    (0, import_set4.default)(AWidget, "MergedWidget", MergedWidget);
  }
  return MergedWidget;
}
function getWidget(schema, widget, registeredWidgets = {}) {
  const type = getSchemaType(schema);
  if (typeof widget === "function" || widget && import_react_is.default.isForwardRef((0, import_react.createElement)(widget)) || import_react_is.default.isMemo(widget)) {
    return mergeWidgetOptions(widget);
  }
  if (typeof widget !== "string") {
    throw new Error(`Unsupported widget definition: ${typeof widget} in schema: ${JSON.stringify(schema)}`);
  }
  if (widget in registeredWidgets) {
    const registeredWidget = registeredWidgets[widget];
    return getWidget(schema, registeredWidget, registeredWidgets);
  }
  if (typeof type === "string") {
    if (!(type in widgetMap)) {
      throw new Error(`No widget for type '${type}' in schema: ${JSON.stringify(schema)}`);
    }
    if (widget in widgetMap[type]) {
      const registeredWidget = registeredWidgets[widgetMap[type][widget]];
      return getWidget(schema, registeredWidget, registeredWidgets);
    }
  }
  throw new Error(`No widget '${widget}' for type '${type}' in schema: ${JSON.stringify(schema)}`);
}

// src/hashForSchema.ts
function hashString(string) {
  let hash = 0;
  for (let i = 0; i < string.length; i += 1) {
    const chr = string.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash = hash & hash;
  }
  return hash.toString(16);
}
function sortedJSONStringify(object) {
  const allKeys = /* @__PURE__ */ new Set();
  JSON.stringify(object, (key, value) => (allKeys.add(key), value));
  return JSON.stringify(object, Array.from(allKeys).sort());
}
function hashObject(object) {
  return hashString(sortedJSONStringify(object));
}
function hashForSchema(schema) {
  return hashObject(schema);
}

// src/hasWidget.ts
function hasWidget(schema, widget, registeredWidgets = {}) {
  try {
    getWidget(schema, widget, registeredWidgets);
    return true;
  } catch (e) {
    const err = e;
    if (err.message && (err.message.startsWith("No widget") || err.message.startsWith("Unsupported widget"))) {
      return false;
    }
    throw e;
  }
}

// src/idGenerators.ts
var import_isString4 = __toESM(require("lodash/isString"), 1);
function idGenerator(id, suffix) {
  const theId = (0, import_isString4.default)(id) ? id : id[ID_KEY];
  return `${theId}__${suffix}`;
}
function descriptionId(id) {
  return idGenerator(id, "description");
}
function errorId(id) {
  return idGenerator(id, "error");
}
function examplesId(id) {
  return idGenerator(id, "examples");
}
function helpId(id) {
  return idGenerator(id, "help");
}
function titleId(id) {
  return idGenerator(id, "title");
}
function ariaDescribedByIds(id, includeExamples = false) {
  const examples = includeExamples ? ` ${examplesId(id)}` : "";
  return `${errorId(id)} ${descriptionId(id)} ${helpId(id)}${examples}`;
}
function optionId(id, optionIndex) {
  return `${id}-${optionIndex}`;
}
function buttonId(id, btn) {
  return idGenerator(id, btn);
}
function optionalControlsId(id, element) {
  return idGenerator(id, `optional${element}`);
}

// src/isFormDataAvailable.ts
var import_isNil3 = __toESM(require("lodash/isNil"), 1);
var import_isEmpty5 = __toESM(require("lodash/isEmpty"), 1);
var import_isObject11 = __toESM(require("lodash/isObject"), 1);
function isFormDataAvailable(formData) {
  return !(0, import_isNil3.default)(formData) && (!(0, import_isObject11.default)(formData) || Array.isArray(formData) || !(0, import_isEmpty5.default)(formData));
}

// src/isRootSchema.ts
var import_isEqual2 = __toESM(require("lodash/isEqual"), 1);
function isRootSchema(registry, schemaToCompare) {
  const { rootSchema, schemaUtils } = registry;
  if ((0, import_isEqual2.default)(schemaToCompare, rootSchema)) {
    return true;
  }
  if (REF_KEY in rootSchema) {
    const resolvedSchema = schemaUtils.retrieveSchema(rootSchema);
    return (0, import_isEqual2.default)(schemaToCompare, resolvedSchema);
  }
  return false;
}

// src/labelValue.ts
function labelValue(label, hideLabel, fallback) {
  return hideLabel ? fallback : label;
}

// src/localToUTC.ts
function localToUTC(dateString) {
  return dateString ? new Date(dateString).toJSON() : void 0;
}

// src/lookupFromFormContext.ts
var import_get21 = __toESM(require("lodash/get"), 1);
var import_has6 = __toESM(require("lodash/has"), 1);
function lookupFromFormContext(regOrFc, toLookup, fallback) {
  const lookupPath = [LOOKUP_MAP_NAME];
  if ((0, import_has6.default)(regOrFc, FORM_CONTEXT_NAME)) {
    lookupPath.unshift(FORM_CONTEXT_NAME);
  }
  return (0, import_get21.default)(regOrFc, [...lookupPath, toLookup], fallback);
}

// src/orderProperties.ts
function orderProperties(properties, order) {
  if (!Array.isArray(order)) {
    return properties;
  }
  const arrayToHash = (arr) => arr.reduce((prev, curr) => {
    prev[curr] = true;
    return prev;
  }, {});
  const errorPropList = (arr) => arr.length > 1 ? `properties '${arr.join("', '")}'` : `property '${arr[0]}'`;
  const propertyHash = arrayToHash(properties);
  const orderFiltered = order.filter((prop) => prop === "*" || propertyHash[prop]);
  const orderHash = arrayToHash(orderFiltered);
  const rest = properties.filter((prop) => !orderHash[prop]);
  const restIndex = orderFiltered.indexOf("*");
  if (restIndex === -1) {
    if (rest.length) {
      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);
    }
    return orderFiltered;
  }
  if (restIndex !== orderFiltered.lastIndexOf("*")) {
    throw new Error("uiSchema order list contains more than one wildcard item");
  }
  const complete = [...orderFiltered];
  complete.splice(restIndex, 1, ...rest);
  return complete;
}

// src/parseDateString.ts
function parseDateString(dateString, includeTime = true) {
  if (!dateString) {
    return {
      year: -1,
      month: -1,
      day: -1,
      hour: includeTime ? -1 : 0,
      minute: includeTime ? -1 : 0,
      second: includeTime ? -1 : 0
    };
  }
  const date = new Date(dateString);
  if (Number.isNaN(date.getTime())) {
    throw new Error("Unable to parse date " + dateString);
  }
  return {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    // oh you, javascript.
    day: date.getUTCDate(),
    hour: includeTime ? date.getUTCHours() : 0,
    minute: includeTime ? date.getUTCMinutes() : 0,
    second: includeTime ? date.getUTCSeconds() : 0
  };
}

// src/schemaRequiresTrueValue.ts
function schemaRequiresTrueValue(schema) {
  if (schema.const) {
    return true;
  }
  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {
    return true;
  }
  if (schema.anyOf && schema.anyOf.length === 1) {
    return schemaRequiresTrueValue(schema.anyOf[0]);
  }
  if (schema.oneOf && schema.oneOf.length === 1) {
    return schemaRequiresTrueValue(schema.oneOf[0]);
  }
  if (schema.allOf) {
    const schemaSome = (subSchema) => schemaRequiresTrueValue(subSchema);
    return schema.allOf.some(schemaSome);
  }
  return false;
}

// src/shouldRender.ts
function shouldRender(component, nextProps, nextState, updateStrategy = "customDeep") {
  if (updateStrategy === "always") {
    return true;
  }
  if (updateStrategy === "shallow") {
    const { props: props2, state: state2 } = component;
    return !shallowEquals(props2, nextProps) || !shallowEquals(state2, nextState);
  }
  const { props, state } = component;
  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);
}

// src/shouldRenderOptionalField.ts
var import_isObject12 = __toESM(require("lodash/isObject"), 1);
var import_uniq2 = __toESM(require("lodash/uniq"), 1);
function getSchemaTypesForXxxOf(schemas) {
  const allTypes = (0, import_uniq2.default)(
    schemas.map((s) => (0, import_isObject12.default)(s) ? getSchemaType(s) : void 0).flat().filter((t) => t !== void 0)
  );
  return allTypes.length === 1 ? allTypes[0] : allTypes;
}
function shouldRenderOptionalField(registry, schema, required, uiSchema) {
  const { enableOptionalDataFieldForType = [] } = getUiOptions(uiSchema, registry.globalUiOptions);
  let schemaType;
  if (ANY_OF_KEY in schema && Array.isArray(schema[ANY_OF_KEY])) {
    schemaType = getSchemaTypesForXxxOf(schema[ANY_OF_KEY]);
  } else if (ONE_OF_KEY in schema && Array.isArray(schema[ONE_OF_KEY])) {
    schemaType = getSchemaTypesForXxxOf(schema[ONE_OF_KEY]);
  } else {
    schemaType = getSchemaType(schema);
  }
  return !isRootSchema(registry, schema) && !required && !!schemaType && !Array.isArray(schemaType) && !!enableOptionalDataFieldForType.find((val) => val === schemaType);
}

// src/toDateString.ts
function toDateString(dateObject, time = true) {
  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;
  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);
  const datetime = new Date(utcTime).toJSON();
  return time ? datetime : datetime.slice(0, 10);
}

// src/toErrorList.ts
var import_isPlainObject3 = __toESM(require("lodash/isPlainObject"), 1);
function toErrorList(errorSchema, fieldPath = []) {
  if (!errorSchema) {
    return [];
  }
  let errorList = [];
  if (ERRORS_KEY in errorSchema) {
    errorList = errorList.concat(
      errorSchema[ERRORS_KEY].map((message) => {
        const property = `.${fieldPath.join(".")}`;
        return {
          property,
          message,
          stack: `${property} ${message}`
        };
      })
    );
  }
  return Object.keys(errorSchema).reduce((acc, key) => {
    if (key !== ERRORS_KEY) {
      const childSchema = errorSchema[key];
      if ((0, import_isPlainObject3.default)(childSchema)) {
        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));
      }
    }
    return acc;
  }, errorList);
}

// src/toErrorSchema.ts
var import_toPath = __toESM(require("lodash/toPath"), 1);
function toErrorSchema(errors) {
  const builder = new ErrorSchemaBuilder();
  if (errors.length) {
    errors.forEach((error) => {
      const { property, message } = error;
      const path = property === "." ? [] : (0, import_toPath.default)(property);
      if (path.length > 0 && path[0] === "") {
        path.splice(0, 1);
      }
      if (message) {
        builder.addErrors(message, path);
      }
    });
  }
  return builder.ErrorSchema;
}

// src/toFieldPathId.ts
function toFieldPathId(fieldPath, globalFormOptions, parentPath, isMultiValue) {
  const basePath = Array.isArray(parentPath) ? parentPath : parentPath?.path;
  const childPath = fieldPath === "" ? [] : [fieldPath];
  const path = basePath ? basePath.concat(...childPath) : childPath;
  const id = [globalFormOptions.idPrefix, ...path].join(globalFormOptions.idSeparator);
  let name;
  if (globalFormOptions.nameGenerator && path.length > 0) {
    name = globalFormOptions.nameGenerator(path, globalFormOptions.idPrefix, isMultiValue);
  }
  return { path, [ID_KEY]: id, ...name !== void 0 && { name } };
}

// src/unwrapErrorHandler.ts
var import_isPlainObject4 = __toESM(require("lodash/isPlainObject"), 1);
function unwrapErrorHandler(errorHandler) {
  return Object.keys(errorHandler).reduce((acc, key) => {
    if (key === "addError") {
      return acc;
    } else {
      const childSchema = errorHandler[key];
      if ((0, import_isPlainObject4.default)(childSchema)) {
        return {
          ...acc,
          [key]: unwrapErrorHandler(childSchema)
        };
      }
      return { ...acc, [key]: childSchema };
    }
  }, {});
}

// src/useAltDateWidgetProps.tsx
var import_react2 = require("react");
var import_jsx_runtime2 = require("react/jsx-runtime");
function readyForChange(state) {
  return Object.values(state).every((value) => value !== -1);
}
function DateElement(props) {
  const {
    className = "form-control",
    type,
    range,
    value,
    select,
    rootId,
    name,
    disabled,
    readonly,
    autofocus,
    registry,
    onBlur,
    onFocus
  } = props;
  const id = `${rootId}_${type}`;
  const { SelectWidget } = registry.widgets;
  const onChange = (0, import_react2.useCallback)((value2) => select(type, value2), [select, type]);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    SelectWidget,
    {
      schema: { type: "integer" },
      id,
      name,
      className,
      options: { enumOptions: dateRangeOptions(range[0], range[1]) },
      placeholder: type,
      value,
      disabled,
      readonly,
      autofocus,
      onChange,
      onBlur,
      onFocus,
      registry,
      label: "",
      "aria-describedby": ariaDescribedByIds(rootId)
    }
  );
}
function useAltDateWidgetProps(props) {
  const { time = false, disabled = false, readonly = false, options, onChange, value } = props;
  const [state, setState] = (0, import_react2.useState)(parseDateString(value, time));
  (0, import_react2.useEffect)(() => {
    setState(parseDateString(value, time));
  }, [time, value]);
  const handleChange = (0, import_react2.useCallback)(
    (property, value2) => {
      const nextState = {
        ...state,
        [property]: typeof value2 === "undefined" ? -1 : value2
      };
      if (readyForChange(nextState)) {
        onChange(toDateString(nextState, time));
      } else {
        setState(nextState);
      }
    },
    [state, onChange, time]
  );
  const handleClear = (0, import_react2.useCallback)(
    (event) => {
      event.preventDefault();
      if (disabled || readonly) {
        return;
      }
      onChange(void 0);
    },
    [disabled, readonly, onChange]
  );
  const handleSetNow = (0, import_react2.useCallback)(
    (event) => {
      event.preventDefault();
      if (disabled || readonly) {
        return;
      }
      const nextState = parseDateString((/* @__PURE__ */ new Date()).toJSON(), time);
      onChange(toDateString(nextState, time));
    },
    [disabled, readonly, time, onChange]
  );
  const elements = (0, import_react2.useMemo)(
    () => getDateElementProps(
      state,
      time,
      options.yearsRange,
      options.format
    ),
    [state, time, options.yearsRange, options.format]
  );
  return { elements, handleChange, handleClear, handleSetNow };
}

// src/useDeepCompareMemo.ts
var import_react3 = require("react");
var import_isEqual3 = __toESM(require("lodash/isEqual"), 1);
function useDeepCompareMemo(newValue) {
  const valueRef = (0, import_react3.useRef)(newValue);
  if (!(0, import_isEqual3.default)(newValue, valueRef.current)) {
    valueRef.current = newValue;
  }
  return valueRef.current;
}

// src/useFileWidgetProps.ts
var import_react4 = require("react");
function addNameToDataURL(dataURL, name) {
  return dataURL.replace(";base64", `;name=${encodeURIComponent(name)};base64`);
}
function processFile(file) {
  const { name, size, type } = file;
  return new Promise((resolve, reject) => {
    const reader = new window.FileReader();
    reader.onerror = reject;
    reader.onload = (event) => {
      if (typeof event.target?.result === "string") {
        resolve({
          dataURL: addNameToDataURL(event.target.result, name),
          name,
          size,
          type
        });
      } else {
        resolve({
          dataURL: null,
          name,
          size,
          type
        });
      }
    };
    reader.readAsDataURL(file);
  });
}
function processFiles(files) {
  return Promise.all(Array.from(files).map(processFile));
}
function extractFileInfo(dataURLs) {
  return dataURLs.reduce((acc, dataURL) => {
    if (!dataURL) {
      return acc;
    }
    try {
      const { blob, name } = dataURItoBlob(dataURL);
      return [
        ...acc,
        {
          dataURL,
          name,
          size: blob.size,
          type: blob.type
        }
      ];
    } catch {
      return acc;
    }
  }, []);
}
function useFileWidgetProps(value, onChange, multiple = false) {
  const values = (0, import_react4.useMemo)(() => {
    if (multiple && value) {
      return Array.isArray(value) ? value : [value];
    }
    return [];
  }, [value, multiple]);
  const filesInfo = (0, import_react4.useMemo)(
    () => Array.isArray(value) ? extractFileInfo(value) : extractFileInfo([value || ""]),
    [value]
  );
  const handleChange = (0, import_react4.useCallback)(
    (files) => {
      processFiles(files).then((filesInfoEvent) => {
        const newValue = filesInfoEvent.map((fileInfo) => fileInfo.dataURL || null);
        if (multiple) {
          onChange(values.concat(...newValue));
        } else {
          onChange(newValue[0]);
        }
      });
    },
    [values, multiple, onChange]
  );
  const handleRemove = (0, import_react4.useCallback)(
    (index) => {
      if (multiple) {
        const newValue = values.filter((_, i) => i !== index);
        onChange(newValue);
      } else {
        onChange(void 0);
      }
    },
    [values, multiple, onChange]
  );
  return { filesInfo, handleChange, handleRemove };
}

// src/utcToLocal.ts
function utcToLocal(jsonDate) {
  if (!jsonDate) {
    return "";
  }
  const date = new Date(jsonDate);
  const yyyy = pad(date.getFullYear(), 4);
  const MM = pad(date.getMonth() + 1, 2);
  const dd = pad(date.getDate(), 2);
  const hh = pad(date.getHours(), 2);
  const mm = pad(date.getMinutes(), 2);
  const ss = pad(date.getSeconds(), 2);
  const SSS = pad(date.getMilliseconds(), 3);
  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;
}

// src/validationDataMerge.ts
var import_isEmpty6 = __toESM(require("lodash/isEmpty"), 1);
function validationDataMerge(validationData, additionalErrorSchema, preventDuplicates = false) {
  if (!additionalErrorSchema) {
    return validationData;
  }
  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;
  let errors = toErrorList(additionalErrorSchema);
  let errorSchema = additionalErrorSchema;
  if (!(0, import_isEmpty6.default)(oldErrorSchema)) {
    errorSchema = mergeObjects(
      oldErrorSchema,
      additionalErrorSchema,
      preventDuplicates ? "preventDuplicates" : true
    );
    errors = [...oldErrors].concat(errors);
  }
  return { errorSchema, errors };
}

// src/withIdRefPrefix.ts
var import_isObject13 = __toESM(require("lodash/isObject"), 1);
function withIdRefPrefixObject(node) {
  for (const key in node) {
    const realObj = node;
    const value = realObj[key];
    if (key === REF_KEY && typeof value === "string" && value.startsWith("#")) {
      realObj[key] = ROOT_SCHEMA_PREFIX + value;
    } else {
      realObj[key] = withIdRefPrefix(value);
    }
  }
  return node;
}
function withIdRefPrefixArray(node) {
  for (let i = 0; i < node.length; i++) {
    node[i] = withIdRefPrefix(node[i]);
  }
  return node;
}
function withIdRefPrefix(schemaNode) {
  if (Array.isArray(schemaNode)) {
    return withIdRefPrefixArray([...schemaNode]);
  }
  if ((0, import_isObject13.default)(schemaNode)) {
    return withIdRefPrefixObject({ ...schemaNode });
  }
  return schemaNode;
}

// src/nameGenerators.ts
var bracketNameGenerator = (path, idPrefix, isMultiValue) => {
  if (!path || path.length === 0) {
    return idPrefix;
  }
  const baseName = path.reduce((acc, pathUnit, index) => {
    if (index === 0) {
      return `${idPrefix}[${String(pathUnit)}]`;
    }
    return `${acc}[${String(pathUnit)}]`;
  }, "");
  return isMultiValue ? `${baseName}[]` : baseName;
};
var dotNotationNameGenerator = (path, idPrefix, _isMultiValue) => {
  if (!path || path.length === 0) {
    return idPrefix;
  }
  return `${idPrefix}.${path.map(String).join(".")}`;
};

// src/enums.ts
var TranslatableString = /* @__PURE__ */ ((TranslatableString2) => {
  TranslatableString2["ArrayItemTitle"] = "Item";
  TranslatableString2["MissingItems"] = "Missing items definition";
  TranslatableString2["EmptyArray"] = "No items yet. Use the button below to add some.";
  TranslatableString2["YesLabel"] = "Yes";
  TranslatableString2["NoLabel"] = "No";
  TranslatableString2["CloseLabel"] = "Close";
  TranslatableString2["ErrorsLabel"] = "Errors";
  TranslatableString2["NewStringDefault"] = "New Value";
  TranslatableString2["AddButton"] = "Add";
  TranslatableString2["AddItemButton"] = "Add Item";
  TranslatableString2["CopyButton"] = "Copy";
  TranslatableString2["MoveDownButton"] = "Move down";
  TranslatableString2["MoveUpButton"] = "Move up";
  TranslatableString2["RemoveButton"] = "Remove";
  TranslatableString2["NowLabel"] = "Now";
  TranslatableString2["ClearLabel"] = "Clear";
  TranslatableString2["AriaDateLabel"] = "Select a date";
  TranslatableString2["PreviewLabel"] = "Preview";
  TranslatableString2["DecrementAriaLabel"] = "Decrease value by 1";
  TranslatableString2["IncrementAriaLabel"] = "Increase value by 1";
  TranslatableString2["OptionalObjectAdd"] = "Add data for optional field";
  TranslatableString2["OptionalObjectRemove"] = "Remove data for optional field";
  TranslatableString2["OptionalObjectEmptyMsg"] = "No data for optional field";
  TranslatableString2["Type"] = "Type";
  TranslatableString2["Value"] = "Value";
  TranslatableString2["UnknownFieldType"] = "Unknown field type %1";
  TranslatableString2["OptionPrefix"] = "Option %1";
  TranslatableString2["TitleOptionPrefix"] = "%1 option %2";
  TranslatableString2["KeyLabel"] = "%1 Key";
  TranslatableString2["InvalidObjectField"] = 'Invalid "%1" object field configuration: _%2_.';
  TranslatableString2["UnsupportedField"] = "Unsupported field schema.";
  TranslatableString2["UnsupportedFieldWithId"] = "Unsupported field schema for field `%1`.";
  TranslatableString2["UnsupportedFieldWithReason"] = "Unsupported field schema: _%1_.";
  TranslatableString2["UnsupportedFieldWithIdAndReason"] = "Unsupported field schema for field `%1`: _%2_.";
  TranslatableString2["FilesInfo"] = "**%1** (%2, %3 bytes)";
  return TranslatableString2;
})(TranslatableString || {});

// src/parser/schemaParser.ts
var import_forEach = __toESM(require("lodash/forEach"), 1);

// src/parser/ParserValidator.ts
var import_get22 = __toESM(require("lodash/get"), 1);
var ParserValidator = class {
  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`
   * first.
   *
   * @param rootSchema - The root schema against which this validator will be executed
   */
  constructor(rootSchema) {
    /** The map of schemas encountered by the ParserValidator */
    this.schemaMap = {};
    this.rootSchema = rootSchema;
    this.addSchema(rootSchema, hashForSchema(rootSchema));
  }
  /** Resets the internal AJV validator to clear schemas from it. Can be helpful for resetting the validator for tests.
   */
  reset() {
    this.schemaMap = {};
  }
  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the
   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be
   * associated with it's `hash` for future use (by a schema compiler).
   *
   * @param schema - The schema which is to be added to the map
   * @param hash - The hash value at which to map the schema
   */
  addSchema(schema, hash) {
    const key = (0, import_get22.default)(schema, ID_KEY, hash);
    const identifiedSchema = { ...schema, [ID_KEY]: key };
    const existing = this.schemaMap[key];
    if (!existing) {
      this.schemaMap[key] = identifiedSchema;
    } else if (!deepEquals(existing, identifiedSchema)) {
      console.error("existing schema:", JSON.stringify(existing, null, 2));
      console.error("new schema:", JSON.stringify(identifiedSchema, null, 2));
      throw new Error(
        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`
      );
    }
  }
  /** Returns the current `schemaMap` to the caller
   */
  getSchemaMap() {
    return this.schemaMap;
  }
  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when
   * the `rootSchema` is not the same as the root schema provided during construction.
   *
   * @param schema - The schema to record in the `schemaMap`
   * @param _formData - The formData parameter that is ignored
   * @param rootSchema - The root schema associated with the schema
   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction
   */
  isValid(schema, _formData, rootSchema) {
    if (!deepEquals(rootSchema, this.rootSchema)) {
      throw new Error("Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema");
    }
    this.addSchema(schema, hashForSchema(schema));
    return false;
  }
  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called
   *
   * @param _schema - The schema parameter that is ignored
   * @param _formData - The formData parameter that is ignored
   */
  rawValidation(_schema, _formData) {
    throw new Error("Unexpectedly calling the `rawValidation()` method during schema parsing");
  }
  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called
   *
   * @param _errorSchema - The error schema parameter that is ignored
   * @param _fieldPath - The field path parameter that is ignored
   */
  toErrorList(_errorSchema, _fieldPath) {
    throw new Error("Unexpectedly calling the `toErrorList()` method during schema parsing");
  }
  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be
   * called
   *
   * @param _formData - The formData parameter that is ignored
   * @param _schema - The schema parameter that is ignored
   * @param _customValidate - The customValidate parameter that is ignored
   * @param _transformErrors - The transformErrors parameter that is ignored
   * @param _uiSchema - The uiSchema parameter that is ignored
   */
  validateFormData(_formData, _schema, _customValidate, _transformErrors, _uiSchema) {
    throw new Error("Unexpectedly calling the `validateFormData()` method during schema parsing");
  }
};

// src/parser/schemaParser.ts
function parseSchema(validator, recurseList, rootSchema, schema) {
  const schemas = retrieveSchemaInternal(validator, schema, rootSchema, void 0, true);
  schemas.forEach((schema2) => {
    const sameSchemaIndex = recurseList.findIndex((item) => deepEquals(item, schema2));
    if (sameSchemaIndex === -1) {
      recurseList.push(schema2);
      const allOptions = resolveAnyOrOneOfSchemas(validator, schema2, rootSchema, true);
      allOptions.forEach((s) => {
        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {
          (0, import_forEach.default)(schema2[PROPERTIES_KEY], (value) => {
            parseSchema(validator, recurseList, rootSchema, value);
          });
        }
      });
      if (ITEMS_KEY in schema2 && !Array.isArray(schema2.items) && typeof schema2.items !== "boolean") {
        parseSchema(validator, recurseList, rootSchema, schema2.items);
      }
    }
  });
}
function schemaParser(rootSchema) {
  const validator = new ParserValidator(rootSchema);
  const recurseList = [];
  parseSchema(validator, recurseList, rootSchema, rootSchema);
  return validator.getSchemaMap();
}
//# sourceMappingURL=index.cjs.map
